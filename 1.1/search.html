<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<link rel="icon"  href="/favicon.ico" />
<title>Search</title>
<meta name="description" content=""/>
<meta name="keywords" content=""/>
<base id="baseURL" href="/1.1/" />
<meta id="docsVersion" content="1.1" />
<meta name="last-modified" content="2019-12-09 11:39:29 +0530" />
<meta http-equiv="cache-control" content="max-age=24" />
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Cache-Control" content="no-store" />
<meta http-equiv="pragma" content="no-cache" />
<meta http-equiv="Expires" content="600" />

<link rel="stylesheet" href="/css/font-awesome.min.css">
<link rel="stylesheet" href="/css/bootstrap.min.css">
<link rel="stylesheet" href="/css/pygments/perldoc.css">
<link rel="stylesheet" href="/css/style.css?v=09122019">
<link rel="stylesheet" href="/css/github.css?v=09122019">


</head>
<body class=" latestVersion">
	<div class="widgetLatestVersionNotification"></div>
	<header>
    <div class="header">
        <nav class="nav-secondary-tabs affix" >
            <div class="container-fluid">
                <div class="navbar-collapse" aria-expanded="false" style="height: 1px;">
                    <div class="sidebar-toggle">
    <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
    </button>
</div>
<div class="nav-container">
    <a class="logo" href="/" title="Tizen Documentation">
        Tizen
    </a>
    <div id="tabs">
        
        
        <ul class="tabs" id="jsTOCHorizontal">
            <li class="">
                <a href="design/">Design</a>
            </li>
            <li class="">
                <a href="application/">Development</a>
            </li>
            <li class="">
                <a href="iot/">IoT</a>
            </li>
            <li class="">
                <a href="tizenstudio/setup/overview/">Tizen Studio</a>
            </li>
        </ul>
    </div>
    <div class="ctrl-right hidden-xs hidden-sm">
        <a href="javascript:void(0)" id="menu-toggle"><i class="fa fa-indent" aria-hidden="true"></i></a>
        <div class="widgetVersionSwitcher"></div>
    </div>
    <div class="search-form">
        <form action="search.html">
            <input class="search-field form-control ds-input st-search-input" value="" name="q" placeholder="Search the docs" type="search" autocomplete="off" spellcheck="false" dir="auto">
            <button type="submit" class="search-button">
                <i class="fa fa-search"></i>
            </button>
        </form>
    </div>
    
</div>

                </div>
            </div>
        </nav>
    </div>
</header>
    <div class="wrapper search-page container">
		<div class="container-fluid">
			<div class="row">
				<div class="col-body">
					<main class="col-content main-content">
						<section class="section">
							<div class="wrapper space">
	<p><span id="search-process">Loading</span> results <span id="search-query-container" style="display: none;">for "<strong id="search-query"></strong>"</span></p>
	<ul id="search-results"></ul>
</div>
<script>
	window.data = {
		
			
				
					
					
					"tizenstudio-setup-about-ide": {
						"id": "tizenstudio-setup-about-ide",
						"title": "Meet Tizen Studio",
						"categories": "",
						"url": " tizenstudio/setup/about_ide/",
						"content": "Overview\n\nTizen Studio is the official IDE for developing Web applications and Native applications for Tizen. Tizen Studio consists of a comprehensive set of tools such as emulator, toolchain, sample code, documentation, and so on. These tools are used to develop the Tizen applications. Tizen Studio runs on Windows®, Ubuntu, and macOS. The following figure shows various benefits that you can achieve using the IDE tools:\n\n\n\nTizen Studio Views\n\n\n  Project Explorer: \nThis view provides a hierarchical view of all the resources in the workspace. You can open files for editing or select resources for operations, such as building, packaging, signing, or validating an application.\n  Edit:\nCode editing can be done in the editor area.\n  Outline:\nThis view shows the structure outline and Object hierarchy of C, C++, and JavaScript.\n  Problem:\nThis view shows the status of build and packaging error or warning.\n  Console:\nThis view shows the target or emulator log when applications are running.\n  Property:\nThis view shows the property of selected files on Project Explorer, such as file path, size, and name.\n\n\n\n\nTizen Studio Tools\n\n\n  Device Manager:\nManages the connected devices and supports installation of applications. It also supports real target, virtual target, and remote target.\n  Certificate Manager:\nManages the certificate profile. It can create or import author certificate. It can also use default or import distributor certificate.\n  Package Manager:\nRetrieves detailed information of the installed packages on the device, such as package name, label, path to the icon image, version, type, and installed storage.\n  Emulator Manager:\nCreates an actual hardware environment that has real device controls, and you can check the application features, such as data processing and user scenarios.\n  Dynamic Analyzer: \nHelps in performance monitoring and is an analysis tool for your Native and Web applications on a Tizen device or an emulator."
					}
					
				
			
		
			
				
					,
					
					"tizenstudio-setup-additional-requirements": {
						"id": "tizenstudio-setup-additional-requirements",
						"title": "Tizen Documentation",
						"categories": "",
						"url": " tizenstudio/setup/additional-requirements/",
						"content": "Additional Requirements\n\nThis page explains you the summary of various requirements that are necessary to configure your development environment for optimal and seamless development experience. Tizen studio tools such as Emulator, Web Inspector, and various other tools need to be configured specifically on your development hardware, such that the dependent development processes work efficiently.\n\nTizen Studio Emulator\n\nTizen Studio Emulator simulates Tizen based devices on your computer, so that you can test your Tizen applications without having the requirement of each physical device. Tizen Studio Emulator provides almost all of the capabilities of a real Tizen based device.\n\nTo use Tizen Studio Emulator, ensure that your development hardware meets the following configurations:\n\n\n\n\nComponent\nRequirements&nbsp;\n\n\n\n\nCPU\nSupport for Intel Virtualization Technology (VTx)\n\n\nScreen Resolution\n1280 x 1024\n\n\n\nNVIDIA&reg; Graphics Card\n&nbsp;\n\n\nIf the host machine uses the NVIDIA&reg; Optimus&reg; technology, the emulator works with the onboard graphics card. To prevent this, either disable the Optimus&reg; technology or set the emulator to run with the external NVIDIA graphics card.\nNote You must upgrade to the latest vendor-provided version of the graphics card driver for OpenGL&reg; ES acceleration.&lt;/p&gt;\n\n\n\nSystem Drivers&nbsp;\n\nWindows&reg;:\nTo check and install the latest drivers, open&nbsp;Control Panel &gt; System and Security &gt; Windows Update.\n\n\n\n\nUbuntu&reg;:&nbsp;\nTo check and install the latest Ubuntu&nbsp;drivers, open&nbsp;System Settings &gt; Software &amp; Updates &gt; Additional Drivers.\n\n\n\nWebcam\n\nUse the emulator with an inbuilt webcam. The webcam must support the USB Video Class (UVC) driver.\nThe&nbsp;supported image formats are: &nbsp;UYYY, YYU420, YUY420, and YUYY.\n\n\n\n\n\nGoogle Chrome® Browser\n\nYou can use the Web Inspector tool in the Google Chrome browser for debugging your applications. For more information, see Web Inspector. The Web Inspector server uses the Web core of the platform.\n\n\n  Note\n\n  You must use Google Chrome™ browser version 52 or lower, such that all the functions of the Web Inspector work properly. For more information, see Google Chrome™.\n\n\nT-Trace\n\nThe T-Trace tool is a Tizen profiling tool that is used to optimize the performance of an application.\n\nThe following table lists the requirements that you must ensure to use the T-Trace tool:\n\n\n\n\nComponent\nRequirement\n\n\n\n\n\nT-Trace \n\nTo use T-trace in Windows&reg; 8 and higher, you must install Python 2.7.X or higher.\n \nTo download and install Python, follow these steps: \n\n\n Download an appropriate Python version for your hardware and Windows&reg;. For more information, see the  Python website.\n\n\nRun the downloaded installer file and follow the on-screen instructions.\n\n\nNote\n\nTo use Python in native command prompt, set the %PATH% environment variable in My Computer &gt; Properties &gt; Advanced &gt; Environment Variables."
					}
					
				
			
		
			
				
					,
					
					"tizenstudio-common-tools-dynamic-analyzer-advanced-tasks": {
						"id": "tizenstudio-common-tools-dynamic-analyzer-advanced-tasks",
						"title": "Handling Advanced Dynamic Analyzer Tasks",
						"categories": "",
						"url": " tizenstudio/common-tools/dynamic-analyzer/advanced-tasks/",
						"content": "Handling Advanced Dynamic Analyzer Tasks\n\nThis topic explains some additional functionality of the Dynamic Analyzer.\n\nRange Inspection\n\nYou can analyze specific ranges using markers or drag and drop operations.\n\n\nRange Inspection with Markers\n\nYou can create markers at specific times and analyze the time between the markers:\n\n\n  \n    Create the markers by double-clicking a chart or detail table view that has a timestamp.\n  \n  \n    Right-click between the markers, and select Select range.\n\n    The table data is updated based on the range inspection results.\n  \n\n\nFigure: Range inspection with markers\n\n\n\nYou can create as many markers as you want, and can move the marker by dragging and dropping with a mouse. To delete a marker, double-click it.\n\nRange Inspection with Drag and Drop\n\nIf you drag and drop on a chart view, a range is set and the table data is updated based on the range inspection results.\n\nFigure: Range inspection with drag and drop\n\n\n\nThe drag and drop action creates a temporary range. If you click another area on the chart view, the range selection is removed.\n\nSearch Dialog\n\nYou can search for a specific keyword in the detail table view, and the search result is highlighted by color.\n\nYou can set some search parameters:\n\n\n  Case sensitive: Case-sensitive matching\n  Whole word: Whole word matching\n\n\nFigure: Search dialog\n\n\n\nTarget Dialog\n\nYou can check the connected target information in the target dialog:\n\n\n  Device: Device type of the connected target (Mobile/Wearable/TV)\n  Application: List of applications that can be analyzed in the connected target\n  Description: Detail information about the connected target:\n    \n      Platform Version\n      Model Name\n      RAM\n      Binary Information\n      Application ID\n      Package ID\n      Package Version\n      Package Installed Time\n      Application Exec Path\n    \n\n    Figure: Target dialog\n\n    \n  \n\n\nData Load and Save Dialogs\n\nYou can save the tracing result into a file and load it later for analysis:\n\n\n  \n    You can save the analysis result to a ZIP file.\n\n    Figure: Saving data\n\n    \n  \n  \n    You can load the analysis result from the ZIP file. After loading, the chart and table data are updated from the loaded data.\n\n    Figure: Loading data\n\n    \n  \n\n\nPreference Dialog\n\nTo adjust the Dynamic Analyzer functions during a trace, you can open the preference dialog by clicking the Preference button on the toolbar.\n\nThe preference dialog contains the following settings:\n\n\n  General\n    \n      Source view: Enable the source view option that opens the source view in the detail table view.\n      System sampling rate: Define the system sampling rate.\n      Function sampling rate: Define the function sampling rate.\n    \n  \n  Screenshot feature\n    \n      Periodically: Enable screenshot captures periodically and set the time between captures in seconds.\n      On scene transition: Enable screenshot captures on scene transitions.\n    \n  \n  Heap Allocation feature\n    \n      Leak Sanitizer: Enable the Leak Sanitizer analysis to detect memory leaks in the application.\n    \n  \n\n\nFigure: Preference dialog\n\n\n\nKeyboard Shortcuts\n\nYou can trigger some major analysis functions with keyboard shortcuts.\n\nTable: Keyboard shortcuts\n\n\t\n\t\t\n\t\t\tCommand\n\t\t\tShortcut\n\t\t\n\t\t\n\t\t\tWindows&reg;\n\t\t\tmacOS\n\t\t\n\t\n\t\n\t\t\n\t\t\tFile\n\t\t\tNew\n\t\t\tCtrl + N\n\t\t\tCommand + N\n\t\t\n\t\t\n\t\t\tLoad\n\t\t\tCtrl + O\n\t\t\tCommand + O\n\t\t\n\t\t\n\t\t\tSave\n\t\t\tCtrl + S\n\t\t\tCommand + S\n\t\t\n\t\t\n\t\t\tExit\n\t\t\tCtrl + Q\n\t\t\tCommand + Q\n\t\t\n\t\t\n\t\t\tAnalyze\n\t\t\tStart or stop trace\n\t\t\tF5\n\t\t\tFn + F5\n\t\t\n\t\t\n\t\t\tSearch\n\t\t\tCtrl + F\n\t\t\tCommand + F\n\t\t\n\t\t\n\t\t\tTarget\n\t\t\tCtrl + T\n\t\t\tCommand + T\n\t\t\n\t\t\n\t\t\tScreenshot\n\t\t\tF9\n\t\t\tFn + F9\n\t\t\n\t\t\n\t\t\tPreferences\n\t\t\tF10\n\t\t\tFn + F10\n\t\t\n\t\t\n\t\t\tDetail\n\t\t\tCtrl + H\n\t\t\tCommand + H\n\t\t\n\t\t\n\t\t\tNavigate\n\t\t\tZoom in\n\t\t\tW\n\t\t\tW\n\t\t\n\t\t\n\t\t\tZoom out\n\t\t\tS\n\t\t\tS\n\t\t\n\t\t\n\t\t\tMove left\n\t\t\tA\n\t\t\tA\n\t\t\n\t\t\n\t\t\tMove right\n\t\t\tD\n\t\t\tD\n\t\t\n\t\t\n\t\t\tMove first\n\t\t\tQ\n\t\t\tQ\n\t\t\n\t\t\n\t\t\tMove end\n\t\t\tE\n\t\t\tE\n\t\t\n\t\t\n\t\t\tHelp\n\t\t\tHow to use Dynamic Analyzer\n\t\t\tF1\n\t\t\tFn + F1\n\t\t\n\t\n\n\nTable Data Copying and Export\n\nTo copy or export data in TSV (Tab Separated Values) format from a table in the Dynamic Analyzer:\n\n\n  \n    Select the data you want to copy or export.\n  \n  \n    Right-click the selection and select:\n    \n      \n        Copy to copy the selected data to the clipboard.\nYou can also copy using the Ctrl + C or Ctrl + Insert keyboard shortcuts.\n      \n      \n        Export to file to export the selected data to a TSV file.\nYou can define a file location for the exported data.\n      \n    \n  \n\n\nCommand Line Interface\n\nYou can use the command line interface (CLI) with the Dynamic Analyzer. You can collect tracing data from your application from a target device and later open it in the Dynamic Analyzer GUI (graphical interface) for analysis.\n\nTo launch tracing, you must know the target device name (or IP address) and your application identifier, and you must specify the profiling features to be enabled.\n\nTo view the CLI help, run the ./dacli.jar -h command:\n\nUsage: dacli.jar &lt;command&gt; [options...]\nList of commands:\n    devices : show list of connected devices and emulators\n        -u                           show list of devices where tracing is running\n\n    apps &lt;ip:port|serial&gt; : show list of applications of specified target\n\n    start &lt;ip:port|serial&gt; : start tracing on specified target for specified\n                             application using selected tracing features\n        -a &lt;application identifier&gt;  identifier of application to trace\n        -o &lt;output filename&gt;         redirect tracing output to file\n        -C,--cpu-usage &lt;arg&gt;         select cpu usage tracing\n                                     Possible arguments: usage, core, frequency, all\n                                     If no arguments provided - 'all' is selected\n        -M,--memory &lt;arg&gt;            select memory tracing\n                                     Possible arguments: system, process, heap, all\n                                     If no arguments provided - 'process,system' is selected\n        -F,--file &lt;arg&gt;              select file tracing\n                                     Possible arguments: io, analysis, all\n                                     If no arguments provided - 'all' is selected\n        -G,--graphics &lt;arg&gt;          select graphics tracing\n                                     Possible arguments: opengl, all\n                                     If no arguments provided - 'all' is selected\n        -N,--network &lt;arg&gt;           select network tracing\n                                     Possible arguments: io, analysis, all\n                                     If no arguments provided - 'all' is selected\n        -T,--thread-analysis         select thread analysis tracing\n        -U,--ui-event                select ui event tracing\n        -P,--peripheral-status       select peripheral status tracing\n        -E,--power-estimation        select power estimation tracing\n        -S &lt;period&gt;                  enable screenshots capturing periodically\n        -s,                          enable screenshots capturing on scene transition\n        -L,--leak-sanitizer          select LeakSanitizer analysis tracing\n                                     Works only if 'heap' memory tracing is selected and does not work\n                                     with thread analysis tracing\n\n    stop &lt;ip:port|serial&gt; : stop currently running tracing process on specified device\n\n    version : print information about version\n\n\nEnvironment Setup\n\nThe CLI tool requires Java VM installed on your computer. The minimum supported version is Java VM 1.7.\n\nYou can launch the dacli.jar file from the Dynamic Analyzer installation directory by using the ./dacli.jar command. To make launching easier, add the directory to your PATH variable. For example, use the following command on Ubuntu:\n\nexport PATH=$PATH:&lt;path-to-tizen-studio&gt;/tools/dynamic-analyzer/\n\n\n\n  Note\nIf you have trouble with the execution, you can try one of the following:\n\n  \n    \n      Grant execution permissions to the dacli.jar file:\n\n      chmod +x dacli.jar\n    \n    \n      Use the following command to launch the Dynamic Analyzer CLI tool:\n\n      java -jar dacli.jar\n    \n  \n\n\nUseful Commands\n\nThe following commands are the most useful when controlling the Dynamic Analyzer with the CLI:\n\n\n  \n    devices\n\n    The command shows a list of connected devices. If you specify the -u option, only the devices where tracing is already launched through the CLI are listed.\n\n    Command syntax:\n    devices [-u]\n    \n\n    For example:\n    $ ./dacli.jar devices\nList of connected devices:\n    &lt;Device Name&gt; &lt;Serial Number&gt;\n    m-0818-1      emulator-26101\n    \n\n    Take note of the device serial number. It is used to specify the device in other Dynamic Analyzer CLI commands.\n  \n  \n    apps\n\n    The command shows a list of installed applications on a specified device.\n\n    Command syntax:\n    apps &lt;ip:port|serial&gt;\n    \n    For example:\n    $ ./dacli.jar apps emulator-26101\nList of installed applications:\n  &lt;Application ID&gt;               : &lt;Package ID&gt;             : &lt;Application Name&gt;\n  org.tizen.camera-app           : org.tizen.camera-app     : Camera\n  org.tizen.calendar             : org.tizen.calendar       : Calendar\n  org.tizen.contacts             : org.tizen.contacts       : Contacts\n  org.tizen.gallery              : org.tizen.gallery        : Gallery\n  org.tizen.browser              : org.tizen.browser        : Internet\n    \n    Take note of your application identifier. It is used to specify the application in other Dynamic Analyzer CLI commands. If you cannot find your application, make sure it has been installed (for example, from the Tizen Studio). The application ID can differ from the package ID.\n  \n  \n    start\n\n    The command starts tracing your application on the specified device. In addition, you must specify at least 1 profiling feature to be enabled.\n\n    Command syntax:\n    start &lt;ip:port|serial&gt; -a &lt;application identifier&gt; &lt;features&gt; [options...]\n    \n    For example, you can specify the -C option to enable all CPU profiling features. You can see a list of all available features in the command help message.\n\n    The following command starts the Camera application on the emulator-26101 device with the CPU profiling features enabled:\n    $ ./dacli.jar start emulator-26101 -a org.tizen.camera-app -C\nDA tracing started.\nRun \"dacli stop emulator-26101\" to finish it.\n    \n    You can specify the -o option to customize the tracing result location.\n  \n  \n    stop\n\n    The command stops the active tracing process on a specified device.\n\n    Command syntax:\n    stop &lt;ip:port|serial&gt;\n    \n    For example:\n    $ ./dacli.jar stop emulator-26101\nDA tracing finished.\nTotal time:   1m 37.777s\nTracing time: 1m 29.362s\nOutput:       /home/eclipse/tizen-sdk-data/dynamic-analyzer/save/org.tizen.camera-app_2016-08-18-16-51-53.zip\n    \n    In the command output:\n    \n      Total time is the time required to perform all the tracing activities: connection, command communication, data interchange, and activity finalization.\n      Tracing time is the pure tracing time: from the beginning to the end of your program.\n      Output is the location where the tracing result is stored: it can be opened for further analysis in the Dynamic Analyzer GUI.\n    \n  \n  \n    version\n\n    The command displays information about the Dynamic Analyzer, including its version, build time, and useful links.\n\n    Command syntax:\n    version\n    \n    For example:\n    $ ./dacli.jar version\nDA Version      2.4.4\nBuild Time      20161213-0258\nTizen Site      http://www.tizen.org\nRelease Note    https://developer.tizen.org/development/tizen-studio/download/release-notes\n    \n    In the command output:\n    \n      DA Version is the version of the Dynamic Analyzer.\n      Build Time is the build timestamp.\n      Tizen Site is the link to the Tizen Web site.\n      Release Note is the link to the Tizen Studio Release Notes.\n    \n  \n\n\nRelated Information\n\n  Dependencies\n    \n      Tizen Studio 1.0 and Higher"
					}
					
				
			
		
			
				
					,
					
					"design-introduction-air": {
						"id": "design-introduction-air",
						"title": "Design",
						"categories": "",
						"url": " design/introduction/air/",
						"content": "“Air”\n\n“Air” is one of the inspirations behind the Tizen design. The concept was introduced to achieve the key principles of openness, flow, curiosity, and focus. “Air” is a conceptual element that inspires an open, flexible, and rich visual experience. Designs should be created to satisfy users with visually reinforced presentations.\n\nThe Origins of the “Air” Concept\n\n“Air” interacts with “Ground,” “Atmosphere,” and “Wind,” to create different results.\n\n“Ground” symbolizes the structure and layout of the Tizen design. “Atmosphere” is the subtle variations of the “Air” principles, such as colors, themes, and overall design variations. “Wind” is created by the flow and movement of “Air.” For Tizen, it symbolizes visually pleasing motion graphics designs.\n\nNatural Elements in the Design Language\n\n“GROUND”: Bold and Distinctive Layout Design\n\n\n\nRidges are formed where air touches the ground\n\nIn our design language, “Ground” is the first element “Air” touches. Solid structural designs powered by Tizen provide distinctive divisions on which all the other design elements are placed. Across all applicable platforms, such structural distinctiveness leads to glanceable and quickly recognizable designs.\n\nThe “Air” concept embraces the beauty of less and pursues minimalism in the layout. It aims to provide only the essential content based on actual needs. Therefore, the “Air” concept may not reveal its full potential at first look.\n\n“ATMOSPHERE”: Natural Tones, Colors, and Moods\n\n“Atmosphere” represents natural tones, colors, and moods present in the design. Inspired by the colorful gradients found in nature, such as deep blue skies with a slight hint of white cloud, sunrises, sunsets, and the Northern Lights, “Atmosphere” emphasizes the use of color gradients to achieve a natural, aesthetic design. A well-implemented “Atmosphere” can vastly enhance user experience.\n\n \n\nColor inspiration from nature\n\nUsing light, “Atmosphere” aims to achieve natural transition of colors as they are found in the sky. With carefully selected colors, “Atmosphere” creates natural, yet appealing color gradients.\n\nWe recommend contrasting color combinations in the background and foreground to ensure optimal readability. The use of subtle gradient prevents high-contrast screens from becoming boring by adding variations that keep the screen visually intriguing.\n\n“WIND”: Animated Graphics from Nature\n\nThe “Wind” concept is based on animations providing users with feedback for each interaction, while conveying meaningful information to help orient users. For example, page-turning effects visually suggest the direction of navigation, and page-end effects inform users that they have reached the last page of the current content. Uniform, harmonious animations on the screen allow for a pleasant visual experience while maximizing the responsiveness of the design.\n\n\n\nThe wind is the flow of the content\n\nTizen screens have a multilayered structure. Each layer has its own directional flow, based on the uses and features, for consistent screen transition. Difference in direction helps users clearly identify which layer, level, or part of the design the interaction is taking place on.\n\nAnimation effects also include fade effects for transitions between layers and for opening and closing app screens."
					}
					
				
			
		
			
				
					,
					
					"application-porting-application": {
						"id": "application-porting-application",
						"title": "Application",
						"categories": "",
						"url": " application/porting/application/",
						"content": "Application\n\nTizen supports both core and reference applications. Core applications are developed with platform internal interfaces, such as the Enlightenment Foundation Libraries (EFL) and other third party libraries. Reference applications are developed with Tizen native APIs.\n\nThe following table shows whether the core and reference versions of the preloaded sample applications are supported by default on the emulator and target device.\n\nTable: Sample application support\n\n\n  \n    \n      Application name\n      Emulator\n       \n      Target\n       \n    \n  \n  \n    \n       \n      Core application\n      Reference application\n      Core application\n      Reference application\n    \n    \n      Calculator\n      No\n      Yes\n      Yes\n      No\n    \n    \n      Calendar\n      No\n      Yes\n      Yes\n      No\n    \n    \n      CalendarService\n      No\n      Yes\n      Yes\n      No\n    \n    \n      Camera\n      No\n      Yes\n      Yes\n      No\n    \n    \n      Clock\n      No\n      Yes\n      Yes\n      No\n    \n    \n      Contacts\n      No\n      Yes\n      Yes\n      No\n    \n    \n      Email\n      No\n      Yes\n      Yes\n      No\n    \n    \n      Gallery\n      No\n      Yes\n      Yes\n      No\n    \n    \n      Home\n      Yes\n      No\n      Yes\n      No\n    \n    \n      ImageViewer\n      No\n      Yes\n      Yes\n      No\n    \n    \n      Internet\n      No\n      Yes\n      No\n      Yes\n    \n    \n      Lock\n      Yes\n      No\n      Yes\n      No\n    \n    \n      Memo\n      No\n      Yes\n      Yes\n      No\n    \n    \n      Messages\n      No\n      Yes\n      Yes\n      No\n    \n    \n      MusicPlayer\n      No\n      Yes\n      Yes\n      No\n    \n    \n      MyFiles\n      No\n      Yes\n      Yes\n      No\n    \n    \n      Phone\n      No\n      Yes\n      Yes\n      No\n    \n    \n      Settings\n      No\n      Yes\n      Yes\n      No\n    \n    \n      VideoPlayer\n      No\n      Yes\n      Yes\n      No\n    \n  \n\n\nConfiguration\n\nYou can switch a preloaded sample application between core and reference applications using the MIC image creator. To switch the application, remove the preloaded application package and add the new package image with the correct name. The following table shows the core and reference application image names of the preloaded sample applications.\n\nTable: Sample application image names\n\n\n  \n    \n      Application name\n      Core application\n      Reference application\n    \n  \n  \n    \n      Calculator\n      org.tizen.calculator\n      apps.Calculator\n    \n    \n      Calendar\n      org.tizen.calendar\n      apps.Calendar\n    \n    \n      CalendarService\n      org.tizencalendar-service\n      apps.CalendarService\n    \n    \n      Camera\n      org.tizen.camera-app\n      apps.Camera\n    \n    \n      Clock\n      org.tizen.clock\n      apps.Clock\n    \n    \n      Contacts\n      org.tizen.contacts\n      apps.Contacts\n    \n    \n      Email\n      org.tizen.email\n      apps.Email\n    \n    \n      Gallery\n      org.tizen.gallery\n      apps.Gallery\n    \n    \n      Home\n      org.tizen.menu-screen\n      apps.Home\n    \n    \n      ImageViewer\n      org.tizen.image-viewer\n      apps.ImageViewer\n    \n    \n      Internet\n      org.tizen.browser\n      apps.Internet\n    \n    \n      Lock\n      org.tizen.lockscreen\n      apps.Lock\n    \n    \n      Memo\n      org.tizen.memo\n      apps.Memo\n    \n    \n      Messages\n      org.tizen.message\n      apps.Messages\n    \n    \n      MusicPlayer\n      org.tizen.music-player\n      apps.MusicPlayer\n    \n    \n      MyFiles\n      org.tizen.myfile\n      apps.MyFiles\n    \n    \n      Phone\n      org.tizen.call\n      apps.Phone\n    \n    \n      Settings\n      org.tizen.setting\n      apps.Settings\n    \n    \n      VideoPlayer\n      org.tizen.video-player\n      apps.VideoPlayer"
					}
					
				
			
		
			
				
					,
					
					"platform-porting-application": {
						"id": "platform-porting-application",
						"title": "Application",
						"categories": "",
						"url": " platform/porting/application/",
						"content": "Application\n\nTizen supports both core and reference applications. Core applications are developed with platform internal interfaces, such as the Enlightenment Foundation Libraries (EFL) and other third party libraries. Reference applications are developed with Tizen native APIs.\n\nThe following table shows whether the core and reference versions of the preloaded sample applications are supported by default on the emulator and target device.\n\nTable: Sample application support\n\n\n  \n    \n      Application name\n      Emulator\n       \n      Target\n       \n    \n  \n  \n    \n       \n      Core application\n      Reference application\n      Core application\n      Reference application\n    \n    \n      Calculator\n      No\n      Yes\n      Yes\n      No\n    \n    \n      Calendar\n      No\n      Yes\n      Yes\n      No\n    \n    \n      CalendarService\n      No\n      Yes\n      Yes\n      No\n    \n    \n      Camera\n      No\n      Yes\n      Yes\n      No\n    \n    \n      Clock\n      No\n      Yes\n      Yes\n      No\n    \n    \n      Contacts\n      No\n      Yes\n      Yes\n      No\n    \n    \n      Email\n      No\n      Yes\n      Yes\n      No\n    \n    \n      Gallery\n      No\n      Yes\n      Yes\n      No\n    \n    \n      Home\n      Yes\n      No\n      Yes\n      No\n    \n    \n      ImageViewer\n      No\n      Yes\n      Yes\n      No\n    \n    \n      Internet\n      No\n      Yes\n      No\n      Yes\n    \n    \n      Lock\n      Yes\n      No\n      Yes\n      No\n    \n    \n      Memo\n      No\n      Yes\n      Yes\n      No\n    \n    \n      Messages\n      No\n      Yes\n      Yes\n      No\n    \n    \n      MusicPlayer\n      No\n      Yes\n      Yes\n      No\n    \n    \n      MyFiles\n      No\n      Yes\n      Yes\n      No\n    \n    \n      Phone\n      No\n      Yes\n      Yes\n      No\n    \n    \n      Settings\n      No\n      Yes\n      Yes\n      No\n    \n    \n      VideoPlayer\n      No\n      Yes\n      Yes\n      No\n    \n  \n\n\nConfiguration\n\nYou can switch a preloaded sample application between core and reference applications using the MIC image creator. To switch the application, remove the preloaded application package and add the new package image with the correct name. The following table shows the core and reference application image names of the preloaded sample applications.\n\nTable: Sample application image names\n\n\n  \n    \n      Application name\n      Core application\n      Reference application\n    \n  \n  \n    \n      Calculator\n      org.tizen.calculator\n      apps.Calculator\n    \n    \n      Calendar\n      org.tizen.calendar\n      apps.Calendar\n    \n    \n      CalendarService\n      org.tizencalendar-service\n      apps.CalendarService\n    \n    \n      Camera\n      org.tizen.camera-app\n      apps.Camera\n    \n    \n      Clock\n      org.tizen.clock\n      apps.Clock\n    \n    \n      Contacts\n      org.tizen.contacts\n      apps.Contacts\n    \n    \n      Email\n      org.tizen.email\n      apps.Email\n    \n    \n      Gallery\n      org.tizen.gallery\n      apps.Gallery\n    \n    \n      Home\n      org.tizen.menu-screen\n      apps.Home\n    \n    \n      ImageViewer\n      org.tizen.image-viewer\n      apps.ImageViewer\n    \n    \n      Internet\n      org.tizen.browser\n      apps.Internet\n    \n    \n      Lock\n      org.tizen.lockscreen\n      apps.Lock\n    \n    \n      Memo\n      org.tizen.memo\n      apps.Memo\n    \n    \n      Messages\n      org.tizen.message\n      apps.Messages\n    \n    \n      MusicPlayer\n      org.tizen.music-player\n      apps.MusicPlayer\n    \n    \n      MyFiles\n      org.tizen.myfile\n      apps.MyFiles\n    \n    \n      Phone\n      org.tizen.call\n      apps.Phone\n    \n    \n      Settings\n      org.tizen.setting\n      apps.Settings\n    \n    \n      VideoPlayer\n      org.tizen.video-player\n      apps.VideoPlayer"
					}
					
				
			
		
			
				
					,
					
					"iot-porting-application": {
						"id": "iot-porting-application",
						"title": "Application",
						"categories": "",
						"url": " iot/porting/application/",
						"content": "Application\n\nTizen supports both core and reference applications. Core applications are developed with platform internal interfaces, such as the Enlightenment Foundation Libraries (EFL) and other third party libraries. Reference applications are developed with Tizen native APIs.\n\nThe following table shows whether the core and reference versions of the preloaded sample applications are supported by default on the emulator and target device.\n\nTable: Sample application support\n\n\n  \n    \n      Application name\n      Emulator\n       \n      Target\n       \n    \n  \n  \n    \n       \n      Core application\n      Reference application\n      Core application\n      Reference application\n    \n    \n      Calculator\n      No\n      Yes\n      Yes\n      No\n    \n    \n      Calendar\n      No\n      Yes\n      Yes\n      No\n    \n    \n      CalendarService\n      No\n      Yes\n      Yes\n      No\n    \n    \n      Camera\n      No\n      Yes\n      Yes\n      No\n    \n    \n      Clock\n      No\n      Yes\n      Yes\n      No\n    \n    \n      Contacts\n      No\n      Yes\n      Yes\n      No\n    \n    \n      Email\n      No\n      Yes\n      Yes\n      No\n    \n    \n      Gallery\n      No\n      Yes\n      Yes\n      No\n    \n    \n      Home\n      Yes\n      No\n      Yes\n      No\n    \n    \n      ImageViewer\n      No\n      Yes\n      Yes\n      No\n    \n    \n      Internet\n      No\n      Yes\n      No\n      Yes\n    \n    \n      Lock\n      Yes\n      No\n      Yes\n      No\n    \n    \n      Memo\n      No\n      Yes\n      Yes\n      No\n    \n    \n      Messages\n      No\n      Yes\n      Yes\n      No\n    \n    \n      MusicPlayer\n      No\n      Yes\n      Yes\n      No\n    \n    \n      MyFiles\n      No\n      Yes\n      Yes\n      No\n    \n    \n      Phone\n      No\n      Yes\n      Yes\n      No\n    \n    \n      Settings\n      No\n      Yes\n      Yes\n      No\n    \n    \n      VideoPlayer\n      No\n      Yes\n      Yes\n      No\n    \n  \n\n\nConfiguration\n\nYou can switch a preloaded sample application between core and reference applications using the MIC image creator. To switch the application, remove the preloaded application package and add the new package image with the correct name. The following table shows the core and reference application image names of the preloaded sample applications.\n\nTable: Sample application image names\n\n\n  \n    \n      Application name\n      Core application\n      Reference application\n    \n  \n  \n    \n      Calculator\n      org.tizen.calculator\n      apps.Calculator\n    \n    \n      Calendar\n      org.tizen.calendar\n      apps.Calendar\n    \n    \n      CalendarService\n      org.tizencalendar-service\n      apps.CalendarService\n    \n    \n      Camera\n      org.tizen.camera-app\n      apps.Camera\n    \n    \n      Clock\n      org.tizen.clock\n      apps.Clock\n    \n    \n      Contacts\n      org.tizen.contacts\n      apps.Contacts\n    \n    \n      Email\n      org.tizen.email\n      apps.Email\n    \n    \n      Gallery\n      org.tizen.gallery\n      apps.Gallery\n    \n    \n      Home\n      org.tizen.menu-screen\n      apps.Home\n    \n    \n      ImageViewer\n      org.tizen.image-viewer\n      apps.ImageViewer\n    \n    \n      Internet\n      org.tizen.browser\n      apps.Internet\n    \n    \n      Lock\n      org.tizen.lockscreen\n      apps.Lock\n    \n    \n      Memo\n      org.tizen.memo\n      apps.Memo\n    \n    \n      Messages\n      org.tizen.message\n      apps.Messages\n    \n    \n      MusicPlayer\n      org.tizen.music-player\n      apps.MusicPlayer\n    \n    \n      MyFiles\n      org.tizen.myfile\n      apps.MyFiles\n    \n    \n      Phone\n      org.tizen.call\n      apps.Phone\n    \n    \n      Settings\n      org.tizen.setting\n      apps.Settings\n    \n    \n      VideoPlayer\n      org.tizen.video-player\n      apps.VideoPlayer"
					}
					
				
			
		
			
				
					,
					
					"application-developing-building-all": {
						"id": "application-developing-building-all",
						"title": "Building All Packages Locally with GBS",
						"categories": "",
						"url": " application/developing/building-all/",
						"content": "Building All Packages Locally with GBS\n\nYou can perform a build for all Tizen packages using the Git Build System (GBS).\n\nBefore performing the build, study the following instructions:\n\n\n  Setting up the Development Environment\n  Installing Development Tools\n  Building Packages Locally with GBS\n\n\n\n  Note\n\n  \n    To understand the local full build commands, see GBS Build Concepts.\n    To speed up the build process when hardware allows, see Speeding up a Local Build.\n  \n\n\nCloning All Tizen Projects\n\nYou can clone all Tizen projects over SSH or HTTPS.\n\n\n  Note\n\n  Procedures to clone all projects over SSH and HTTPS are almost identical, the only difference being the Git cloning protocol. However, you can only contribute code to Tizen using the SSH method.\n\n\nCloning All Projects over SSH\nYou can clone the source of all projects over SSH, including the latest source and the snapshot source.\n\n\n  Note\n\n  Make sure the SSH configuration file is correctly configured according to Setting up the Development Environment. Otherwise, synchronization cannot be performed successfully and the following error message is displayed:\n\n  ...\nnc: connection failed, SOCKS error 1\nssh_exchange_identification: Connection closed by remote host\nnc: connection failed, SOCKS error 1\n...\nfatal: Could not read from remote repository.\n\nPlease make sure you have the correct access rights and the repository exists.\nssh_exchange_identification: Connection closed by remote host\nfatal: Could not read from remote repository.\n  \n\n\nTo clone the latest sources of all projects over SSH:\n\n\n  Note\n\n  The latest source does not mean the latest sources in the Gerrit server, but the reference snapshot sources where images generated by the reference snapshot are guaranteed by passing all test cases.\n\n\n\n  \n    Create a new directory for Tizen and switch to it:\n\n    $ mkdir ~/&lt;Tizen_Project&gt; &amp;&amp; cd ~/&lt;Tizen_Project&gt;\n    \n  \n  \n    Create a .repo/ directory that contains all the information - for example, Git repositories, commit IDs, and remote URLs - to download all Git repositories to construct all Tizen projects.\nInitialize the repository by executing the following command:\n\n    $ repo init -u ssh://&lt;Username&gt;@review.tizen.org:29418/scm/manifest -b &lt;tizen branch&gt; -m ${profile}_${repository}.xml\n    \n\n    &lt;tizen branch&gt; is tizen for Tizen 5.0, tizen_4.0 for Tizen 4.0 and tizen_3.0 for Tizen 3.0.\n\n    For example:\n\n    \n      \n        Tizen 5.0 Unified / standard\n\n        $ repo init -u ssh://&lt;Username&gt;@review.tizen.org:29418/scm/manifest -b tizen -m unified_standard.xml\n        \n      \n      \n        Tizen 5.0 Unified / emulator\n\n        $ repo init -u ssh://&lt;Username&gt;@review.tizen.org:29418/scm/manifest -b tizen -m unified_emulator.xml\n        \n      \n      \n        Tizen 4.0 Unified / standard\n\n        $ repo init -u ssh://&lt;Username&gt;@review.tizen.org:29418/scm/manifest -b tizen_4.0 -m unified_standard.xml\n        \n      \n      \n        Tizen 4.0 Unified / standard\n\n        $ repo init -u ssh://&lt;Username&gt;@review.tizen.org:29418/scm/manifest -b tizen_4.0 -m unified_standard.xml\n        \n      \n      \n        Tizen 4.0 Unified / emulator\n\n        $ repo init -u ssh://&lt;Username&gt;@review.tizen.org:29418/scm/manifest -b tizen_4.0 -m unified_emulator.xml\n        \n      \n      \n        Tizen 3.0 Common / arm-wayland\n\n        $ repo init -u ssh://&lt;Username&gt;@review.tizen.org:29418/scm/manifest -b tizen_3.0 -m common_arm-wayland.xml\n        \n      \n      \n        Tizen 3.0 Common / arm64-wayland\n\n        $ repo init -u ssh://&lt;Username&gt;@review.tizen.org:29418/scm/manifest -b tizen_3.0 -m common_arm64-wayland.xml\n        \n      \n      \n        Tizen 3.0 Common / emulator32-wayland\n\n        $ repo init -u ssh://&lt;Username&gt;@review.tizen.org:29418/scm/manifest -b tizen_3.0 -m common_emulator32-wayland.xml\n        \n      \n      \n        Tizen 3.0 Common / ia32-wayland\n\n        $ repo init -u ssh://&lt;Username&gt;@review.tizen.org:29418/scm/manifest -b tizen_3.0 -m common_ia32-wayland.xml\n        \n      \n      \n        Tizen 3.0 Common / x86_64-wayland\n\n        $ repo init -u ssh://&lt;Username&gt;@review.tizen.org:29418/scm/manifest -b tizen_3.0 -m common_x86_64-wayland.xml\n        \n      \n      \n        Tizen 3.0 Mobile / arm-wayland\n\n        $ repo init -u ssh://&lt;Username&gt;@review.tizen.org:29418/scm/manifest -b tizen_3.0 -m mobile_arm-wayland.xml\n        \n      \n      \n        Tizen 3.0 Mobile / emulator-wayland\n\n        $ repo init -u ssh://&lt;Username&gt;@review.tizen.org:29418/scm/manifest -b tizen_3.0 -m mobile_emulator-wayland.xml\n        \n      \n      \n        Tizen 3.0 Mobile / target-TM1\n\n        $ repo init -u ssh://&lt;Username&gt;@review.tizen.org:29418/scm/manifest -b tizen_3.0 -m mobile_target-TM1.xml\n        \n      \n      \n        Tizen 3.0 TV / arm-wayland\n\n        $ repo init -u ssh://&lt;Username&gt;@review.tizen.org:29418/scm/manifest -b tizen_3.0 -m tv_arm-wayland.xml\n        \n      \n      \n        Tizen 3.0 TV / emulator32-wayland\n\n        $ repo init -u ssh://&lt;Username&gt;@review.tizen.org:29418/scm/manifest -b tizen_3.0 -m tv_emulator32-wayland.xml\n        \n      \n      \n        Tizen 3.0 TV / emulator64-wayland\n\n        $ repo init -u ssh://&lt;Username&gt;@review.tizen.org:29418/scm/manifest -b tizen_3.0 -m tv_emulator64-wayland.xml\n        \n      \n      \n        Tizen 3.0 Wearable / emulator-circle\n\n        $ repo init -u ssh://&lt;Username&gt;@review.tizen.org:29418/scm/manifest -b tizen_3.0 -m wearable_emulator-circle.xml\n        \n      \n      \n        Tizen 3.0 Wearable / target-circle\n\n        $ repo init -u ssh://&lt;Username&gt;@review.tizen.org:29418/scm/manifest -b tizen_3.0 -m wearable_target-circle.xml\n        \n      \n      \n        Tizen 3.0 Wearable / emulator32-wayland\n\n        $ repo init -u ssh://&lt;Username&gt;@review.tizen.org:29418/scm/manifest -b tizen_3.0 -m wearable_emulator32-wayland.xml\n        \n      \n      \n        Tizen 3.0 IVI /arm\n\n        $ repo init -u ssh://&lt;Username&gt;@review.tizen.org:29418/scm/manifest -b tizen_3.0 -m ivi_arm.xml\n        \n      \n      \n        Tizen 3.0 IVI / emulator\n\n        $ repo init -u ssh://&lt;Username&gt;@review.tizen.org:29418/scm/manifest -b tizen_3.0 -m ivi_emulator.xml\n        \n      \n    \n  \n  \n    Clone the specific snapshot source of all projects over SSH (optional).\nReplace the latest manifest with a snapshot manifest and make proper modifications by executing the following commands, as appropriate:\n\n    $ wget  &lt;Snapshot_Manifest_URL&gt; -O .repo/manifests/&lt;profile&gt;/&lt;repository&gt;/projects.xml\n$ sed -i '3,4d' .repo/manifests/&lt;profile&gt;/&lt;repository&gt;/projects.xml\n    \n\n    For example:\n\n    \n      \n        Tizen 5.0 Unified / standard\n\n        $ wget http://download.tizen.org/releases/weekly/tizen/unified/tizen-unified_20170928.1/builddata/manifest/tizen-unified_20170928.1_standard.xml -O .repo/manifests/unified/standard/projects.xml\n$ sed -i '3,4d' .repo/manifests/unified/standard/projects.xml\n        \n      \n      \n        Tizen 4.0 Unified / emulator\n\n        $ wget http://download.tizen.org/releases/weekly/tizen/4.0-unified/tizen-4.0-unified_20171027.1/builddata/manifest/tizen-4.0-unified_20171027.1_emulator.xml -O .repo/manifests/unified/standard/projects.xml\n$ sed -i '3,4d' .repo/manifests/unified/standard/projects.xml\n        \n      \n      \n        Tizen 3.0 Common / arm64-wayland\n\n        $ wget  http://download.tizen.org/snapshots/tizen/3.0-common/tizen-3.0-common_20170627.1/builddata/manifest/tizen-3.0-common_20170627.1_arm64-wayland.xml -O .repo/manifests/common/arm64-wayland/projects.xml\n$ sed -i '3,4d' .repo/manifests/common/arm64-wayland/projects.xml\n        \n      \n      \n        Tizen 3.0 Mobile / target-TM1\n\n        $ wget  http://download.tizen.org/snapshots/tizen/3.0-mobile/tizen-3.0-mobile_20170627.1/builddata/manifest/tizen-3.0-mobile_20170627.1_target-TM1.xml -O .repo/manifests/mobile/target-TM1/projects.xml\n$ sed -i '3,4d' .repo/manifests/mobile/target-TM1/projects.xml\n        \n      \n      \n        Tizen 3.0 TV / arm-wayland\n\n        $ wget  http://download.tizen.org/snapshots/tizen/3.0-tv/tizen-3.0-tv_20170627.1/builddata/manifest/tizen-3.0-tv_20170627.1_arm-wayland.xml -O .repo/manifests/tv/arm-wayland/projects.xml\n$ sed -i '3,4d' .repo/manifests/tv/arm-wayland/projects.xml\n        \n      \n      \n        Tizen 3.0 Wearable / emulator-circle\n\n        $ wget  http://download.tizen.org/snapshots/tizen/3.0-wearable/tizen-3.0-wearable_20170627.1/builddata/manifest/tizen-3.0-wearable_20170627.1_emulator-circle.xml -O .repo/manifests/wearable/emulator-circle/projects.xml\n$ sed -i '3,4d' .repo/manifests/wearable/emulator-circle/projects.xml\n        \n      \n      \n        Tizen 3.0 IVI / arm\n\n        $ wget  http://download.tizen.org/snapshots/tizen/3.0-ivi/tizen-3.0-ivi_20170627.1/builddata/manifest/tizen-3.0-ivi_20170627.1_arm.xml -O .repo/manifests/ivi/arm/projects.xml\n$ sed -i '3,4d' .repo/manifests/ivi/arm/projects.xml\n        \n      \n    \n  \n  \n    Synchronize the files for all the projects based on the information downloaded by the repo init command by executing the following command:\n    $ repo sync\n    \n  \n\n\nCloning All Projects over HTTPS\n\nYou can clone the source of all projects over HTTPS, including the latest source and the snapshot source.\n\nTo clone the latest sources of all projects over HTTPS:\n\n\n  \n    Create a new directory for Tizen and switch to it:\n\n    $ mkdir ~/&lt;Tizen_Project&gt; &amp;&amp; cd ~/&lt;Tizen_Project&gt;\n    \n  \n  \n    Create a .repo/ directory.\nInitialize the repository by executing the following command:\n\n    $ repo init -u https://git.tizen.org/cgit/scm/manifest -b &lt;tizen branch&gt; -m unified_${repository}.xml\n    \n\n    &lt;tizen branch&gt; is tizen for Tizen 5.0,  tizen_4.0 for Tizen 4.0 and tizen_3.0 for Tizen 3.0.\n\n    \n      Note\n\n      The repo init command using HTTPS is almost identical to that of using SSH. The only difference is the parameter of the '-u' option. Replace 'ssh://&lt;Username&gt;@review.tizen.org:29418/scm/manifest' with 'https://git.tizen.org/cgit/scm/manifests'.\n    \n\n    For example:\n\n    \n      \n        Tizen 5.0 Unified / standard\n\n        $ repo init -u https://git.tizen.org/cgit/scm/manifest -b tizen -m unified_standard.xml\n        \n      \n      \n        Tizen 4.0 Unified / emulator\n\n        $ repo init -u https://git.tizen.org/cgit/scm/manifest -b tizen_4.0 -m unified_emulator.xml\n        \n      \n      \n        Tizen 3.0 Common / arm64-wayland\n\n        $ repo init -u https://git.tizen.org/cgit/scm/manifest -b tizen_3.0 -m common_arm64-wayland.xml\n        \n      \n      \n        Tizen 3.0 Mobile / target-TM1\n\n        $ repo init -u https://git.tizen.org/cgit/scm/manifest -b tizen_3.0 -m mobile_target-TM1.xml\n        \n      \n      \n        Tizen 3.0 TV / arm-wayland\n\n        $ repo init -u https://git.tizen.org/cgit/scm/manifest -b tizen_3.0 -m tv_arm-wayland.xml\n        \n      \n      \n        Tizen 3.0 Wearable / emulator-circle\n\n        $ repo init -u https://git.tizen.org/cgit/scm/manifest -b tizen_3.0 -m wearable_emulator-circle.xml\n        \n      \n      \n        Tizen 3.0 IVI /arm\n\n        $ repo init -u https://git.tizen.org/cgit/scm/manifest -b tizen_3.0 -m ivi_arm.xml\n        \n      \n    \n  \n  \n    Replace the remote ‘fetch url’ in the _remote.xml file by executing the following command:\n\n    $ sed -i 's/ssh://review.tizen.org/https://git.tizen.org//cgit/' .repo/manifests/_remote.xml\n    \n\n    This changes the ‘fetch url’ from fetch=\"ssh://review.tizen.org/\" to fetch=\"https://git.tizen.org/cgit/\".\n  \n  \n    Clone the specific snapshot source of all projects over HTTPS (optional).\n\n    Replace the latest manifest with a snapshot manifest and make proper modifications by executing the following commands, as appropriate:\n\n    $ wget &lt;Snapshot_Manifest_URL&gt; -O .repo/manifests/&lt;profile&gt;/&lt;repository&gt;/projects.xml\n$ sed -i '3,4d' .repo/manifests/&lt;profile&gt;/&lt;repository&gt;/projects.xml\n    \n\n    \n      Note\n\n      This procedure is the same as for SSH.\n    \n  \n  \n    Synchronize the files for all the projects based on the information downloaded by the repo init command by executing the following command:\n    $ repo sync\n    \n  \n\n\nBuilding All Packages\n\nBuild all packages by executing the following commands:\n\n$ cd &lt;Tizen_Project&gt;\n$ gbs build &lt;gbs build option&gt;\n\n\nFor example:\n\n$ cd &lt;Tizen_Project&gt;\n$ gbs build -A i586 --threads=4 --clean-once\n\n\n\n  Note\n\n  Since the GBS configuration file (.gbs.conf) and build configuration file (build.conf) are also included in scm/manifests, they are automatically downloaded in the following paths after the repo sync:\n\n  \n    .gbs.conf: ~/&lt;Tizen_Project&gt;/.gbs.conf\n    build.conf: ~/&lt;Tizen_Project&gt;/scm/meta/build-config/&lt;Tizen version&gt;/&lt;profile&gt;/&lt;repository&gt;_build.conf\n  \n\n\nGBS Build Concepts\nThe following build concepts help you understand the full build commands:\n\n\n  Dependency cycles\n    \n      In Tizen versions 2.4 and higher, packages with dependency cycles are only included in the Tizen:[&lt;Tizen version&gt;]:Base OBS project. Since building packages with dependency cycles is not supported by GBS, it is impossible to build all packages locally with GBS for Tizen:[&lt;Tizen version&gt;]:Base. Therefore, a remote repo which contains RPMs built by OBS for Tizen:[&lt;Tizen version&gt;]:Base needs to be added in the .gbs.conf file.\n      In Tizen versions lower than Tizen 2.3, there is only 1 OBS project and packages with dependency cycles are included in it. To continue the build by breaking the dependency cycles for Tizen versions lower than Tizen 2.3, see Excluding Specific Packages.\n    \n  \n  Accelerator packages\n    \n      Tizen provides cross-compilers and other accelerator packages. For Tizen versions 2.4 and higher, these accelerator packages are included in the Tizen:[&lt;Tizen version&gt;]:Base OBS project.\n      For Tizen versions lower than Tizen 2.3, there is only 1 OBS project and the accelerator packages are included in it. These packages have names ending with -x64 and need to be excluded to build locally with GBS. Otherwise, built out packages are installed and used, and the accelerator packages fail to work. To exclude these accelerator packages for Tizen versions lower than Tizen 2.3, see Excluding Specific Packages."
					}
					
				
			
		
			
				
					,
					
					"platform-developing-building-all": {
						"id": "platform-developing-building-all",
						"title": "Building All Packages Locally with GBS",
						"categories": "",
						"url": " platform/developing/building-all/",
						"content": "Building All Packages Locally with GBS\n\nYou can perform a build for all Tizen packages using the Git Build System (GBS).\n\nBefore performing the build, study the following instructions:\n\n\n  Setting up the Development Environment\n  Installing Development Tools\n  Building Packages Locally with GBS\n\n\n\n  Note\n\n  \n    To understand the local full build commands, see GBS Build Concepts.\n    To speed up the build process when hardware allows, see Speeding up a Local Build.\n  \n\n\nCloning All Tizen Projects\n\nYou can clone all Tizen projects over SSH or HTTPS.\n\n\n  Note\n\n  Procedures to clone all projects over SSH and HTTPS are almost identical, the only difference being the Git cloning protocol. However, you can only contribute code to Tizen using the SSH method.\n\n\nCloning All Projects over SSH\nYou can clone the source of all projects over SSH, including the latest source and the snapshot source.\n\n\n  Note\n\n  Make sure the SSH configuration file is correctly configured according to Setting up the Development Environment. Otherwise, synchronization cannot be performed successfully and the following error message is displayed:\n\n  ...\nnc: connection failed, SOCKS error 1\nssh_exchange_identification: Connection closed by remote host\nnc: connection failed, SOCKS error 1\n...\nfatal: Could not read from remote repository.\n\nPlease make sure you have the correct access rights and the repository exists.\nssh_exchange_identification: Connection closed by remote host\nfatal: Could not read from remote repository.\n  \n\n\nTo clone the latest sources of all projects over SSH:\n\n\n  Note\n\n  The latest source does not mean the latest sources in the Gerrit server, but the reference snapshot sources where images generated by the reference snapshot are guaranteed by passing all test cases.\n\n\n\n  \n    Create a new directory for Tizen and switch to it:\n\n    $ mkdir ~/&lt;Tizen_Project&gt; &amp;&amp; cd ~/&lt;Tizen_Project&gt;\n    \n  \n  \n    Create a .repo/ directory that contains all the information - for example, Git repositories, commit IDs, and remote URLs - to download all Git repositories to construct all Tizen projects.\nInitialize the repository by executing the following command:\n\n    $ repo init -u ssh://&lt;Username&gt;@review.tizen.org:29418/scm/manifest -b &lt;tizen branch&gt; -m ${profile}_${repository}.xml\n    \n\n    &lt;tizen branch&gt; is tizen for Tizen 5.0, tizen_4.0 for Tizen 4.0 and tizen_3.0 for Tizen 3.0.\n\n    For example:\n\n    \n      \n        Tizen 5.0 Unified / standard\n\n        $ repo init -u ssh://&lt;Username&gt;@review.tizen.org:29418/scm/manifest -b tizen -m unified_standard.xml\n        \n      \n      \n        Tizen 5.0 Unified / emulator\n\n        $ repo init -u ssh://&lt;Username&gt;@review.tizen.org:29418/scm/manifest -b tizen -m unified_emulator.xml\n        \n      \n      \n        Tizen 4.0 Unified / standard\n\n        $ repo init -u ssh://&lt;Username&gt;@review.tizen.org:29418/scm/manifest -b tizen_4.0 -m unified_standard.xml\n        \n      \n      \n        Tizen 4.0 Unified / standard\n\n        $ repo init -u ssh://&lt;Username&gt;@review.tizen.org:29418/scm/manifest -b tizen_4.0 -m unified_standard.xml\n        \n      \n      \n        Tizen 4.0 Unified / emulator\n\n        $ repo init -u ssh://&lt;Username&gt;@review.tizen.org:29418/scm/manifest -b tizen_4.0 -m unified_emulator.xml\n        \n      \n      \n        Tizen 3.0 Common / arm-wayland\n\n        $ repo init -u ssh://&lt;Username&gt;@review.tizen.org:29418/scm/manifest -b tizen_3.0 -m common_arm-wayland.xml\n        \n      \n      \n        Tizen 3.0 Common / arm64-wayland\n\n        $ repo init -u ssh://&lt;Username&gt;@review.tizen.org:29418/scm/manifest -b tizen_3.0 -m common_arm64-wayland.xml\n        \n      \n      \n        Tizen 3.0 Common / emulator32-wayland\n\n        $ repo init -u ssh://&lt;Username&gt;@review.tizen.org:29418/scm/manifest -b tizen_3.0 -m common_emulator32-wayland.xml\n        \n      \n      \n        Tizen 3.0 Common / ia32-wayland\n\n        $ repo init -u ssh://&lt;Username&gt;@review.tizen.org:29418/scm/manifest -b tizen_3.0 -m common_ia32-wayland.xml\n        \n      \n      \n        Tizen 3.0 Common / x86_64-wayland\n\n        $ repo init -u ssh://&lt;Username&gt;@review.tizen.org:29418/scm/manifest -b tizen_3.0 -m common_x86_64-wayland.xml\n        \n      \n      \n        Tizen 3.0 Mobile / arm-wayland\n\n        $ repo init -u ssh://&lt;Username&gt;@review.tizen.org:29418/scm/manifest -b tizen_3.0 -m mobile_arm-wayland.xml\n        \n      \n      \n        Tizen 3.0 Mobile / emulator-wayland\n\n        $ repo init -u ssh://&lt;Username&gt;@review.tizen.org:29418/scm/manifest -b tizen_3.0 -m mobile_emulator-wayland.xml\n        \n      \n      \n        Tizen 3.0 Mobile / target-TM1\n\n        $ repo init -u ssh://&lt;Username&gt;@review.tizen.org:29418/scm/manifest -b tizen_3.0 -m mobile_target-TM1.xml\n        \n      \n      \n        Tizen 3.0 TV / arm-wayland\n\n        $ repo init -u ssh://&lt;Username&gt;@review.tizen.org:29418/scm/manifest -b tizen_3.0 -m tv_arm-wayland.xml\n        \n      \n      \n        Tizen 3.0 TV / emulator32-wayland\n\n        $ repo init -u ssh://&lt;Username&gt;@review.tizen.org:29418/scm/manifest -b tizen_3.0 -m tv_emulator32-wayland.xml\n        \n      \n      \n        Tizen 3.0 TV / emulator64-wayland\n\n        $ repo init -u ssh://&lt;Username&gt;@review.tizen.org:29418/scm/manifest -b tizen_3.0 -m tv_emulator64-wayland.xml\n        \n      \n      \n        Tizen 3.0 Wearable / emulator-circle\n\n        $ repo init -u ssh://&lt;Username&gt;@review.tizen.org:29418/scm/manifest -b tizen_3.0 -m wearable_emulator-circle.xml\n        \n      \n      \n        Tizen 3.0 Wearable / target-circle\n\n        $ repo init -u ssh://&lt;Username&gt;@review.tizen.org:29418/scm/manifest -b tizen_3.0 -m wearable_target-circle.xml\n        \n      \n      \n        Tizen 3.0 Wearable / emulator32-wayland\n\n        $ repo init -u ssh://&lt;Username&gt;@review.tizen.org:29418/scm/manifest -b tizen_3.0 -m wearable_emulator32-wayland.xml\n        \n      \n      \n        Tizen 3.0 IVI /arm\n\n        $ repo init -u ssh://&lt;Username&gt;@review.tizen.org:29418/scm/manifest -b tizen_3.0 -m ivi_arm.xml\n        \n      \n      \n        Tizen 3.0 IVI / emulator\n\n        $ repo init -u ssh://&lt;Username&gt;@review.tizen.org:29418/scm/manifest -b tizen_3.0 -m ivi_emulator.xml\n        \n      \n    \n  \n  \n    Clone the specific snapshot source of all projects over SSH (optional).\nReplace the latest manifest with a snapshot manifest and make proper modifications by executing the following commands, as appropriate:\n\n    $ wget  &lt;Snapshot_Manifest_URL&gt; -O .repo/manifests/&lt;profile&gt;/&lt;repository&gt;/projects.xml\n$ sed -i '3,4d' .repo/manifests/&lt;profile&gt;/&lt;repository&gt;/projects.xml\n    \n\n    For example:\n\n    \n      \n        Tizen 5.0 Unified / standard\n\n        $ wget http://download.tizen.org/releases/weekly/tizen/unified/tizen-unified_20170928.1/builddata/manifest/tizen-unified_20170928.1_standard.xml -O .repo/manifests/unified/standard/projects.xml\n$ sed -i '3,4d' .repo/manifests/unified/standard/projects.xml\n        \n      \n      \n        Tizen 4.0 Unified / emulator\n\n        $ wget http://download.tizen.org/releases/weekly/tizen/4.0-unified/tizen-4.0-unified_20171027.1/builddata/manifest/tizen-4.0-unified_20171027.1_emulator.xml -O .repo/manifests/unified/standard/projects.xml\n$ sed -i '3,4d' .repo/manifests/unified/standard/projects.xml\n        \n      \n      \n        Tizen 3.0 Common / arm64-wayland\n\n        $ wget  http://download.tizen.org/snapshots/tizen/3.0-common/tizen-3.0-common_20170627.1/builddata/manifest/tizen-3.0-common_20170627.1_arm64-wayland.xml -O .repo/manifests/common/arm64-wayland/projects.xml\n$ sed -i '3,4d' .repo/manifests/common/arm64-wayland/projects.xml\n        \n      \n      \n        Tizen 3.0 Mobile / target-TM1\n\n        $ wget  http://download.tizen.org/snapshots/tizen/3.0-mobile/tizen-3.0-mobile_20170627.1/builddata/manifest/tizen-3.0-mobile_20170627.1_target-TM1.xml -O .repo/manifests/mobile/target-TM1/projects.xml\n$ sed -i '3,4d' .repo/manifests/mobile/target-TM1/projects.xml\n        \n      \n      \n        Tizen 3.0 TV / arm-wayland\n\n        $ wget  http://download.tizen.org/snapshots/tizen/3.0-tv/tizen-3.0-tv_20170627.1/builddata/manifest/tizen-3.0-tv_20170627.1_arm-wayland.xml -O .repo/manifests/tv/arm-wayland/projects.xml\n$ sed -i '3,4d' .repo/manifests/tv/arm-wayland/projects.xml\n        \n      \n      \n        Tizen 3.0 Wearable / emulator-circle\n\n        $ wget  http://download.tizen.org/snapshots/tizen/3.0-wearable/tizen-3.0-wearable_20170627.1/builddata/manifest/tizen-3.0-wearable_20170627.1_emulator-circle.xml -O .repo/manifests/wearable/emulator-circle/projects.xml\n$ sed -i '3,4d' .repo/manifests/wearable/emulator-circle/projects.xml\n        \n      \n      \n        Tizen 3.0 IVI / arm\n\n        $ wget  http://download.tizen.org/snapshots/tizen/3.0-ivi/tizen-3.0-ivi_20170627.1/builddata/manifest/tizen-3.0-ivi_20170627.1_arm.xml -O .repo/manifests/ivi/arm/projects.xml\n$ sed -i '3,4d' .repo/manifests/ivi/arm/projects.xml\n        \n      \n    \n  \n  \n    Synchronize the files for all the projects based on the information downloaded by the repo init command by executing the following command:\n    $ repo sync\n    \n  \n\n\nCloning All Projects over HTTPS\n\nYou can clone the source of all projects over HTTPS, including the latest source and the snapshot source.\n\nTo clone the latest sources of all projects over HTTPS:\n\n\n  \n    Create a new directory for Tizen and switch to it:\n\n    $ mkdir ~/&lt;Tizen_Project&gt; &amp;&amp; cd ~/&lt;Tizen_Project&gt;\n    \n  \n  \n    Create a .repo/ directory.\nInitialize the repository by executing the following command:\n\n    $ repo init -u https://git.tizen.org/cgit/scm/manifest -b &lt;tizen branch&gt; -m unified_${repository}.xml\n    \n\n    &lt;tizen branch&gt; is tizen for Tizen 5.0,  tizen_4.0 for Tizen 4.0 and tizen_3.0 for Tizen 3.0.\n\n    \n      Note\n\n      The repo init command using HTTPS is almost identical to that of using SSH. The only difference is the parameter of the '-u' option. Replace 'ssh://&lt;Username&gt;@review.tizen.org:29418/scm/manifest' with 'https://git.tizen.org/cgit/scm/manifests'.\n    \n\n    For example:\n\n    \n      \n        Tizen 5.0 Unified / standard\n\n        $ repo init -u https://git.tizen.org/cgit/scm/manifest -b tizen -m unified_standard.xml\n        \n      \n      \n        Tizen 4.0 Unified / emulator\n\n        $ repo init -u https://git.tizen.org/cgit/scm/manifest -b tizen_4.0 -m unified_emulator.xml\n        \n      \n      \n        Tizen 3.0 Common / arm64-wayland\n\n        $ repo init -u https://git.tizen.org/cgit/scm/manifest -b tizen_3.0 -m common_arm64-wayland.xml\n        \n      \n      \n        Tizen 3.0 Mobile / target-TM1\n\n        $ repo init -u https://git.tizen.org/cgit/scm/manifest -b tizen_3.0 -m mobile_target-TM1.xml\n        \n      \n      \n        Tizen 3.0 TV / arm-wayland\n\n        $ repo init -u https://git.tizen.org/cgit/scm/manifest -b tizen_3.0 -m tv_arm-wayland.xml\n        \n      \n      \n        Tizen 3.0 Wearable / emulator-circle\n\n        $ repo init -u https://git.tizen.org/cgit/scm/manifest -b tizen_3.0 -m wearable_emulator-circle.xml\n        \n      \n      \n        Tizen 3.0 IVI /arm\n\n        $ repo init -u https://git.tizen.org/cgit/scm/manifest -b tizen_3.0 -m ivi_arm.xml\n        \n      \n    \n  \n  \n    Replace the remote ‘fetch url’ in the _remote.xml file by executing the following command:\n\n    $ sed -i 's/ssh://review.tizen.org/https://git.tizen.org//cgit/' .repo/manifests/_remote.xml\n    \n\n    This changes the ‘fetch url’ from fetch=\"ssh://review.tizen.org/\" to fetch=\"https://git.tizen.org/cgit/\".\n  \n  \n    Clone the specific snapshot source of all projects over HTTPS (optional).\n\n    Replace the latest manifest with a snapshot manifest and make proper modifications by executing the following commands, as appropriate:\n\n    $ wget &lt;Snapshot_Manifest_URL&gt; -O .repo/manifests/&lt;profile&gt;/&lt;repository&gt;/projects.xml\n$ sed -i '3,4d' .repo/manifests/&lt;profile&gt;/&lt;repository&gt;/projects.xml\n    \n\n    \n      Note\n\n      This procedure is the same as for SSH.\n    \n  \n  \n    Synchronize the files for all the projects based on the information downloaded by the repo init command by executing the following command:\n    $ repo sync\n    \n  \n\n\nBuilding All Packages\n\nBuild all packages by executing the following commands:\n\n$ cd &lt;Tizen_Project&gt;\n$ gbs build &lt;gbs build option&gt;\n\n\nFor example:\n\n$ cd &lt;Tizen_Project&gt;\n$ gbs build -A i586 --threads=4 --clean-once\n\n\n\n  Note\n\n  Since the GBS configuration file (.gbs.conf) and build configuration file (build.conf) are also included in scm/manifests, they are automatically downloaded in the following paths after the repo sync:\n\n  \n    .gbs.conf: ~/&lt;Tizen_Project&gt;/.gbs.conf\n    build.conf: ~/&lt;Tizen_Project&gt;/scm/meta/build-config/&lt;Tizen version&gt;/&lt;profile&gt;/&lt;repository&gt;_build.conf\n  \n\n\nGBS Build Concepts\nThe following build concepts help you understand the full build commands:\n\n\n  Dependency cycles\n    \n      In Tizen versions 2.4 and higher, packages with dependency cycles are only included in the Tizen:[&lt;Tizen version&gt;]:Base OBS project. Since building packages with dependency cycles is not supported by GBS, it is impossible to build all packages locally with GBS for Tizen:[&lt;Tizen version&gt;]:Base. Therefore, a remote repo which contains RPMs built by OBS for Tizen:[&lt;Tizen version&gt;]:Base needs to be added in the .gbs.conf file.\n      In Tizen versions lower than Tizen 2.3, there is only 1 OBS project and packages with dependency cycles are included in it. To continue the build by breaking the dependency cycles for Tizen versions lower than Tizen 2.3, see Excluding Specific Packages.\n    \n  \n  Accelerator packages\n    \n      Tizen provides cross-compilers and other accelerator packages. For Tizen versions 2.4 and higher, these accelerator packages are included in the Tizen:[&lt;Tizen version&gt;]:Base OBS project.\n      For Tizen versions lower than Tizen 2.3, there is only 1 OBS project and the accelerator packages are included in it. These packages have names ending with -x64 and need to be excluded to build locally with GBS. Otherwise, built out packages are installed and used, and the accelerator packages fail to work. To exclude these accelerator packages for Tizen versions lower than Tizen 2.3, see Excluding Specific Packages."
					}
					
				
			
		
			
				
					,
					
					"iot-developing-building-all": {
						"id": "iot-developing-building-all",
						"title": "Building All Packages Locally with GBS",
						"categories": "",
						"url": " iot/developing/building-all/",
						"content": "Building All Packages Locally with GBS\n\nYou can perform a build for all Tizen packages using the Git Build System (GBS).\n\nBefore performing the build, study the following instructions:\n\n\n  Setting up the Development Environment\n  Installing Development Tools\n  Building Packages Locally with GBS\n\n\n\n  Note\n\n  \n    To understand the local full build commands, see GBS Build Concepts.\n    To speed up the build process when hardware allows, see Speeding up a Local Build.\n  \n\n\nCloning All Tizen Projects\n\nYou can clone all Tizen projects over SSH or HTTPS.\n\n\n  Note\n\n  Procedures to clone all projects over SSH and HTTPS are almost identical, the only difference being the Git cloning protocol. However, you can only contribute code to Tizen using the SSH method.\n\n\nCloning All Projects over SSH\nYou can clone the source of all projects over SSH, including the latest source and the snapshot source.\n\n\n  Note\n\n  Make sure the SSH configuration file is correctly configured according to Setting up the Development Environment. Otherwise, synchronization cannot be performed successfully and the following error message is displayed:\n\n  ...\nnc: connection failed, SOCKS error 1\nssh_exchange_identification: Connection closed by remote host\nnc: connection failed, SOCKS error 1\n...\nfatal: Could not read from remote repository.\n\nPlease make sure you have the correct access rights and the repository exists.\nssh_exchange_identification: Connection closed by remote host\nfatal: Could not read from remote repository.\n  \n\n\nTo clone the latest sources of all projects over SSH:\n\n\n  Note\n\n  The latest source does not mean the latest sources in the Gerrit server, but the reference snapshot sources where images generated by the reference snapshot are guaranteed by passing all test cases.\n\n\n\n  \n    Create a new directory for Tizen and switch to it:\n\n    $ mkdir ~/&lt;Tizen_Project&gt; &amp;&amp; cd ~/&lt;Tizen_Project&gt;\n    \n  \n  \n    Create a .repo/ directory that contains all the information - for example, Git repositories, commit IDs, and remote URLs - to download all Git repositories to construct all Tizen projects.\nInitialize the repository by executing the following command:\n\n    $ repo init -u ssh://&lt;Username&gt;@review.tizen.org:29418/scm/manifest -b &lt;tizen branch&gt; -m ${profile}_${repository}.xml\n    \n\n    &lt;tizen branch&gt; is tizen for Tizen 5.0, tizen_4.0 for Tizen 4.0 and tizen_3.0 for Tizen 3.0.\n\n    For example:\n\n    \n      \n        Tizen 5.0 Unified / standard\n\n        $ repo init -u ssh://&lt;Username&gt;@review.tizen.org:29418/scm/manifest -b tizen -m unified_standard.xml\n        \n      \n      \n        Tizen 5.0 Unified / emulator\n\n        $ repo init -u ssh://&lt;Username&gt;@review.tizen.org:29418/scm/manifest -b tizen -m unified_emulator.xml\n        \n      \n      \n        Tizen 4.0 Unified / standard\n\n        $ repo init -u ssh://&lt;Username&gt;@review.tizen.org:29418/scm/manifest -b tizen_4.0 -m unified_standard.xml\n        \n      \n      \n        Tizen 4.0 Unified / standard\n\n        $ repo init -u ssh://&lt;Username&gt;@review.tizen.org:29418/scm/manifest -b tizen_4.0 -m unified_standard.xml\n        \n      \n      \n        Tizen 4.0 Unified / emulator\n\n        $ repo init -u ssh://&lt;Username&gt;@review.tizen.org:29418/scm/manifest -b tizen_4.0 -m unified_emulator.xml\n        \n      \n      \n        Tizen 3.0 Common / arm-wayland\n\n        $ repo init -u ssh://&lt;Username&gt;@review.tizen.org:29418/scm/manifest -b tizen_3.0 -m common_arm-wayland.xml\n        \n      \n      \n        Tizen 3.0 Common / arm64-wayland\n\n        $ repo init -u ssh://&lt;Username&gt;@review.tizen.org:29418/scm/manifest -b tizen_3.0 -m common_arm64-wayland.xml\n        \n      \n      \n        Tizen 3.0 Common / emulator32-wayland\n\n        $ repo init -u ssh://&lt;Username&gt;@review.tizen.org:29418/scm/manifest -b tizen_3.0 -m common_emulator32-wayland.xml\n        \n      \n      \n        Tizen 3.0 Common / ia32-wayland\n\n        $ repo init -u ssh://&lt;Username&gt;@review.tizen.org:29418/scm/manifest -b tizen_3.0 -m common_ia32-wayland.xml\n        \n      \n      \n        Tizen 3.0 Common / x86_64-wayland\n\n        $ repo init -u ssh://&lt;Username&gt;@review.tizen.org:29418/scm/manifest -b tizen_3.0 -m common_x86_64-wayland.xml\n        \n      \n      \n        Tizen 3.0 Mobile / arm-wayland\n\n        $ repo init -u ssh://&lt;Username&gt;@review.tizen.org:29418/scm/manifest -b tizen_3.0 -m mobile_arm-wayland.xml\n        \n      \n      \n        Tizen 3.0 Mobile / emulator-wayland\n\n        $ repo init -u ssh://&lt;Username&gt;@review.tizen.org:29418/scm/manifest -b tizen_3.0 -m mobile_emulator-wayland.xml\n        \n      \n      \n        Tizen 3.0 Mobile / target-TM1\n\n        $ repo init -u ssh://&lt;Username&gt;@review.tizen.org:29418/scm/manifest -b tizen_3.0 -m mobile_target-TM1.xml\n        \n      \n      \n        Tizen 3.0 TV / arm-wayland\n\n        $ repo init -u ssh://&lt;Username&gt;@review.tizen.org:29418/scm/manifest -b tizen_3.0 -m tv_arm-wayland.xml\n        \n      \n      \n        Tizen 3.0 TV / emulator32-wayland\n\n        $ repo init -u ssh://&lt;Username&gt;@review.tizen.org:29418/scm/manifest -b tizen_3.0 -m tv_emulator32-wayland.xml\n        \n      \n      \n        Tizen 3.0 TV / emulator64-wayland\n\n        $ repo init -u ssh://&lt;Username&gt;@review.tizen.org:29418/scm/manifest -b tizen_3.0 -m tv_emulator64-wayland.xml\n        \n      \n      \n        Tizen 3.0 Wearable / emulator-circle\n\n        $ repo init -u ssh://&lt;Username&gt;@review.tizen.org:29418/scm/manifest -b tizen_3.0 -m wearable_emulator-circle.xml\n        \n      \n      \n        Tizen 3.0 Wearable / target-circle\n\n        $ repo init -u ssh://&lt;Username&gt;@review.tizen.org:29418/scm/manifest -b tizen_3.0 -m wearable_target-circle.xml\n        \n      \n      \n        Tizen 3.0 Wearable / emulator32-wayland\n\n        $ repo init -u ssh://&lt;Username&gt;@review.tizen.org:29418/scm/manifest -b tizen_3.0 -m wearable_emulator32-wayland.xml\n        \n      \n      \n        Tizen 3.0 IVI /arm\n\n        $ repo init -u ssh://&lt;Username&gt;@review.tizen.org:29418/scm/manifest -b tizen_3.0 -m ivi_arm.xml\n        \n      \n      \n        Tizen 3.0 IVI / emulator\n\n        $ repo init -u ssh://&lt;Username&gt;@review.tizen.org:29418/scm/manifest -b tizen_3.0 -m ivi_emulator.xml\n        \n      \n    \n  \n  \n    Clone the specific snapshot source of all projects over SSH (optional).\nReplace the latest manifest with a snapshot manifest and make proper modifications by executing the following commands, as appropriate:\n\n    $ wget  &lt;Snapshot_Manifest_URL&gt; -O .repo/manifests/&lt;profile&gt;/&lt;repository&gt;/projects.xml\n$ sed -i '3,4d' .repo/manifests/&lt;profile&gt;/&lt;repository&gt;/projects.xml\n    \n\n    For example:\n\n    \n      \n        Tizen 5.0 Unified / standard\n\n        $ wget http://download.tizen.org/releases/weekly/tizen/unified/tizen-unified_20170928.1/builddata/manifest/tizen-unified_20170928.1_standard.xml -O .repo/manifests/unified/standard/projects.xml\n$ sed -i '3,4d' .repo/manifests/unified/standard/projects.xml\n        \n      \n      \n        Tizen 4.0 Unified / emulator\n\n        $ wget http://download.tizen.org/releases/weekly/tizen/4.0-unified/tizen-4.0-unified_20171027.1/builddata/manifest/tizen-4.0-unified_20171027.1_emulator.xml -O .repo/manifests/unified/standard/projects.xml\n$ sed -i '3,4d' .repo/manifests/unified/standard/projects.xml\n        \n      \n      \n        Tizen 3.0 Common / arm64-wayland\n\n        $ wget  http://download.tizen.org/snapshots/tizen/3.0-common/tizen-3.0-common_20170627.1/builddata/manifest/tizen-3.0-common_20170627.1_arm64-wayland.xml -O .repo/manifests/common/arm64-wayland/projects.xml\n$ sed -i '3,4d' .repo/manifests/common/arm64-wayland/projects.xml\n        \n      \n      \n        Tizen 3.0 Mobile / target-TM1\n\n        $ wget  http://download.tizen.org/snapshots/tizen/3.0-mobile/tizen-3.0-mobile_20170627.1/builddata/manifest/tizen-3.0-mobile_20170627.1_target-TM1.xml -O .repo/manifests/mobile/target-TM1/projects.xml\n$ sed -i '3,4d' .repo/manifests/mobile/target-TM1/projects.xml\n        \n      \n      \n        Tizen 3.0 TV / arm-wayland\n\n        $ wget  http://download.tizen.org/snapshots/tizen/3.0-tv/tizen-3.0-tv_20170627.1/builddata/manifest/tizen-3.0-tv_20170627.1_arm-wayland.xml -O .repo/manifests/tv/arm-wayland/projects.xml\n$ sed -i '3,4d' .repo/manifests/tv/arm-wayland/projects.xml\n        \n      \n      \n        Tizen 3.0 Wearable / emulator-circle\n\n        $ wget  http://download.tizen.org/snapshots/tizen/3.0-wearable/tizen-3.0-wearable_20170627.1/builddata/manifest/tizen-3.0-wearable_20170627.1_emulator-circle.xml -O .repo/manifests/wearable/emulator-circle/projects.xml\n$ sed -i '3,4d' .repo/manifests/wearable/emulator-circle/projects.xml\n        \n      \n      \n        Tizen 3.0 IVI / arm\n\n        $ wget  http://download.tizen.org/snapshots/tizen/3.0-ivi/tizen-3.0-ivi_20170627.1/builddata/manifest/tizen-3.0-ivi_20170627.1_arm.xml -O .repo/manifests/ivi/arm/projects.xml\n$ sed -i '3,4d' .repo/manifests/ivi/arm/projects.xml\n        \n      \n    \n  \n  \n    Synchronize the files for all the projects based on the information downloaded by the repo init command by executing the following command:\n    $ repo sync\n    \n  \n\n\nCloning All Projects over HTTPS\n\nYou can clone the source of all projects over HTTPS, including the latest source and the snapshot source.\n\nTo clone the latest sources of all projects over HTTPS:\n\n\n  \n    Create a new directory for Tizen and switch to it:\n\n    $ mkdir ~/&lt;Tizen_Project&gt; &amp;&amp; cd ~/&lt;Tizen_Project&gt;\n    \n  \n  \n    Create a .repo/ directory.\nInitialize the repository by executing the following command:\n\n    $ repo init -u https://git.tizen.org/cgit/scm/manifest -b &lt;tizen branch&gt; -m unified_${repository}.xml\n    \n\n    &lt;tizen branch&gt; is tizen for Tizen 5.0,  tizen_4.0 for Tizen 4.0 and tizen_3.0 for Tizen 3.0.\n\n    \n      Note\n\n      The repo init command using HTTPS is almost identical to that of using SSH. The only difference is the parameter of the '-u' option. Replace 'ssh://&lt;Username&gt;@review.tizen.org:29418/scm/manifest' with 'https://git.tizen.org/cgit/scm/manifests'.\n    \n\n    For example:\n\n    \n      \n        Tizen 5.0 Unified / standard\n\n        $ repo init -u https://git.tizen.org/cgit/scm/manifest -b tizen -m unified_standard.xml\n        \n      \n      \n        Tizen 4.0 Unified / emulator\n\n        $ repo init -u https://git.tizen.org/cgit/scm/manifest -b tizen_4.0 -m unified_emulator.xml\n        \n      \n      \n        Tizen 3.0 Common / arm64-wayland\n\n        $ repo init -u https://git.tizen.org/cgit/scm/manifest -b tizen_3.0 -m common_arm64-wayland.xml\n        \n      \n      \n        Tizen 3.0 Mobile / target-TM1\n\n        $ repo init -u https://git.tizen.org/cgit/scm/manifest -b tizen_3.0 -m mobile_target-TM1.xml\n        \n      \n      \n        Tizen 3.0 TV / arm-wayland\n\n        $ repo init -u https://git.tizen.org/cgit/scm/manifest -b tizen_3.0 -m tv_arm-wayland.xml\n        \n      \n      \n        Tizen 3.0 Wearable / emulator-circle\n\n        $ repo init -u https://git.tizen.org/cgit/scm/manifest -b tizen_3.0 -m wearable_emulator-circle.xml\n        \n      \n      \n        Tizen 3.0 IVI /arm\n\n        $ repo init -u https://git.tizen.org/cgit/scm/manifest -b tizen_3.0 -m ivi_arm.xml\n        \n      \n    \n  \n  \n    Replace the remote ‘fetch url’ in the _remote.xml file by executing the following command:\n\n    $ sed -i 's/ssh://review.tizen.org/https://git.tizen.org//cgit/' .repo/manifests/_remote.xml\n    \n\n    This changes the ‘fetch url’ from fetch=\"ssh://review.tizen.org/\" to fetch=\"https://git.tizen.org/cgit/\".\n  \n  \n    Clone the specific snapshot source of all projects over HTTPS (optional).\n\n    Replace the latest manifest with a snapshot manifest and make proper modifications by executing the following commands, as appropriate:\n\n    $ wget &lt;Snapshot_Manifest_URL&gt; -O .repo/manifests/&lt;profile&gt;/&lt;repository&gt;/projects.xml\n$ sed -i '3,4d' .repo/manifests/&lt;profile&gt;/&lt;repository&gt;/projects.xml\n    \n\n    \n      Note\n\n      This procedure is the same as for SSH.\n    \n  \n  \n    Synchronize the files for all the projects based on the information downloaded by the repo init command by executing the following command:\n    $ repo sync\n    \n  \n\n\nBuilding All Packages\n\nBuild all packages by executing the following commands:\n\n$ cd &lt;Tizen_Project&gt;\n$ gbs build &lt;gbs build option&gt;\n\n\nFor example:\n\n$ cd &lt;Tizen_Project&gt;\n$ gbs build -A i586 --threads=4 --clean-once\n\n\n\n  Note\n\n  Since the GBS configuration file (.gbs.conf) and build configuration file (build.conf) are also included in scm/manifests, they are automatically downloaded in the following paths after the repo sync:\n\n  \n    .gbs.conf: ~/&lt;Tizen_Project&gt;/.gbs.conf\n    build.conf: ~/&lt;Tizen_Project&gt;/scm/meta/build-config/&lt;Tizen version&gt;/&lt;profile&gt;/&lt;repository&gt;_build.conf\n  \n\n\nGBS Build Concepts\nThe following build concepts help you understand the full build commands:\n\n\n  Dependency cycles\n    \n      In Tizen versions 2.4 and higher, packages with dependency cycles are only included in the Tizen:[&lt;Tizen version&gt;]:Base OBS project. Since building packages with dependency cycles is not supported by GBS, it is impossible to build all packages locally with GBS for Tizen:[&lt;Tizen version&gt;]:Base. Therefore, a remote repo which contains RPMs built by OBS for Tizen:[&lt;Tizen version&gt;]:Base needs to be added in the .gbs.conf file.\n      In Tizen versions lower than Tizen 2.3, there is only 1 OBS project and packages with dependency cycles are included in it. To continue the build by breaking the dependency cycles for Tizen versions lower than Tizen 2.3, see Excluding Specific Packages.\n    \n  \n  Accelerator packages\n    \n      Tizen provides cross-compilers and other accelerator packages. For Tizen versions 2.4 and higher, these accelerator packages are included in the Tizen:[&lt;Tizen version&gt;]:Base OBS project.\n      For Tizen versions lower than Tizen 2.3, there is only 1 OBS project and the accelerator packages are included in it. These packages have names ending with -x64 and need to be excluded to build locally with GBS. Otherwise, built out packages are installed and used, and the accelerator packages fail to work. To exclude these accelerator packages for Tizen versions lower than Tizen 2.3, see Excluding Specific Packages."
					}
					
				
			
		
			
				
					,
					
					"application-developing-building": {
						"id": "application-developing-building",
						"title": "Building Packages Locally with GBS",
						"categories": "",
						"url": " application/developing/building/",
						"content": "Building Packages Locally with GBS\n\nYou can perform local builds using the Git Build System (GBS).\n\nBefore performing local builds, study the following instructions:\n\n\n  Setting up the Development Environment\n  Installing Development Tools\n  Cloning Tizen Source Files\n\n\nTo build a package for a specific project:\n\n\n  To clone the source of a specific project, follow the instructions in Cloning Tizen Source Files.\n  \n    Switch to the directory that contains the project:\n\n    $ cd &lt;Specific_Project&gt;\n    \n  \n  \n    Create a  &lt;Specific_Project&gt;/.gbs.conf GBS configuration file (optional).\n\n    If a &lt;Specific_Project&gt;/.gbs.conf file exists, the configuration in that file is used when building the project with GBS. If not, the default GBS configuration in the ~/.gbs.conf file is used.\n\n    For more information about the .gbs.conf file and the customization of remote repositories, see GBS Configuration and Setting up the Development Environment, respectively.\n  \n  \n    Build a package for the project:\n\n    $ gbs build &lt;gbs build option&gt;\n    \n  \n  Take follow-up actions, if necessary. For more information, see Performing Another Build.\n\n\nBuild Tips\n\nThe build tips for local builds include:\n\n\n  How to exclude specific packages.\n  How to speed up a local build.\n  How to perform another build.\n\n\nExcluding Specific Packages\n\nTo exclude specific packages when building locally with GBS, you can either list them in the --exclude argument of the gbs build command, or list them in the .gbs.conf file:\n\n\n  To exclude packages when running the gbs build command, use the --exclude build argument:\n    $ exclude_pkgs=\"aaa bbb ccc ddd\"\n$ gbs build -A armv7l --exclude=${exclude_pkgs},eee,fff\n    \n  \n  To specify a list of excluded packages in the .gbs.conf file, use the excluded_packages parameter inside a profile block:\n    [profile.unified_standard]\nrepos = repo.base_arm,repo.base_arm_debug,repo.base_arm64,repo.base_arm64_debug,repo.base_ia32,repo.base_ia32_debug,repo.base_x86_64,repo.base_x86_64_debug,repo.unified_standard,repo.unified_standard_debug\nexclude_packages=aaa,bbb,ccc,ddd,eee,fff\n    \n  \n\n\nSpeeding up a Local Build\n\nIf the size of your RAM and swap file are both larger than 8 GB, you can speed up building by creating a GBS BUILD-ROOTS directory and mounting it as a RAM disk:\n\n$ mkdir -p ~/GBS-ROOT/local/BUILD-ROOTS\n$ sudo mount -t tmpfs -o size=16G tmpfs ~/GBS-ROOT/local/BUILD-ROOTS\n\n\nPerforming Another Build\n\nWhen the result of the first build is unsatisfactory, perform another build by executing 1 of the following commands, as appropriate:\n\n\n  Scenario 1:\n    \n      The URL of the remote repository is the same as in the previous build.\n      New packages to be built are dependent on previously built packages.\n      You want previously built packages to participate in the new build.\n    \n\n    $ gbs build -A &lt;Arch&gt;\n    \n  \n  Scenario 2:\n    \n      The URL of the remote repository is the same as in the previous build.\n      New packages to be built are dependent on previously built packages.\n      You do not want previously built packages to participate in the new build.\n    \n\n    $ gbs build -A &lt;Arch&gt; --clean-repos\n    \n  \n  \n    Scenario 3:\n\n    \n      The URL of the remote repository has changed.\n      New packages to be built are not dependent on previously built packages.\n    \n\n    $ gbs build -A &lt;Arch&gt; --clean\n    \n  \n  Scenario 4:\n    \n      The URL of the remote repository has changed.\n      New packages to be built are dependent on previously built packages.\n      You want previously built packages to participate in the new build.\n    \n\n    $ gbs build -A &lt;Arch&gt; --clean\n    \n  \n  Scenario 5:\n    \n      The URL of the remote repository has changed.\n      New packages to be built are dependent on previously built packages.\n      You do not want previously built packages to participate in the new build.\n    \n\n    $ gbs build -A &lt;Arch&gt; --clean --clean-repos\n    \n  \n\n\nThe building directory during runtime is ~/GBS-ROOT/local/BUILD-ROOTS/scratch.&lt;Arch&gt;.&lt;Number_of_Threads&gt;, into which the following input related to the current build is loaded to construct an independent building environment:\n\n\n  Source code in &lt;Specific_Project&gt;\n  Local RPM packages in ~/GBS-ROOT/local/repos/&lt;Release_ID&gt;/&lt;Arch&gt;\n  Remote RPM packages in a repository URL inside the GBS configuration file. For example: http://download.tizen.org/releases/daily/tizen/&lt;Tizen_Profile&gt;/&lt;Release_ID&gt;/repos/&lt;Repository&gt;/packages/\n\n\nAfter a successful build, GBS moves the build result, including generated RPM packages, SRPM packages, and build logs, into the output directory, ~/GBS-ROOT/local/repos/&lt;Release_ID&gt;/&lt;Arch&gt;. The output directory content automatically participates in a new build, if any, and can have a potential impact on the new build, depending on the dependency between the existing packages already built and new packages to be built. For example:\n\n\n  Suppose package B has a dependency on package A, which means in package B building, A-1.rpm in the remote repository is used.\n  Build package A first.\n  A-2.rpm is generated under ~/GBS-ROOT/.\n  Build package B.\n  A-2.rpm under ~/GBS-ROOT/ is used in package B building, instead of A-1.rpm in the remote repository.\n\n\nBased on the above working mechanism of the GBS build, the following rules must be followed for the gbs buildcommand to guarantee the quality of the new build:\n\n\n  If the URL of the remote repository has changed, add the --clean parameter. If this parameter is given, the current ~/GBS-ROOT/local/BUILD-ROOTS/scratch.&lt;Arch&gt;.&lt;Number_of_Threads&gt; directory is cleaned up, to remove previously constructed GBS build environment.\n  If new packages to be built are dependent on the previously built packages that you do not want to involve in the new build, add the --clean-repos parameter. If this parameter is given, the current ~/GBS-ROOT/local/repos/&lt;Release_ID&gt;/&lt;Arch&gt; directory is cleaned up, to remove previously built packages."
					}
					
				
			
		
			
				
					,
					
					"platform-developing-building": {
						"id": "platform-developing-building",
						"title": "Building Packages Locally with GBS",
						"categories": "",
						"url": " platform/developing/building/",
						"content": "Building Packages Locally with GBS\n\nYou can perform local builds using the Git Build System (GBS).\n\nBefore performing local builds, study the following instructions:\n\n\n  Setting up the Development Environment\n  Installing Development Tools\n  Cloning Tizen Source Files\n\n\nTo build a package for a specific project:\n\n\n  To clone the source of a specific project, follow the instructions in Cloning Tizen Source Files.\n  \n    Switch to the directory that contains the project:\n\n    $ cd &lt;Specific_Project&gt;\n    \n  \n  \n    Create a  &lt;Specific_Project&gt;/.gbs.conf GBS configuration file (optional).\n\n    If a &lt;Specific_Project&gt;/.gbs.conf file exists, the configuration in that file is used when building the project with GBS. If not, the default GBS configuration in the ~/.gbs.conf file is used.\n\n    For more information about the .gbs.conf file and the customization of remote repositories, see GBS Configuration and Setting up the Development Environment, respectively.\n  \n  \n    Build a package for the project:\n\n    $ gbs build &lt;gbs build option&gt;\n    \n  \n  Take follow-up actions, if necessary. For more information, see Performing Another Build.\n\n\nBuild Tips\n\nThe build tips for local builds include:\n\n\n  How to exclude specific packages.\n  How to speed up a local build.\n  How to perform another build.\n\n\nExcluding Specific Packages\n\nTo exclude specific packages when building locally with GBS, you can either list them in the --exclude argument of the gbs build command, or list them in the .gbs.conf file:\n\n\n  To exclude packages when running the gbs build command, use the --exclude build argument:\n    $ exclude_pkgs=\"aaa bbb ccc ddd\"\n$ gbs build -A armv7l --exclude=${exclude_pkgs},eee,fff\n    \n  \n  To specify a list of excluded packages in the .gbs.conf file, use the excluded_packages parameter inside a profile block:\n    [profile.unified_standard]\nrepos = repo.base_arm,repo.base_arm_debug,repo.base_arm64,repo.base_arm64_debug,repo.base_ia32,repo.base_ia32_debug,repo.base_x86_64,repo.base_x86_64_debug,repo.unified_standard,repo.unified_standard_debug\nexclude_packages=aaa,bbb,ccc,ddd,eee,fff\n    \n  \n\n\nSpeeding up a Local Build\n\nIf the size of your RAM and swap file are both larger than 8 GB, you can speed up building by creating a GBS BUILD-ROOTS directory and mounting it as a RAM disk:\n\n$ mkdir -p ~/GBS-ROOT/local/BUILD-ROOTS\n$ sudo mount -t tmpfs -o size=16G tmpfs ~/GBS-ROOT/local/BUILD-ROOTS\n\n\nPerforming Another Build\n\nWhen the result of the first build is unsatisfactory, perform another build by executing 1 of the following commands, as appropriate:\n\n\n  Scenario 1:\n    \n      The URL of the remote repository is the same as in the previous build.\n      New packages to be built are dependent on previously built packages.\n      You want previously built packages to participate in the new build.\n    \n\n    $ gbs build -A &lt;Arch&gt;\n    \n  \n  Scenario 2:\n    \n      The URL of the remote repository is the same as in the previous build.\n      New packages to be built are dependent on previously built packages.\n      You do not want previously built packages to participate in the new build.\n    \n\n    $ gbs build -A &lt;Arch&gt; --clean-repos\n    \n  \n  \n    Scenario 3:\n\n    \n      The URL of the remote repository has changed.\n      New packages to be built are not dependent on previously built packages.\n    \n\n    $ gbs build -A &lt;Arch&gt; --clean\n    \n  \n  Scenario 4:\n    \n      The URL of the remote repository has changed.\n      New packages to be built are dependent on previously built packages.\n      You want previously built packages to participate in the new build.\n    \n\n    $ gbs build -A &lt;Arch&gt; --clean\n    \n  \n  Scenario 5:\n    \n      The URL of the remote repository has changed.\n      New packages to be built are dependent on previously built packages.\n      You do not want previously built packages to participate in the new build.\n    \n\n    $ gbs build -A &lt;Arch&gt; --clean --clean-repos\n    \n  \n\n\nThe building directory during runtime is ~/GBS-ROOT/local/BUILD-ROOTS/scratch.&lt;Arch&gt;.&lt;Number_of_Threads&gt;, into which the following input related to the current build is loaded to construct an independent building environment:\n\n\n  Source code in &lt;Specific_Project&gt;\n  Local RPM packages in ~/GBS-ROOT/local/repos/&lt;Release_ID&gt;/&lt;Arch&gt;\n  Remote RPM packages in a repository URL inside the GBS configuration file. For example: http://download.tizen.org/releases/daily/tizen/&lt;Tizen_Profile&gt;/&lt;Release_ID&gt;/repos/&lt;Repository&gt;/packages/\n\n\nAfter a successful build, GBS moves the build result, including generated RPM packages, SRPM packages, and build logs, into the output directory, ~/GBS-ROOT/local/repos/&lt;Release_ID&gt;/&lt;Arch&gt;. The output directory content automatically participates in a new build, if any, and can have a potential impact on the new build, depending on the dependency between the existing packages already built and new packages to be built. For example:\n\n\n  Suppose package B has a dependency on package A, which means in package B building, A-1.rpm in the remote repository is used.\n  Build package A first.\n  A-2.rpm is generated under ~/GBS-ROOT/.\n  Build package B.\n  A-2.rpm under ~/GBS-ROOT/ is used in package B building, instead of A-1.rpm in the remote repository.\n\n\nBased on the above working mechanism of the GBS build, the following rules must be followed for the gbs buildcommand to guarantee the quality of the new build:\n\n\n  If the URL of the remote repository has changed, add the --clean parameter. If this parameter is given, the current ~/GBS-ROOT/local/BUILD-ROOTS/scratch.&lt;Arch&gt;.&lt;Number_of_Threads&gt; directory is cleaned up, to remove previously constructed GBS build environment.\n  If new packages to be built are dependent on the previously built packages that you do not want to involve in the new build, add the --clean-repos parameter. If this parameter is given, the current ~/GBS-ROOT/local/repos/&lt;Release_ID&gt;/&lt;Arch&gt; directory is cleaned up, to remove previously built packages."
					}
					
				
			
		
			
				
					,
					
					"iot-developing-building": {
						"id": "iot-developing-building",
						"title": "Building Packages Locally with GBS",
						"categories": "",
						"url": " iot/developing/building/",
						"content": "Building Packages Locally with GBS\n\nYou can perform local builds using the Git Build System (GBS).\n\nBefore performing local builds, study the following instructions:\n\n\n  Setting up the Development Environment\n  Installing Development Tools\n  Cloning Tizen Source Files\n\n\nTo build a package for a specific project:\n\n\n  To clone the source of a specific project, follow the instructions in Cloning Tizen Source Files.\n  \n    Switch to the directory that contains the project:\n\n    $ cd &lt;Specific_Project&gt;\n    \n  \n  \n    Create a  &lt;Specific_Project&gt;/.gbs.conf GBS configuration file (optional).\n\n    If a &lt;Specific_Project&gt;/.gbs.conf file exists, the configuration in that file is used when building the project with GBS. If not, the default GBS configuration in the ~/.gbs.conf file is used.\n\n    For more information about the .gbs.conf file and the customization of remote repositories, see GBS Configuration and Setting up the Development Environment, respectively.\n  \n  \n    Build a package for the project:\n\n    $ gbs build &lt;gbs build option&gt;\n    \n  \n  Take follow-up actions, if necessary. For more information, see Performing Another Build.\n\n\nBuild Tips\n\nThe build tips for local builds include:\n\n\n  How to exclude specific packages.\n  How to speed up a local build.\n  How to perform another build.\n\n\nExcluding Specific Packages\n\nTo exclude specific packages when building locally with GBS, you can either list them in the --exclude argument of the gbs build command, or list them in the .gbs.conf file:\n\n\n  To exclude packages when running the gbs build command, use the --exclude build argument:\n    $ exclude_pkgs=\"aaa bbb ccc ddd\"\n$ gbs build -A armv7l --exclude=${exclude_pkgs},eee,fff\n    \n  \n  To specify a list of excluded packages in the .gbs.conf file, use the excluded_packages parameter inside a profile block:\n    [profile.unified_standard]\nrepos = repo.base_arm,repo.base_arm_debug,repo.base_arm64,repo.base_arm64_debug,repo.base_ia32,repo.base_ia32_debug,repo.base_x86_64,repo.base_x86_64_debug,repo.unified_standard,repo.unified_standard_debug\nexclude_packages=aaa,bbb,ccc,ddd,eee,fff\n    \n  \n\n\nSpeeding up a Local Build\n\nIf the size of your RAM and swap file are both larger than 8 GB, you can speed up building by creating a GBS BUILD-ROOTS directory and mounting it as a RAM disk:\n\n$ mkdir -p ~/GBS-ROOT/local/BUILD-ROOTS\n$ sudo mount -t tmpfs -o size=16G tmpfs ~/GBS-ROOT/local/BUILD-ROOTS\n\n\nPerforming Another Build\n\nWhen the result of the first build is unsatisfactory, perform another build by executing 1 of the following commands, as appropriate:\n\n\n  Scenario 1:\n    \n      The URL of the remote repository is the same as in the previous build.\n      New packages to be built are dependent on previously built packages.\n      You want previously built packages to participate in the new build.\n    \n\n    $ gbs build -A &lt;Arch&gt;\n    \n  \n  Scenario 2:\n    \n      The URL of the remote repository is the same as in the previous build.\n      New packages to be built are dependent on previously built packages.\n      You do not want previously built packages to participate in the new build.\n    \n\n    $ gbs build -A &lt;Arch&gt; --clean-repos\n    \n  \n  \n    Scenario 3:\n\n    \n      The URL of the remote repository has changed.\n      New packages to be built are not dependent on previously built packages.\n    \n\n    $ gbs build -A &lt;Arch&gt; --clean\n    \n  \n  Scenario 4:\n    \n      The URL of the remote repository has changed.\n      New packages to be built are dependent on previously built packages.\n      You want previously built packages to participate in the new build.\n    \n\n    $ gbs build -A &lt;Arch&gt; --clean\n    \n  \n  Scenario 5:\n    \n      The URL of the remote repository has changed.\n      New packages to be built are dependent on previously built packages.\n      You do not want previously built packages to participate in the new build.\n    \n\n    $ gbs build -A &lt;Arch&gt; --clean --clean-repos\n    \n  \n\n\nThe building directory during runtime is ~/GBS-ROOT/local/BUILD-ROOTS/scratch.&lt;Arch&gt;.&lt;Number_of_Threads&gt;, into which the following input related to the current build is loaded to construct an independent building environment:\n\n\n  Source code in &lt;Specific_Project&gt;\n  Local RPM packages in ~/GBS-ROOT/local/repos/&lt;Release_ID&gt;/&lt;Arch&gt;\n  Remote RPM packages in a repository URL inside the GBS configuration file. For example: http://download.tizen.org/releases/daily/tizen/&lt;Tizen_Profile&gt;/&lt;Release_ID&gt;/repos/&lt;Repository&gt;/packages/\n\n\nAfter a successful build, GBS moves the build result, including generated RPM packages, SRPM packages, and build logs, into the output directory, ~/GBS-ROOT/local/repos/&lt;Release_ID&gt;/&lt;Arch&gt;. The output directory content automatically participates in a new build, if any, and can have a potential impact on the new build, depending on the dependency between the existing packages already built and new packages to be built. For example:\n\n\n  Suppose package B has a dependency on package A, which means in package B building, A-1.rpm in the remote repository is used.\n  Build package A first.\n  A-2.rpm is generated under ~/GBS-ROOT/.\n  Build package B.\n  A-2.rpm under ~/GBS-ROOT/ is used in package B building, instead of A-1.rpm in the remote repository.\n\n\nBased on the above working mechanism of the GBS build, the following rules must be followed for the gbs buildcommand to guarantee the quality of the new build:\n\n\n  If the URL of the remote repository has changed, add the --clean parameter. If this parameter is given, the current ~/GBS-ROOT/local/BUILD-ROOTS/scratch.&lt;Arch&gt;.&lt;Number_of_Threads&gt; directory is cleaned up, to remove previously constructed GBS build environment.\n  If new packages to be built are dependent on the previously built packages that you do not want to involve in the new build, add the --clean-repos parameter. If this parameter is given, the current ~/GBS-ROOT/local/repos/&lt;Release_ID&gt;/&lt;Arch&gt; directory is cleaned up, to remove previously built packages."
					}
					
				
			
		
			
				
					,
					
					"application-developing-cloning": {
						"id": "application-developing-cloning",
						"title": "Cloning Tizen Source Files",
						"categories": "",
						"url": " application/developing/cloning/",
						"content": "Cloning Tizen Source Files\n\nYou can clone Tizen source files over SSH or HTTPS.\n\n\n  Note\n\n  The procedures to clone Tizen source files over SSH and HTTPS are almost identical, the only difference being the URL in the Git command. However, you can only contribute code to Tizen using the SSH protocol.\n\n\nBefore cloning source files, study the following instructions:\n\n\n  Setting up the Development Environment\n  Installing Development Tools\n\n\nCloning over SSH\n\nYou can clone source files over SSH, either for a specific project or for all Tizen projects.\n\nTo clone a specific project over SSH:\n\n\n  \n    Confirm the package name by checking it on Tizen Project List or by running the following command:\n\n    $ ssh review.tizen.org gerrit ls-projects\n    \n  \n  \n    Clone the required package:\n\n    $ git clone [-b &lt;Branch&gt;] ssh://&lt;Username&gt;@review.tizen.org:29418/&lt;Gerrit_Project&gt; [&lt;Local_Project&gt;]\n    \n\n    For example:\n\n    $ git clone ssh://&lt;Username&gt;@review.tizen.org:29418/platform/core/account/account-common\n    \n  \n\n\nTo clone all Tizen projects over SSH, see Cloning All Projects over SSH.\n\nCloning over HTTPS\n\nYou can clone source files over HTTPS, either for a specific project or for all Tizen projects.\n\nTo clone a specific project over HTTPS:\n\n\n  \n    Clone the required package:\n\n    $ git clone [-b &lt;Branch&gt;] https://git.tizen.org/cgit/&lt;Gerrit_Project&gt; [&lt;Local_Project&gt;]\n    \n\n    For example:\n\n    $ git clone https://git.tizen.org/cgit/platform/core/multimedia/avsystem\n    \n  \n\n\nTo clone all Tizen projects over HTTPS, see Cloning All Projects over HTTPS."
					}
					
				
			
		
			
				
					,
					
					"platform-developing-cloning": {
						"id": "platform-developing-cloning",
						"title": "Cloning Tizen Source Files",
						"categories": "",
						"url": " platform/developing/cloning/",
						"content": "Cloning Tizen Source Files\n\nYou can clone Tizen source files over SSH or HTTPS.\n\n\n  Note\n\n  The procedures to clone Tizen source files over SSH and HTTPS are almost identical, the only difference being the URL in the Git command. However, you can only contribute code to Tizen using the SSH protocol.\n\n\nBefore cloning source files, study the following instructions:\n\n\n  Setting up the Development Environment\n  Installing Development Tools\n\n\nCloning over SSH\n\nYou can clone source files over SSH, either for a specific project or for all Tizen projects.\n\nTo clone a specific project over SSH:\n\n\n  \n    Confirm the package name by checking it on Tizen Project List or by running the following command:\n\n    $ ssh review.tizen.org gerrit ls-projects\n    \n  \n  \n    Clone the required package:\n\n    $ git clone [-b &lt;Branch&gt;] ssh://&lt;Username&gt;@review.tizen.org:29418/&lt;Gerrit_Project&gt; [&lt;Local_Project&gt;]\n    \n\n    For example:\n\n    $ git clone ssh://&lt;Username&gt;@review.tizen.org:29418/platform/core/account/account-common\n    \n  \n\n\nTo clone all Tizen projects over SSH, see Cloning All Projects over SSH.\n\nCloning over HTTPS\n\nYou can clone source files over HTTPS, either for a specific project or for all Tizen projects.\n\nTo clone a specific project over HTTPS:\n\n\n  \n    Clone the required package:\n\n    $ git clone [-b &lt;Branch&gt;] https://git.tizen.org/cgit/&lt;Gerrit_Project&gt; [&lt;Local_Project&gt;]\n    \n\n    For example:\n\n    $ git clone https://git.tizen.org/cgit/platform/core/multimedia/avsystem\n    \n  \n\n\nTo clone all Tizen projects over HTTPS, see Cloning All Projects over HTTPS."
					}
					
				
			
		
			
				
					,
					
					"iot-developing-cloning": {
						"id": "iot-developing-cloning",
						"title": "Cloning Tizen Source Files",
						"categories": "",
						"url": " iot/developing/cloning/",
						"content": "Cloning Tizen Source Files\n\nYou can clone Tizen source files over SSH or HTTPS.\n\n\n  Note\n\n  The procedures to clone Tizen source files over SSH and HTTPS are almost identical, the only difference being the URL in the Git command. However, you can only contribute code to Tizen using the SSH protocol.\n\n\nBefore cloning source files, study the following instructions:\n\n\n  Setting up the Development Environment\n  Installing Development Tools\n\n\nCloning over SSH\n\nYou can clone source files over SSH, either for a specific project or for all Tizen projects.\n\nTo clone a specific project over SSH:\n\n\n  \n    Confirm the package name by checking it on Tizen Project List or by running the following command:\n\n    $ ssh review.tizen.org gerrit ls-projects\n    \n  \n  \n    Clone the required package:\n\n    $ git clone [-b &lt;Branch&gt;] ssh://&lt;Username&gt;@review.tizen.org:29418/&lt;Gerrit_Project&gt; [&lt;Local_Project&gt;]\n    \n\n    For example:\n\n    $ git clone ssh://&lt;Username&gt;@review.tizen.org:29418/platform/core/account/account-common\n    \n  \n\n\nTo clone all Tizen projects over SSH, see Cloning All Projects over SSH.\n\nCloning over HTTPS\n\nYou can clone source files over HTTPS, either for a specific project or for all Tizen projects.\n\nTo clone a specific project over HTTPS:\n\n\n  \n    Clone the required package:\n\n    $ git clone [-b &lt;Branch&gt;] https://git.tizen.org/cgit/&lt;Gerrit_Project&gt; [&lt;Local_Project&gt;]\n    \n\n    For example:\n\n    $ git clone https://git.tizen.org/cgit/platform/core/multimedia/avsystem\n    \n  \n\n\nTo clone all Tizen projects over HTTPS, see Cloning All Projects over HTTPS."
					}
					
				
			
		
			
				
					,
					
					"tizenstudio-configurable-sdk-configurable-sdk": {
						"id": "tizenstudio-configurable-sdk-configurable-sdk",
						"title": "Configurable SDK",
						"categories": "",
						"url": " tizenstudio/configurable-sdk/configurable-sdk/",
						"content": "Configurable SDK\n\nOne of the main goals of Tizen 4.0 is configurability. The platform is not limited to a specific device type or profile, so vendors and platform developers can customize Tizen to support the functionalities they need.\n\nThe main features of the Tizen mobile, wearable, and TV application life-cycles are extended to support configurable SDK platforms.\n\nFigure: Configurable Tizen platform\n\n\n\nThe Tizen Studio allows you to develop applications in a customizable Tizen platform environment. You can use the application development features of the Tizen Studio with configurable SDKs in the same way as with the existing mobile, wearable, and TV profiles. You can create new projects, validate config.xml and manifest.xml files, and take advantage of the API code assist features. You can also build, package, run, and debug your projects.\n\nIn the following instructions, the IoT Headed 4.0 platform is used as an example of a configurable SDK.\n\nInstalling Configurable SDK Platforms \n\nConfigurable SDKs are installed and managed as extensions in the Package Manager Extension SDK tab.\n\nTo install the IoT Headed 4.0 platform SDK:\n\n\n  Launch the Package Manager.\n  In the Package Manager, select the Extension SDK tab.\n  \n    Click install next to the extensions you want.\n\n    \n  \n\n\nCreating Configurable SDK Projects \n\nAfter you have installed the IoT Headed 4.0 platform, you can create an IoT Headed 4.0 native project in the Tizen Studio:\n\n\n  In the Tizen Studio menu, select File &gt; New &gt; Tizen Project.\n  \n    In the Project Wizard, in the Custom drop-down menu, select Iot-headed v4.0, and click Next.\n\n    \n  \n  \n    Select the Native Application application type, and click Next.\n\n    \n  \n  \n    Select the Basic UI template, and click Next.\n\n    \n  \n  \n    Define the project name and click Finish.\n\n    \n  \n\n\nYou can see the created project in the Project Explorer view.\n\n\n\nBuilding and Packaging Applications \n\nWhen you have finished developing your application, build and test it.\n\nTo build and package your application, right-click the project in the Project Explorer view, and select Build Signed Package.\n\nFigure: Building the application\n\n\n\nThe package is created in the Debug subdirectory.\n\nFigure: Created package\n\n\n\nRelated Information\n\n  Dependencies\n    \n      Tizen Studio 2.0 and Higher"
					}
					
				
			
		
			
				
					,
					
					"application-porting-connectivity": {
						"id": "application-porting-connectivity",
						"title": "Connectivity",
						"categories": "",
						"url": " application/porting/connectivity/",
						"content": "Connectivity\n\nYou can implement various connectivity features, such as Bluetooth, WLAN, and NFC.\n\nBluetooth\n\nBluetooth is a short range communication protocol used to communicate between 2 devices. Tizen uses open source Bluetooth components, such as BlueZ and ObexD. Bluez and ObexD run as a daemon and an interface library, Bluetooth Framework, is used for applications to access them over the D-Bus interface.\n\nThis section explains the Bluetooth architecture on the Tizen platform and how Tizen can be ported, along with the configuration parameters and their values.\n\nFigure: Tizen Bluetooth architecture\n\n\n\nThe Bluetooth framework provides a dialogue for the user to control the BlueZ, ObexD, and PulseAudio daemons. Bluetooth provides a standard interface between the Bluetooth chip and AP, called the HCI (Host Controller Interface). HCI can be implemented on USB, UART, and SDIO, but for the mobile environment, UART is the most common. HCI activation can differ depending on the chip vendor. The vendor provides the HCI configuration and the initial scripts. For example, Broadcom and Spreadtrum provide firmware and a loading tool. Tizen supports Bluetooth version 4.2, and the GATT, FTP, OPP, MAP, PBAP, A2DP, AVRCP, HSP/HFP, RFCOMM, HID, HDP, and PAN profiles. Bluetooth Low Energy functions have been implemented in BlueZ and bluetooth-frwk.\n\nThe Tizen Bluetooth framework is based on the open source BlueZ project. BlueZ provides the DBUS API and based on it, Tizen Bluetooth framework provides the C Language API. Using the Tizen Bluetooth framework is recommended.\n\nThe following components are necessary for Bluetooth:\n\n\n  Application\n    \n      User dialogue that controls the BlueZ, ObexD, and PulseAudio daemons\n    \n  \n  ObexD\n    \n      Open source component\n      Object exchange daemon\n      Supports OPP, FTP, PBAP, SYNC, and MAP profile stack\n    \n  \n  BluetoothD\n    \n      BluetoothD is the open source component, BlueZ 5.37 is supported\n      Bluetooth central daemon\n      Supports GAP, SDP, A2DP, AVRCP, HFP, HSP, and GATT profile stack\n    \n  \n  Bluetooth subsystem\n    \n      Provides the BT unix socket. Each protocol can be accessed by its socket.\n      Supports the L2CAP, RFCOMM, SCO, and HCI protocols\n    \n  \n  Bluetooth driver\n    \n      BT Chip driver\n      For UART, the interface is provided by the Linux kernel.\n      GPIO configuration, rfkill (radio frequency management), and power management can be handled by both the vendor and the porting engineer\n    \n  \n  Bluetooth firmware loading module\n    \n      Depending on the environment, it loads the Bluetooth firmware to the Bluetooth chip\n      Tizen and the chipset vendor need to implement this together\n      Package: bluetooth-tools\n    \n  \n\n\nPorting the OAL Interface\n\nThe following OAL scripts are run during the Bluetooth stack start and end sequences. These scripts invoke the Bluetooth chip-specific (such as Broadcom and Spreadtrum) scripts, provided by the chipset vendor to perform chip-specific configuration. These scripts are available in the bluetooth-dev-tools.under package. When this package is installed, it copies the following scripts in the /usr/etc/Bluetooth/ directory:\n\n\n  bt-stack-up.sh\n  bt-stack-down.sh\n  bt-reset-env.sh\n\n\nTizen BT Obex Profiles\n\nIn Tizen, the open source ObexD is used for the obex-based profiles:\n\n\n  BT Obex profiles server (obexd)\n  BT Obex profiles client (obex-client)\n\n\nConfiguration\n\nThere are a few configuration changes that need to be made to enable the specific chipset and the scripts and other chipset-specific configuration information, such as UART speed and UART terminal (tty). These changes must be provided by the chipset vendor.\n\n\n  Configuration for the Broadcomm BCM4358 Bluetooth chipset\n    \n      hciattach\nThe bluez/tools/hciattach.c file is patched to enable the hciattach tool specific to the BCM4358 chipset. This service attaches the BT UART HCI interface to the Bluetooth stack at a baud rate of 3000000. It is also responsible for loading the Bluetooth firmware on BCM4358.\n      Bluetooth UART used is /dev/ttySAC3\n      Broadcom firmware used is BCM4358A1_001.002.005.0032.0066.hcd\n      UART speed configuration for BCM4358A1 is 3000000\n      bcmtool used is bcmtool_4358a1\n      .bd_addr contains the unique Bluetooth address, which is generated during the first Bluetooth activation\n      Register the Bluetooth device:\n        bcmtool_4358a1 /dev/ttySAC0 -FILE=BCM4358A1_001.002.005.0032.0066.hcd -BAUD=3000000 -ADDR=/csa/bluetooth/.bd_addr -SETSCO=0,0,0,0,0,0,0,3,3,0 -LP\n        \n      \n      Attach a serial device to the Bluetooth stack using the UART HCI for a Broadcomm device:\n        hciattach /dev/ttySAC3 -S 3000000 bcm2035 3000000 flow\n        \n      \n      Run the Bluetooth daemon version 5.37:\n        bluetoothd\n        \n      \n      Bring the device up, set up the device name, and enable the SSP mode:\n        hciconfig hci0 up\nhciconfig hci0 name \"Tizen-Mobile\"\nhciconfig hci0 sspmode 1\n        \n      \n      Switch on the Bluetooth radio:\n        rfkill unblock bluetooth\n        \n      \n      Switch off the Bluetooth radio:\n        rfkill block bluetooth\n        \n      \n    \n  \n  Configuration for the Spreadtrum sc2331 Bluetooth chipset\n    \n      hciattach\nThe bluez/tools/hciattach.c file is patched to enable the hciattach tool specific to the sc2331 chipset. This service attaches the BT UART HCI interface to the Bluetooth stack at a baud rate of 3000000. It is also responsible for loading the Bluetooth firmware on sc2331.\n      Register the Bluetooth device:\nThe cp2-download tool is provided for downloading the Spreadtrum firmware. This tool also downloads the Wi-Fi firmware at boot time.\n      Install the following files in the target’s /usr/lib/firmware directory:\n        sc2331_fdl.bin\nsc2331_fw.bin\nscx35_pikeavivaltove_3M_MARLIN_connectivity_calibration.ini\nscx35_pikeavivaltove_3M_MARLIN_connectivity_configure.ini\n        \n      \n      Bluetooth UART used is /dev/ttyS0\n      UART speed configuration for sc233 is 3000000\n      Attach a serial device to the Bluetooth stack using the UART HCI:\n        hciattach -s 3000000 /dev/ttyS0 sprd 3000000 flow\n        \n      \n      Run the bluetooth daemon version 5.37:\n        bluetoothd\n        \n      \n      Bring the device up, set up the device name, and enable the SSP mode:\n        hciconfig hci0 up\nhciconfig hci0 name \"Tizen-Mobile\"\nhciconfig hci0 sspmode 1\n        \n      \n    \n  \n\n\nReferences\n\nOpen source component version: BlueZ 5.37\n\nFor more information, see http://www.bluez.org/.\n\nThe reference kernel configuration for Bluetooth:\n\n\n  The following kernel .config lines are enabled for Broadcom Bluetooth support:\n    CONFIG_BT=y\nCONFIG_BT_L2CAP=y\nCONFIG_BT_RFCOMM=y\nCONFIG_BT_RFCOMM_TTY=y\nCONFIG_BT_BNEP=y\nCONFIG_BT_HIDP=y\nCONFIG_BT_HCIUART=y\nCONFIG_BT_HCIUART_H4=y\nCONFIG_BCM4330=y\nCONFIG_RFKILL=y\nCONFIG_RFKILL_INPUT=y\nCONFIG_RXTRA_FIRMWARE_BCM4330=\"BCM4330.hcd\"\n    \n  \n  The following kernel .config lines are enabled for Bluetooth AVRCP support:\n    CONFIG_INPUT_MISC=y\nCONFIG_INPUT_UINPUT=y\n    \n  \n  The following kernel .config lines are enabled for Bluetooth HID support:\n    CONFIG_INPUT_GP2A=y\nCONFIG_INPUT_KR3DH=y\n    \n  \n  The following kernel .config lines are enabled for Bluetooth Audio (SCO-over-PCM) support:\n    CONFIG_BT_SCO=y\nCONFIG_INPUT_GP2A=y\nCONFIG_INPUT_KR3DH=y\n    \n  \n\n\nWLAN\n\nThis section provides a step-by-step explanation of what is involved in adding a new Wi-Fi driver and making Wi-Fi work.\n\nFigure: Tizen Wi-FI architecture\n\n\n\nFeature overview:\n\n\n  WLAN (802.11 b/g/n)\n  WPS PBC\n  EAP (PEAP, TTLS)\n\n\nTizen uses wpa_supplicant as the platform interface to Wi-Fi devices. Your Wi-Fi driver must be compatible with the standard wpa_supplicant.\n\nThe Tizen WLAN architecture is centered on the Linux wireless (IEEE-802.11) subsystem. The Linux wireless SW stack defines the WLAN hardware adaptation software interfaces that need to be used in Tizen. In practice, the required interfaces are defined by cfg80211 for FullMAC WLAN devices and by mac80211 for SoftMAC WLAN devices. In addition, a Linux network interface needs to be supported towards the Linux TCP/IP stack.\n\nThe Connection Manager (ConnMan) is a daemon for managing Internet connections within embedded devices running the Linux operating system.\n\nThe wpa_supplicant interface is a WPA Supplicant with support for WPA and WPA2 (IEEE 802.11i / RSN). WPA Supplicant is the IEEE 802.1X/WPA component that is used in the client stations. It implements key negotiation with a WPA Authenticator and it controls roaming and the IEEE 802.11 authentication/association of the WLAN driver.\n\nPorting the OAL Interface\n\nThe WLAN driver plugin is specific to a Wi-Fi chipset. This includes firmware and chipset-specific tools. Wi-Fi chipset firmware and tool files must be copied to the WLAN driver plugin directory, built, and installed before testing the Wi-Fi functionality. Because of Tizen platform requirements, the Wi-Fi driver must create the /opt/etc/.mac.info file, which has the device MAC address.\n\nThe WLAN driver plugin contains the wlan.sh file (located in /usr/bin/wlan.sh), which is used to load or unload the Wi-Fi driver firmware.\n\nWhen the wifi_activate() function is called, the load driver request is sent to the NET-CONFIG daemon. The NET-CONFIG daemon loads the Wi-Fi driver using the wlan.sh script file. Similarly, the wifi_deactivate() function requests unloading of the Wi-Fi driver. In case of Wi-Fi Direct®, the wifi_direct_activate() and wifi_direct_deactivate() functions make the Wi-Fi Direct manager load or unload the Wi-Fi driver using the wlan.sh script.\n\nUsing the /usr/bin/wlan.sh script:\n\n\n  wlan.sh start: Power up the Wi-Fi driver in station mode by loading the driver and running the firmware file.\n  wlan.sh p2p: Power up the Wi-Fi driver in Wi-Fi Direct mode by loading the driver and running the firmware file.\n  wlan.sh softap: Power up the Wi-Fi driver in Soft AP mode by loading the driver and running the firmware file.\n  wlan.sh stop: Power down the Wi-Fi driver.\n\n\nAll other Wi-Fi related functionality is handled by the ConnMan daemon.\n\nReferences\n\n\n  Connection Manager (ConnMan) project website: https://01.org/connman\n  Linux wireless (IEEE-802.11) subsystem: https://wireless.wiki.kernel.org\n  Information on Linux WPA/WPA2/IEEE 802.1X Supplicant: http://hostap.epitest.fi/wpa_supplicant/\n  Latest ConnMan release: http://git.kernel.org/?p=network/connman/connman.git;a=summary\n  WLAN driver plugin Git path: /adaptation/devices/wlandrv-plugin-tizen-bcm43xx\n  Reference kernel configurations\n  The following options must be enabled if the driver supports the cfg802.11 configuration API, instead of the wireless extension API. For more information, see http://linuxwireless.org.\n    CONFIG_CFG80211\nCONFIG_LIB80211\nCONFIG_MAC80211 (Enable this flag, if the driver supports the softMAC feature)\n    \n  \n  The following configuration options must be enabled in the kernel if the driver supports wireless extension APIs:\n    CONFIG_WIRELESS_EXT=y\nCONFIG_WEXT_CORE=y\nCONFIG_WEXT_PROC=y\nCONFIG_WEXT_PRIV=y\nCONFIG_WEXT_SPY=y\nCONFIG_WIRELESS_EXT_SYSFS=y\n    \n  \n\n\nNFC\n\nThe NFC application enables the user to:\n\n  Read and import the content written on an NFC tag.\n  Edit the content written on an NFC tag.\n  Write and save data on an NFC tag.\n  Load and save the NFC data from or in a file.\n\n\nFigure: NFC architecture\n\n\n\nThe NFC implementation has the following main components:\n\n\n  NFC client acts as an interface between the NFC application and the NFC manager, while writing or editing tag information in any physical tag.\n  NFC manager is the main interface, which actually deals with NFC physical tags, creates a connection with tags, and detects it. It is a daemon process to control the NFC chipset (such as NXP pn544). It provides the read and write service and basic P2P communication service, as well as the basic API for the client application.\n  NFC stack contains the required plugin, based on the NFC chipset. Currently, the nfc-plugin-nxp is used for the NXP chipset. The NFC plugin acts as an interface between the NFC chipset with the NFC framework (nfc-manager). It must be implemented according to the interface provided by the nfc-manager.\n\n\nPorting the OAL Interface\n\nThe NFC plugin is implemented as a shared library and it interfaces the Tizen nfc-manager and the vendor NFC chip. The NFC manager loads the libnfc-plugin.so library at runtime from the /usr/lib/libnfc-plugin.so directory. Any vendor-specific plugin is installed within the same path. The plugin must be written with predefined OAL API interfaces.\n\nDuring initialization, the nfc-manager loads the nfc-plugin.so library, searches for the onload() function, and calls the function with an interface structure instance as an argument for mapping all the OAL interfaces. These OAL/OEM interfaces are implemented according to the underlying NFC chipset. Once the mapping is done, the NFC manager interacts with nfc-plugin, which implements the vendor-specific OAL interfaces.\n\nThe following example shows the onload() function:\n\nBool\nonload(net_nfc_oem_interface_s *oem_interfaces) {\n    oem_interfaces-&gt;init = xxx;  /* xxx refers to plugin APIs */\n    oem_interfaces-&gt;deinit = xxx;\n    oem_interfaces-&gt;register_listener = xxx;\n    oem_interfaces-&gt;unregister_listener = xxx;\n    oem_interfaces-&gt;check_firmware_version = xxx;\n\n    return true;\n}\n\n\nThe NFC OAL interfaces are defined in the following structure. Use the net_nfc_oem_controller.h header file.\n\ntypedef struct _net_nfc_oem_interface_s {\n    net_nfc_oem_controller_init init;\n    net_nfc_oem_controller_deinit deinit;\n    net_nfc_oem_controller_register_listener register_listener;\n    net_nfc_oem_controller_unregister_listener unregister_listener;\n    net_nfc_oem_controller_check_firmware_version check_firmware_version;\n    net_nfc_oem_controller_update_firmware update_firmware;\n    net_nfc_oem_controller_get_stack_information get_stack_information;\n    net_nfc_oem_controller_configure_discovery configure_discovery;\n    net_nfc_oem_controller_get_secure_element_list get_secure_element_list;\n    net_nfc_oem_controller_set_secure_element_mode set_secure_element_mode;\n    net_nfc_oem_controller_connect connect;\n    net_nfc_oem_controller_connect disconnect;\n    net_nfc_oem_controller_check_ndef check_ndef;\n    net_nfc_oem_controller_check_target_presence check_presence;\n    net_nfc_oem_controller_read_ndef read_ndef;\n    net_nfc_oem_controller_write_ndef write_ndef;\n    net_nfc_oem_controller_make_read_only_ndef make_read_only_ndef;\n    net_nfc_oem_controller_transceive transceive;\n    net_nfc_oem_controller_format_ndef format_ndef;\n    net_nfc_oem_controller_exception_handler exception_handler;\n    net_nfc_oem_controller_is_ready is_ready;\n    net_nfc_oem_controller_llcp_config config_llcp;\n    net_nfc_oem_controller_llcp_check_llcp check_llcp_status;\n    net_nfc_oem_controller_llcp_activate_llcp activate_llcp;\n    net_nfc_oem_controller_llcp_create_socket create_llcp_socket;\n    net_nfc_oem_controller_llcp_bind bind_llcp_socket;\n    net_nfc_oem_controller_llcp_listen listen_llcp_socket;\n    net_nfc_oem_controller_llcp_accept accept_llcp_socket;\n    net_nfc_oem_controller_llcp_connect_by_url connect_llcp_by_url;\n    net_nfc_oem_controller_llcp_connect connect_llcp;\n    net_nfc_oem_controller_llcp_disconnect disconnect_llcp;\n    net_nfc_oem_controller_llcp_socket_close close_llcp_socket;\n    net_nfc_oem_controller_llcp_recv recv_llcp;\n    net_nfc_oem_controller_llcp_send send_llcp;\n    net_nfc_oem_controller_llcp_recv_from recv_from_llcp;\n    net_nfc_oem_controller_llcp_send_to send_to_llcp;\n    net_nfc_oem_controller_llcp_reject reject_llcp;\n    net_nfc_oem_controller_llcp_get_remote_config get_remote_config;\n    net_nfc_oem_controller_llcp_get_remote_socket_info get_remote_socket_info;\n    net_nfc_oem_controller_sim_test sim_test;\n    net_nfc_oem_controller_test_mode_on test_mode_on;\n    net_nfc_oem_controller_test_mode_off test_mode_off;\n    net_nfc_oem_controller_support_nfc support_nfc;\n} net_nfc_oem_interface_s;\n\n\nThe nfc_oem_interface_s struct is exported in the nfc-plugin. Using this interface structure, the nfc-manager communicates with the OAL interfaces at runtime. The NFC plugin loads when the nfc-manager is started and the plugin init() function is called to initialize the NFC chip.\n\nint (*init) (net_nfc_oem_controller_init*);\n\n\nThe nfc-manager issues the deinit() function to deinitialize the NFC chip:\n\nint (*deinit) (net_nfc_oem_controller_deinit *);\n\n\nPay attention to the following:\n\n\n  Sending the notification to the upper layer (NFC service)\nSee the phdal4nfc_message_glib.c file. The g_idle_add_full is used for handling the message in the NFC service. You can use the callback client asynchronously in the client context. Post a message in queue, and the message is processed by a client thread.\n  Reference implementation of the NFC plugin\nSample code snippets cannot be reproduced. Code is proprietary. For reference, see the nfc-plugin-emul and nfc-plugin-nxp files.\n\n\nNFC OAL API\n\nThe following table lists all the NFC OAL API functions.\n\nTable: NFC OAL API functions\n\n\n  \n    \n      Function\n      Description\n      Parameter\n    \n  \n  \n    \n      net_nfc_oem_controller_init init;\n      Initializes the NFC chip.\n      net_nfc_error_e: Returns an error code on failure\n    \n    \n      net_nfc_oem_controller_deinit deinit;\n      Deinitializes the NFC chip.\n      -\n    \n    \n      net_nfc_oem_controller_register_listener register_listener;\n      Registers a callback function for a tag event, SE event, and llcp event.\n      target_detection_listener_cb target_detection_listener: Tag event callback functionse_transaction_listener_cb se_transaction_listener: SE event callback functionllcp_event_listener_cb llcp_event_listener: llcp event callback functionnet_nfc_error_e: Returns an error code on failure\n    \n    \n      net_nfc_oem_controller_unregister_listener unregister_listener;\n      Releases a callback function for a tag event, SE event, and llcp event.\n      -\n    \n    \n      net_nfc_oem_controller_check_firmware_version check_firmware_version;\n      Checks the firmware version of the NFC chip.\n      net_nfc_error_e: Returns an error code on failure\n    \n    \n      net_nfc_oem_controller_update_firmware update_firmware;\n      Updates the NFC chip firmware.\n      net_nfc_error_e: Returns an error code on failure\n    \n    \n      net_nfc_oem_controller_get_stack_information get_stack_information;\n      Gets the list of supported tags and the current firmware version.\n      net_nfc_stack_information_s: Pointer value to get the information of support tags and the current firmware versionnet_nfc_error_e: Returns an error code on failure\n    \n    \n      net_nfc_oem_controller_configure_discovery configure_discovery;\n      Delivers the config information on discovery.\n      net_nfc_discovery_mode_e: Start/stop modenet_nfc_event_filter_e config: Information for tag filteringnet_nfc_error_e: Returns an error code on failure\n    \n    \n      net_nfc_oem_controller_get_secure_element_list get_secure_element_list;\n      Gets the information of the current secure element.\n      net_nfc_secure_element_info_s: Pointer value to get secure element informationint: Pointer value to get the count of the secure elementnet_nfc_error_e: Returns an error code on failure\n    \n    \n      net_nfc_oem_controller_set_secure_element_mode set_secure_element_mode;\n      Sets the secure element to use.\n      net_nfc_secure_element_type_e: Secure element informationnet_nfc_secure_element_mode_e: Mode information to setnet_nfc_error_e: Returns an error code on failure\n    \n    \n      net_nfc_oem_controller_connect connect;\n      Connects to the detected tag/target.\n      net_nfc_target_handle_s: Tag/target handle for connectingnet_nfc_error_e: Returns an error code on failure\n    \n    \n      net_nfc_oem_controller_connect disconnect;\n      Disconnects the connected tag/target.\n      net_nfc_target_handle_s: Tag/target handle for disconnectingnet_nfc_error_e: Returns an error code on failure\n    \n    \n      net_nfc_oem_controller_check_ndef check_ndef;\n      Checks the tag for ndef support.\n      net_nfc_target_handle_s: Tag handle to check ndefint: Max size supported in the tagint: Real data size saved in the tagnet_nfc_error_e: Returns an error code on failure\n    \n    \n      net_nfc_oem_controller_check_target_presence check_presence;\n      Checks whether a tag exists in the RF range.\n      net_nfc_target_handle_s: Tag handle to check presencenet_nfc_error_e: Returns an error code on failure\n    \n    \n      net_nfc_oem_controller_read_ndef read_ndef;\n      Reads ndef data in a tag.\n      net_nfc_target_handle_s: Tag handle to readdata_s: Pointer value to save the ndef datanet_nfc_error_e: Returns an error code on failure\n    \n    \n      net_nfc_oem_controller_write_ndef write_ndef;\n      Writes the data to the tag.\n      net_nfc_target_handle_s: Handle to writedata_s: Data to writenet_nfc_error_e: Returns an error code on failure\n    \n    \n      net_nfc_oem_controller_make_read_only_ndef make_read_only_ndef;\n      Makes the tag to a read-only tag.\n      net_nfc_target_handle_s: Target tag handlenet_nfc_error_e: Returns an error code on failure\n    \n    \n      net_nfc_oem_controller_transceive transceive;\n      Sends and receives the low command to the tag or target.\n      net_nfc_target_handle_s: Tag or target handle to transceivenet_nfc_transceive_info_s: Pointer value including command or data to send and data to receivedata_s: Pointer value to send the information of contextnet_nfc_error_e: Returns an error code on failure\n    \n    \n      net_nfc_oem_controller_format_ndef format_ndef;\n      Formats the tag.\n      net_nfc_target_handle_s: Tag handle to formatdata_s: Key value to send the tag for formattingnet_nfc_error_e: Returns an error code on failure\n    \n    \n      net_nfc_oem_controller_exception_handler exception_handler;\n      When the nfc-manager faces an unwanted exception, it tries to deinitialize and initialize the stack before unregistering and registering the callback function.\n      -\n    \n    \n      net_nfc_oem_controller_is_ready is_ready;\n      Checks the status of the NFC stack.\n      net_nfc_error_e: Returns an error code on failure\n    \n    \n      net_nfc_oem_controller_llcp_config config_llcp;\n      Sets the llcp configuration (miu, lto, wks, option).\n      net_nfc_target_handle_s: Target handle to set llcpnet_nfc_error_e: Returns an error code on failure\n    \n    \n      net_nfc_oem_controller_llcp_check_llcp check_llcp_status;\n      Checks the llcp configuration (miu, lto, wks, option).\n      net_nfc_target_handle_s: Target handle to check llcpnet_nfc_error_e: Returns an error code on failure\n    \n    \n      net_nfc_oem_controller_llcp_activate_llcp activate_llcp;\n      Activates the llcp functionality.\n      net_nfc_target_handle_s: Target handle to activatenet_nfc_error_e: Returns an error code on failure\n    \n    \n      net_nfc_oem_controller_llcp_create_socket create_llcp_socket;\n      Creates the llcp socket.\n      net_nfc_llcp_socket_t: Pointer value to receive the socket informationnet_nfc_socket_type_e socketType: Type of socket to createuint16_t miu: miu valueuint8_t rw: rw valuenet_nfc_error_e: Returns an error code on failurevoid: value to control the context (can be set to NULL)\n    \n    \n      net_nfc_oem_controller_llcp_bind bind_llcp_socket;\n      Binds the socket.\n      net_nfc_llcp_socket_t socket: Information about the socket to binduint8_t service_access_point: Information of access point to bindnet_nfc_error_e: Returns an error code on failure\n    \n    \n      net_nfc_oem_controller_llcp_listen listen_llcp_socket;\n      Sets the socket to listen.\n      net_nfc_target_handle_s: Target handleuint8_t: Service name to listennet_nfc_llcp_socket_t socket: Socket informationnet_nfc_error_e: Returns an error code on failurevoid: Value to control the context (can be set to NULL)\n    \n    \n      net_nfc_oem_controller_llcp_accept accept_llcp_socket;\n      Accepts the connect request in listening status.\n      net_nfc_llcp_socket_t socket: Socket information to acceptnet_nfc_error_e: Returns an error code on failure\n    \n    \n      net_nfc_oem_controller_llcp_connect_by_url connect_llcp_by_url;\n      Connects the server with the service name.\n      net_nfc_target_handle_s: Handle of the target to connectnet_nfc_llcp_socket_t socket: Socket informationuint8_t: Service name to connectnet_nfc_error_e: Returns an error code on failurevoid: Value to control the context (can be set to NULL)\n    \n    \n      net_nfc_oem_controller_llcp_connect connect_llcp;\n      Connects to the server with access point (port number).\n      net_nfc_target_handle_s: Target handlenet_nfc_llcp_socket_t socket: Socket informationuint8_t service_access_point: Access point numbernet_nfc_error_e: Returns an error code on failurevoid: Value to control the context (can be set to NULL)\n    \n    \n      net_nfc_oem_controller_llcp_disconnect disconnect_llcp;\n      Disconnects the llcp link.\n      net_nfc_target_handle_s: Socket information to disconnectnet_nfc_llcp_socket_t socket: Information of the socket to disconnectnet_nfc_error_e: Returns an error code on failurevoid: Value to control the context (can be set to NULL)\n    \n    \n      net_nfc_oem_controller_llcp_socket_close close_llcp_socket;\n      Closes the llcp socket.\n      net_nfc_llcp_socket_t socket: Socket information to closenet_nfc_error_e: Returns an error code on failure\n    \n    \n      net_nfc_oem_controller_llcp_recv recv_llcp;\n      Receives the data using the llcp link.\n      net_nfc_target_handle_s: Target handle to receivenet_nfc_llcp_socket_t socket: Socket information to receivedata_s: Pointer value to receive the datanet_nfc_error_e: Returns an error code on failurevoid: Value to control the context (can be set to NULL)\n    \n    \n      net_nfc_oem_controller_llcp_send send_llcp;\n      Sends the data using llcp link.\n      net_nfc_target_handle_s: Target handle to sendnet_nfc_llcp_socket_t socket: Socket information to senddata_s: Data to sendnet_nfc_error_e: Returns an error code on failurevoid: Value to control the context (can be set to NULL)\n    \n    \n      net_nfc_oem_controller_llcp_recv_from recv_from_llcp;\n      Rejects the connect request from the client socket.\n      net_nfc_target_handle_s: Target handle to rejectnet_nfc_llcp_socket_t socket: Socket information to rejectnet_nfc_error_e: Returns an error code on failure\n    \n    \n      net_nfc_oem_controller_llcp_send_to send_to_llcp;\n      Sends the data using the service access point.\n      net_nfc_target_handle_s: Peer target handlenet_nfc_llcp_socket_t socket: Socket informationdata_s: Data to senduint8_t service_access_point: Service access point to sendnet_nfc_error_e: Returns an error code on failurevoid: Value to control the context (can be set to NULL)\n    \n    \n      net_nfc_oem_controller_llcp_reject reject_llcp;\n      Rejects the connect request from the client socket.\n      net_nfc_target_handle_s: Target handle to rejectnet_nfc_llcp_socket_t socket: Socket information to rejectnet_nfc_error_e: Returns an error code on failure\n    \n    \n      net_nfc_oem_controller_llcp_get_remote_config get_remote_config;\n      Gets the llcp socket config information of the peer device.\n      net_nfc_target_handle_s: Peer target handlenet_nfc_llcp_config_info_s: Pointer value to get config information of peer device’s llcp socketnet_nfc_error_e: Returns an error code on failure\n    \n    \n      net_nfc_oem_controller_llcp_get_remote_socket_info get_remote_socket_info;\n      Gets the llcp socket information of the peer device.\n      net_nfc_target_handle_s: Peer target handlenet_nfc_llcp_socket_t socket: llcp socket informationnet_nfc_llcp_socket_option_s: Pointer value to save the information of remote socketnet_nfc_error_e: Returns an error code on failure\n    \n    \n      net_nfc_oem_controller_sim_test sim_test;\n      Tests the SWP link with SIM and NFC chipset.\n      net_nfc_error_e: Returns an error code on failure\n    \n    \n      net_nfc_oem_controller_test_mode_on test_mode_on;\n      Changes the NFC chip to test mode. (Test mode exists only in the NXP case. If there are none, it does not need to implemented.)\n      net_nfc_error_e: Returns an error code on failure\n    \n    \n      net_nfc_oem_controller_test_mode_off test_mode_off;\n      Changes the status of the NFC chip from test mode to normal mode. (Test mode exists only in the NXP case. If there are none, it does not need to implemented.)\n      net_nfc_error_e: Returns an error code on failure\n    \n    \n      net_nfc_oem_controller_support_nfc support_nfc\n      Checks each device file of each chip.\n      -\n    \n  \n\n\nConfiguration\n\nThe nfc-plugin package must be saved to the /usr/lib/libnfc-plugin.so directory when installed. When the nfc-manager starts, it looks for the plugin library and loads it dynamically from this path.\n\nReferences\n\nEnable the following configuration options in the kernel .config file:\n\nUsing Pn544: CONFIG_PN544_NFC\nUsing Pn65n: CONFIG_PN65N_NFC\n\n\nAPI references are available in the Tizen 3.0 Porting Guide appendix.\n\nFor more information, see http://nfc-forum.org/.\n\nMTP\nThe Media Transfer Protocol (MTP) is used for exchanging media files between 2 devices:\n\n\n  MTP exchanges can only occur between 2 devices at a time.\n  In each communication, 1 devices acts as the initiator and the other as the responder.\n  \n    The initiator is the device that initiates actions with the responder by sending operations to the responder.\n\n    Figure: MTP Initiator\n\n    \n  \n  \n    The responder cannot initiate any actions, and can only send responses to operations sent by the initiator or send events.\n\n    Figure: MTP Responder\n\n    \n  \n  In the Tizen system, the USB host is the initiator, and the USB device is the responder.\n\n\nPorting the OAL Interface\n\nThe Tizen MTP initiator and responder do not have an OAL Interface. There are extension possibilities for the MTP Transport layer.\n\nConfiguration\n\nThe following configuration is needed:\n\n\n  MTP initiator\n    \n      The MTP Initiator consists of 3 packages:\n        mtp-initiator daemon\nmtp-initiator api\nlibmtp opensource\n        \n      \n      The MTP initiator does not operate independently. It requires the help of another module, such as USB.\n      When the USB device is connected to the host, the module must run the MTP initiator daemon.\n    \n  \n  MTP responder\n    \n      The MTP responder consists of 1 package:\n        mtp-responder daemon\n        \n      \n      The MTP responder does not operate independently. It requires the help of another module, such as USB.\n      When the USB device is connected to the host, the module must run the MTP responder daemon.\n    \n  \n\n\nReferences\n\n\n  Media Transfer Protocol v.1.1 Spec: http://www.usb.org/developers/docs/devclass_docs/"
					}
					
				
			
		
			
				
					,
					
					"platform-porting-connectivity": {
						"id": "platform-porting-connectivity",
						"title": "Connectivity",
						"categories": "",
						"url": " platform/porting/connectivity/",
						"content": "Connectivity\n\nYou can implement various connectivity features, such as Bluetooth, WLAN, and NFC.\n\nBluetooth\n\nBluetooth is a short range communication protocol used to communicate between 2 devices. Tizen uses open source Bluetooth components, such as BlueZ and ObexD. Bluez and ObexD run as a daemon and an interface library, Bluetooth Framework, is used for applications to access them over the D-Bus interface.\n\nThis section explains the Bluetooth architecture on the Tizen platform and how Tizen can be ported, along with the configuration parameters and their values.\n\nFigure: Tizen Bluetooth architecture\n\n\n\nThe Bluetooth framework provides a dialogue for the user to control the BlueZ, ObexD, and PulseAudio daemons. Bluetooth provides a standard interface between the Bluetooth chip and AP, called the HCI (Host Controller Interface). HCI can be implemented on USB, UART, and SDIO, but for the mobile environment, UART is the most common. HCI activation can differ depending on the chip vendor. The vendor provides the HCI configuration and the initial scripts. For example, Broadcom and Spreadtrum provide firmware and a loading tool. Tizen supports Bluetooth version 4.2, and the GATT, FTP, OPP, MAP, PBAP, A2DP, AVRCP, HSP/HFP, RFCOMM, HID, HDP, and PAN profiles. Bluetooth Low Energy functions have been implemented in BlueZ and bluetooth-frwk.\n\nThe Tizen Bluetooth framework is based on the open source BlueZ project. BlueZ provides the DBUS API and based on it, Tizen Bluetooth framework provides the C Language API. Using the Tizen Bluetooth framework is recommended.\n\nThe following components are necessary for Bluetooth:\n\n\n  Application\n    \n      User dialogue that controls the BlueZ, ObexD, and PulseAudio daemons\n    \n  \n  ObexD\n    \n      Open source component\n      Object exchange daemon\n      Supports OPP, FTP, PBAP, SYNC, and MAP profile stack\n    \n  \n  BluetoothD\n    \n      BluetoothD is the open source component, BlueZ 5.37 is supported\n      Bluetooth central daemon\n      Supports GAP, SDP, A2DP, AVRCP, HFP, HSP, and GATT profile stack\n    \n  \n  Bluetooth subsystem\n    \n      Provides the BT unix socket. Each protocol can be accessed by its socket.\n      Supports the L2CAP, RFCOMM, SCO, and HCI protocols\n    \n  \n  Bluetooth driver\n    \n      BT Chip driver\n      For UART, the interface is provided by the Linux kernel.\n      GPIO configuration, rfkill (radio frequency management), and power management can be handled by both the vendor and the porting engineer\n    \n  \n  Bluetooth firmware loading module\n    \n      Depending on the environment, it loads the Bluetooth firmware to the Bluetooth chip\n      Tizen and the chipset vendor need to implement this together\n      Package: bluetooth-tools\n    \n  \n\n\nPorting the OAL Interface\n\nThe following OAL scripts are run during the Bluetooth stack start and end sequences. These scripts invoke the Bluetooth chip-specific (such as Broadcom and Spreadtrum) scripts, provided by the chipset vendor to perform chip-specific configuration. These scripts are available in the bluetooth-dev-tools.under package. When this package is installed, it copies the following scripts in the /usr/etc/Bluetooth/ directory:\n\n\n  bt-stack-up.sh\n  bt-stack-down.sh\n  bt-reset-env.sh\n\n\nTizen BT Obex Profiles\n\nIn Tizen, the open source ObexD is used for the obex-based profiles:\n\n\n  BT Obex profiles server (obexd)\n  BT Obex profiles client (obex-client)\n\n\nConfiguration\n\nThere are a few configuration changes that need to be made to enable the specific chipset and the scripts and other chipset-specific configuration information, such as UART speed and UART terminal (tty). These changes must be provided by the chipset vendor.\n\n\n  Configuration for the Broadcomm BCM4358 Bluetooth chipset\n    \n      hciattach\nThe bluez/tools/hciattach.c file is patched to enable the hciattach tool specific to the BCM4358 chipset. This service attaches the BT UART HCI interface to the Bluetooth stack at a baud rate of 3000000. It is also responsible for loading the Bluetooth firmware on BCM4358.\n      Bluetooth UART used is /dev/ttySAC3\n      Broadcom firmware used is BCM4358A1_001.002.005.0032.0066.hcd\n      UART speed configuration for BCM4358A1 is 3000000\n      bcmtool used is bcmtool_4358a1\n      .bd_addr contains the unique Bluetooth address, which is generated during the first Bluetooth activation\n      Register the Bluetooth device:\n        bcmtool_4358a1 /dev/ttySAC0 -FILE=BCM4358A1_001.002.005.0032.0066.hcd -BAUD=3000000 -ADDR=/csa/bluetooth/.bd_addr -SETSCO=0,0,0,0,0,0,0,3,3,0 -LP\n        \n      \n      Attach a serial device to the Bluetooth stack using the UART HCI for a Broadcomm device:\n        hciattach /dev/ttySAC3 -S 3000000 bcm2035 3000000 flow\n        \n      \n      Run the Bluetooth daemon version 5.37:\n        bluetoothd\n        \n      \n      Bring the device up, set up the device name, and enable the SSP mode:\n        hciconfig hci0 up\nhciconfig hci0 name \"Tizen-Mobile\"\nhciconfig hci0 sspmode 1\n        \n      \n      Switch on the Bluetooth radio:\n        rfkill unblock bluetooth\n        \n      \n      Switch off the Bluetooth radio:\n        rfkill block bluetooth\n        \n      \n    \n  \n  Configuration for the Spreadtrum sc2331 Bluetooth chipset\n    \n      hciattach\nThe bluez/tools/hciattach.c file is patched to enable the hciattach tool specific to the sc2331 chipset. This service attaches the BT UART HCI interface to the Bluetooth stack at a baud rate of 3000000. It is also responsible for loading the Bluetooth firmware on sc2331.\n      Register the Bluetooth device:\nThe cp2-download tool is provided for downloading the Spreadtrum firmware. This tool also downloads the Wi-Fi firmware at boot time.\n      Install the following files in the target’s /usr/lib/firmware directory:\n        sc2331_fdl.bin\nsc2331_fw.bin\nscx35_pikeavivaltove_3M_MARLIN_connectivity_calibration.ini\nscx35_pikeavivaltove_3M_MARLIN_connectivity_configure.ini\n        \n      \n      Bluetooth UART used is /dev/ttyS0\n      UART speed configuration for sc233 is 3000000\n      Attach a serial device to the Bluetooth stack using the UART HCI:\n        hciattach -s 3000000 /dev/ttyS0 sprd 3000000 flow\n        \n      \n      Run the bluetooth daemon version 5.37:\n        bluetoothd\n        \n      \n      Bring the device up, set up the device name, and enable the SSP mode:\n        hciconfig hci0 up\nhciconfig hci0 name \"Tizen-Mobile\"\nhciconfig hci0 sspmode 1\n        \n      \n    \n  \n\n\nReferences\n\nOpen source component version: BlueZ 5.37\n\nFor more information, see http://www.bluez.org/.\n\nThe reference kernel configuration for Bluetooth:\n\n\n  The following kernel .config lines are enabled for Broadcom Bluetooth support:\n    CONFIG_BT=y\nCONFIG_BT_L2CAP=y\nCONFIG_BT_RFCOMM=y\nCONFIG_BT_RFCOMM_TTY=y\nCONFIG_BT_BNEP=y\nCONFIG_BT_HIDP=y\nCONFIG_BT_HCIUART=y\nCONFIG_BT_HCIUART_H4=y\nCONFIG_BCM4330=y\nCONFIG_RFKILL=y\nCONFIG_RFKILL_INPUT=y\nCONFIG_RXTRA_FIRMWARE_BCM4330=\"BCM4330.hcd\"\n    \n  \n  The following kernel .config lines are enabled for Bluetooth AVRCP support:\n    CONFIG_INPUT_MISC=y\nCONFIG_INPUT_UINPUT=y\n    \n  \n  The following kernel .config lines are enabled for Bluetooth HID support:\n    CONFIG_INPUT_GP2A=y\nCONFIG_INPUT_KR3DH=y\n    \n  \n  The following kernel .config lines are enabled for Bluetooth Audio (SCO-over-PCM) support:\n    CONFIG_BT_SCO=y\nCONFIG_INPUT_GP2A=y\nCONFIG_INPUT_KR3DH=y\n    \n  \n\n\nWLAN\n\nThis section provides a step-by-step explanation of what is involved in adding a new Wi-Fi driver and making Wi-Fi work.\n\nFigure: Tizen Wi-FI architecture\n\n\n\nFeature overview:\n\n\n  WLAN (802.11 b/g/n)\n  WPS PBC\n  EAP (PEAP, TTLS)\n\n\nTizen uses wpa_supplicant as the platform interface to Wi-Fi devices. Your Wi-Fi driver must be compatible with the standard wpa_supplicant.\n\nThe Tizen WLAN architecture is centered on the Linux wireless (IEEE-802.11) subsystem. The Linux wireless SW stack defines the WLAN hardware adaptation software interfaces that need to be used in Tizen. In practice, the required interfaces are defined by cfg80211 for FullMAC WLAN devices and by mac80211 for SoftMAC WLAN devices. In addition, a Linux network interface needs to be supported towards the Linux TCP/IP stack.\n\nThe Connection Manager (ConnMan) is a daemon for managing Internet connections within embedded devices running the Linux operating system.\n\nThe wpa_supplicant interface is a WPA Supplicant with support for WPA and WPA2 (IEEE 802.11i / RSN). WPA Supplicant is the IEEE 802.1X/WPA component that is used in the client stations. It implements key negotiation with a WPA Authenticator and it controls roaming and the IEEE 802.11 authentication/association of the WLAN driver.\n\nPorting the OAL Interface\n\nThe WLAN driver plugin is specific to a Wi-Fi chipset. This includes firmware and chipset-specific tools. Wi-Fi chipset firmware and tool files must be copied to the WLAN driver plugin directory, built, and installed before testing the Wi-Fi functionality. Because of Tizen platform requirements, the Wi-Fi driver must create the /opt/etc/.mac.info file, which has the device MAC address.\n\nThe WLAN driver plugin contains the wlan.sh file (located in /usr/bin/wlan.sh), which is used to load or unload the Wi-Fi driver firmware.\n\nWhen the wifi_activate() function is called, the load driver request is sent to the NET-CONFIG daemon. The NET-CONFIG daemon loads the Wi-Fi driver using the wlan.sh script file. Similarly, the wifi_deactivate() function requests unloading of the Wi-Fi driver. In case of Wi-Fi Direct®, the wifi_direct_activate() and wifi_direct_deactivate() functions make the Wi-Fi Direct manager load or unload the Wi-Fi driver using the wlan.sh script.\n\nUsing the /usr/bin/wlan.sh script:\n\n\n  wlan.sh start: Power up the Wi-Fi driver in station mode by loading the driver and running the firmware file.\n  wlan.sh p2p: Power up the Wi-Fi driver in Wi-Fi Direct mode by loading the driver and running the firmware file.\n  wlan.sh softap: Power up the Wi-Fi driver in Soft AP mode by loading the driver and running the firmware file.\n  wlan.sh stop: Power down the Wi-Fi driver.\n\n\nAll other Wi-Fi related functionality is handled by the ConnMan daemon.\n\nReferences\n\n\n  Connection Manager (ConnMan) project website: https://01.org/connman\n  Linux wireless (IEEE-802.11) subsystem: https://wireless.wiki.kernel.org\n  Information on Linux WPA/WPA2/IEEE 802.1X Supplicant: http://hostap.epitest.fi/wpa_supplicant/\n  Latest ConnMan release: http://git.kernel.org/?p=network/connman/connman.git;a=summary\n  WLAN driver plugin Git path: /adaptation/devices/wlandrv-plugin-tizen-bcm43xx\n  Reference kernel configurations\n  The following options must be enabled if the driver supports the cfg802.11 configuration API, instead of the wireless extension API. For more information, see http://linuxwireless.org.\n    CONFIG_CFG80211\nCONFIG_LIB80211\nCONFIG_MAC80211 (Enable this flag, if the driver supports the softMAC feature)\n    \n  \n  The following configuration options must be enabled in the kernel if the driver supports wireless extension APIs:\n    CONFIG_WIRELESS_EXT=y\nCONFIG_WEXT_CORE=y\nCONFIG_WEXT_PROC=y\nCONFIG_WEXT_PRIV=y\nCONFIG_WEXT_SPY=y\nCONFIG_WIRELESS_EXT_SYSFS=y\n    \n  \n\n\nNFC\n\nThe NFC application enables the user to:\n\n  Read and import the content written on an NFC tag.\n  Edit the content written on an NFC tag.\n  Write and save data on an NFC tag.\n  Load and save the NFC data from or in a file.\n\n\nFigure: NFC architecture\n\n\n\nThe NFC implementation has the following main components:\n\n\n  NFC client acts as an interface between the NFC application and the NFC manager, while writing or editing tag information in any physical tag.\n  NFC manager is the main interface, which actually deals with NFC physical tags, creates a connection with tags, and detects it. It is a daemon process to control the NFC chipset (such as NXP pn544). It provides the read and write service and basic P2P communication service, as well as the basic API for the client application.\n  NFC stack contains the required plugin, based on the NFC chipset. Currently, the nfc-plugin-nxp is used for the NXP chipset. The NFC plugin acts as an interface between the NFC chipset with the NFC framework (nfc-manager). It must be implemented according to the interface provided by the nfc-manager.\n\n\nPorting the OAL Interface\n\nThe NFC plugin is implemented as a shared library and it interfaces the Tizen nfc-manager and the vendor NFC chip. The NFC manager loads the libnfc-plugin.so library at runtime from the /usr/lib/libnfc-plugin.so directory. Any vendor-specific plugin is installed within the same path. The plugin must be written with predefined OAL API interfaces.\n\nDuring initialization, the nfc-manager loads the nfc-plugin.so library, searches for the onload() function, and calls the function with an interface structure instance as an argument for mapping all the OAL interfaces. These OAL/OEM interfaces are implemented according to the underlying NFC chipset. Once the mapping is done, the NFC manager interacts with nfc-plugin, which implements the vendor-specific OAL interfaces.\n\nThe following example shows the onload() function:\n\nBool\nonload(net_nfc_oem_interface_s *oem_interfaces) {\n    oem_interfaces-&gt;init = xxx;  /* xxx refers to plugin APIs */\n    oem_interfaces-&gt;deinit = xxx;\n    oem_interfaces-&gt;register_listener = xxx;\n    oem_interfaces-&gt;unregister_listener = xxx;\n    oem_interfaces-&gt;check_firmware_version = xxx;\n\n    return true;\n}\n\n\nThe NFC OAL interfaces are defined in the following structure. Use the net_nfc_oem_controller.h header file.\n\ntypedef struct _net_nfc_oem_interface_s {\n    net_nfc_oem_controller_init init;\n    net_nfc_oem_controller_deinit deinit;\n    net_nfc_oem_controller_register_listener register_listener;\n    net_nfc_oem_controller_unregister_listener unregister_listener;\n    net_nfc_oem_controller_check_firmware_version check_firmware_version;\n    net_nfc_oem_controller_update_firmware update_firmware;\n    net_nfc_oem_controller_get_stack_information get_stack_information;\n    net_nfc_oem_controller_configure_discovery configure_discovery;\n    net_nfc_oem_controller_get_secure_element_list get_secure_element_list;\n    net_nfc_oem_controller_set_secure_element_mode set_secure_element_mode;\n    net_nfc_oem_controller_connect connect;\n    net_nfc_oem_controller_connect disconnect;\n    net_nfc_oem_controller_check_ndef check_ndef;\n    net_nfc_oem_controller_check_target_presence check_presence;\n    net_nfc_oem_controller_read_ndef read_ndef;\n    net_nfc_oem_controller_write_ndef write_ndef;\n    net_nfc_oem_controller_make_read_only_ndef make_read_only_ndef;\n    net_nfc_oem_controller_transceive transceive;\n    net_nfc_oem_controller_format_ndef format_ndef;\n    net_nfc_oem_controller_exception_handler exception_handler;\n    net_nfc_oem_controller_is_ready is_ready;\n    net_nfc_oem_controller_llcp_config config_llcp;\n    net_nfc_oem_controller_llcp_check_llcp check_llcp_status;\n    net_nfc_oem_controller_llcp_activate_llcp activate_llcp;\n    net_nfc_oem_controller_llcp_create_socket create_llcp_socket;\n    net_nfc_oem_controller_llcp_bind bind_llcp_socket;\n    net_nfc_oem_controller_llcp_listen listen_llcp_socket;\n    net_nfc_oem_controller_llcp_accept accept_llcp_socket;\n    net_nfc_oem_controller_llcp_connect_by_url connect_llcp_by_url;\n    net_nfc_oem_controller_llcp_connect connect_llcp;\n    net_nfc_oem_controller_llcp_disconnect disconnect_llcp;\n    net_nfc_oem_controller_llcp_socket_close close_llcp_socket;\n    net_nfc_oem_controller_llcp_recv recv_llcp;\n    net_nfc_oem_controller_llcp_send send_llcp;\n    net_nfc_oem_controller_llcp_recv_from recv_from_llcp;\n    net_nfc_oem_controller_llcp_send_to send_to_llcp;\n    net_nfc_oem_controller_llcp_reject reject_llcp;\n    net_nfc_oem_controller_llcp_get_remote_config get_remote_config;\n    net_nfc_oem_controller_llcp_get_remote_socket_info get_remote_socket_info;\n    net_nfc_oem_controller_sim_test sim_test;\n    net_nfc_oem_controller_test_mode_on test_mode_on;\n    net_nfc_oem_controller_test_mode_off test_mode_off;\n    net_nfc_oem_controller_support_nfc support_nfc;\n} net_nfc_oem_interface_s;\n\n\nThe nfc_oem_interface_s struct is exported in the nfc-plugin. Using this interface structure, the nfc-manager communicates with the OAL interfaces at runtime. The NFC plugin loads when the nfc-manager is started and the plugin init() function is called to initialize the NFC chip.\n\nint (*init) (net_nfc_oem_controller_init*);\n\n\nThe nfc-manager issues the deinit() function to deinitialize the NFC chip:\n\nint (*deinit) (net_nfc_oem_controller_deinit *);\n\n\nPay attention to the following:\n\n\n  Sending the notification to the upper layer (NFC service)\nSee the phdal4nfc_message_glib.c file. The g_idle_add_full is used for handling the message in the NFC service. You can use the callback client asynchronously in the client context. Post a message in queue, and the message is processed by a client thread.\n  Reference implementation of the NFC plugin\nSample code snippets cannot be reproduced. Code is proprietary. For reference, see the nfc-plugin-emul and nfc-plugin-nxp files.\n\n\nNFC OAL API\n\nThe following table lists all the NFC OAL API functions.\n\nTable: NFC OAL API functions\n\n\n  \n    \n      Function\n      Description\n      Parameter\n    \n  \n  \n    \n      net_nfc_oem_controller_init init;\n      Initializes the NFC chip.\n      net_nfc_error_e: Returns an error code on failure\n    \n    \n      net_nfc_oem_controller_deinit deinit;\n      Deinitializes the NFC chip.\n      -\n    \n    \n      net_nfc_oem_controller_register_listener register_listener;\n      Registers a callback function for a tag event, SE event, and llcp event.\n      target_detection_listener_cb target_detection_listener: Tag event callback functionse_transaction_listener_cb se_transaction_listener: SE event callback functionllcp_event_listener_cb llcp_event_listener: llcp event callback functionnet_nfc_error_e: Returns an error code on failure\n    \n    \n      net_nfc_oem_controller_unregister_listener unregister_listener;\n      Releases a callback function for a tag event, SE event, and llcp event.\n      -\n    \n    \n      net_nfc_oem_controller_check_firmware_version check_firmware_version;\n      Checks the firmware version of the NFC chip.\n      net_nfc_error_e: Returns an error code on failure\n    \n    \n      net_nfc_oem_controller_update_firmware update_firmware;\n      Updates the NFC chip firmware.\n      net_nfc_error_e: Returns an error code on failure\n    \n    \n      net_nfc_oem_controller_get_stack_information get_stack_information;\n      Gets the list of supported tags and the current firmware version.\n      net_nfc_stack_information_s: Pointer value to get the information of support tags and the current firmware versionnet_nfc_error_e: Returns an error code on failure\n    \n    \n      net_nfc_oem_controller_configure_discovery configure_discovery;\n      Delivers the config information on discovery.\n      net_nfc_discovery_mode_e: Start/stop modenet_nfc_event_filter_e config: Information for tag filteringnet_nfc_error_e: Returns an error code on failure\n    \n    \n      net_nfc_oem_controller_get_secure_element_list get_secure_element_list;\n      Gets the information of the current secure element.\n      net_nfc_secure_element_info_s: Pointer value to get secure element informationint: Pointer value to get the count of the secure elementnet_nfc_error_e: Returns an error code on failure\n    \n    \n      net_nfc_oem_controller_set_secure_element_mode set_secure_element_mode;\n      Sets the secure element to use.\n      net_nfc_secure_element_type_e: Secure element informationnet_nfc_secure_element_mode_e: Mode information to setnet_nfc_error_e: Returns an error code on failure\n    \n    \n      net_nfc_oem_controller_connect connect;\n      Connects to the detected tag/target.\n      net_nfc_target_handle_s: Tag/target handle for connectingnet_nfc_error_e: Returns an error code on failure\n    \n    \n      net_nfc_oem_controller_connect disconnect;\n      Disconnects the connected tag/target.\n      net_nfc_target_handle_s: Tag/target handle for disconnectingnet_nfc_error_e: Returns an error code on failure\n    \n    \n      net_nfc_oem_controller_check_ndef check_ndef;\n      Checks the tag for ndef support.\n      net_nfc_target_handle_s: Tag handle to check ndefint: Max size supported in the tagint: Real data size saved in the tagnet_nfc_error_e: Returns an error code on failure\n    \n    \n      net_nfc_oem_controller_check_target_presence check_presence;\n      Checks whether a tag exists in the RF range.\n      net_nfc_target_handle_s: Tag handle to check presencenet_nfc_error_e: Returns an error code on failure\n    \n    \n      net_nfc_oem_controller_read_ndef read_ndef;\n      Reads ndef data in a tag.\n      net_nfc_target_handle_s: Tag handle to readdata_s: Pointer value to save the ndef datanet_nfc_error_e: Returns an error code on failure\n    \n    \n      net_nfc_oem_controller_write_ndef write_ndef;\n      Writes the data to the tag.\n      net_nfc_target_handle_s: Handle to writedata_s: Data to writenet_nfc_error_e: Returns an error code on failure\n    \n    \n      net_nfc_oem_controller_make_read_only_ndef make_read_only_ndef;\n      Makes the tag to a read-only tag.\n      net_nfc_target_handle_s: Target tag handlenet_nfc_error_e: Returns an error code on failure\n    \n    \n      net_nfc_oem_controller_transceive transceive;\n      Sends and receives the low command to the tag or target.\n      net_nfc_target_handle_s: Tag or target handle to transceivenet_nfc_transceive_info_s: Pointer value including command or data to send and data to receivedata_s: Pointer value to send the information of contextnet_nfc_error_e: Returns an error code on failure\n    \n    \n      net_nfc_oem_controller_format_ndef format_ndef;\n      Formats the tag.\n      net_nfc_target_handle_s: Tag handle to formatdata_s: Key value to send the tag for formattingnet_nfc_error_e: Returns an error code on failure\n    \n    \n      net_nfc_oem_controller_exception_handler exception_handler;\n      When the nfc-manager faces an unwanted exception, it tries to deinitialize and initialize the stack before unregistering and registering the callback function.\n      -\n    \n    \n      net_nfc_oem_controller_is_ready is_ready;\n      Checks the status of the NFC stack.\n      net_nfc_error_e: Returns an error code on failure\n    \n    \n      net_nfc_oem_controller_llcp_config config_llcp;\n      Sets the llcp configuration (miu, lto, wks, option).\n      net_nfc_target_handle_s: Target handle to set llcpnet_nfc_error_e: Returns an error code on failure\n    \n    \n      net_nfc_oem_controller_llcp_check_llcp check_llcp_status;\n      Checks the llcp configuration (miu, lto, wks, option).\n      net_nfc_target_handle_s: Target handle to check llcpnet_nfc_error_e: Returns an error code on failure\n    \n    \n      net_nfc_oem_controller_llcp_activate_llcp activate_llcp;\n      Activates the llcp functionality.\n      net_nfc_target_handle_s: Target handle to activatenet_nfc_error_e: Returns an error code on failure\n    \n    \n      net_nfc_oem_controller_llcp_create_socket create_llcp_socket;\n      Creates the llcp socket.\n      net_nfc_llcp_socket_t: Pointer value to receive the socket informationnet_nfc_socket_type_e socketType: Type of socket to createuint16_t miu: miu valueuint8_t rw: rw valuenet_nfc_error_e: Returns an error code on failurevoid: value to control the context (can be set to NULL)\n    \n    \n      net_nfc_oem_controller_llcp_bind bind_llcp_socket;\n      Binds the socket.\n      net_nfc_llcp_socket_t socket: Information about the socket to binduint8_t service_access_point: Information of access point to bindnet_nfc_error_e: Returns an error code on failure\n    \n    \n      net_nfc_oem_controller_llcp_listen listen_llcp_socket;\n      Sets the socket to listen.\n      net_nfc_target_handle_s: Target handleuint8_t: Service name to listennet_nfc_llcp_socket_t socket: Socket informationnet_nfc_error_e: Returns an error code on failurevoid: Value to control the context (can be set to NULL)\n    \n    \n      net_nfc_oem_controller_llcp_accept accept_llcp_socket;\n      Accepts the connect request in listening status.\n      net_nfc_llcp_socket_t socket: Socket information to acceptnet_nfc_error_e: Returns an error code on failure\n    \n    \n      net_nfc_oem_controller_llcp_connect_by_url connect_llcp_by_url;\n      Connects the server with the service name.\n      net_nfc_target_handle_s: Handle of the target to connectnet_nfc_llcp_socket_t socket: Socket informationuint8_t: Service name to connectnet_nfc_error_e: Returns an error code on failurevoid: Value to control the context (can be set to NULL)\n    \n    \n      net_nfc_oem_controller_llcp_connect connect_llcp;\n      Connects to the server with access point (port number).\n      net_nfc_target_handle_s: Target handlenet_nfc_llcp_socket_t socket: Socket informationuint8_t service_access_point: Access point numbernet_nfc_error_e: Returns an error code on failurevoid: Value to control the context (can be set to NULL)\n    \n    \n      net_nfc_oem_controller_llcp_disconnect disconnect_llcp;\n      Disconnects the llcp link.\n      net_nfc_target_handle_s: Socket information to disconnectnet_nfc_llcp_socket_t socket: Information of the socket to disconnectnet_nfc_error_e: Returns an error code on failurevoid: Value to control the context (can be set to NULL)\n    \n    \n      net_nfc_oem_controller_llcp_socket_close close_llcp_socket;\n      Closes the llcp socket.\n      net_nfc_llcp_socket_t socket: Socket information to closenet_nfc_error_e: Returns an error code on failure\n    \n    \n      net_nfc_oem_controller_llcp_recv recv_llcp;\n      Receives the data using the llcp link.\n      net_nfc_target_handle_s: Target handle to receivenet_nfc_llcp_socket_t socket: Socket information to receivedata_s: Pointer value to receive the datanet_nfc_error_e: Returns an error code on failurevoid: Value to control the context (can be set to NULL)\n    \n    \n      net_nfc_oem_controller_llcp_send send_llcp;\n      Sends the data using llcp link.\n      net_nfc_target_handle_s: Target handle to sendnet_nfc_llcp_socket_t socket: Socket information to senddata_s: Data to sendnet_nfc_error_e: Returns an error code on failurevoid: Value to control the context (can be set to NULL)\n    \n    \n      net_nfc_oem_controller_llcp_recv_from recv_from_llcp;\n      Rejects the connect request from the client socket.\n      net_nfc_target_handle_s: Target handle to rejectnet_nfc_llcp_socket_t socket: Socket information to rejectnet_nfc_error_e: Returns an error code on failure\n    \n    \n      net_nfc_oem_controller_llcp_send_to send_to_llcp;\n      Sends the data using the service access point.\n      net_nfc_target_handle_s: Peer target handlenet_nfc_llcp_socket_t socket: Socket informationdata_s: Data to senduint8_t service_access_point: Service access point to sendnet_nfc_error_e: Returns an error code on failurevoid: Value to control the context (can be set to NULL)\n    \n    \n      net_nfc_oem_controller_llcp_reject reject_llcp;\n      Rejects the connect request from the client socket.\n      net_nfc_target_handle_s: Target handle to rejectnet_nfc_llcp_socket_t socket: Socket information to rejectnet_nfc_error_e: Returns an error code on failure\n    \n    \n      net_nfc_oem_controller_llcp_get_remote_config get_remote_config;\n      Gets the llcp socket config information of the peer device.\n      net_nfc_target_handle_s: Peer target handlenet_nfc_llcp_config_info_s: Pointer value to get config information of peer device’s llcp socketnet_nfc_error_e: Returns an error code on failure\n    \n    \n      net_nfc_oem_controller_llcp_get_remote_socket_info get_remote_socket_info;\n      Gets the llcp socket information of the peer device.\n      net_nfc_target_handle_s: Peer target handlenet_nfc_llcp_socket_t socket: llcp socket informationnet_nfc_llcp_socket_option_s: Pointer value to save the information of remote socketnet_nfc_error_e: Returns an error code on failure\n    \n    \n      net_nfc_oem_controller_sim_test sim_test;\n      Tests the SWP link with SIM and NFC chipset.\n      net_nfc_error_e: Returns an error code on failure\n    \n    \n      net_nfc_oem_controller_test_mode_on test_mode_on;\n      Changes the NFC chip to test mode. (Test mode exists only in the NXP case. If there are none, it does not need to implemented.)\n      net_nfc_error_e: Returns an error code on failure\n    \n    \n      net_nfc_oem_controller_test_mode_off test_mode_off;\n      Changes the status of the NFC chip from test mode to normal mode. (Test mode exists only in the NXP case. If there are none, it does not need to implemented.)\n      net_nfc_error_e: Returns an error code on failure\n    \n    \n      net_nfc_oem_controller_support_nfc support_nfc\n      Checks each device file of each chip.\n      -\n    \n  \n\n\nConfiguration\n\nThe nfc-plugin package must be saved to the /usr/lib/libnfc-plugin.so directory when installed. When the nfc-manager starts, it looks for the plugin library and loads it dynamically from this path.\n\nReferences\n\nEnable the following configuration options in the kernel .config file:\n\nUsing Pn544: CONFIG_PN544_NFC\nUsing Pn65n: CONFIG_PN65N_NFC\n\n\nAPI references are available in the Tizen 3.0 Porting Guide appendix.\n\nFor more information, see http://nfc-forum.org/.\n\nMTP\nThe Media Transfer Protocol (MTP) is used for exchanging media files between 2 devices:\n\n\n  MTP exchanges can only occur between 2 devices at a time.\n  In each communication, 1 devices acts as the initiator and the other as the responder.\n  \n    The initiator is the device that initiates actions with the responder by sending operations to the responder.\n\n    Figure: MTP Initiator\n\n    \n  \n  \n    The responder cannot initiate any actions, and can only send responses to operations sent by the initiator or send events.\n\n    Figure: MTP Responder\n\n    \n  \n  In the Tizen system, the USB host is the initiator, and the USB device is the responder.\n\n\nPorting the OAL Interface\n\nThe Tizen MTP initiator and responder do not have an OAL Interface. There are extension possibilities for the MTP Transport layer.\n\nConfiguration\n\nThe following configuration is needed:\n\n\n  MTP initiator\n    \n      The MTP Initiator consists of 3 packages:\n        mtp-initiator daemon\nmtp-initiator api\nlibmtp opensource\n        \n      \n      The MTP initiator does not operate independently. It requires the help of another module, such as USB.\n      When the USB device is connected to the host, the module must run the MTP initiator daemon.\n    \n  \n  MTP responder\n    \n      The MTP responder consists of 1 package:\n        mtp-responder daemon\n        \n      \n      The MTP responder does not operate independently. It requires the help of another module, such as USB.\n      When the USB device is connected to the host, the module must run the MTP responder daemon.\n    \n  \n\n\nReferences\n\n\n  Media Transfer Protocol v.1.1 Spec: http://www.usb.org/developers/docs/devclass_docs/"
					}
					
				
			
		
			
				
					,
					
					"iot-porting-connectivity": {
						"id": "iot-porting-connectivity",
						"title": "Connectivity",
						"categories": "",
						"url": " iot/porting/connectivity/",
						"content": "Connectivity\n\nYou can implement various connectivity features, such as Bluetooth, WLAN, and NFC.\n\nBluetooth\n\nBluetooth is a short range communication protocol used to communicate between 2 devices. Tizen uses open source Bluetooth components, such as BlueZ and ObexD. Bluez and ObexD run as a daemon and an interface library, Bluetooth Framework, is used for applications to access them over the D-Bus interface.\n\nThis section explains the Bluetooth architecture on the Tizen platform and how Tizen can be ported, along with the configuration parameters and their values.\n\nFigure: Tizen Bluetooth architecture\n\n\n\nThe Bluetooth framework provides a dialogue for the user to control the BlueZ, ObexD, and PulseAudio daemons. Bluetooth provides a standard interface between the Bluetooth chip and AP, called the HCI (Host Controller Interface). HCI can be implemented on USB, UART, and SDIO, but for the mobile environment, UART is the most common. HCI activation can differ depending on the chip vendor. The vendor provides the HCI configuration and the initial scripts. For example, Broadcom and Spreadtrum provide firmware and a loading tool. Tizen supports Bluetooth version 4.2, and the GATT, FTP, OPP, MAP, PBAP, A2DP, AVRCP, HSP/HFP, RFCOMM, HID, HDP, and PAN profiles. Bluetooth Low Energy functions have been implemented in BlueZ and bluetooth-frwk.\n\nThe Tizen Bluetooth framework is based on the open source BlueZ project. BlueZ provides the DBUS API and based on it, Tizen Bluetooth framework provides the C Language API. Using the Tizen Bluetooth framework is recommended.\n\nThe following components are necessary for Bluetooth:\n\n\n  Application\n    \n      User dialogue that controls the BlueZ, ObexD, and PulseAudio daemons\n    \n  \n  ObexD\n    \n      Open source component\n      Object exchange daemon\n      Supports OPP, FTP, PBAP, SYNC, and MAP profile stack\n    \n  \n  BluetoothD\n    \n      BluetoothD is the open source component, BlueZ 5.37 is supported\n      Bluetooth central daemon\n      Supports GAP, SDP, A2DP, AVRCP, HFP, HSP, and GATT profile stack\n    \n  \n  Bluetooth subsystem\n    \n      Provides the BT unix socket. Each protocol can be accessed by its socket.\n      Supports the L2CAP, RFCOMM, SCO, and HCI protocols\n    \n  \n  Bluetooth driver\n    \n      BT Chip driver\n      For UART, the interface is provided by the Linux kernel.\n      GPIO configuration, rfkill (radio frequency management), and power management can be handled by both the vendor and the porting engineer\n    \n  \n  Bluetooth firmware loading module\n    \n      Depending on the environment, it loads the Bluetooth firmware to the Bluetooth chip\n      Tizen and the chipset vendor need to implement this together\n      Package: bluetooth-tools\n    \n  \n\n\nPorting the OAL Interface\n\nThe following OAL scripts are run during the Bluetooth stack start and end sequences. These scripts invoke the Bluetooth chip-specific (such as Broadcom and Spreadtrum) scripts, provided by the chipset vendor to perform chip-specific configuration. These scripts are available in the bluetooth-dev-tools.under package. When this package is installed, it copies the following scripts in the /usr/etc/Bluetooth/ directory:\n\n\n  bt-stack-up.sh\n  bt-stack-down.sh\n  bt-reset-env.sh\n\n\nTizen BT Obex Profiles\n\nIn Tizen, the open source ObexD is used for the obex-based profiles:\n\n\n  BT Obex profiles server (obexd)\n  BT Obex profiles client (obex-client)\n\n\nConfiguration\n\nThere are a few configuration changes that need to be made to enable the specific chipset and the scripts and other chipset-specific configuration information, such as UART speed and UART terminal (tty). These changes must be provided by the chipset vendor.\n\n\n  Configuration for the Broadcomm BCM4358 Bluetooth chipset\n    \n      hciattach\nThe bluez/tools/hciattach.c file is patched to enable the hciattach tool specific to the BCM4358 chipset. This service attaches the BT UART HCI interface to the Bluetooth stack at a baud rate of 3000000. It is also responsible for loading the Bluetooth firmware on BCM4358.\n      Bluetooth UART used is /dev/ttySAC3\n      Broadcom firmware used is BCM4358A1_001.002.005.0032.0066.hcd\n      UART speed configuration for BCM4358A1 is 3000000\n      bcmtool used is bcmtool_4358a1\n      .bd_addr contains the unique Bluetooth address, which is generated during the first Bluetooth activation\n      Register the Bluetooth device:\n        bcmtool_4358a1 /dev/ttySAC0 -FILE=BCM4358A1_001.002.005.0032.0066.hcd -BAUD=3000000 -ADDR=/csa/bluetooth/.bd_addr -SETSCO=0,0,0,0,0,0,0,3,3,0 -LP\n        \n      \n      Attach a serial device to the Bluetooth stack using the UART HCI for a Broadcomm device:\n        hciattach /dev/ttySAC3 -S 3000000 bcm2035 3000000 flow\n        \n      \n      Run the Bluetooth daemon version 5.37:\n        bluetoothd\n        \n      \n      Bring the device up, set up the device name, and enable the SSP mode:\n        hciconfig hci0 up\nhciconfig hci0 name \"Tizen-Mobile\"\nhciconfig hci0 sspmode 1\n        \n      \n      Switch on the Bluetooth radio:\n        rfkill unblock bluetooth\n        \n      \n      Switch off the Bluetooth radio:\n        rfkill block bluetooth\n        \n      \n    \n  \n  Configuration for the Spreadtrum sc2331 Bluetooth chipset\n    \n      hciattach\nThe bluez/tools/hciattach.c file is patched to enable the hciattach tool specific to the sc2331 chipset. This service attaches the BT UART HCI interface to the Bluetooth stack at a baud rate of 3000000. It is also responsible for loading the Bluetooth firmware on sc2331.\n      Register the Bluetooth device:\nThe cp2-download tool is provided for downloading the Spreadtrum firmware. This tool also downloads the Wi-Fi firmware at boot time.\n      Install the following files in the target’s /usr/lib/firmware directory:\n        sc2331_fdl.bin\nsc2331_fw.bin\nscx35_pikeavivaltove_3M_MARLIN_connectivity_calibration.ini\nscx35_pikeavivaltove_3M_MARLIN_connectivity_configure.ini\n        \n      \n      Bluetooth UART used is /dev/ttyS0\n      UART speed configuration for sc233 is 3000000\n      Attach a serial device to the Bluetooth stack using the UART HCI:\n        hciattach -s 3000000 /dev/ttyS0 sprd 3000000 flow\n        \n      \n      Run the bluetooth daemon version 5.37:\n        bluetoothd\n        \n      \n      Bring the device up, set up the device name, and enable the SSP mode:\n        hciconfig hci0 up\nhciconfig hci0 name \"Tizen-Mobile\"\nhciconfig hci0 sspmode 1\n        \n      \n    \n  \n\n\nReferences\n\nOpen source component version: BlueZ 5.37\n\nFor more information, see http://www.bluez.org/.\n\nThe reference kernel configuration for Bluetooth:\n\n\n  The following kernel .config lines are enabled for Broadcom Bluetooth support:\n    CONFIG_BT=y\nCONFIG_BT_L2CAP=y\nCONFIG_BT_RFCOMM=y\nCONFIG_BT_RFCOMM_TTY=y\nCONFIG_BT_BNEP=y\nCONFIG_BT_HIDP=y\nCONFIG_BT_HCIUART=y\nCONFIG_BT_HCIUART_H4=y\nCONFIG_BCM4330=y\nCONFIG_RFKILL=y\nCONFIG_RFKILL_INPUT=y\nCONFIG_RXTRA_FIRMWARE_BCM4330=\"BCM4330.hcd\"\n    \n  \n  The following kernel .config lines are enabled for Bluetooth AVRCP support:\n    CONFIG_INPUT_MISC=y\nCONFIG_INPUT_UINPUT=y\n    \n  \n  The following kernel .config lines are enabled for Bluetooth HID support:\n    CONFIG_INPUT_GP2A=y\nCONFIG_INPUT_KR3DH=y\n    \n  \n  The following kernel .config lines are enabled for Bluetooth Audio (SCO-over-PCM) support:\n    CONFIG_BT_SCO=y\nCONFIG_INPUT_GP2A=y\nCONFIG_INPUT_KR3DH=y\n    \n  \n\n\nWLAN\n\nThis section provides a step-by-step explanation of what is involved in adding a new Wi-Fi driver and making Wi-Fi work.\n\nFigure: Tizen Wi-FI architecture\n\n\n\nFeature overview:\n\n\n  WLAN (802.11 b/g/n)\n  WPS PBC\n  EAP (PEAP, TTLS)\n\n\nTizen uses wpa_supplicant as the platform interface to Wi-Fi devices. Your Wi-Fi driver must be compatible with the standard wpa_supplicant.\n\nThe Tizen WLAN architecture is centered on the Linux wireless (IEEE-802.11) subsystem. The Linux wireless SW stack defines the WLAN hardware adaptation software interfaces that need to be used in Tizen. In practice, the required interfaces are defined by cfg80211 for FullMAC WLAN devices and by mac80211 for SoftMAC WLAN devices. In addition, a Linux network interface needs to be supported towards the Linux TCP/IP stack.\n\nThe Connection Manager (ConnMan) is a daemon for managing Internet connections within embedded devices running the Linux operating system.\n\nThe wpa_supplicant interface is a WPA Supplicant with support for WPA and WPA2 (IEEE 802.11i / RSN). WPA Supplicant is the IEEE 802.1X/WPA component that is used in the client stations. It implements key negotiation with a WPA Authenticator and it controls roaming and the IEEE 802.11 authentication/association of the WLAN driver.\n\nPorting the OAL Interface\n\nThe WLAN driver plugin is specific to a Wi-Fi chipset. This includes firmware and chipset-specific tools. Wi-Fi chipset firmware and tool files must be copied to the WLAN driver plugin directory, built, and installed before testing the Wi-Fi functionality. Because of Tizen platform requirements, the Wi-Fi driver must create the /opt/etc/.mac.info file, which has the device MAC address.\n\nThe WLAN driver plugin contains the wlan.sh file (located in /usr/bin/wlan.sh), which is used to load or unload the Wi-Fi driver firmware.\n\nWhen the wifi_activate() function is called, the load driver request is sent to the NET-CONFIG daemon. The NET-CONFIG daemon loads the Wi-Fi driver using the wlan.sh script file. Similarly, the wifi_deactivate() function requests unloading of the Wi-Fi driver. In case of Wi-Fi Direct®, the wifi_direct_activate() and wifi_direct_deactivate() functions make the Wi-Fi Direct manager load or unload the Wi-Fi driver using the wlan.sh script.\n\nUsing the /usr/bin/wlan.sh script:\n\n\n  wlan.sh start: Power up the Wi-Fi driver in station mode by loading the driver and running the firmware file.\n  wlan.sh p2p: Power up the Wi-Fi driver in Wi-Fi Direct mode by loading the driver and running the firmware file.\n  wlan.sh softap: Power up the Wi-Fi driver in Soft AP mode by loading the driver and running the firmware file.\n  wlan.sh stop: Power down the Wi-Fi driver.\n\n\nAll other Wi-Fi related functionality is handled by the ConnMan daemon.\n\nReferences\n\n\n  Connection Manager (ConnMan) project website: https://01.org/connman\n  Linux wireless (IEEE-802.11) subsystem: https://wireless.wiki.kernel.org\n  Information on Linux WPA/WPA2/IEEE 802.1X Supplicant: http://hostap.epitest.fi/wpa_supplicant/\n  Latest ConnMan release: http://git.kernel.org/?p=network/connman/connman.git;a=summary\n  WLAN driver plugin Git path: /adaptation/devices/wlandrv-plugin-tizen-bcm43xx\n  Reference kernel configurations\n  The following options must be enabled if the driver supports the cfg802.11 configuration API, instead of the wireless extension API. For more information, see http://linuxwireless.org.\n    CONFIG_CFG80211\nCONFIG_LIB80211\nCONFIG_MAC80211 (Enable this flag, if the driver supports the softMAC feature)\n    \n  \n  The following configuration options must be enabled in the kernel if the driver supports wireless extension APIs:\n    CONFIG_WIRELESS_EXT=y\nCONFIG_WEXT_CORE=y\nCONFIG_WEXT_PROC=y\nCONFIG_WEXT_PRIV=y\nCONFIG_WEXT_SPY=y\nCONFIG_WIRELESS_EXT_SYSFS=y\n    \n  \n\n\nNFC\n\nThe NFC application enables the user to:\n\n  Read and import the content written on an NFC tag.\n  Edit the content written on an NFC tag.\n  Write and save data on an NFC tag.\n  Load and save the NFC data from or in a file.\n\n\nFigure: NFC architecture\n\n\n\nThe NFC implementation has the following main components:\n\n\n  NFC client acts as an interface between the NFC application and the NFC manager, while writing or editing tag information in any physical tag.\n  NFC manager is the main interface, which actually deals with NFC physical tags, creates a connection with tags, and detects it. It is a daemon process to control the NFC chipset (such as NXP pn544). It provides the read and write service and basic P2P communication service, as well as the basic API for the client application.\n  NFC stack contains the required plugin, based on the NFC chipset. Currently, the nfc-plugin-nxp is used for the NXP chipset. The NFC plugin acts as an interface between the NFC chipset with the NFC framework (nfc-manager). It must be implemented according to the interface provided by the nfc-manager.\n\n\nPorting the OAL Interface\n\nThe NFC plugin is implemented as a shared library and it interfaces the Tizen nfc-manager and the vendor NFC chip. The NFC manager loads the libnfc-plugin.so library at runtime from the /usr/lib/libnfc-plugin.so directory. Any vendor-specific plugin is installed within the same path. The plugin must be written with predefined OAL API interfaces.\n\nDuring initialization, the nfc-manager loads the nfc-plugin.so library, searches for the onload() function, and calls the function with an interface structure instance as an argument for mapping all the OAL interfaces. These OAL/OEM interfaces are implemented according to the underlying NFC chipset. Once the mapping is done, the NFC manager interacts with nfc-plugin, which implements the vendor-specific OAL interfaces.\n\nThe following example shows the onload() function:\n\nBool\nonload(net_nfc_oem_interface_s *oem_interfaces) {\n    oem_interfaces-&gt;init = xxx;  /* xxx refers to plugin APIs */\n    oem_interfaces-&gt;deinit = xxx;\n    oem_interfaces-&gt;register_listener = xxx;\n    oem_interfaces-&gt;unregister_listener = xxx;\n    oem_interfaces-&gt;check_firmware_version = xxx;\n\n    return true;\n}\n\n\nThe NFC OAL interfaces are defined in the following structure. Use the net_nfc_oem_controller.h header file.\n\ntypedef struct _net_nfc_oem_interface_s {\n    net_nfc_oem_controller_init init;\n    net_nfc_oem_controller_deinit deinit;\n    net_nfc_oem_controller_register_listener register_listener;\n    net_nfc_oem_controller_unregister_listener unregister_listener;\n    net_nfc_oem_controller_check_firmware_version check_firmware_version;\n    net_nfc_oem_controller_update_firmware update_firmware;\n    net_nfc_oem_controller_get_stack_information get_stack_information;\n    net_nfc_oem_controller_configure_discovery configure_discovery;\n    net_nfc_oem_controller_get_secure_element_list get_secure_element_list;\n    net_nfc_oem_controller_set_secure_element_mode set_secure_element_mode;\n    net_nfc_oem_controller_connect connect;\n    net_nfc_oem_controller_connect disconnect;\n    net_nfc_oem_controller_check_ndef check_ndef;\n    net_nfc_oem_controller_check_target_presence check_presence;\n    net_nfc_oem_controller_read_ndef read_ndef;\n    net_nfc_oem_controller_write_ndef write_ndef;\n    net_nfc_oem_controller_make_read_only_ndef make_read_only_ndef;\n    net_nfc_oem_controller_transceive transceive;\n    net_nfc_oem_controller_format_ndef format_ndef;\n    net_nfc_oem_controller_exception_handler exception_handler;\n    net_nfc_oem_controller_is_ready is_ready;\n    net_nfc_oem_controller_llcp_config config_llcp;\n    net_nfc_oem_controller_llcp_check_llcp check_llcp_status;\n    net_nfc_oem_controller_llcp_activate_llcp activate_llcp;\n    net_nfc_oem_controller_llcp_create_socket create_llcp_socket;\n    net_nfc_oem_controller_llcp_bind bind_llcp_socket;\n    net_nfc_oem_controller_llcp_listen listen_llcp_socket;\n    net_nfc_oem_controller_llcp_accept accept_llcp_socket;\n    net_nfc_oem_controller_llcp_connect_by_url connect_llcp_by_url;\n    net_nfc_oem_controller_llcp_connect connect_llcp;\n    net_nfc_oem_controller_llcp_disconnect disconnect_llcp;\n    net_nfc_oem_controller_llcp_socket_close close_llcp_socket;\n    net_nfc_oem_controller_llcp_recv recv_llcp;\n    net_nfc_oem_controller_llcp_send send_llcp;\n    net_nfc_oem_controller_llcp_recv_from recv_from_llcp;\n    net_nfc_oem_controller_llcp_send_to send_to_llcp;\n    net_nfc_oem_controller_llcp_reject reject_llcp;\n    net_nfc_oem_controller_llcp_get_remote_config get_remote_config;\n    net_nfc_oem_controller_llcp_get_remote_socket_info get_remote_socket_info;\n    net_nfc_oem_controller_sim_test sim_test;\n    net_nfc_oem_controller_test_mode_on test_mode_on;\n    net_nfc_oem_controller_test_mode_off test_mode_off;\n    net_nfc_oem_controller_support_nfc support_nfc;\n} net_nfc_oem_interface_s;\n\n\nThe nfc_oem_interface_s struct is exported in the nfc-plugin. Using this interface structure, the nfc-manager communicates with the OAL interfaces at runtime. The NFC plugin loads when the nfc-manager is started and the plugin init() function is called to initialize the NFC chip.\n\nint (*init) (net_nfc_oem_controller_init*);\n\n\nThe nfc-manager issues the deinit() function to deinitialize the NFC chip:\n\nint (*deinit) (net_nfc_oem_controller_deinit *);\n\n\nPay attention to the following:\n\n\n  Sending the notification to the upper layer (NFC service)\nSee the phdal4nfc_message_glib.c file. The g_idle_add_full is used for handling the message in the NFC service. You can use the callback client asynchronously in the client context. Post a message in queue, and the message is processed by a client thread.\n  Reference implementation of the NFC plugin\nSample code snippets cannot be reproduced. Code is proprietary. For reference, see the nfc-plugin-emul and nfc-plugin-nxp files.\n\n\nNFC OAL API\n\nThe following table lists all the NFC OAL API functions.\n\nTable: NFC OAL API functions\n\n\n  \n    \n      Function\n      Description\n      Parameter\n    \n  \n  \n    \n      net_nfc_oem_controller_init init;\n      Initializes the NFC chip.\n      net_nfc_error_e: Returns an error code on failure\n    \n    \n      net_nfc_oem_controller_deinit deinit;\n      Deinitializes the NFC chip.\n      -\n    \n    \n      net_nfc_oem_controller_register_listener register_listener;\n      Registers a callback function for a tag event, SE event, and llcp event.\n      target_detection_listener_cb target_detection_listener: Tag event callback functionse_transaction_listener_cb se_transaction_listener: SE event callback functionllcp_event_listener_cb llcp_event_listener: llcp event callback functionnet_nfc_error_e: Returns an error code on failure\n    \n    \n      net_nfc_oem_controller_unregister_listener unregister_listener;\n      Releases a callback function for a tag event, SE event, and llcp event.\n      -\n    \n    \n      net_nfc_oem_controller_check_firmware_version check_firmware_version;\n      Checks the firmware version of the NFC chip.\n      net_nfc_error_e: Returns an error code on failure\n    \n    \n      net_nfc_oem_controller_update_firmware update_firmware;\n      Updates the NFC chip firmware.\n      net_nfc_error_e: Returns an error code on failure\n    \n    \n      net_nfc_oem_controller_get_stack_information get_stack_information;\n      Gets the list of supported tags and the current firmware version.\n      net_nfc_stack_information_s: Pointer value to get the information of support tags and the current firmware versionnet_nfc_error_e: Returns an error code on failure\n    \n    \n      net_nfc_oem_controller_configure_discovery configure_discovery;\n      Delivers the config information on discovery.\n      net_nfc_discovery_mode_e: Start/stop modenet_nfc_event_filter_e config: Information for tag filteringnet_nfc_error_e: Returns an error code on failure\n    \n    \n      net_nfc_oem_controller_get_secure_element_list get_secure_element_list;\n      Gets the information of the current secure element.\n      net_nfc_secure_element_info_s: Pointer value to get secure element informationint: Pointer value to get the count of the secure elementnet_nfc_error_e: Returns an error code on failure\n    \n    \n      net_nfc_oem_controller_set_secure_element_mode set_secure_element_mode;\n      Sets the secure element to use.\n      net_nfc_secure_element_type_e: Secure element informationnet_nfc_secure_element_mode_e: Mode information to setnet_nfc_error_e: Returns an error code on failure\n    \n    \n      net_nfc_oem_controller_connect connect;\n      Connects to the detected tag/target.\n      net_nfc_target_handle_s: Tag/target handle for connectingnet_nfc_error_e: Returns an error code on failure\n    \n    \n      net_nfc_oem_controller_connect disconnect;\n      Disconnects the connected tag/target.\n      net_nfc_target_handle_s: Tag/target handle for disconnectingnet_nfc_error_e: Returns an error code on failure\n    \n    \n      net_nfc_oem_controller_check_ndef check_ndef;\n      Checks the tag for ndef support.\n      net_nfc_target_handle_s: Tag handle to check ndefint: Max size supported in the tagint: Real data size saved in the tagnet_nfc_error_e: Returns an error code on failure\n    \n    \n      net_nfc_oem_controller_check_target_presence check_presence;\n      Checks whether a tag exists in the RF range.\n      net_nfc_target_handle_s: Tag handle to check presencenet_nfc_error_e: Returns an error code on failure\n    \n    \n      net_nfc_oem_controller_read_ndef read_ndef;\n      Reads ndef data in a tag.\n      net_nfc_target_handle_s: Tag handle to readdata_s: Pointer value to save the ndef datanet_nfc_error_e: Returns an error code on failure\n    \n    \n      net_nfc_oem_controller_write_ndef write_ndef;\n      Writes the data to the tag.\n      net_nfc_target_handle_s: Handle to writedata_s: Data to writenet_nfc_error_e: Returns an error code on failure\n    \n    \n      net_nfc_oem_controller_make_read_only_ndef make_read_only_ndef;\n      Makes the tag to a read-only tag.\n      net_nfc_target_handle_s: Target tag handlenet_nfc_error_e: Returns an error code on failure\n    \n    \n      net_nfc_oem_controller_transceive transceive;\n      Sends and receives the low command to the tag or target.\n      net_nfc_target_handle_s: Tag or target handle to transceivenet_nfc_transceive_info_s: Pointer value including command or data to send and data to receivedata_s: Pointer value to send the information of contextnet_nfc_error_e: Returns an error code on failure\n    \n    \n      net_nfc_oem_controller_format_ndef format_ndef;\n      Formats the tag.\n      net_nfc_target_handle_s: Tag handle to formatdata_s: Key value to send the tag for formattingnet_nfc_error_e: Returns an error code on failure\n    \n    \n      net_nfc_oem_controller_exception_handler exception_handler;\n      When the nfc-manager faces an unwanted exception, it tries to deinitialize and initialize the stack before unregistering and registering the callback function.\n      -\n    \n    \n      net_nfc_oem_controller_is_ready is_ready;\n      Checks the status of the NFC stack.\n      net_nfc_error_e: Returns an error code on failure\n    \n    \n      net_nfc_oem_controller_llcp_config config_llcp;\n      Sets the llcp configuration (miu, lto, wks, option).\n      net_nfc_target_handle_s: Target handle to set llcpnet_nfc_error_e: Returns an error code on failure\n    \n    \n      net_nfc_oem_controller_llcp_check_llcp check_llcp_status;\n      Checks the llcp configuration (miu, lto, wks, option).\n      net_nfc_target_handle_s: Target handle to check llcpnet_nfc_error_e: Returns an error code on failure\n    \n    \n      net_nfc_oem_controller_llcp_activate_llcp activate_llcp;\n      Activates the llcp functionality.\n      net_nfc_target_handle_s: Target handle to activatenet_nfc_error_e: Returns an error code on failure\n    \n    \n      net_nfc_oem_controller_llcp_create_socket create_llcp_socket;\n      Creates the llcp socket.\n      net_nfc_llcp_socket_t: Pointer value to receive the socket informationnet_nfc_socket_type_e socketType: Type of socket to createuint16_t miu: miu valueuint8_t rw: rw valuenet_nfc_error_e: Returns an error code on failurevoid: value to control the context (can be set to NULL)\n    \n    \n      net_nfc_oem_controller_llcp_bind bind_llcp_socket;\n      Binds the socket.\n      net_nfc_llcp_socket_t socket: Information about the socket to binduint8_t service_access_point: Information of access point to bindnet_nfc_error_e: Returns an error code on failure\n    \n    \n      net_nfc_oem_controller_llcp_listen listen_llcp_socket;\n      Sets the socket to listen.\n      net_nfc_target_handle_s: Target handleuint8_t: Service name to listennet_nfc_llcp_socket_t socket: Socket informationnet_nfc_error_e: Returns an error code on failurevoid: Value to control the context (can be set to NULL)\n    \n    \n      net_nfc_oem_controller_llcp_accept accept_llcp_socket;\n      Accepts the connect request in listening status.\n      net_nfc_llcp_socket_t socket: Socket information to acceptnet_nfc_error_e: Returns an error code on failure\n    \n    \n      net_nfc_oem_controller_llcp_connect_by_url connect_llcp_by_url;\n      Connects the server with the service name.\n      net_nfc_target_handle_s: Handle of the target to connectnet_nfc_llcp_socket_t socket: Socket informationuint8_t: Service name to connectnet_nfc_error_e: Returns an error code on failurevoid: Value to control the context (can be set to NULL)\n    \n    \n      net_nfc_oem_controller_llcp_connect connect_llcp;\n      Connects to the server with access point (port number).\n      net_nfc_target_handle_s: Target handlenet_nfc_llcp_socket_t socket: Socket informationuint8_t service_access_point: Access point numbernet_nfc_error_e: Returns an error code on failurevoid: Value to control the context (can be set to NULL)\n    \n    \n      net_nfc_oem_controller_llcp_disconnect disconnect_llcp;\n      Disconnects the llcp link.\n      net_nfc_target_handle_s: Socket information to disconnectnet_nfc_llcp_socket_t socket: Information of the socket to disconnectnet_nfc_error_e: Returns an error code on failurevoid: Value to control the context (can be set to NULL)\n    \n    \n      net_nfc_oem_controller_llcp_socket_close close_llcp_socket;\n      Closes the llcp socket.\n      net_nfc_llcp_socket_t socket: Socket information to closenet_nfc_error_e: Returns an error code on failure\n    \n    \n      net_nfc_oem_controller_llcp_recv recv_llcp;\n      Receives the data using the llcp link.\n      net_nfc_target_handle_s: Target handle to receivenet_nfc_llcp_socket_t socket: Socket information to receivedata_s: Pointer value to receive the datanet_nfc_error_e: Returns an error code on failurevoid: Value to control the context (can be set to NULL)\n    \n    \n      net_nfc_oem_controller_llcp_send send_llcp;\n      Sends the data using llcp link.\n      net_nfc_target_handle_s: Target handle to sendnet_nfc_llcp_socket_t socket: Socket information to senddata_s: Data to sendnet_nfc_error_e: Returns an error code on failurevoid: Value to control the context (can be set to NULL)\n    \n    \n      net_nfc_oem_controller_llcp_recv_from recv_from_llcp;\n      Rejects the connect request from the client socket.\n      net_nfc_target_handle_s: Target handle to rejectnet_nfc_llcp_socket_t socket: Socket information to rejectnet_nfc_error_e: Returns an error code on failure\n    \n    \n      net_nfc_oem_controller_llcp_send_to send_to_llcp;\n      Sends the data using the service access point.\n      net_nfc_target_handle_s: Peer target handlenet_nfc_llcp_socket_t socket: Socket informationdata_s: Data to senduint8_t service_access_point: Service access point to sendnet_nfc_error_e: Returns an error code on failurevoid: Value to control the context (can be set to NULL)\n    \n    \n      net_nfc_oem_controller_llcp_reject reject_llcp;\n      Rejects the connect request from the client socket.\n      net_nfc_target_handle_s: Target handle to rejectnet_nfc_llcp_socket_t socket: Socket information to rejectnet_nfc_error_e: Returns an error code on failure\n    \n    \n      net_nfc_oem_controller_llcp_get_remote_config get_remote_config;\n      Gets the llcp socket config information of the peer device.\n      net_nfc_target_handle_s: Peer target handlenet_nfc_llcp_config_info_s: Pointer value to get config information of peer device’s llcp socketnet_nfc_error_e: Returns an error code on failure\n    \n    \n      net_nfc_oem_controller_llcp_get_remote_socket_info get_remote_socket_info;\n      Gets the llcp socket information of the peer device.\n      net_nfc_target_handle_s: Peer target handlenet_nfc_llcp_socket_t socket: llcp socket informationnet_nfc_llcp_socket_option_s: Pointer value to save the information of remote socketnet_nfc_error_e: Returns an error code on failure\n    \n    \n      net_nfc_oem_controller_sim_test sim_test;\n      Tests the SWP link with SIM and NFC chipset.\n      net_nfc_error_e: Returns an error code on failure\n    \n    \n      net_nfc_oem_controller_test_mode_on test_mode_on;\n      Changes the NFC chip to test mode. (Test mode exists only in the NXP case. If there are none, it does not need to implemented.)\n      net_nfc_error_e: Returns an error code on failure\n    \n    \n      net_nfc_oem_controller_test_mode_off test_mode_off;\n      Changes the status of the NFC chip from test mode to normal mode. (Test mode exists only in the NXP case. If there are none, it does not need to implemented.)\n      net_nfc_error_e: Returns an error code on failure\n    \n    \n      net_nfc_oem_controller_support_nfc support_nfc\n      Checks each device file of each chip.\n      -\n    \n  \n\n\nConfiguration\n\nThe nfc-plugin package must be saved to the /usr/lib/libnfc-plugin.so directory when installed. When the nfc-manager starts, it looks for the plugin library and loads it dynamically from this path.\n\nReferences\n\nEnable the following configuration options in the kernel .config file:\n\nUsing Pn544: CONFIG_PN544_NFC\nUsing Pn65n: CONFIG_PN65N_NFC\n\n\nAPI references are available in the Tizen 3.0 Porting Guide appendix.\n\nFor more information, see http://nfc-forum.org/.\n\nMTP\nThe Media Transfer Protocol (MTP) is used for exchanging media files between 2 devices:\n\n\n  MTP exchanges can only occur between 2 devices at a time.\n  In each communication, 1 devices acts as the initiator and the other as the responder.\n  \n    The initiator is the device that initiates actions with the responder by sending operations to the responder.\n\n    Figure: MTP Initiator\n\n    \n  \n  \n    The responder cannot initiate any actions, and can only send responses to operations sent by the initiator or send events.\n\n    Figure: MTP Responder\n\n    \n  \n  In the Tizen system, the USB host is the initiator, and the USB device is the responder.\n\n\nPorting the OAL Interface\n\nThe Tizen MTP initiator and responder do not have an OAL Interface. There are extension possibilities for the MTP Transport layer.\n\nConfiguration\n\nThe following configuration is needed:\n\n\n  MTP initiator\n    \n      The MTP Initiator consists of 3 packages:\n        mtp-initiator daemon\nmtp-initiator api\nlibmtp opensource\n        \n      \n      The MTP initiator does not operate independently. It requires the help of another module, such as USB.\n      When the USB device is connected to the host, the module must run the MTP initiator daemon.\n    \n  \n  MTP responder\n    \n      The MTP responder consists of 1 package:\n        mtp-responder daemon\n        \n      \n      The MTP responder does not operate independently. It requires the help of another module, such as USB.\n      When the USB device is connected to the host, the module must run the MTP responder daemon.\n    \n  \n\n\nReferences\n\n\n  Media Transfer Protocol v.1.1 Spec: http://www.usb.org/developers/docs/devclass_docs/"
					}
					
				
			
		
			
				
					,
					
					"application-developing-contributing": {
						"id": "application-developing-contributing",
						"title": "Contributing Code to Tizen",
						"categories": "",
						"url": " application/developing/contributing/",
						"content": "Contributing Code to Tizen\n\nThis topic describes how you can contribute code to Tizen.\n\nFor more information about the whole work process, see Tizen Development Workflow.\n\nCloning Source Files over SSH\n\nTo clone source files for a specific project, see Cloning Tizen Source Files.\n\nSubmitting a Patch to Gerrit\n\nYou can perform patch submission and review on Gerrit.\n\nTo submit a patch to Gerrit:\n\n\n  \n    Switch to the project directory and perform local development.\n  \n  Stage the revised content:\n    $ git add &lt;Revised_File&gt;...\n    \n  \n  Commit the revised content:\n    $ git commit\n    \n  \n  \n    Push the patch to Gerrit:\n\n    $ git push origin HEAD:refs/for/&lt;remote_branch_name&gt;\n    \n    \n      Note\n\n      Valid values for &lt;remote_branch_name&gt; are:\n      \n        tizen: corresponds to the branch of the latest Tizen version\n        tizen_3.0: corresponds to the Tizen 3.0 branch\n      \n    \n  \n\n\nFor more information, see Gerrit Documentation.\n\nReviewing a Patch on Gerrit\n\nTo review a patch in the Gerrit Web UI, publish the comments and vote for the patch.\n\nThe patch is merged or discarded depending on the voting results.The merge is performed if:\n\n\n  The patch has at least one “+2” score and no “-2” score in the Code Review category.\n  The patch has at least one “+1” score and no “-1” score in the Verified category.\n\n\n\n  Note\n\n  Voting “+2” requires a proper privilege level.\n\n\nWhen a patch meets the above criteria, privileged users can submit to merge the patch to the Git repository.\n\nSubmitting Packages to the Build System\n\nYou can submit a single package or a group of packages.\n\nSubmitting a Single Package\n\nTo submit a package to the build system, execute the following command:\n\n$ gbs submit [-c &lt;Commit_ID&gt;] -m \"&lt;Comments&gt;\"\n\n\nDuring the submission, GBS automatically creates an annotated tag in the following format:\n\nsubmit/$Tizen_Version/$(%Y%m%d.%H%M%S)\n\n\nIf the code change has already been merged in Gerrit, a merge request is created and release engineers are notified to review.\n\n\n  Note\n\n  If the patch has not been merged in Gerrit, the backend services abort the operation and send an email to the patch owner, to notify that the patch needs to be re-submitted after it is merged.\n\n\nSubmitting a Group of Packages\n\nIf multiple changed packages have mutual dependencies, they must be submitted as a group. This means that all of the packages must be submitted with 1 unified identification, through a process known as group submission.\n\nThis feature is supported by the collaboration of the Tizen client development tool (GBS) and Tizen backend services.\n\nFor the platform developers, GBS provides the --tag &lt;TAG&gt; option, to accept a developer-specified “TAG” for the gbs submit command. All submissions for multiple packages with the same TAG are considered as a group, and packages in the same group are handled in the build system together.\n\nFor example, assume that “ail”, a low level library, depends on “aul”. “ail” developers have changed some APIs, and “aul” must be updated to adapt to the new API changes in “ail”. Therefore, once all related patches have been merged to “ail” and “aul” separately, these 2 packages must be submitted as a group:\n\n\n  \n    Submit 1 of the packages in the group to create a tag:\n\n    $ cd platform/core/appfw/aul-1/\n$ gbs submit -m \"&lt;Comments&gt;\"\n    \n  \n  \n    Obtain the tag name from the output of the above command, and use the same tag as a --tag parameter for other packages in the group:\n\n    $ cd platform/core/appfw/ail/\n$ gbs submit --tag &lt;same_tag&gt; -m \"&lt;Comments&gt;\"\n    \n  \n\n\nYou can also specify the tag yourself, and use the same tag for all packages in the package group. In this case, the tag must follow the usual tag format with an optional suffix:\n\nsubmit/$Tizen_Version/$(%Y%m%d.%H%M%S).N (N is a number you can choose freely)\n\n\nTizen backend services take care of all submissions with the same tag, and build them together.\n\nReviewing a Package on the Build Server\n\nIf you are a release engineer, you can review and accept changes on the build system side.\n\nAfter a developer runs the gbs submit command, the Tizen backend service starts the pre-release and normal release processes at the same time. During the pre-release process, packages and Tizen images with a specific package inside are presented to release engineers and Quality Assurance (QA) engineers for review.\n\nQA engineers are responsible for testing packages as isolated objects, as well as verifying Tizen images with a specific package inside to offer release engineers comprehensive information to make appropriate decision about whether to accept or reject a package, including the following:\n\n\n  Whether the package impacts other dependent package builds.\n  Whether the package brings in new bugs.\n  Whether the package causes regression issues.\n  Whether the package influences the performance of the Tizen image.\n\n\nAfter the packages are accepted by release engineers, the corresponding images are automatically created by the normal release process and can be obtained on http://download.tizen.org/releases/daily."
					}
					
				
			
		
			
				
					,
					
					"platform-developing-contributing": {
						"id": "platform-developing-contributing",
						"title": "Contributing Code to Tizen",
						"categories": "",
						"url": " platform/developing/contributing/",
						"content": "Contributing Code to Tizen\n\nThis topic describes how you can contribute code to Tizen.\n\nFor more information about the whole work process, see Tizen Development Workflow.\n\nCloning Source Files over SSH\n\nTo clone source files for a specific project, see Cloning Tizen Source Files.\n\nSubmitting a Patch to Gerrit\n\nYou can perform patch submission and review on Gerrit.\n\nTo submit a patch to Gerrit:\n\n\n  \n    Switch to the project directory and perform local development.\n  \n  Stage the revised content:\n    $ git add &lt;Revised_File&gt;...\n    \n  \n  Commit the revised content:\n    $ git commit\n    \n  \n  \n    Push the patch to Gerrit:\n\n    $ git push origin HEAD:refs/for/&lt;remote_branch_name&gt;\n    \n    \n      Note\n\n      Valid values for &lt;remote_branch_name&gt; are:\n      \n        tizen: corresponds to the branch of the latest Tizen version\n        tizen_3.0: corresponds to the Tizen 3.0 branch\n      \n    \n  \n\n\nFor more information, see Gerrit Documentation.\n\nReviewing a Patch on Gerrit\n\nTo review a patch in the Gerrit Web UI, publish the comments and vote for the patch.\n\nThe patch is merged or discarded depending on the voting results.The merge is performed if:\n\n\n  The patch has at least one “+2” score and no “-2” score in the Code Review category.\n  The patch has at least one “+1” score and no “-1” score in the Verified category.\n\n\n\n  Note\n\n  Voting “+2” requires a proper privilege level.\n\n\nWhen a patch meets the above criteria, privileged users can submit to merge the patch to the Git repository.\n\nSubmitting Packages to the Build System\n\nYou can submit a single package or a group of packages.\n\nSubmitting a Single Package\n\nTo submit a package to the build system, execute the following command:\n\n$ gbs submit [-c &lt;Commit_ID&gt;] -m \"&lt;Comments&gt;\"\n\n\nDuring the submission, GBS automatically creates an annotated tag in the following format:\n\nsubmit/$Tizen_Version/$(%Y%m%d.%H%M%S)\n\n\nIf the code change has already been merged in Gerrit, a merge request is created and release engineers are notified to review.\n\n\n  Note\n\n  If the patch has not been merged in Gerrit, the backend services abort the operation and send an email to the patch owner, to notify that the patch needs to be re-submitted after it is merged.\n\n\nSubmitting a Group of Packages\n\nIf multiple changed packages have mutual dependencies, they must be submitted as a group. This means that all of the packages must be submitted with 1 unified identification, through a process known as group submission.\n\nThis feature is supported by the collaboration of the Tizen client development tool (GBS) and Tizen backend services.\n\nFor the platform developers, GBS provides the --tag &lt;TAG&gt; option, to accept a developer-specified “TAG” for the gbs submit command. All submissions for multiple packages with the same TAG are considered as a group, and packages in the same group are handled in the build system together.\n\nFor example, assume that “ail”, a low level library, depends on “aul”. “ail” developers have changed some APIs, and “aul” must be updated to adapt to the new API changes in “ail”. Therefore, once all related patches have been merged to “ail” and “aul” separately, these 2 packages must be submitted as a group:\n\n\n  \n    Submit 1 of the packages in the group to create a tag:\n\n    $ cd platform/core/appfw/aul-1/\n$ gbs submit -m \"&lt;Comments&gt;\"\n    \n  \n  \n    Obtain the tag name from the output of the above command, and use the same tag as a --tag parameter for other packages in the group:\n\n    $ cd platform/core/appfw/ail/\n$ gbs submit --tag &lt;same_tag&gt; -m \"&lt;Comments&gt;\"\n    \n  \n\n\nYou can also specify the tag yourself, and use the same tag for all packages in the package group. In this case, the tag must follow the usual tag format with an optional suffix:\n\nsubmit/$Tizen_Version/$(%Y%m%d.%H%M%S).N (N is a number you can choose freely)\n\n\nTizen backend services take care of all submissions with the same tag, and build them together.\n\nReviewing a Package on the Build Server\n\nIf you are a release engineer, you can review and accept changes on the build system side.\n\nAfter a developer runs the gbs submit command, the Tizen backend service starts the pre-release and normal release processes at the same time. During the pre-release process, packages and Tizen images with a specific package inside are presented to release engineers and Quality Assurance (QA) engineers for review.\n\nQA engineers are responsible for testing packages as isolated objects, as well as verifying Tizen images with a specific package inside to offer release engineers comprehensive information to make appropriate decision about whether to accept or reject a package, including the following:\n\n\n  Whether the package impacts other dependent package builds.\n  Whether the package brings in new bugs.\n  Whether the package causes regression issues.\n  Whether the package influences the performance of the Tizen image.\n\n\nAfter the packages are accepted by release engineers, the corresponding images are automatically created by the normal release process and can be obtained on http://download.tizen.org/releases/daily."
					}
					
				
			
		
			
				
					,
					
					"iot-developing-contributing": {
						"id": "iot-developing-contributing",
						"title": "Contributing Code to Tizen",
						"categories": "",
						"url": " iot/developing/contributing/",
						"content": "Contributing Code to Tizen\n\nThis topic describes how you can contribute code to Tizen.\n\nFor more information about the whole work process, see Tizen Development Workflow.\n\nCloning Source Files over SSH\n\nTo clone source files for a specific project, see Cloning Tizen Source Files.\n\nSubmitting a Patch to Gerrit\n\nYou can perform patch submission and review on Gerrit.\n\nTo submit a patch to Gerrit:\n\n\n  \n    Switch to the project directory and perform local development.\n  \n  Stage the revised content:\n    $ git add &lt;Revised_File&gt;...\n    \n  \n  Commit the revised content:\n    $ git commit\n    \n  \n  \n    Push the patch to Gerrit:\n\n    $ git push origin HEAD:refs/for/&lt;remote_branch_name&gt;\n    \n    \n      Note\n\n      Valid values for &lt;remote_branch_name&gt; are:\n      \n        tizen: corresponds to the branch of the latest Tizen version\n        tizen_3.0: corresponds to the Tizen 3.0 branch\n      \n    \n  \n\n\nFor more information, see Gerrit Documentation.\n\nReviewing a Patch on Gerrit\n\nTo review a patch in the Gerrit Web UI, publish the comments and vote for the patch.\n\nThe patch is merged or discarded depending on the voting results.The merge is performed if:\n\n\n  The patch has at least one “+2” score and no “-2” score in the Code Review category.\n  The patch has at least one “+1” score and no “-1” score in the Verified category.\n\n\n\n  Note\n\n  Voting “+2” requires a proper privilege level.\n\n\nWhen a patch meets the above criteria, privileged users can submit to merge the patch to the Git repository.\n\nSubmitting Packages to the Build System\n\nYou can submit a single package or a group of packages.\n\nSubmitting a Single Package\n\nTo submit a package to the build system, execute the following command:\n\n$ gbs submit [-c &lt;Commit_ID&gt;] -m \"&lt;Comments&gt;\"\n\n\nDuring the submission, GBS automatically creates an annotated tag in the following format:\n\nsubmit/$Tizen_Version/$(%Y%m%d.%H%M%S)\n\n\nIf the code change has already been merged in Gerrit, a merge request is created and release engineers are notified to review.\n\n\n  Note\n\n  If the patch has not been merged in Gerrit, the backend services abort the operation and send an email to the patch owner, to notify that the patch needs to be re-submitted after it is merged.\n\n\nSubmitting a Group of Packages\n\nIf multiple changed packages have mutual dependencies, they must be submitted as a group. This means that all of the packages must be submitted with 1 unified identification, through a process known as group submission.\n\nThis feature is supported by the collaboration of the Tizen client development tool (GBS) and Tizen backend services.\n\nFor the platform developers, GBS provides the --tag &lt;TAG&gt; option, to accept a developer-specified “TAG” for the gbs submit command. All submissions for multiple packages with the same TAG are considered as a group, and packages in the same group are handled in the build system together.\n\nFor example, assume that “ail”, a low level library, depends on “aul”. “ail” developers have changed some APIs, and “aul” must be updated to adapt to the new API changes in “ail”. Therefore, once all related patches have been merged to “ail” and “aul” separately, these 2 packages must be submitted as a group:\n\n\n  \n    Submit 1 of the packages in the group to create a tag:\n\n    $ cd platform/core/appfw/aul-1/\n$ gbs submit -m \"&lt;Comments&gt;\"\n    \n  \n  \n    Obtain the tag name from the output of the above command, and use the same tag as a --tag parameter for other packages in the group:\n\n    $ cd platform/core/appfw/ail/\n$ gbs submit --tag &lt;same_tag&gt; -m \"&lt;Comments&gt;\"\n    \n  \n\n\nYou can also specify the tag yourself, and use the same tag for all packages in the package group. In this case, the tag must follow the usual tag format with an optional suffix:\n\nsubmit/$Tizen_Version/$(%Y%m%d.%H%M%S).N (N is a number you can choose freely)\n\n\nTizen backend services take care of all submissions with the same tag, and build them together.\n\nReviewing a Package on the Build Server\n\nIf you are a release engineer, you can review and accept changes on the build system side.\n\nAfter a developer runs the gbs submit command, the Tizen backend service starts the pre-release and normal release processes at the same time. During the pre-release process, packages and Tizen images with a specific package inside are presented to release engineers and Quality Assurance (QA) engineers for review.\n\nQA engineers are responsible for testing packages as isolated objects, as well as verifying Tizen images with a specific package inside to offer release engineers comprehensive information to make appropriate decision about whether to accept or reject a package, including the following:\n\n\n  Whether the package impacts other dependent package builds.\n  Whether the package brings in new bugs.\n  Whether the package causes regression issues.\n  Whether the package influences the performance of the Tizen image.\n\n\nAfter the packages are accepted by release engineers, the corresponding images are automatically created by the normal release process and can be obtained on http://download.tizen.org/releases/daily."
					}
					
				
			
		
			
				
					,
					
					"application-about-conventions": {
						"id": "application-about-conventions",
						"title": "Typographic Conventions",
						"categories": "",
						"url": " application/about/conventions/",
						"content": "Typographic Conventions\n\nThis documentation set uses the following typographic conventions:\n\n\n  \n    [Optional_Argument]\n\n    The square brackets, [], indicate an optional argument.\n  \n  \n    &lt;Variable&gt;\n\n    The angle brackets, &lt;&gt;, indicate a variable. Replace &lt;Variable&gt; with an actual value.\n  \n  \n    \n      \n        \n          x\n          y\n          z\n        \n      \n    \n\n    The vertical bar, |, indicates that only 1 of the options can be selected.\n  \n  \n    \\\n\n    The backslash, \\, indicates that the new line followed is a continuance of a long statement. For example, the following 2 command line statements are equivalent:\n\n    \n      With backslash:\n        $ tar -zxvf \\\nrepo.tar.gz\n        \n      \n      Without backslash:\n        $ tar -zxvf repo.tar.gz"
					}
					
				
			
		
			
				
					,
					
					"platform-about-conventions": {
						"id": "platform-about-conventions",
						"title": "Typographic Conventions",
						"categories": "",
						"url": " platform/about/conventions/",
						"content": "Typographic Conventions\n\nThis documentation set uses the following typographic conventions:\n\n\n  \n    [Optional_Argument]\n\n    The square brackets, [], indicate an optional argument.\n  \n  \n    &lt;Variable&gt;\n\n    The angle brackets, &lt;&gt;, indicate a variable. Replace &lt;Variable&gt; with an actual value.\n  \n  \n    \n      \n        \n          x\n          y\n          z\n        \n      \n    \n\n    The vertical bar, |, indicates that only 1 of the options can be selected.\n  \n  \n    \\\n\n    The backslash, \\, indicates that the new line followed is a continuance of a long statement. For example, the following 2 command line statements are equivalent:\n\n    \n      With backslash:\n        $ tar -zxvf \\\nrepo.tar.gz\n        \n      \n      Without backslash:\n        $ tar -zxvf repo.tar.gz"
					}
					
				
			
		
			
				
					,
					
					"iot-about-conventions": {
						"id": "iot-about-conventions",
						"title": "Typographic Conventions",
						"categories": "",
						"url": " iot/about/conventions/",
						"content": "Typographic Conventions\n\nThis documentation set uses the following typographic conventions:\n\n\n  \n    [Optional_Argument]\n\n    The square brackets, [], indicate an optional argument.\n  \n  \n    &lt;Variable&gt;\n\n    The angle brackets, &lt;&gt;, indicate a variable. Replace &lt;Variable&gt; with an actual value.\n  \n  \n    \n      \n        \n          x\n          y\n          z\n        \n      \n    \n\n    The vertical bar, |, indicates that only 1 of the options can be selected.\n  \n  \n    \\\n\n    The backslash, \\, indicates that the new line followed is a continuance of a long statement. For example, the following 2 command line statements are equivalent:\n\n    \n      With backslash:\n        $ tar -zxvf \\\nrepo.tar.gz\n        \n      \n      Without backslash:\n        $ tar -zxvf repo.tar.gz"
					}
					
				
			
		
			
				
					,
					
					"application-developing-creating": {
						"id": "application-developing-creating",
						"title": "Creating Tizen Images with MIC",
						"categories": "",
						"url": " application/developing/creating/",
						"content": "Creating Tizen Images with MIC\n\nThis topic provides information on how to create a Tizen image.\n\nBefore creating an image, study the following instructions:\n\n\n  Setting up the Development Environment\n  Installing Development Tools\n  Cloning Tizen Source Files\n  Building Packages Locally with GBS\n\n\nPreparing the Kickstart File\n\nImage creation requires a kickstart file that describes how to create an image. To prepare the kickstart file:\n\n\n  \n    Download the original kickstart file:\n\n    $ wget &lt;Snapshot_date_URL&gt;/builddata/images/&lt;Repository&gt;/image-configurations/&lt;kickstart_file&gt;\n    \n\n    \n      \n        For example:\n\n        \n          \n            Tizen: 4.0: Unified / standard / mobile-wayland-armv7l-tm1.ks\n\n            $ wget http://download.tizen.org/releases/daily/tizen/unified/tizen-unified_20170627.1/builddata/images/standard/image-configurations/mobile-wayland-armv7l-tm1.ks\n            \n          \n          \n            Tizen: 4.0: Unified / emulator / tv-emulator32-wayland.ks\n\n            $ wget http://download.tizen.org/releases/daily/tizen/unified/tizen-unified_20170627.1/builddata/images/emulator/image-configurations/tv-emulator32-wayland.ks\n            \n          \n          \n            Tizen: 3.0: Wearable / target-circle / wearable-wayland-armv7l-circle.ks\n\n            $ wget http://download.tizen.org/releases/daily/tizen/3.0-wearable/tizen-3.0-wearable_20170627.1/builddata/images/target-circle/image-configurations/wearable-wayland-armv7l-circle.ks\n            \n          \n        \n      \n    \n  \n  \n    Modify the original kickstart file to include locally built RPMs into the Tizen image.\n\n    For example: Tizen: 4.0: Unified / standard / mobile-wayland-armv7l-tm1.ks\n\n    \n      \n        The repo section of the original kickstart file:\n\n        repo --name=unified-standard --baseurl=http://download.tizen.org/snapshots/tizen/unified/@BUILD_ID@/repos/standard/packages/ --ssl_verify=no\nrepo --name=base_arm --baseurl=http://download.tizen.org/snapshots/tizen/base/latest/repos/arm/packages/ --ssl_verify=no\n        \n      \n      \n        The repo section of the modified kickstart file:\n\n        repo --name=unified-standard --baseurl=http://download.tizen.org/snapshots/tizen/unified/@BUILD_ID@/repos/standard/packages/ --ssl_verify=no --priority=99\nrepo --name=base_arm --baseurl=http://download.tizen.org/snapshots/tizen/base/latest/repos/arm/packages/ --ssl_verify=no --priority=99\nrepo --name=local --baseurl=file:///home/&lt;User&gt;/GBS-ROOT/local/repos/tizen3.0-tm1/armv7l/ --priority=1\n        \n      \n    \n\n    \n      Note\n\n      \n        The baseurl property of the local repo specifies the file path where locally built RPMs are located.\n        Setting the priority of the local repository at 1 and the priorities of remote repositories at 99 guarantees that MIC uses the packages that exist in the local repository with a higher priority, when packages are available in both remote and local repositories.\n        To add new packages into a Tizen image, add the new packages’ names into the %package section, and add them into the local repository.\n      \n    \n  \n\n\nCreating a Tizen Image\n\nTo create a Tizen image:\n\n$ gbs createimage --ks-file=mobile-wayland-armv7l-tm1.ks\n\n\nIf you have more than 4 GB of RAM available, use the --tmpfs option to speed up the image creation:\n\n$ gbs createimage --ks-file=mobile-wayland-armv7l-tm1.ks --tmpfs\n\n\nThe following example shows the gbs createimage command output:\n\n...\nInfo: Running scripts ...\nkickstart post script start\nInfo: Checking filesystem /var/tmp/mic/build/imgcreate-Rii2MC/tmp-pVQesQ/platform.img\nInfo: Checking filesystem /var/tmp/mic/build/imgcreate-Rii2MC/tmp-pVQesQ/data.img\nInfo: Checking filesystem /var/tmp/mic/build/imgcreate-Rii2MC/tmp-pVQesQ/ums.img\nInfo: Pack all loop images together to TM1-new-201609030819.tar.gz\nInfo: The new image can be found here:\n/home/&lt;User&gt;/tizen/mic-output/TM1-201609030819.tar.gz\n/home/&lt;User&gt;/tizen/mic-output/TM1-201609030833.packages\n/home/&lt;User&gt;/tizen/mic-output/TM1-201609030819.xml\nInfo: Finished.\n\n\nTM1-201609030819.tar.gz is the image file and TM1-201609030833.packages contains package info integrated in the image, including package name, version, and VCS information.\n\nOnce the Tizen image is created, the final step is to flash the image to a target device for verification. For more information, see Flashing an Image to Device."
					}
					
				
			
		
			
				
					,
					
					"platform-developing-creating": {
						"id": "platform-developing-creating",
						"title": "Creating Tizen Images with MIC",
						"categories": "",
						"url": " platform/developing/creating/",
						"content": "Creating Tizen Images with MIC\n\nThis topic provides information on how to create a Tizen image.\n\nBefore creating an image, study the following instructions:\n\n\n  Setting up the Development Environment\n  Installing Development Tools\n  Cloning Tizen Source Files\n  Building Packages Locally with GBS\n\n\nPreparing the Kickstart File\n\nImage creation requires a kickstart file that describes how to create an image. To prepare the kickstart file:\n\n\n  \n    Download the original kickstart file:\n\n    $ wget &lt;Snapshot_date_URL&gt;/builddata/images/&lt;Repository&gt;/image-configurations/&lt;kickstart_file&gt;\n    \n\n    \n      \n        For example:\n\n        \n          \n            Tizen: 4.0: Unified / standard / mobile-wayland-armv7l-tm1.ks\n\n            $ wget http://download.tizen.org/releases/daily/tizen/unified/tizen-unified_20170627.1/builddata/images/standard/image-configurations/mobile-wayland-armv7l-tm1.ks\n            \n          \n          \n            Tizen: 4.0: Unified / emulator / tv-emulator32-wayland.ks\n\n            $ wget http://download.tizen.org/releases/daily/tizen/unified/tizen-unified_20170627.1/builddata/images/emulator/image-configurations/tv-emulator32-wayland.ks\n            \n          \n          \n            Tizen: 3.0: Wearable / target-circle / wearable-wayland-armv7l-circle.ks\n\n            $ wget http://download.tizen.org/releases/daily/tizen/3.0-wearable/tizen-3.0-wearable_20170627.1/builddata/images/target-circle/image-configurations/wearable-wayland-armv7l-circle.ks\n            \n          \n        \n      \n    \n  \n  \n    Modify the original kickstart file to include locally built RPMs into the Tizen image.\n\n    For example: Tizen: 4.0: Unified / standard / mobile-wayland-armv7l-tm1.ks\n\n    \n      \n        The repo section of the original kickstart file:\n\n        repo --name=unified-standard --baseurl=http://download.tizen.org/snapshots/tizen/unified/@BUILD_ID@/repos/standard/packages/ --ssl_verify=no\nrepo --name=base_arm --baseurl=http://download.tizen.org/snapshots/tizen/base/latest/repos/arm/packages/ --ssl_verify=no\n        \n      \n      \n        The repo section of the modified kickstart file:\n\n        repo --name=unified-standard --baseurl=http://download.tizen.org/snapshots/tizen/unified/@BUILD_ID@/repos/standard/packages/ --ssl_verify=no --priority=99\nrepo --name=base_arm --baseurl=http://download.tizen.org/snapshots/tizen/base/latest/repos/arm/packages/ --ssl_verify=no --priority=99\nrepo --name=local --baseurl=file:///home/&lt;User&gt;/GBS-ROOT/local/repos/tizen3.0-tm1/armv7l/ --priority=1\n        \n      \n    \n\n    \n      Note\n\n      \n        The baseurl property of the local repo specifies the file path where locally built RPMs are located.\n        Setting the priority of the local repository at 1 and the priorities of remote repositories at 99 guarantees that MIC uses the packages that exist in the local repository with a higher priority, when packages are available in both remote and local repositories.\n        To add new packages into a Tizen image, add the new packages’ names into the %package section, and add them into the local repository.\n      \n    \n  \n\n\nCreating a Tizen Image\n\nTo create a Tizen image:\n\n$ gbs createimage --ks-file=mobile-wayland-armv7l-tm1.ks\n\n\nIf you have more than 4 GB of RAM available, use the --tmpfs option to speed up the image creation:\n\n$ gbs createimage --ks-file=mobile-wayland-armv7l-tm1.ks --tmpfs\n\n\nThe following example shows the gbs createimage command output:\n\n...\nInfo: Running scripts ...\nkickstart post script start\nInfo: Checking filesystem /var/tmp/mic/build/imgcreate-Rii2MC/tmp-pVQesQ/platform.img\nInfo: Checking filesystem /var/tmp/mic/build/imgcreate-Rii2MC/tmp-pVQesQ/data.img\nInfo: Checking filesystem /var/tmp/mic/build/imgcreate-Rii2MC/tmp-pVQesQ/ums.img\nInfo: Pack all loop images together to TM1-new-201609030819.tar.gz\nInfo: The new image can be found here:\n/home/&lt;User&gt;/tizen/mic-output/TM1-201609030819.tar.gz\n/home/&lt;User&gt;/tizen/mic-output/TM1-201609030833.packages\n/home/&lt;User&gt;/tizen/mic-output/TM1-201609030819.xml\nInfo: Finished.\n\n\nTM1-201609030819.tar.gz is the image file and TM1-201609030833.packages contains package info integrated in the image, including package name, version, and VCS information.\n\nOnce the Tizen image is created, the final step is to flash the image to a target device for verification. For more information, see Flashing an Image to Device."
					}
					
				
			
		
			
				
					,
					
					"iot-developing-creating": {
						"id": "iot-developing-creating",
						"title": "Creating Tizen Images with MIC",
						"categories": "",
						"url": " iot/developing/creating/",
						"content": "Creating Tizen Images with MIC\n\nThis topic provides information on how to create a Tizen image.\n\nBefore creating an image, study the following instructions:\n\n\n  Setting up the Development Environment\n  Installing Development Tools\n  Cloning Tizen Source Files\n  Building Packages Locally with GBS\n\n\nPreparing the Kickstart File\n\nImage creation requires a kickstart file that describes how to create an image. To prepare the kickstart file:\n\n\n  \n    Download the original kickstart file:\n\n    $ wget &lt;Snapshot_date_URL&gt;/builddata/images/&lt;Repository&gt;/image-configurations/&lt;kickstart_file&gt;\n    \n\n    \n      \n        For example:\n\n        \n          \n            Tizen: 4.0: Unified / standard / mobile-wayland-armv7l-tm1.ks\n\n            $ wget http://download.tizen.org/releases/daily/tizen/unified/tizen-unified_20170627.1/builddata/images/standard/image-configurations/mobile-wayland-armv7l-tm1.ks\n            \n          \n          \n            Tizen: 4.0: Unified / emulator / tv-emulator32-wayland.ks\n\n            $ wget http://download.tizen.org/releases/daily/tizen/unified/tizen-unified_20170627.1/builddata/images/emulator/image-configurations/tv-emulator32-wayland.ks\n            \n          \n          \n            Tizen: 3.0: Wearable / target-circle / wearable-wayland-armv7l-circle.ks\n\n            $ wget http://download.tizen.org/releases/daily/tizen/3.0-wearable/tizen-3.0-wearable_20170627.1/builddata/images/target-circle/image-configurations/wearable-wayland-armv7l-circle.ks\n            \n          \n        \n      \n    \n  \n  \n    Modify the original kickstart file to include locally built RPMs into the Tizen image.\n\n    For example: Tizen: 4.0: Unified / standard / mobile-wayland-armv7l-tm1.ks\n\n    \n      \n        The repo section of the original kickstart file:\n\n        repo --name=unified-standard --baseurl=http://download.tizen.org/snapshots/tizen/unified/@BUILD_ID@/repos/standard/packages/ --ssl_verify=no\nrepo --name=base_arm --baseurl=http://download.tizen.org/snapshots/tizen/base/latest/repos/arm/packages/ --ssl_verify=no\n        \n      \n      \n        The repo section of the modified kickstart file:\n\n        repo --name=unified-standard --baseurl=http://download.tizen.org/snapshots/tizen/unified/@BUILD_ID@/repos/standard/packages/ --ssl_verify=no --priority=99\nrepo --name=base_arm --baseurl=http://download.tizen.org/snapshots/tizen/base/latest/repos/arm/packages/ --ssl_verify=no --priority=99\nrepo --name=local --baseurl=file:///home/&lt;User&gt;/GBS-ROOT/local/repos/tizen3.0-tm1/armv7l/ --priority=1\n        \n      \n    \n\n    \n      Note\n\n      \n        The baseurl property of the local repo specifies the file path where locally built RPMs are located.\n        Setting the priority of the local repository at 1 and the priorities of remote repositories at 99 guarantees that MIC uses the packages that exist in the local repository with a higher priority, when packages are available in both remote and local repositories.\n        To add new packages into a Tizen image, add the new packages’ names into the %package section, and add them into the local repository.\n      \n    \n  \n\n\nCreating a Tizen Image\n\nTo create a Tizen image:\n\n$ gbs createimage --ks-file=mobile-wayland-armv7l-tm1.ks\n\n\nIf you have more than 4 GB of RAM available, use the --tmpfs option to speed up the image creation:\n\n$ gbs createimage --ks-file=mobile-wayland-armv7l-tm1.ks --tmpfs\n\n\nThe following example shows the gbs createimage command output:\n\n...\nInfo: Running scripts ...\nkickstart post script start\nInfo: Checking filesystem /var/tmp/mic/build/imgcreate-Rii2MC/tmp-pVQesQ/platform.img\nInfo: Checking filesystem /var/tmp/mic/build/imgcreate-Rii2MC/tmp-pVQesQ/data.img\nInfo: Checking filesystem /var/tmp/mic/build/imgcreate-Rii2MC/tmp-pVQesQ/ums.img\nInfo: Pack all loop images together to TM1-new-201609030819.tar.gz\nInfo: The new image can be found here:\n/home/&lt;User&gt;/tizen/mic-output/TM1-201609030819.tar.gz\n/home/&lt;User&gt;/tizen/mic-output/TM1-201609030833.packages\n/home/&lt;User&gt;/tizen/mic-output/TM1-201609030819.xml\nInfo: Finished.\n\n\nTM1-201609030819.tar.gz is the image file and TM1-201609030833.packages contains package info integrated in the image, including package name, version, and VCS information.\n\nOnce the Tizen image is created, the final step is to flash the image to a target device for verification. For more information, see Flashing an Image to Device."
					}
					
				
			
		
			
				
					,
					
					"design-tv-design-principles": {
						"id": "design-tv-design-principles",
						"title": "Design Principles",
						"categories": "",
						"url": " design/tv/design-principles/",
						"content": "Design Principles\n\nThe Tizen 4.0 TV design principles provide a clear and comfortable\nvisual identity for your application. The harmonious and delightful\nelements help the user get information easily and enjoy content fully.\n\nThere are 3 design principles used in Tizen 4.0 TVs:\n\n\n  Simplicity\n  Natural intuitiveness\n  Breathing space\n\n\nSimplicity\n\nUsing many decorative elements on the screen at the same time can confuse and distract the user.\n\nSimplify your application design to allow the user to clearly identify the content.\n\nCircular Icons\n\nTizen 4.0 TV icons are circular, covering a smaller area than\nrectangular icons. Consequently, the user can see more of the screen\nbackground.\n\n\n\nCircular icons taking less space on the screen.\n\nHidden Inactive Icons\n\nAn inactive icon partly hides itself to take up even less space on the screen. This approach also allows the user to recognize active icons without visual interruption from inactive icons.\n\n\n\nInactive icons are hidden.\n\nNo Unnecessary Decorations\n\nWithin functional design elements, clean up unnecessary decorations, such as a divider bar. Instead, use more functionally-effective visual expressions or separate information. It makes the UI look cleaner and more organized.\n\n\n\nNo divider bar between different pieces of information.\n\nNatural Intuitiveness\n\nEnhance the usability and make the interface naturally familiar to the user by, for example, using shadow effects. This allows the user to access content and information easily with a pleasing natural visual balance.\n\nShadow Effect\n\nShadow effects can add subtle but clear emphasis to generated items. The effect is natural and consequently also harmonizes with the content. The user can focus better without any visual strain.\n\n\n\nShadow effect emphasizes the element.\n\nBreathing Space\n\nA screen that is full of design elements can be eye-catching, but it makes the user unable to focus on any specific item. Use screen space properly to guide the user’s attention.\n\nAllow Empty Space\n\nA right amount of empty space between different pieces of information makes the UI both easier to understand and more pleasing to look at. Do not think that precious screen space is wasted. Properly used empty space is a proven technique for better screen design.\n\n\n\nLeave breathing room between the elements.\n\nPrioritize and Balance\n\nPrioritize elements on the screen based on their importance, and balance the primary and secondary elements accordingly. When the information is correctly balanced, the most important content elements are displayed in the most visible manner.\n\n\n\nLess important back key information is dimmed."
					}
					
				
			
		
			
				
					,
					
					"design-mobile-design-principles": {
						"id": "design-mobile-design-principles",
						"title": "Design Principles",
						"categories": "",
						"url": " design/mobile/design-principles/",
						"content": "Design Principles\n\nTizen design principles explained in this section of the document are provided to suggest clear guidelines for developers, to design simple and easy-to-use apps for everyone.\n \nFocus on the Primary Goals\n\nEnsure that your app allows users to easily use its major features. You can simplify the screen layout of your app and emphasize important features so that users can easily find them\n\nIdentify the Primary Goals and Provide the Components in a Noticeable Way\n\nDisplay the most frequently used features on the first screen. Floating action buttons are a convenient option that allows users to access the main features quickly and easily. On the other hand, less frequently used features may be placed on the ‘More’ menu screen. Users can access the ‘More’ menu by pressing the Menu key.\n\nBy focusing on the primary features and presenting them in a consistent way, you can design an app that is easy to use.\n\n\n\nA floating action button\n\nProvide Essential Information First and Give Additional Information upon Request\n\nUsers are only interested in the information they need. Therefore, provide only essential information on the screen. You can provide more detailed information when a user requests it or takes action, but avoid trying to provide everything on one screen.\n\nWhen you design a screen layout, ensure that you include enough empty space between information. It increases the readability and allows users to be able to understand given information more easily.\n\nProvide One Simple Way for Users to Achieve their Goals\n\nProviding multiple ways to access a single feature may confuse users. Tizen aims to keep its design simple and practical because it targets a wide range of users, from beginners to advanced users. Hidden gestures or menus without any visual cues are not recommended when designing Tizen apps.\n\nAvoid using hidden gestures or additional quick actions that require tutorials in your design. Find the most effective and reasonable way to perform an action and allow users to access it via an action button. If you need to add subordinate actions in the design, provide them in ‘More’ menu.\n\n\n\nThe More menu\n\nCreate a Sense of Flow\n\nA good flow in the app design makes it easy for users to make decisions. Users may lose interest in your app if it is hard to navigate and difficult to understand.\n\nProvide Users with an Accessible Structure\n\nEnsure that the access flow of your app does not include any redundant steps. Eliminate unnecessary dialog boxes and confirmation windows that slow down user progress. Users want quick access to information, to complete their tasks in fewer steps.\n\nHelp users instantly perform simple actions. For example, quick access to the Internet browser is a good feature to have. By facilitating user access to major websites, you can minimize the effort required.\n\n\n\nQuick access feature for an Internet browser\n\nUse Animations and Visual Cues\n\nStacked layers create a visual hierarchy, and each layer comes with a clear direction of movement. When layers are assembled well, they create a flow that guides the users. For example, to inform users of new events that require user’s attention, active notifications always slide down from the top, over the current screen users are working on. Refer to Animations for more information.\n \n\n\nAn active notification.\n\nVisual cues are another way to guide users. Also, carefully placed pop-up notifications and toast pop-up messages will help users complete tasks more easily by providing them with essential information about the process.\n\nProvide Consistent Design\n\nA consistent design allows users to learn how to use new features faster. Consider what common actions are noticed by the average user and design your features to use the same actions. For example, the Back key is generally used for returning to previous pages or canceling current tasks. So, in your app, design the Back key to return to the previous page or cancel tasks, and avoid using it for something else.\n\n\n\nNavigating back from a message\n\nProvide Information at a Glance\n\nWhen you design screens for your app, ensure that the purpose of each screen is easily understood at a glance. Design the primary information to be clearly visible and easily accessible.\n\nPresent Information in Order of Importance\n\nEnsure that your app screen displays the most important content first. For example, in the detail view, show the essential information on the first screen and allow users to scroll down to see the additional information.\n\n \n\nDisplay important information first\n\nCreate Clear Distinctions between the Information on the Screen\n\nUse different font sizes, weights, colors, and layouts to separate the information on the screen and allow important information to stand out. For example, the Contacts menu includes tabs, a search field, a contact list, and a floating action button on the same page. However, different styles and colors applied to these elements enable users to clearly separate them.\n\n\n\nClear distinction between different types of information\n\nMake the Touchable Elements Look Touchable\n\nApply consistent designs for interactive elements on the screen, and disable or hide the elements that are not available. For example, you can disable the ‘Done’ button to let users know that a required field is empty.\n\n \n\nA disabled Done button shows that the required field is not filled."
					}
					
				
			
		
			
				
					,
					
					"tizenstudio-setup-faq": {
						"id": "tizenstudio-setup-faq",
						"title": "Frequently Asked Questions",
						"categories": "",
						"url": " tizenstudio/setup/faq/",
						"content": "Frequently Asked Questions\n\nThis page contains answers to most commonly asked questions or errors that you may encounter while installing Tizen studio and developing apps in Tizen Studio.\n\n\n  \n    How to run Tizen Studio on Ubuntu 18.04?\n\n    Tizen studio supports Ubuntu 18.04. However, Ubuntu 18.04 distribution does not include the runtime libraray libpng12-0. To experience optimal installation experience, install the runtime library and run the following command:\n     $ wget http://mirrors.kernel.org/ubuntu/pool/main/libp/libpng/libpng12-0_1.2.54-1ubuntu1_amd64.deb\n $ sudo dpkg -i libpng12-0_1.2.54-1ubuntu1_amd64.deb \n    \n\n    Generally, installing packages from older distributions may break apt installation system. Since its dependencies are also present in Ubuntu-18.04, it will not break apt installation system.\n  \n  \n    How to manage certificates and package applications in different Ubuntu setups?\n\n    In Linux operating systems, Tizen Certificate Manager in Tizen Studio stores the passwords of the certificates in the gnome-keyring application. Therefore, you must enable the gnome-keyring application to ensure that Tizen Studio functions flawlessly.\n\n    The remote login in a Linux desktop system does not have the DBUS_SESSION_BUS_ADDRESS variable set in the session. \n  To store and lookup passwords in the host’s Login keyring, you must set the DBUS_SESSION_BUS_ADDRESS variable.\n  For more information, see Manage certificates through remote login, headless Linux sytems, and Docker containers.\n  \n  \n    What to do when Tizen Studio fails to launch?\n\n    Tizen Studio fails to launch if you have incorrect JDK version installed on your system. Ensure that you have recommended version of JDK, OpenJDK installed.\n\n    Check your JDK version and download an appropriate version.\n\n    Verify you are using a supported version  JDK 8 or OpenJDK 10.\n\n    \n      On your terminal or console window,  type java -version.\nIf this command does not show which version is installed, see How can I find which version of Java is installed without running an applet in Windows or Mac.\n      Verify whether the available version is JDK 8 and OpenJDK 10.\n      Set or update your JAVA_HOME environment variable. For more information, see the installation pages.\n    \n\n    To download an earlier version of the JDK, see Oracle Java Archive.\n  \n  \n    How to do form validation using Tizen Web?\n\n    Form validation normally occurs at the server end after the client enters all necessary data. The user clicks Submit button to send the data to the server. \nIf the data entered by a client is incorrect or the data is missing, the server responds back and user needs to resubmit the form with corrrect information. \nThis process  server was an overhead on the server and time elaped was on higher side, For more information, see simple form validation in Tizen Web app.\n  \n  \n    How to implement vibration API in Tizen Web app?\n\n    To provide tactile feedback to the user or to interact with user even when the device volume is low, vibration provides a better user experience and improves the perception of application. When it comes to the Tizen app development, external third party library is not required to implement vibration feature, as you can use the internal Tizen API, for more information, see Vibration API.\n  \n  \n    How to troubleshoot compatibility with previous versions of Tizen Studio?\n\n    The Following are the various conditions that can cause compatibility issues:\n    \n      You are using an older workspace in the installed version of Tizen Studio.\n      The Tizen Web, Tizen Native and Tizen Native UI Builder perspectives are used.\n      The Tizen Native or Tizen Native Builder perspective was used previously.\n      After installing the latest Tizen Studio using the installer without installing other tools using package manager.\n    \n\n    For more information, see troubleshooting for compatibility."
					}
					
				
			
		
			
				
					,
					
					"application-developing-flashing": {
						"id": "application-developing-flashing",
						"title": "Flashing an Image to Device",
						"categories": "",
						"url": " application/developing/flashing/",
						"content": "Flashing an Image to Device\n\nThe instructions for flashing depend on the type of device you are using. Instructions are available for the following devices:\n\n  TM1 reference device\n\n\nTo flash the Tizen image to the TM1 reference device:\n\n\n  \n    Boot the device into download mode:\n\n    \n      \n        Make sure the device is powered off.\n      \n      \n        Press the Volume down, Home, and Power keys simultaneously.\n\n        The device boots up and the download mode image is displayed on the screen.\n      \n    \n  \n  \n    Connect the device to the Linux PC with a USB cable.\n  \n  \n    Flash the image.\n\n    To flash the image, execute the lthor command in a console on the Linux PC:\n    $ sudo ./lthor TM1-201609030819.tar.gz\n    \n  \n  \n    Wait until files are downloaded on to the device. The device is automatically rebooted after a successful download.\n  \n\n\n\n  Note\n\n  Tizen images of version 2.4 and higher do not contain the TM1-hardware-dependent binaries by default. To make TM1 function correctly, you must install the additional binaries manually. For more information, see Tizen Device Firmware."
					}
					
				
			
		
			
				
					,
					
					"platform-developing-flashing": {
						"id": "platform-developing-flashing",
						"title": "Flashing an Image to Device",
						"categories": "",
						"url": " platform/developing/flashing/",
						"content": "Flashing an Image to Device\n\nThe instructions for flashing depend on the type of device you are using. Instructions are available for the following devices:\n\n  TM1 reference device\n\n\nTo flash the Tizen image to the TM1 reference device:\n\n\n  \n    Boot the device into download mode:\n\n    \n      \n        Make sure the device is powered off.\n      \n      \n        Press the Volume down, Home, and Power keys simultaneously.\n\n        The device boots up and the download mode image is displayed on the screen.\n      \n    \n  \n  \n    Connect the device to the Linux PC with a USB cable.\n  \n  \n    Flash the image.\n\n    To flash the image, execute the lthor command in a console on the Linux PC:\n    $ sudo ./lthor TM1-201609030819.tar.gz\n    \n  \n  \n    Wait until files are downloaded on to the device. The device is automatically rebooted after a successful download.\n  \n\n\n\n  Note\n\n  Tizen images of version 2.4 and higher do not contain the TM1-hardware-dependent binaries by default. To make TM1 function correctly, you must install the additional binaries manually. For more information, see Tizen Device Firmware."
					}
					
				
			
		
			
				
					,
					
					"iot-developing-flashing": {
						"id": "iot-developing-flashing",
						"title": "Flashing an Image to Device",
						"categories": "",
						"url": " iot/developing/flashing/",
						"content": "Flashing an Image to Device\n\nThe instructions for flashing depend on the type of device you are using. Instructions are available for the following devices:\n\n  TM1 reference device\n\n\nTo flash the Tizen image to the TM1 reference device:\n\n\n  \n    Boot the device into download mode:\n\n    \n      \n        Make sure the device is powered off.\n      \n      \n        Press the Volume down, Home, and Power keys simultaneously.\n\n        The device boots up and the download mode image is displayed on the screen.\n      \n    \n  \n  \n    Connect the device to the Linux PC with a USB cable.\n  \n  \n    Flash the image.\n\n    To flash the image, execute the lthor command in a console on the Linux PC:\n    $ sudo ./lthor TM1-201609030819.tar.gz\n    \n  \n  \n    Wait until files are downloaded on to the device. The device is automatically rebooted after a successful download.\n  \n\n\n\n  Note\n\n  Tizen images of version 2.4 and higher do not contain the TM1-hardware-dependent binaries by default. To make TM1 function correctly, you must install the additional binaries manually. For more information, see Tizen Device Firmware."
					}
					
				
			
		
			
				
					,
					
					"application-reference-gbs-gbs-build": {
						"id": "application-reference-gbs-gbs-build",
						"title": "Customizing Images",
						"categories": "",
						"url": " application/reference/gbs/gbs-build/",
						"content": "gbs build\n\nUse the gbs build subcommand to build the source code and generate RPM packages locally.\n\nFor command usage details, enter:\n\n$ gbs build -help\n\n\nCommand Workflow\n\nThe gbs build command requires the following input:\n\n\n  Git projects that contain RPM packaging files\n  \n    Binary RPM repositories (remote or local)\n\n    The binary RPM repositories contain all the binary RPM packages used to create the chroot environment and build packages, which can be remote, like tizen release or snapshot repositories, or local. The local repository supports 2 types:\n\n    \n      Standard repository with existing repodata\n      Normal directory containing RPM packages. GBS finds all RPM packages within the directory.\n    \n\n    To configure a repository, see GBS Configuration.\n  \n  Project build configurations (such as macros and flags)\n\n\nThe following figure shows the basic GBS build workflow. The figure illustrates that input and output are both repositories, and the output repository is located at ~/GBS-ROOT/locals/repos/ by default. You can change the repository path by using the --buildroot option.\n\nFigure: GBS build workflow\n\n ____________________\n|                    |      ___________\n| Source Code (GIT)  |----&gt;|           |      _________________________\n|____________________|     |           |     |                         |\n ____________________      |           |     |  Local repository of    |\n|                    |     |           |     |                         |\n|    Build config    |----&gt;| GBS build |----&gt;|                         |\n|____________________|     |           |     |                         |\n ____________________      |           |     |  build RPM packages     |\n|                    |     |           |     |(~/GBS-ROOT/local/repos/)|\n|Binary repositories |     |           |     |_________________________|\n|in GBS conf         |----&gt;|___________|                  |\n|(Remote or Local)   |           ^                        |\n|____________________|           |________________________|\n\n\nLocal repos in the GBS build root (~/GBS-ROOT by default) affect build results, so make sure that repositories do not contain old or unnecessary RPM packages. While running the gbs build command, you can specify the --clean-repos option to clean up local GBS-created repositories before building. To avoid problems, also set a different GBS build root directory for each profile. The GBS build directory can be defined in many ways:\n\n\n  By default, the GBS build puts all output files under ~/GBS-ROOT/.\n  If the TIZEN_BUILD_ROOT environment variable exists, ${TIZEN_BUILD_ROOT} is used as the output top directory.\n  If the -B option is specified, the specified directory is used, even if ${TIZEN_BUILD_ROOT} exists.\n\n\n\n  Note\n\n  All RPM packages under the output repository (by default, ~/GBS-ROOT/local/repos/&lt;VERSION&gt;/) are used when building packages. Since all the packages under the output repository are applied to the build environment, avoid unexpected results by making sure that the output repository is clean.\n\n\nThe following example shows the structure of the GBS build root directory in the workflow output:\n\ngbs output top dir\n|-- local\n| |-- cache # repodata and RPMs from remote repositories\n| |-- repos # generated local repo top directory\n| | |-- tizen # distro one: tizen\n| | | |-- armv7l # store armv7l RPM packages\n| | | |-- i586 # store x86 RPM packages\n| | `-- tizen2.0 # build for distro two: tizen2.0\n| | `-- i586 # the same as above\n| |-- scratch.armv7l.0 # first build root for arm build\n| |-- scratch.i586.0 # second build root for x86 build\n| |-- scratch.i586.1 # third build root for x86 build\n| |-- scratch.i586.2 # fourth build root for x86 build\n| |-- scratch.i586.3 # fifth build root for x86 build\n| | # The above build root dir can be used by gbs chroot &lt;build root dir&gt;\n| `-- sources # sources generated for build, including tarball, spec, patches, etc.\n| |-- tizen\n| `-- tizen2.0\n`-- meta # meta data used by gbs\n\n\nExamples\n\nTo perform a basic build:\n\n\n  Build a single package:\n    $ cd package1$ gbs build -A i586\n    \n  \n  Build a package for different architectures:\n    \n      Note\n\n      Supported architectures include x86_64, i586, armv6l, armv7hl, armv7l, aarch64, mips, and mipsel.\n    \n\n    $ gbs build -A armv7l #build package for armv7l\n$ gbs build -A i586 #build package for i586\n    \n  \n  \n    Make a clean build by deleting the old build root.\n\n    The --clean option must be specified if the repository has been changed, for example, to another release.\n\n    $ gbs build -A armv7l --clean\n    \n  \n  Build the package with a specific commit:\n    $ gbs build -A armv7l --commit=&lt;COMMIT_ID&gt;\n    \n  \n  \n    Use the --overwrite option to trigger a rebuild.\n\n    If you have already built before, and want to rebuild, specify the --overwrite option or the packages are skipped.\n    $ gbs build -A i586 --overwrite\n    \n\n    If you change the commit or specify the --include-all option, it always rebuilds. In these cases, the --overwrite option is not needed.\n  \n  Output the debug info:\n    $ gbs build -A i586 --debug\n    \n  \n  \n    Build against a local repository.\n\n    You can configure the local repo in the .gbs.conf file or through the command line.\n    $ gbs build -R /path/to/repo/dir/ -A i586\n    \n  \n  \n    Use the --noinit option to build a package in offline mode.\n\n    This option can only be used if the build root is ready. When it is used, GBS does not connect the remote repository, and skips parsing and checking the repository and initializing the build environment. The package is built directly.\n\n    $ gbs build -A i586 # build first and create build environment\n$ gbs build -A i586 --noinit # use --noinit to start building directly\n    \n  \n  \n    Build with all uncommitted changes using the --include-all option.\n\n    In the following examples, the Git tree contains 1 modified file and 2 extra files:\n    $ git status -s\nM ail.pc.in\n?? base.repo\n?? main.repo\n    \n    \n      \n        Build without the --include-all option\n\n        Only committed files are built. None of the modified files, which are neither committed nor added, are built:\n\n        $ gbs build -A i586\nwarning: the following untracked files would NOT be included: base.repo main.repo\nwarning: the following uncommitted changes would NOT be included: ail.pc.in\nwarning: you can specify '--include-all' option to include these uncommitted and untracked files.\n....\ninfo: Binaries RPM packages can be found here:\n/home/test/GBS-ROOT/local/scratch.i586.0/home/abuild/rpmbuild/RPMS/\ninfo: Done\n        \n      \n      \n        Build with the --include-all option\n\n        All the files are built:\n        $ gbs build -A i586\nwarning: the following untracked files would NOT be included: base.repo main.repo\nwarning: the following uncommitted changes would NOT be included: ail.pc.in\nwarning: you can specify '--include-all' option to include these uncommitted and untracked files.\n....\ninfo: Binaries RPM packages can be found here:\n/home/test/GBS-ROOT/local/scratch.i586.0/home/abuild/rpmbuild/RPMS/\ninfo: Done\n        \n      \n      \n        Use .gitignore to ignore specific files when using the --include-all option.\n\n        If you want to ignore some file types, update your .gitignore:\n\n        $ cat .gitignore\n.*\n*/.*\n*.pyc\n*.patch*\n        \n      \n    \n  \n\n\nIncremental Build\n\nStarting from GBS 0.10, the gbs build subcommand supports the --incremental option, which allows you to build incrementally.\n\nThe incremental mode is designed for development and verification of single packages. It is not intended to replace the standard mode. Only 1 package can be built at a time using the incremental mode.\n\nThe incremental mode sets up the build environment in multiple steps, finishing by mounting the local Git tree of a package in the chroot build environment.\n\n\n  Note\n\n  Because GBS mounts your Git tree to the build root, be very careful when you remove your build root. You need to make sure you have already unmounted the source tree manually before you remove it.\n\n\nThe incremental mode has the following benefits:\n\n\n  The build environment uses the latest source code and changes to source do not trigger a new build environment (in the chroot).\n  The Git source tree becomes the source of the builds. Any change made in the Git repository followed by invocation of the build script builds the changed sources.\n  If the build fails for some reason, the build script continues from the spot where it has failed, once the code has been changed to fix the problem causing the failure.\n\n\nIncremental building is, in many ways, similar to traditional code development, where changes are made to sources, followed by running make to test and compile the changes. However, it enables development using the build environment of the target, instead of the host OS.\n\nThe incremental mode has some limitations, mostly related to packaging and how the sources are maintained. Among others, it depends on how the RPM spec file is composed:\n\n\n  \n    The incremental mode does not support patches in the spec file. All source has to be maintained as part of the Git tree.\n  \n  \n    The incremental mode requires a clean packaging workflow. Exotic workflows in the spec files do not always work well, because the incremental mode expects the following model:\n\n    \n      Code preparation (%prep)\n      Code building (%build)\n      Code installation (%install)\n    \n  \n  \n    The %prep section can only contain the %setup macro to unpack the tarball, and must not contain other source code-related operations, such as unpacking another source or applying patches.\n  \n  \n    Because the %build section is run every time, if the %build script has configuration scripts (auto-tools), binaries can be regenerated, causing a complete build every time. To avoid this, use the following macros, which can be overridden using the --no-configure option:\n\n    \n      %configure: runs the configure script with pre-defined paths and options.\n      %reconfigure: regenerates the scripts and runs %configure.\n      %autogen: runs the autogen script.\n    \n  \n  \n    You can build only a single package. You cannot build multiple packages in parallel.\n  \n  \n    The tarball’s name in the spec file must be %{name}-%{version}.{tar.gz|tar.bz2|zip|...}. Otherwise, GBS cannot mount the source code to build the root correctly.\n  \n\n\nThe following example uses the dlog source code. First, it builds with the --incremental option, then modifies 1 source file and triggers the incremental build again. You can see that only modified source code gets compiled during the incremental build.\n\n$ cd dlog\n# first build:\n$ gbs build -A i586 --incremental\n$ vim log.c # change code\n# second build:\n$ gbs build -A i586 --incremental\ninfo: generate repositories ...\ninfo: build conf has been downloaded at:\n/var/tmp/test-gbs/tizen.conf\ninfo: Start building packages from: /home/test/packages/dlog (git)\ninfo: Prepare sources...\ninfo: Retrieving repo metadata...\ninfo: Parsing package data...\ninfo: *** overwriting dlog-0.4.1-5.1 i586 ***\ninfo: Next pass:\ndlog\ninfo: *** building dlog-0.4.1-5.1 i586 tizen (worker: 0) ***\ninfo: Doing incremental build\n[ 0s] Memory limit set to 10854336KB\n[ 0s] Using BUILD_ROOT=/home/test/GBS-ROOT/local/scratch.i586.0\n[ 0s] Using BUILD_ARCH=i686:i586:i486:i386:noarch\n[ 0s] test-desktop started \"build dlog.spec\" at Thu Sep 13 07:36:14 UTC 2012.\n[ 0s] -----------------------------------------------------------------\n[ 0s] ----- building dlog.spec (user abuild)\n[ 0s] -----------------------------------------------------------------\n[ 0s] -----------------------------------------------------------------\n[ 0s] + rpmbuild --short-circuit -bc /home/abuild/rpmbuild/SOURCES/dlog.spec\n[ 0s] Executing(%build): /bin/sh -e /var/tmp/rpm-tmp.XLz8je\n[ 0s] + umask 022\n[ 0s] + export LD_AS_NEEDED\n[ 4s] + make -j4\n[ 4s] make all-am\n[ 4s] make[1]: Entering directory /home/abuild/rpmbuild/BUILD/dlog-0.4.1\n[ 4s] /bin/sh ./libtool --tag=CC --mode=compile gcc -c -o log.lo log.c\n[ 4s] mv -f .deps/log.Tpo .deps/log.Plo\n[ 4s] /bin/sh ./libtool --tag=CC --mode=link gcc -o libdlog.la /usr/lib log.lo\n[ 4s] libtool: link: gcc -shared .libs/log.o -o .libs/libdlog.so.0.0.0\n[ 4s] libtool: link: ar cru .libs/libdlog.a log.o\n[ 4s] libtool: link: ranlib .libs/libdlog.a\n[ 4s] make[1]: Leaving directory /home/abuild/rpmbuild/BUILD/dlog-0.4.1\n[ 4s] + exit 0\n[ 4s] finished \"build dlog.spec\" at Thu Sep 13 07:36:18 UTC 2012.\n[ 4s]\ninfo: finished incremental building dlog\ninfo: Local repo can be found here:\n/home/test/GBS-ROOT/local/repos/tizen/\ninfo: Done\n\n\nFrom the build log, you can see that only log.c has been re-compiled. That is the point of the incremental build behavior.\n\nThe --noinit option can be used together with --incremental to make a build more quickly:\n\n$ gbs build --incremental --noinit\n\n\nMultiple Package Build (Dependency Build)\n\nMultiple package build has been supported since GBS 0.10. If packages have dependencies on each other, GBS builds them in the correct order calculated by the dependency relationships. Previously built RPMs are used to build the packages that depend on them. This process is called a dependency build.\n\nTo perform a multiple package build:\n\n\n  \n    Build all packages under a specific package directory:\n\n    $ mkdir tizen-packages\n$ cp package1 package2 package3 ... tizen-packages/\n$ gbs build -A i586 tizen-packages # build all packages under tizen-packages\n    \n  \n  \n    Build multiple packages in parallel with the --threads option:\n\n    # current directory have multiple packages, --threads can be used to set the max build worker at the same time\n$ gbs build -A armv7l --threads=4\n    \n  \n  \n    Select a group of packages to be built:\n\n    \n      The --binary-from-file option specifies a text file that contains a name list of RPM packages to be built. The format in the text file is 1 package per line.\n      The --binary-list option specifies a list in which the package names are separated by commas.\n    \n\n    When the number of packages is small and the packages can be clearly listed in the command line, use the --binary-list option for simplicity.\n\n    $ gbs build -A i586 --binary-from-file=/path/to/packages.list\n$ gbs build -A i586 --binary-list=&lt;pkg1&gt;,&lt;pkg2&gt;\n    \n  \n  \n    Exclude certain packages:\n\n    \n      The --exclude option specifies a list in which the names of packages to be ignored are separated by commas.\n      The --exclude-from-file option specifies a text file that contains a name list of packages to be ignored.\n    \n\n    $ gbs build -A i586 tizen-packages --exclude=&lt;pkg1&gt;\n$ gbs build -A i586 tizen-packages --exclude=&lt;pkg1&gt;,&lt;pkg2&gt;\n$ gbs build -A i586 tizen-packages --exclude-from-file=/path/to/packages.list\n    \n  \n  \n    Build packages based on dependencies:\n\n    \n      The --deps option enables GBS to build specific packages, together with all related packages on which they depend.\n      The --rdep option enables GBS to build specific packages, together with all related packages that depend on them.\n    \n\n    The specific packages can be included by the --binary-from-file or --binary-list option, and excluded by the --exclude or --exclude-from-file option.\n\n    The --deps and --rdep options are compatible. When added at the same time, besides the specific packages, GBS builds not only the related packages on which they depend, but also all the related packages that depend on them.\n\n    $ gbs build -A i586 --binary-list=&lt;pkg1&gt;,&lt;pkg2&gt; --deps\n$ gbs build -A i586 --binary-list=&lt;pkg1&gt;,&lt;pkg2&gt; --rdeps\n$ gbs build -A i586 --binary-list=&lt;pkg1&gt;,&lt;pkg2&gt; --deps --rdeps\n    \n  \n\n\nUseful Building Options\n\nThe gbs build command offers some useful options:\n\n\n  \n    Install extra packages to build a root\n\n    The --extra-packs=&lt;packages separated by commas&gt; option can be used to install extra packages:\n\n    $ gbs build -A i586 --extra-packs=&lt;pkg1&gt;,&lt;pkg2&gt; --deps\n$ gbs build -A i586 --extra-packs=&lt;pkg1&gt;,&lt;pkg2&gt; --rdeps\n$ gbs build -A i586 --extra-packs=&lt;pkg1&gt;,&lt;pkg2&gt; --deps --rdeps\n    \n  \n  \n    Keep all packages in the build root\n\n    Generally, the GBS build removes unnecessary packages in the build root. While transferring to build another package, you can use the --keep-packs option to keep all unnecessary packages, and just install missing required build packages. This option can be used to speed up building multiple packages.\n\n    $ gbs build --keep-packs\n    \n\n    The --keep-packs option can be used to create 1 build root for building multiple packages. Once the build root is ready, you can use the --noinit option to build these packages quickly.\n\n    $ gbs build pkg1/ --keep-packs -A i586\n$ gbs build pkg2/ --keep-packs -A i586\n$ gbs build pkg3/ --keep-packs -A i586\n    \n\n    Now, the build root (~/GBS-ROOT/local/scratch.i586.0) is ready for building pkg1, pkg2, and pkg3. You can use the --noinit option to build them offline, and need waste no time to check for repository updates and build root.\n\n    $ gbs build pkg1 --noinit\n$ gbs build pkg2 --noinit\n$ gbs build pkg3 --noinit\n    \n  \n\n\nForcing GBS to Work in the Native Mode\n\nUse the --fallback-to-native option to force GBS to perform packaging for non-native packages in the native packaging mode in the packaging phase of the building process, that is, ignore the upstream branch and create a tarball from HEAD (by default) or specified commit without generating any patch. Adding the --fallback-to-native option when issuing the gbs build or gbs export command is equivalent to adding the fallback_to_native = true property into the [general] section of the GBS configuration file.\n\n\n  Note\n\n  This option serves as a work-around solution for solving export failures of some non-native packages caused by a tricky engineering problem. For Tizen native packages, GBS always performs packaging in the native packaging mode.\n\n\n$ gbs build -A i586 --fallback-to-native\n\n\nSkipping the Building of the src.rpm File\n\nNormally, 2 types of package files are created during the package building process:\n\n\n  Binary, or executable, package file\n  Source package file\n\n\nThe source package file (src.rpm) contains everything needed to recreate a specific version of a package. This makes the src.rpm file a great way to distribute source code. However, it is optional when developing source code, especially when the source Git tree is huge.\n\nAdding the --skip-srcrpm option enables GBS to skip the building of the src.rpm file, speeding up the building process of huge source Git trees during development:\n\n$ cd &lt;Path_to_crosswalk&gt;\n$ gbs build -A i586 --skip-srcrpm\n\n\nUsing Distributed Compiler Networks\n\nThough GBS provides the --threads option to speed up the build process by activating multiple build workers, the efficiency of just using multiple build workers in 1 local machine is far from satisfactory, especially for a huge Git tree, such as crosswalk.\n\nTo improve the build process efficiency further, use the --icecream option, which activates distributed compiler networks. The option makes GBS use build workers on both the local machine and distributed networks.\n\n$ gbs build -A i586 --icecream=10\n\n\nFetching the Project Build Conf and Customizing the Build Root (for Advanced Users)\n\nThe project build conf describes the build configurations for the project, including all macros, packages, and flags predefined in the build environment. In Tizen releases, the build conf is released together with the released repository.\n\n\n  \n    Fetch the build conf automatically with the gbs build command\n\n    Starting from GBS 0.7.1, by default, GBS fetches the build conf from a remote repository (if you specify the remote Tizen repository) and stores it in your temporary environment:\n\n    $ gbs build -A i586\ninfo: generate repositories ...\ninfo: build conf has been downloaded at:\n/var/tmp/&lt;user&gt;-gbs/tizen2.0.conf\ninfo: generate tar ball: packaging/acpid-2.0.14.tar.bz2\n[sudo] password for &lt;user&gt;:\n    \n  \n  \n    Build the package using your own project build conf, by using the -D option\n\n    You can save and modify the build conf, and use it for your own purposes:\n\n    $ cp /var/tmp/&lt;user&gt;-gbs/tizen2.0.conf ~/tizen2.0.conf\n$ gbs build -A i586 -D ~/tizen2.0.conf\n    \n  \n\n\nTo customize the build config, see http://en.opensuse.org/openSUSE:Build_Service_prjconf."
					}
					
				
			
		
			
				
					,
					
					"platform-reference-gbs-gbs-build": {
						"id": "platform-reference-gbs-gbs-build",
						"title": "Customizing Images",
						"categories": "",
						"url": " platform/reference/gbs/gbs-build/",
						"content": "gbs build\n\nUse the gbs build subcommand to build the source code and generate RPM packages locally.\n\nFor command usage details, enter:\n\n$ gbs build -help\n\n\nCommand Workflow\n\nThe gbs build command requires the following input:\n\n\n  Git projects that contain RPM packaging files\n  \n    Binary RPM repositories (remote or local)\n\n    The binary RPM repositories contain all the binary RPM packages used to create the chroot environment and build packages, which can be remote, like tizen release or snapshot repositories, or local. The local repository supports 2 types:\n\n    \n      Standard repository with existing repodata\n      Normal directory containing RPM packages. GBS finds all RPM packages within the directory.\n    \n\n    To configure a repository, see GBS Configuration.\n  \n  Project build configurations (such as macros and flags)\n\n\nThe following figure shows the basic GBS build workflow. The figure illustrates that input and output are both repositories, and the output repository is located at ~/GBS-ROOT/locals/repos/ by default. You can change the repository path by using the --buildroot option.\n\nFigure: GBS build workflow\n\n ____________________\n|                    |      ___________\n| Source Code (GIT)  |----&gt;|           |      _________________________\n|____________________|     |           |     |                         |\n ____________________      |           |     |  Local repository of    |\n|                    |     |           |     |                         |\n|    Build config    |----&gt;| GBS build |----&gt;|                         |\n|____________________|     |           |     |                         |\n ____________________      |           |     |  build RPM packages     |\n|                    |     |           |     |(~/GBS-ROOT/local/repos/)|\n|Binary repositories |     |           |     |_________________________|\n|in GBS conf         |----&gt;|___________|                  |\n|(Remote or Local)   |           ^                        |\n|____________________|           |________________________|\n\n\nLocal repos in the GBS build root (~/GBS-ROOT by default) affect build results, so make sure that repositories do not contain old or unnecessary RPM packages. While running the gbs build command, you can specify the --clean-repos option to clean up local GBS-created repositories before building. To avoid problems, also set a different GBS build root directory for each profile. The GBS build directory can be defined in many ways:\n\n\n  By default, the GBS build puts all output files under ~/GBS-ROOT/.\n  If the TIZEN_BUILD_ROOT environment variable exists, ${TIZEN_BUILD_ROOT} is used as the output top directory.\n  If the -B option is specified, the specified directory is used, even if ${TIZEN_BUILD_ROOT} exists.\n\n\n\n  Note\n\n  All RPM packages under the output repository (by default, ~/GBS-ROOT/local/repos/&lt;VERSION&gt;/) are used when building packages. Since all the packages under the output repository are applied to the build environment, avoid unexpected results by making sure that the output repository is clean.\n\n\nThe following example shows the structure of the GBS build root directory in the workflow output:\n\ngbs output top dir\n|-- local\n| |-- cache # repodata and RPMs from remote repositories\n| |-- repos # generated local repo top directory\n| | |-- tizen # distro one: tizen\n| | | |-- armv7l # store armv7l RPM packages\n| | | |-- i586 # store x86 RPM packages\n| | `-- tizen2.0 # build for distro two: tizen2.0\n| | `-- i586 # the same as above\n| |-- scratch.armv7l.0 # first build root for arm build\n| |-- scratch.i586.0 # second build root for x86 build\n| |-- scratch.i586.1 # third build root for x86 build\n| |-- scratch.i586.2 # fourth build root for x86 build\n| |-- scratch.i586.3 # fifth build root for x86 build\n| | # The above build root dir can be used by gbs chroot &lt;build root dir&gt;\n| `-- sources # sources generated for build, including tarball, spec, patches, etc.\n| |-- tizen\n| `-- tizen2.0\n`-- meta # meta data used by gbs\n\n\nExamples\n\nTo perform a basic build:\n\n\n  Build a single package:\n    $ cd package1$ gbs build -A i586\n    \n  \n  Build a package for different architectures:\n    \n      Note\n\n      Supported architectures include x86_64, i586, armv6l, armv7hl, armv7l, aarch64, mips, and mipsel.\n    \n\n    $ gbs build -A armv7l #build package for armv7l\n$ gbs build -A i586 #build package for i586\n    \n  \n  \n    Make a clean build by deleting the old build root.\n\n    The --clean option must be specified if the repository has been changed, for example, to another release.\n\n    $ gbs build -A armv7l --clean\n    \n  \n  Build the package with a specific commit:\n    $ gbs build -A armv7l --commit=&lt;COMMIT_ID&gt;\n    \n  \n  \n    Use the --overwrite option to trigger a rebuild.\n\n    If you have already built before, and want to rebuild, specify the --overwrite option or the packages are skipped.\n    $ gbs build -A i586 --overwrite\n    \n\n    If you change the commit or specify the --include-all option, it always rebuilds. In these cases, the --overwrite option is not needed.\n  \n  Output the debug info:\n    $ gbs build -A i586 --debug\n    \n  \n  \n    Build against a local repository.\n\n    You can configure the local repo in the .gbs.conf file or through the command line.\n    $ gbs build -R /path/to/repo/dir/ -A i586\n    \n  \n  \n    Use the --noinit option to build a package in offline mode.\n\n    This option can only be used if the build root is ready. When it is used, GBS does not connect the remote repository, and skips parsing and checking the repository and initializing the build environment. The package is built directly.\n\n    $ gbs build -A i586 # build first and create build environment\n$ gbs build -A i586 --noinit # use --noinit to start building directly\n    \n  \n  \n    Build with all uncommitted changes using the --include-all option.\n\n    In the following examples, the Git tree contains 1 modified file and 2 extra files:\n    $ git status -s\nM ail.pc.in\n?? base.repo\n?? main.repo\n    \n    \n      \n        Build without the --include-all option\n\n        Only committed files are built. None of the modified files, which are neither committed nor added, are built:\n\n        $ gbs build -A i586\nwarning: the following untracked files would NOT be included: base.repo main.repo\nwarning: the following uncommitted changes would NOT be included: ail.pc.in\nwarning: you can specify '--include-all' option to include these uncommitted and untracked files.\n....\ninfo: Binaries RPM packages can be found here:\n/home/test/GBS-ROOT/local/scratch.i586.0/home/abuild/rpmbuild/RPMS/\ninfo: Done\n        \n      \n      \n        Build with the --include-all option\n\n        All the files are built:\n        $ gbs build -A i586\nwarning: the following untracked files would NOT be included: base.repo main.repo\nwarning: the following uncommitted changes would NOT be included: ail.pc.in\nwarning: you can specify '--include-all' option to include these uncommitted and untracked files.\n....\ninfo: Binaries RPM packages can be found here:\n/home/test/GBS-ROOT/local/scratch.i586.0/home/abuild/rpmbuild/RPMS/\ninfo: Done\n        \n      \n      \n        Use .gitignore to ignore specific files when using the --include-all option.\n\n        If you want to ignore some file types, update your .gitignore:\n\n        $ cat .gitignore\n.*\n*/.*\n*.pyc\n*.patch*\n        \n      \n    \n  \n\n\nIncremental Build\n\nStarting from GBS 0.10, the gbs build subcommand supports the --incremental option, which allows you to build incrementally.\n\nThe incremental mode is designed for development and verification of single packages. It is not intended to replace the standard mode. Only 1 package can be built at a time using the incremental mode.\n\nThe incremental mode sets up the build environment in multiple steps, finishing by mounting the local Git tree of a package in the chroot build environment.\n\n\n  Note\n\n  Because GBS mounts your Git tree to the build root, be very careful when you remove your build root. You need to make sure you have already unmounted the source tree manually before you remove it.\n\n\nThe incremental mode has the following benefits:\n\n\n  The build environment uses the latest source code and changes to source do not trigger a new build environment (in the chroot).\n  The Git source tree becomes the source of the builds. Any change made in the Git repository followed by invocation of the build script builds the changed sources.\n  If the build fails for some reason, the build script continues from the spot where it has failed, once the code has been changed to fix the problem causing the failure.\n\n\nIncremental building is, in many ways, similar to traditional code development, where changes are made to sources, followed by running make to test and compile the changes. However, it enables development using the build environment of the target, instead of the host OS.\n\nThe incremental mode has some limitations, mostly related to packaging and how the sources are maintained. Among others, it depends on how the RPM spec file is composed:\n\n\n  \n    The incremental mode does not support patches in the spec file. All source has to be maintained as part of the Git tree.\n  \n  \n    The incremental mode requires a clean packaging workflow. Exotic workflows in the spec files do not always work well, because the incremental mode expects the following model:\n\n    \n      Code preparation (%prep)\n      Code building (%build)\n      Code installation (%install)\n    \n  \n  \n    The %prep section can only contain the %setup macro to unpack the tarball, and must not contain other source code-related operations, such as unpacking another source or applying patches.\n  \n  \n    Because the %build section is run every time, if the %build script has configuration scripts (auto-tools), binaries can be regenerated, causing a complete build every time. To avoid this, use the following macros, which can be overridden using the --no-configure option:\n\n    \n      %configure: runs the configure script with pre-defined paths and options.\n      %reconfigure: regenerates the scripts and runs %configure.\n      %autogen: runs the autogen script.\n    \n  \n  \n    You can build only a single package. You cannot build multiple packages in parallel.\n  \n  \n    The tarball’s name in the spec file must be %{name}-%{version}.{tar.gz|tar.bz2|zip|...}. Otherwise, GBS cannot mount the source code to build the root correctly.\n  \n\n\nThe following example uses the dlog source code. First, it builds with the --incremental option, then modifies 1 source file and triggers the incremental build again. You can see that only modified source code gets compiled during the incremental build.\n\n$ cd dlog\n# first build:\n$ gbs build -A i586 --incremental\n$ vim log.c # change code\n# second build:\n$ gbs build -A i586 --incremental\ninfo: generate repositories ...\ninfo: build conf has been downloaded at:\n/var/tmp/test-gbs/tizen.conf\ninfo: Start building packages from: /home/test/packages/dlog (git)\ninfo: Prepare sources...\ninfo: Retrieving repo metadata...\ninfo: Parsing package data...\ninfo: *** overwriting dlog-0.4.1-5.1 i586 ***\ninfo: Next pass:\ndlog\ninfo: *** building dlog-0.4.1-5.1 i586 tizen (worker: 0) ***\ninfo: Doing incremental build\n[ 0s] Memory limit set to 10854336KB\n[ 0s] Using BUILD_ROOT=/home/test/GBS-ROOT/local/scratch.i586.0\n[ 0s] Using BUILD_ARCH=i686:i586:i486:i386:noarch\n[ 0s] test-desktop started \"build dlog.spec\" at Thu Sep 13 07:36:14 UTC 2012.\n[ 0s] -----------------------------------------------------------------\n[ 0s] ----- building dlog.spec (user abuild)\n[ 0s] -----------------------------------------------------------------\n[ 0s] -----------------------------------------------------------------\n[ 0s] + rpmbuild --short-circuit -bc /home/abuild/rpmbuild/SOURCES/dlog.spec\n[ 0s] Executing(%build): /bin/sh -e /var/tmp/rpm-tmp.XLz8je\n[ 0s] + umask 022\n[ 0s] + export LD_AS_NEEDED\n[ 4s] + make -j4\n[ 4s] make all-am\n[ 4s] make[1]: Entering directory /home/abuild/rpmbuild/BUILD/dlog-0.4.1\n[ 4s] /bin/sh ./libtool --tag=CC --mode=compile gcc -c -o log.lo log.c\n[ 4s] mv -f .deps/log.Tpo .deps/log.Plo\n[ 4s] /bin/sh ./libtool --tag=CC --mode=link gcc -o libdlog.la /usr/lib log.lo\n[ 4s] libtool: link: gcc -shared .libs/log.o -o .libs/libdlog.so.0.0.0\n[ 4s] libtool: link: ar cru .libs/libdlog.a log.o\n[ 4s] libtool: link: ranlib .libs/libdlog.a\n[ 4s] make[1]: Leaving directory /home/abuild/rpmbuild/BUILD/dlog-0.4.1\n[ 4s] + exit 0\n[ 4s] finished \"build dlog.spec\" at Thu Sep 13 07:36:18 UTC 2012.\n[ 4s]\ninfo: finished incremental building dlog\ninfo: Local repo can be found here:\n/home/test/GBS-ROOT/local/repos/tizen/\ninfo: Done\n\n\nFrom the build log, you can see that only log.c has been re-compiled. That is the point of the incremental build behavior.\n\nThe --noinit option can be used together with --incremental to make a build more quickly:\n\n$ gbs build --incremental --noinit\n\n\nMultiple Package Build (Dependency Build)\n\nMultiple package build has been supported since GBS 0.10. If packages have dependencies on each other, GBS builds them in the correct order calculated by the dependency relationships. Previously built RPMs are used to build the packages that depend on them. This process is called a dependency build.\n\nTo perform a multiple package build:\n\n\n  \n    Build all packages under a specific package directory:\n\n    $ mkdir tizen-packages\n$ cp package1 package2 package3 ... tizen-packages/\n$ gbs build -A i586 tizen-packages # build all packages under tizen-packages\n    \n  \n  \n    Build multiple packages in parallel with the --threads option:\n\n    # current directory have multiple packages, --threads can be used to set the max build worker at the same time\n$ gbs build -A armv7l --threads=4\n    \n  \n  \n    Select a group of packages to be built:\n\n    \n      The --binary-from-file option specifies a text file that contains a name list of RPM packages to be built. The format in the text file is 1 package per line.\n      The --binary-list option specifies a list in which the package names are separated by commas.\n    \n\n    When the number of packages is small and the packages can be clearly listed in the command line, use the --binary-list option for simplicity.\n\n    $ gbs build -A i586 --binary-from-file=/path/to/packages.list\n$ gbs build -A i586 --binary-list=&lt;pkg1&gt;,&lt;pkg2&gt;\n    \n  \n  \n    Exclude certain packages:\n\n    \n      The --exclude option specifies a list in which the names of packages to be ignored are separated by commas.\n      The --exclude-from-file option specifies a text file that contains a name list of packages to be ignored.\n    \n\n    $ gbs build -A i586 tizen-packages --exclude=&lt;pkg1&gt;\n$ gbs build -A i586 tizen-packages --exclude=&lt;pkg1&gt;,&lt;pkg2&gt;\n$ gbs build -A i586 tizen-packages --exclude-from-file=/path/to/packages.list\n    \n  \n  \n    Build packages based on dependencies:\n\n    \n      The --deps option enables GBS to build specific packages, together with all related packages on which they depend.\n      The --rdep option enables GBS to build specific packages, together with all related packages that depend on them.\n    \n\n    The specific packages can be included by the --binary-from-file or --binary-list option, and excluded by the --exclude or --exclude-from-file option.\n\n    The --deps and --rdep options are compatible. When added at the same time, besides the specific packages, GBS builds not only the related packages on which they depend, but also all the related packages that depend on them.\n\n    $ gbs build -A i586 --binary-list=&lt;pkg1&gt;,&lt;pkg2&gt; --deps\n$ gbs build -A i586 --binary-list=&lt;pkg1&gt;,&lt;pkg2&gt; --rdeps\n$ gbs build -A i586 --binary-list=&lt;pkg1&gt;,&lt;pkg2&gt; --deps --rdeps\n    \n  \n\n\nUseful Building Options\n\nThe gbs build command offers some useful options:\n\n\n  \n    Install extra packages to build a root\n\n    The --extra-packs=&lt;packages separated by commas&gt; option can be used to install extra packages:\n\n    $ gbs build -A i586 --extra-packs=&lt;pkg1&gt;,&lt;pkg2&gt; --deps\n$ gbs build -A i586 --extra-packs=&lt;pkg1&gt;,&lt;pkg2&gt; --rdeps\n$ gbs build -A i586 --extra-packs=&lt;pkg1&gt;,&lt;pkg2&gt; --deps --rdeps\n    \n  \n  \n    Keep all packages in the build root\n\n    Generally, the GBS build removes unnecessary packages in the build root. While transferring to build another package, you can use the --keep-packs option to keep all unnecessary packages, and just install missing required build packages. This option can be used to speed up building multiple packages.\n\n    $ gbs build --keep-packs\n    \n\n    The --keep-packs option can be used to create 1 build root for building multiple packages. Once the build root is ready, you can use the --noinit option to build these packages quickly.\n\n    $ gbs build pkg1/ --keep-packs -A i586\n$ gbs build pkg2/ --keep-packs -A i586\n$ gbs build pkg3/ --keep-packs -A i586\n    \n\n    Now, the build root (~/GBS-ROOT/local/scratch.i586.0) is ready for building pkg1, pkg2, and pkg3. You can use the --noinit option to build them offline, and need waste no time to check for repository updates and build root.\n\n    $ gbs build pkg1 --noinit\n$ gbs build pkg2 --noinit\n$ gbs build pkg3 --noinit\n    \n  \n\n\nForcing GBS to Work in the Native Mode\n\nUse the --fallback-to-native option to force GBS to perform packaging for non-native packages in the native packaging mode in the packaging phase of the building process, that is, ignore the upstream branch and create a tarball from HEAD (by default) or specified commit without generating any patch. Adding the --fallback-to-native option when issuing the gbs build or gbs export command is equivalent to adding the fallback_to_native = true property into the [general] section of the GBS configuration file.\n\n\n  Note\n\n  This option serves as a work-around solution for solving export failures of some non-native packages caused by a tricky engineering problem. For Tizen native packages, GBS always performs packaging in the native packaging mode.\n\n\n$ gbs build -A i586 --fallback-to-native\n\n\nSkipping the Building of the src.rpm File\n\nNormally, 2 types of package files are created during the package building process:\n\n\n  Binary, or executable, package file\n  Source package file\n\n\nThe source package file (src.rpm) contains everything needed to recreate a specific version of a package. This makes the src.rpm file a great way to distribute source code. However, it is optional when developing source code, especially when the source Git tree is huge.\n\nAdding the --skip-srcrpm option enables GBS to skip the building of the src.rpm file, speeding up the building process of huge source Git trees during development:\n\n$ cd &lt;Path_to_crosswalk&gt;\n$ gbs build -A i586 --skip-srcrpm\n\n\nUsing Distributed Compiler Networks\n\nThough GBS provides the --threads option to speed up the build process by activating multiple build workers, the efficiency of just using multiple build workers in 1 local machine is far from satisfactory, especially for a huge Git tree, such as crosswalk.\n\nTo improve the build process efficiency further, use the --icecream option, which activates distributed compiler networks. The option makes GBS use build workers on both the local machine and distributed networks.\n\n$ gbs build -A i586 --icecream=10\n\n\nFetching the Project Build Conf and Customizing the Build Root (for Advanced Users)\n\nThe project build conf describes the build configurations for the project, including all macros, packages, and flags predefined in the build environment. In Tizen releases, the build conf is released together with the released repository.\n\n\n  \n    Fetch the build conf automatically with the gbs build command\n\n    Starting from GBS 0.7.1, by default, GBS fetches the build conf from a remote repository (if you specify the remote Tizen repository) and stores it in your temporary environment:\n\n    $ gbs build -A i586\ninfo: generate repositories ...\ninfo: build conf has been downloaded at:\n/var/tmp/&lt;user&gt;-gbs/tizen2.0.conf\ninfo: generate tar ball: packaging/acpid-2.0.14.tar.bz2\n[sudo] password for &lt;user&gt;:\n    \n  \n  \n    Build the package using your own project build conf, by using the -D option\n\n    You can save and modify the build conf, and use it for your own purposes:\n\n    $ cp /var/tmp/&lt;user&gt;-gbs/tizen2.0.conf ~/tizen2.0.conf\n$ gbs build -A i586 -D ~/tizen2.0.conf\n    \n  \n\n\nTo customize the build config, see http://en.opensuse.org/openSUSE:Build_Service_prjconf."
					}
					
				
			
		
			
				
					,
					
					"iot-reference-gbs-gbs-build": {
						"id": "iot-reference-gbs-gbs-build",
						"title": "Customizing Images",
						"categories": "",
						"url": " iot/reference/gbs/gbs-build/",
						"content": "gbs build\n\nUse the gbs build subcommand to build the source code and generate RPM packages locally.\n\nFor command usage details, enter:\n\n$ gbs build -help\n\n\nCommand Workflow\n\nThe gbs build command requires the following input:\n\n\n  Git projects that contain RPM packaging files\n  \n    Binary RPM repositories (remote or local)\n\n    The binary RPM repositories contain all the binary RPM packages used to create the chroot environment and build packages, which can be remote, like tizen release or snapshot repositories, or local. The local repository supports 2 types:\n\n    \n      Standard repository with existing repodata\n      Normal directory containing RPM packages. GBS finds all RPM packages within the directory.\n    \n\n    To configure a repository, see GBS Configuration.\n  \n  Project build configurations (such as macros and flags)\n\n\nThe following figure shows the basic GBS build workflow. The figure illustrates that input and output are both repositories, and the output repository is located at ~/GBS-ROOT/locals/repos/ by default. You can change the repository path by using the --buildroot option.\n\nFigure: GBS build workflow\n\n ____________________\n|                    |      ___________\n| Source Code (GIT)  |----&gt;|           |      _________________________\n|____________________|     |           |     |                         |\n ____________________      |           |     |  Local repository of    |\n|                    |     |           |     |                         |\n|    Build config    |----&gt;| GBS build |----&gt;|                         |\n|____________________|     |           |     |                         |\n ____________________      |           |     |  build RPM packages     |\n|                    |     |           |     |(~/GBS-ROOT/local/repos/)|\n|Binary repositories |     |           |     |_________________________|\n|in GBS conf         |----&gt;|___________|                  |\n|(Remote or Local)   |           ^                        |\n|____________________|           |________________________|\n\n\nLocal repos in the GBS build root (~/GBS-ROOT by default) affect build results, so make sure that repositories do not contain old or unnecessary RPM packages. While running the gbs build command, you can specify the --clean-repos option to clean up local GBS-created repositories before building. To avoid problems, also set a different GBS build root directory for each profile. The GBS build directory can be defined in many ways:\n\n\n  By default, the GBS build puts all output files under ~/GBS-ROOT/.\n  If the TIZEN_BUILD_ROOT environment variable exists, ${TIZEN_BUILD_ROOT} is used as the output top directory.\n  If the -B option is specified, the specified directory is used, even if ${TIZEN_BUILD_ROOT} exists.\n\n\n\n  Note\n\n  All RPM packages under the output repository (by default, ~/GBS-ROOT/local/repos/&lt;VERSION&gt;/) are used when building packages. Since all the packages under the output repository are applied to the build environment, avoid unexpected results by making sure that the output repository is clean.\n\n\nThe following example shows the structure of the GBS build root directory in the workflow output:\n\ngbs output top dir\n|-- local\n| |-- cache # repodata and RPMs from remote repositories\n| |-- repos # generated local repo top directory\n| | |-- tizen # distro one: tizen\n| | | |-- armv7l # store armv7l RPM packages\n| | | |-- i586 # store x86 RPM packages\n| | `-- tizen2.0 # build for distro two: tizen2.0\n| | `-- i586 # the same as above\n| |-- scratch.armv7l.0 # first build root for arm build\n| |-- scratch.i586.0 # second build root for x86 build\n| |-- scratch.i586.1 # third build root for x86 build\n| |-- scratch.i586.2 # fourth build root for x86 build\n| |-- scratch.i586.3 # fifth build root for x86 build\n| | # The above build root dir can be used by gbs chroot &lt;build root dir&gt;\n| `-- sources # sources generated for build, including tarball, spec, patches, etc.\n| |-- tizen\n| `-- tizen2.0\n`-- meta # meta data used by gbs\n\n\nExamples\n\nTo perform a basic build:\n\n\n  Build a single package:\n    $ cd package1$ gbs build -A i586\n    \n  \n  Build a package for different architectures:\n    \n      Note\n\n      Supported architectures include x86_64, i586, armv6l, armv7hl, armv7l, aarch64, mips, and mipsel.\n    \n\n    $ gbs build -A armv7l #build package for armv7l\n$ gbs build -A i586 #build package for i586\n    \n  \n  \n    Make a clean build by deleting the old build root.\n\n    The --clean option must be specified if the repository has been changed, for example, to another release.\n\n    $ gbs build -A armv7l --clean\n    \n  \n  Build the package with a specific commit:\n    $ gbs build -A armv7l --commit=&lt;COMMIT_ID&gt;\n    \n  \n  \n    Use the --overwrite option to trigger a rebuild.\n\n    If you have already built before, and want to rebuild, specify the --overwrite option or the packages are skipped.\n    $ gbs build -A i586 --overwrite\n    \n\n    If you change the commit or specify the --include-all option, it always rebuilds. In these cases, the --overwrite option is not needed.\n  \n  Output the debug info:\n    $ gbs build -A i586 --debug\n    \n  \n  \n    Build against a local repository.\n\n    You can configure the local repo in the .gbs.conf file or through the command line.\n    $ gbs build -R /path/to/repo/dir/ -A i586\n    \n  \n  \n    Use the --noinit option to build a package in offline mode.\n\n    This option can only be used if the build root is ready. When it is used, GBS does not connect the remote repository, and skips parsing and checking the repository and initializing the build environment. The package is built directly.\n\n    $ gbs build -A i586 # build first and create build environment\n$ gbs build -A i586 --noinit # use --noinit to start building directly\n    \n  \n  \n    Build with all uncommitted changes using the --include-all option.\n\n    In the following examples, the Git tree contains 1 modified file and 2 extra files:\n    $ git status -s\nM ail.pc.in\n?? base.repo\n?? main.repo\n    \n    \n      \n        Build without the --include-all option\n\n        Only committed files are built. None of the modified files, which are neither committed nor added, are built:\n\n        $ gbs build -A i586\nwarning: the following untracked files would NOT be included: base.repo main.repo\nwarning: the following uncommitted changes would NOT be included: ail.pc.in\nwarning: you can specify '--include-all' option to include these uncommitted and untracked files.\n....\ninfo: Binaries RPM packages can be found here:\n/home/test/GBS-ROOT/local/scratch.i586.0/home/abuild/rpmbuild/RPMS/\ninfo: Done\n        \n      \n      \n        Build with the --include-all option\n\n        All the files are built:\n        $ gbs build -A i586\nwarning: the following untracked files would NOT be included: base.repo main.repo\nwarning: the following uncommitted changes would NOT be included: ail.pc.in\nwarning: you can specify '--include-all' option to include these uncommitted and untracked files.\n....\ninfo: Binaries RPM packages can be found here:\n/home/test/GBS-ROOT/local/scratch.i586.0/home/abuild/rpmbuild/RPMS/\ninfo: Done\n        \n      \n      \n        Use .gitignore to ignore specific files when using the --include-all option.\n\n        If you want to ignore some file types, update your .gitignore:\n\n        $ cat .gitignore\n.*\n*/.*\n*.pyc\n*.patch*\n        \n      \n    \n  \n\n\nIncremental Build\n\nStarting from GBS 0.10, the gbs build subcommand supports the --incremental option, which allows you to build incrementally.\n\nThe incremental mode is designed for development and verification of single packages. It is not intended to replace the standard mode. Only 1 package can be built at a time using the incremental mode.\n\nThe incremental mode sets up the build environment in multiple steps, finishing by mounting the local Git tree of a package in the chroot build environment.\n\n\n  Note\n\n  Because GBS mounts your Git tree to the build root, be very careful when you remove your build root. You need to make sure you have already unmounted the source tree manually before you remove it.\n\n\nThe incremental mode has the following benefits:\n\n\n  The build environment uses the latest source code and changes to source do not trigger a new build environment (in the chroot).\n  The Git source tree becomes the source of the builds. Any change made in the Git repository followed by invocation of the build script builds the changed sources.\n  If the build fails for some reason, the build script continues from the spot where it has failed, once the code has been changed to fix the problem causing the failure.\n\n\nIncremental building is, in many ways, similar to traditional code development, where changes are made to sources, followed by running make to test and compile the changes. However, it enables development using the build environment of the target, instead of the host OS.\n\nThe incremental mode has some limitations, mostly related to packaging and how the sources are maintained. Among others, it depends on how the RPM spec file is composed:\n\n\n  \n    The incremental mode does not support patches in the spec file. All source has to be maintained as part of the Git tree.\n  \n  \n    The incremental mode requires a clean packaging workflow. Exotic workflows in the spec files do not always work well, because the incremental mode expects the following model:\n\n    \n      Code preparation (%prep)\n      Code building (%build)\n      Code installation (%install)\n    \n  \n  \n    The %prep section can only contain the %setup macro to unpack the tarball, and must not contain other source code-related operations, such as unpacking another source or applying patches.\n  \n  \n    Because the %build section is run every time, if the %build script has configuration scripts (auto-tools), binaries can be regenerated, causing a complete build every time. To avoid this, use the following macros, which can be overridden using the --no-configure option:\n\n    \n      %configure: runs the configure script with pre-defined paths and options.\n      %reconfigure: regenerates the scripts and runs %configure.\n      %autogen: runs the autogen script.\n    \n  \n  \n    You can build only a single package. You cannot build multiple packages in parallel.\n  \n  \n    The tarball’s name in the spec file must be %{name}-%{version}.{tar.gz|tar.bz2|zip|...}. Otherwise, GBS cannot mount the source code to build the root correctly.\n  \n\n\nThe following example uses the dlog source code. First, it builds with the --incremental option, then modifies 1 source file and triggers the incremental build again. You can see that only modified source code gets compiled during the incremental build.\n\n$ cd dlog\n# first build:\n$ gbs build -A i586 --incremental\n$ vim log.c # change code\n# second build:\n$ gbs build -A i586 --incremental\ninfo: generate repositories ...\ninfo: build conf has been downloaded at:\n/var/tmp/test-gbs/tizen.conf\ninfo: Start building packages from: /home/test/packages/dlog (git)\ninfo: Prepare sources...\ninfo: Retrieving repo metadata...\ninfo: Parsing package data...\ninfo: *** overwriting dlog-0.4.1-5.1 i586 ***\ninfo: Next pass:\ndlog\ninfo: *** building dlog-0.4.1-5.1 i586 tizen (worker: 0) ***\ninfo: Doing incremental build\n[ 0s] Memory limit set to 10854336KB\n[ 0s] Using BUILD_ROOT=/home/test/GBS-ROOT/local/scratch.i586.0\n[ 0s] Using BUILD_ARCH=i686:i586:i486:i386:noarch\n[ 0s] test-desktop started \"build dlog.spec\" at Thu Sep 13 07:36:14 UTC 2012.\n[ 0s] -----------------------------------------------------------------\n[ 0s] ----- building dlog.spec (user abuild)\n[ 0s] -----------------------------------------------------------------\n[ 0s] -----------------------------------------------------------------\n[ 0s] + rpmbuild --short-circuit -bc /home/abuild/rpmbuild/SOURCES/dlog.spec\n[ 0s] Executing(%build): /bin/sh -e /var/tmp/rpm-tmp.XLz8je\n[ 0s] + umask 022\n[ 0s] + export LD_AS_NEEDED\n[ 4s] + make -j4\n[ 4s] make all-am\n[ 4s] make[1]: Entering directory /home/abuild/rpmbuild/BUILD/dlog-0.4.1\n[ 4s] /bin/sh ./libtool --tag=CC --mode=compile gcc -c -o log.lo log.c\n[ 4s] mv -f .deps/log.Tpo .deps/log.Plo\n[ 4s] /bin/sh ./libtool --tag=CC --mode=link gcc -o libdlog.la /usr/lib log.lo\n[ 4s] libtool: link: gcc -shared .libs/log.o -o .libs/libdlog.so.0.0.0\n[ 4s] libtool: link: ar cru .libs/libdlog.a log.o\n[ 4s] libtool: link: ranlib .libs/libdlog.a\n[ 4s] make[1]: Leaving directory /home/abuild/rpmbuild/BUILD/dlog-0.4.1\n[ 4s] + exit 0\n[ 4s] finished \"build dlog.spec\" at Thu Sep 13 07:36:18 UTC 2012.\n[ 4s]\ninfo: finished incremental building dlog\ninfo: Local repo can be found here:\n/home/test/GBS-ROOT/local/repos/tizen/\ninfo: Done\n\n\nFrom the build log, you can see that only log.c has been re-compiled. That is the point of the incremental build behavior.\n\nThe --noinit option can be used together with --incremental to make a build more quickly:\n\n$ gbs build --incremental --noinit\n\n\nMultiple Package Build (Dependency Build)\n\nMultiple package build has been supported since GBS 0.10. If packages have dependencies on each other, GBS builds them in the correct order calculated by the dependency relationships. Previously built RPMs are used to build the packages that depend on them. This process is called a dependency build.\n\nTo perform a multiple package build:\n\n\n  \n    Build all packages under a specific package directory:\n\n    $ mkdir tizen-packages\n$ cp package1 package2 package3 ... tizen-packages/\n$ gbs build -A i586 tizen-packages # build all packages under tizen-packages\n    \n  \n  \n    Build multiple packages in parallel with the --threads option:\n\n    # current directory have multiple packages, --threads can be used to set the max build worker at the same time\n$ gbs build -A armv7l --threads=4\n    \n  \n  \n    Select a group of packages to be built:\n\n    \n      The --binary-from-file option specifies a text file that contains a name list of RPM packages to be built. The format in the text file is 1 package per line.\n      The --binary-list option specifies a list in which the package names are separated by commas.\n    \n\n    When the number of packages is small and the packages can be clearly listed in the command line, use the --binary-list option for simplicity.\n\n    $ gbs build -A i586 --binary-from-file=/path/to/packages.list\n$ gbs build -A i586 --binary-list=&lt;pkg1&gt;,&lt;pkg2&gt;\n    \n  \n  \n    Exclude certain packages:\n\n    \n      The --exclude option specifies a list in which the names of packages to be ignored are separated by commas.\n      The --exclude-from-file option specifies a text file that contains a name list of packages to be ignored.\n    \n\n    $ gbs build -A i586 tizen-packages --exclude=&lt;pkg1&gt;\n$ gbs build -A i586 tizen-packages --exclude=&lt;pkg1&gt;,&lt;pkg2&gt;\n$ gbs build -A i586 tizen-packages --exclude-from-file=/path/to/packages.list\n    \n  \n  \n    Build packages based on dependencies:\n\n    \n      The --deps option enables GBS to build specific packages, together with all related packages on which they depend.\n      The --rdep option enables GBS to build specific packages, together with all related packages that depend on them.\n    \n\n    The specific packages can be included by the --binary-from-file or --binary-list option, and excluded by the --exclude or --exclude-from-file option.\n\n    The --deps and --rdep options are compatible. When added at the same time, besides the specific packages, GBS builds not only the related packages on which they depend, but also all the related packages that depend on them.\n\n    $ gbs build -A i586 --binary-list=&lt;pkg1&gt;,&lt;pkg2&gt; --deps\n$ gbs build -A i586 --binary-list=&lt;pkg1&gt;,&lt;pkg2&gt; --rdeps\n$ gbs build -A i586 --binary-list=&lt;pkg1&gt;,&lt;pkg2&gt; --deps --rdeps\n    \n  \n\n\nUseful Building Options\n\nThe gbs build command offers some useful options:\n\n\n  \n    Install extra packages to build a root\n\n    The --extra-packs=&lt;packages separated by commas&gt; option can be used to install extra packages:\n\n    $ gbs build -A i586 --extra-packs=&lt;pkg1&gt;,&lt;pkg2&gt; --deps\n$ gbs build -A i586 --extra-packs=&lt;pkg1&gt;,&lt;pkg2&gt; --rdeps\n$ gbs build -A i586 --extra-packs=&lt;pkg1&gt;,&lt;pkg2&gt; --deps --rdeps\n    \n  \n  \n    Keep all packages in the build root\n\n    Generally, the GBS build removes unnecessary packages in the build root. While transferring to build another package, you can use the --keep-packs option to keep all unnecessary packages, and just install missing required build packages. This option can be used to speed up building multiple packages.\n\n    $ gbs build --keep-packs\n    \n\n    The --keep-packs option can be used to create 1 build root for building multiple packages. Once the build root is ready, you can use the --noinit option to build these packages quickly.\n\n    $ gbs build pkg1/ --keep-packs -A i586\n$ gbs build pkg2/ --keep-packs -A i586\n$ gbs build pkg3/ --keep-packs -A i586\n    \n\n    Now, the build root (~/GBS-ROOT/local/scratch.i586.0) is ready for building pkg1, pkg2, and pkg3. You can use the --noinit option to build them offline, and need waste no time to check for repository updates and build root.\n\n    $ gbs build pkg1 --noinit\n$ gbs build pkg2 --noinit\n$ gbs build pkg3 --noinit\n    \n  \n\n\nForcing GBS to Work in the Native Mode\n\nUse the --fallback-to-native option to force GBS to perform packaging for non-native packages in the native packaging mode in the packaging phase of the building process, that is, ignore the upstream branch and create a tarball from HEAD (by default) or specified commit without generating any patch. Adding the --fallback-to-native option when issuing the gbs build or gbs export command is equivalent to adding the fallback_to_native = true property into the [general] section of the GBS configuration file.\n\n\n  Note\n\n  This option serves as a work-around solution for solving export failures of some non-native packages caused by a tricky engineering problem. For Tizen native packages, GBS always performs packaging in the native packaging mode.\n\n\n$ gbs build -A i586 --fallback-to-native\n\n\nSkipping the Building of the src.rpm File\n\nNormally, 2 types of package files are created during the package building process:\n\n\n  Binary, or executable, package file\n  Source package file\n\n\nThe source package file (src.rpm) contains everything needed to recreate a specific version of a package. This makes the src.rpm file a great way to distribute source code. However, it is optional when developing source code, especially when the source Git tree is huge.\n\nAdding the --skip-srcrpm option enables GBS to skip the building of the src.rpm file, speeding up the building process of huge source Git trees during development:\n\n$ cd &lt;Path_to_crosswalk&gt;\n$ gbs build -A i586 --skip-srcrpm\n\n\nUsing Distributed Compiler Networks\n\nThough GBS provides the --threads option to speed up the build process by activating multiple build workers, the efficiency of just using multiple build workers in 1 local machine is far from satisfactory, especially for a huge Git tree, such as crosswalk.\n\nTo improve the build process efficiency further, use the --icecream option, which activates distributed compiler networks. The option makes GBS use build workers on both the local machine and distributed networks.\n\n$ gbs build -A i586 --icecream=10\n\n\nFetching the Project Build Conf and Customizing the Build Root (for Advanced Users)\n\nThe project build conf describes the build configurations for the project, including all macros, packages, and flags predefined in the build environment. In Tizen releases, the build conf is released together with the released repository.\n\n\n  \n    Fetch the build conf automatically with the gbs build command\n\n    Starting from GBS 0.7.1, by default, GBS fetches the build conf from a remote repository (if you specify the remote Tizen repository) and stores it in your temporary environment:\n\n    $ gbs build -A i586\ninfo: generate repositories ...\ninfo: build conf has been downloaded at:\n/var/tmp/&lt;user&gt;-gbs/tizen2.0.conf\ninfo: generate tar ball: packaging/acpid-2.0.14.tar.bz2\n[sudo] password for &lt;user&gt;:\n    \n  \n  \n    Build the package using your own project build conf, by using the -D option\n\n    You can save and modify the build conf, and use it for your own purposes:\n\n    $ cp /var/tmp/&lt;user&gt;-gbs/tizen2.0.conf ~/tizen2.0.conf\n$ gbs build -A i586 -D ~/tizen2.0.conf\n    \n  \n\n\nTo customize the build config, see http://en.opensuse.org/openSUSE:Build_Service_prjconf."
					}
					
				
			
		
			
				
					,
					
					"application-reference-gbs-gbs-maintenance-models": {
						"id": "application-reference-gbs-gbs-maintenance-models",
						"title": "Maintenance Models Supported by GBS",
						"categories": "",
						"url": " application/reference/gbs/gbs-maintenance-models/",
						"content": "Maintenance Models Supported by GBS\n\nFrom a package maintenance point of view, packages can be divided into 2 categories:\n\n\n  Native packages, where you (Tizen) are the upstream and control the source code repository. An example in the context of Tizen could be power-manager. For native packages, you control the versioning and releasing, so package maintenance is simpler. You can release a new version basically whenever you want.\n  Non-native (or upstream) packages, for which you (Tizen) are not the upstream. For example, the Linux kernel or zlib. For these packages, you need to follow the releasing process and schedule of the upstream project. For example, from a developer and legal point of view, it is very beneficial to clearly track the local modifications (that is, separate upstream and local changes) both in the source code repository and on the packaging level.\n\n\nGBS divides packages into these 2 categories. GBS determines a package as non-native, if the Git repository has an upstream branch. The actual name of the upstream branch can be configured using the upstream_branch  option in the .gbs.conf file or with the --upstream-branch command line option.\n\nGBS build, remotebuild, and export commands behave differently for native and non-native packages. Namely, the preparation of the packaging files for building differs.\n\nGBS currently supports 2 different maintenance models for non-native packages: one with packaging and source code in the same branch and one with separate packaging and development branches.\n\nGBS and Native Packages\n\nGBS simply creates a monolithic source tarball from the HEAD of the current branch. Packaging files, from the packaging directory, are copied as is. No patch generation is done.\n\nThe Git repository layout looks like this:\n\n         v1.0    v2.0\n            |       |\no---A---B---C---D---E   master\n\n\nGBS and Non-native Packages with Joint-packaging\n\nIn the joint-packaging model (where packaging and development are in the same branch), packaging data (spec file etc) is kept in the same branch with the source code:\n\n              F---G---H   master (packaging + code changes)\n             /\no---A---B---C---D---E     upstream\n            |       |\n          v1.0    v2.0\n\n\nGBS tries to create a (real) upstream source tarball, auto-generate patches from the local changes, and auto-update the spec file accordingly. The logic is the following:\n\n\n  Generate patches\n    \n      Create patches between upstream-tag…HEAD, and remove possible old patches\n      Update the spec file: remove old Patch: tags and %patch macros and replace them with ones that correspond with the newly generated patches.\n    \n  \n  Create an upstream tarball if patch-generation was successful\n    \n      If the Git repository has a pristine-tar branch (and you have the pristine-tar tool installed), GBS tries to checkout the source tarball with pristine-tar.\n      If the previous step fails, GBS tries to create a source tarball from the correct upstream tag, matching the version taken from the .spec file.\n    \n  \n  If the source tarball or patch generation fails, GBS reverts back to the old method (that is, treats the package as native), creating just 1 monolithic tarball without patch generation.\n\n\nYou cannot have any pre-existing patches in the packaging directory or spec file. Otherwise, GBS refuses to create patches. For information on manually maintained patches, see Manually Maintained Patches.\n\nGBS and Non-native Packages with Orphan-packaging\n\nIn the orphan-packaging model (with separate packaging and development branches), packaging data is kept in a separate (orphan) branch with no source code or common history with the code development branches:\n\no---I---J---K---L         master (packaging)\n\n              F---G---H   development/master/1.0 (local source code changes)\n             /\no---A---B---C---D---E     upstream\n            |       |\n          v1.0    v2.0\n\n\nAll packaging data, including patches, is stored in the packaging branch. The development branch only contains upstream sources with no packaging data. The gbs devel command assists in working with the separate branches.\n\nDevelopers work on the development branch, making changes to the source code. When the package maintainer wants to release a new version of the package, they export changes (with gbs devel, 1 patch per commit) from the development branch to the packaging branch, commit the changes, update the change log, and submit a new version.\n\nWhen building/exporting the package, GBS creates a real upstream source tarball (similar to the joint-packaging model). Patches are auto-generated (and the spec file auto-modified) when working on the development branch. When working on the packaging branch, the packaging files are exported with no modifications.\n\nBuilding in the Joint-packaging Model\n\nFor GBS to see the package as non-native (which enables upstream source tarball and patch generation), you need to:\n\n\n  Have an upstream branch in the Git repository, with untouched upstream sources.\n  Have the upstream tag format configured correctly in the package-specific .gbs.conf file. The default is upstream/${upstreamversion}.\n  Have your development branch be based on the upstream version (indicated in the .spec file).\n  Have all your local manually maintained patches (in the packaging directory) applied to your development branch and removed from the packaging directory.\n\n\nAdditionally, you can have a pristine-tar branch in the Git repository for generating the upstream tarball with the pristine-tar tool.\n\nEdit, commit, and build code on your development branch. GBS handles the tarball and patch generation, as well as updating the .spec file. The following example demonstrates how GBS behaves in this situation (gbs export is being used as an example here for the truncated output):\n\n$ gbs export -o export\ninfo: Generating patches from git (v1.2.7..HEAD)\ninfo: Didn't find any old '%patch' macros, adding new patches after the last '%setup' macro at line %s\ninfo: Didn't find any old 'Patch' tags, adding new patches after the last 'Source' tag.\ninfo: zlib-1.2.7.tar.bz2 does not exist, creating from 'v1.2.7'\ninfo: package files have been exported to:\n/home/test/src/zlib/export/zlib-1.2.7-0\n\n\nWhen trying out the patch generation for the first time, first run the export command and examine the auto-updated spec file in the export directory to ensure that GBS updated it correctly. For information on manually maintained patches, see Manually Maintained Patches.\n\nThe upstream tarball and patch generation operation can fail for several reasons:\n\n\n  Upstream tag was not found\n    \n      Correct version is not present in the Git repository\n      Tag format is configured incorrectly\n    \n  \n  Current branch is not a descendant of the upstream version that it claims to be derived from\n\n\nBuilding in the Orphan-packaging Model\n\nIn order to use the orphan-packaging model with non-native packages, you need to:\n\n\n  Have an upstream branch in the Git repository, with untouched upstream sources.\n  Have the upstream tag format configured correctly in the package-specific .gbs.conf file. The default is upstream/${upstreamversion}.\n  Have an orphan packaging branch that only contains packaging files, including patches.\n  Have a development branch in which all patches have been applied on top of the upstream version.\n\n\nAgain, additionally, you can have a pristine-tar branch in the Git repository for generating the upstream tarball with the pristine-tar tool.\n\nCode development is done on the development branch: edit, commit, and build similarly to the joint-packaging model. However, all packaging changes are done in the packaging branch. And most importantly, submissions (releasing to integration) are done from the packaging branch. Before submitting, the package maintainer creates patches from the new changes in the development branch and commits these to the packaging branch. For more information on how to manage packaging and development branches, see gbs devel.\n\nManaging Upstream Sources\n\nTo maintain packages using the model described above, you need to keep unmodified upstream sources in a separate branch in your Git repository. GBS supports 2 models for this.\n\n\n  \n    Import upstream source archive to Git\n\n    In this model, you import source tarballs (or ZIP files) from the upstream release to your Git repository using the gbs import command. GBS commits the sources in the upstream branch and creates a tag for the upstream release. An example of starting from scratch, that is importing to an empty repo:\n\n    $ mkdir zlib &amp;&amp; cd zlib &amp;&amp; git init\n$ gbs import ../zlib-1.2.6.tar.gz\n...\n$ git branch\n* master\nupstream\n$ git tag\nupstream/1.2.6\n    \n\n    Now you can start development just by adding packaging files to the master branch. When you need to update to a newer upstream version, use the gbs import command again:\n\n    $ gbs import ../zlib-1.2.7.tar.gz\n$ git tag\nupstream/1.2.6\nupstream/1.2.7\n    \n\n    \n      Note\n\n      Currently, GBS automatically merges the new upstream version to your master branch. You need to update the version number in your spec file accordingly.\n    \n  \n  \n    Track the remote Git\n\n    In this model, you directly track a remote (Git) repository and the gbs import command is not used. GBS needs to know only the name of the upstream branch and the format of the upstream release tags. These are package-dependent information so you must configure them in a package-specific .gbs.conf in the master branch. For example, to start a package from scratch:\n\n    $ git clone git://github.com/madler/zlib.git &amp;&amp; cd zlib\n$ git branch -m master origin # to keep origin tracking the upstream\n$ git checkout -b master\n$ vim .gbs.conf\n$ git add .gbs.conf &amp;&amp; git commit -m\"Add gbs.conf\"\n    \n\n    The example .gbs.conf configuration file is:\n\n    [general]\nupstream_branch = origin\nupstream_tag = v${upstreamversion}\n    \n  \n\n\nPristine-tar Support\n\nYou can use the pristine-tar for storing and checking out the upstream tarballs (see http://joeyh.name/code/pristine-tar/). You can install pristine-tar from the Tizen tools repository. The tool guarantees that the tarball generated by GBS is bit-identical to the real upstream release source tarball. GBS uses pristine-tar automatically if you have it installed on your system. If you use gbs import to manage the upstream sources, it automatically commits new tarballs to the pristine-tar branch.\n\n\n  Note\n\n  The use of the pristine-tar tool is optional, but highly recommended.\n\n\nHowever, if you track a remote upstream repository directly, you need to commit the upstream source tarballs to the pristine-tar branch manually. For example:\n\n$ cd zlib\n$ git branch\n* master\norigin\n$ pristine-tar commit ../zlib-1.2.7.tar.gz v1.2.7\n$ git branch\n* master\norigin\npristine-tar\n\n\nConverting an Existing Repository to a Non-native Package\n\nTo convert an existing repository to a non-native package:\n\n\n  An upstream branch is required:\n    \n      If you are already tracking the upstream, just configure the upstream branch name and tag format in the package-specific .gbp.conf file.\n      If not, import the upstream source tarball with gbs import or add the upstream remote to your repository and start tracking that.\n        \n          Tip:\n\n          If you are tracking the upstream Git directly, consider running the pristine-tar commit &lt;tarball&gt; &lt;upstream-tag&gt; command.\n        \n      \n    \n  \n  Rebase your current development branch on the correct upstream version (that is, rebase on the upstream tag).\n  Remove all local patches: apply and commit them on top of your development branch and then remove the patches from the packaging directory and preferably from the spec file, too.\n  Optionally, if you want to maintain the package using the orphan-packaging model, you can create the packaging and development branches using the gbs devel convert command.\n\n\nAdvanced Usage\n\n\nManually Maintained Patches\n\nGBS supports patches that are maintained manually, outside the automatic patch generation. This can be needed for architecture-dependent patches, for example, as GBS patch generation does not yet support conditional patches. Another example are patches that are applied on top of a secondary source tree, whose sources are not maintained in your Git tree, but only as a tarball in your packaging directory.\n\nTo use this feature, you must have your patches in the packaging directory and listed in the spec file. In addition, you must mark the patch to be ignored by the patch generation/importing by putting the # Gbp-Ignore-Patches: &lt;patch numbers&gt; line into the spec file. This makes GBS ignore the Patch: tags and %patch macros of the listed patches when importing or generating patches. An excerpt of an example spec file:\n\n...\nSource0: %{name}-%{version}.tar.bz2\n# Gbp-Ignore-Patches: 0\nPatch0: my.patch\n\n%description\n...\n\n\nThe Gbp-Ignore-Patches marker can be placed anywhere in the file, and is case-insensitive. The GBP prefix comes from git-buildpackage (gbp), which is used by GBS as the backend for patch generation.\n\n\n  Note\n\n  Pay attention to patch generation when building or exporting. The gbs import tool also ignores patches marked for manual maintenance when importing source RPMs.\n\n\nPatch Macro Location\n\nGBS tries to automatically find the correct location to add the %patch macros in the spec file when updating it with the newly generated patches. This is usually successful, but GBS can also guess wrong. You can manually mark the location for auto-generated %patch macros by adding a # Gbp-Patch-Macros marker line into the spec file:\n\n...\n%prep\n%setup\n# do things here...\n\n# Gbp-Patch-Macros\n\n# do more things here...\n\n%build\n\n\nGBS places the new %patch macros after the marker line. This marker is case-insensitive, similar to # Gbp-Ignore-Patches.\n\nSquashing Commits\n\nWhen generating patches, GBS supports squashing several commits into 1 monolithic diff. Currently, you can only squash from upstream-tag up to a given commit-ish. An example use case is squashing commits from an upstream release up to a stable update into a single diff (commits on top of the stable generate multiple patches normally). You can enable this with the squash_patches_until config file option or with the --squash-patches-until command line option: the format for the option is &lt;commit-ish&gt;[:&lt;filename-base&gt;].\n\nFor example:\n\n$ git branch\n* master\nstable\nupstream\n$ gbs export --squash-patches-until=stable:stable-update\ninfo: Generating patches from git (upstream/0.1.2..HEAD)\ninfo: Squashing commits a2a7d82..9c0f5ba into one monolithic 'stable-update.diff'\ninfo: Didn't find any old 'Patch' tags, adding new patches after the last 'Source' tag.\ninfo: Didn't find any old '%patch' macros, adding new patches after the last '%setup' macro\ninfo: mypackage-0.1.2.tar.gz does not exist, creating from 'upstream/0.1.2'\ninfo: package files have been exported to:\n/home/user/src/mypackage/packaging/mypackage-0.1.2-1.21\n\n\n\n  Note\n\n  If you are planning to use this feature, configure it in the package-specific .gbs.conf file. This way, all users (including the automatic build machinery) build and export the package in a similar way."
					}
					
				
			
		
			
				
					,
					
					"platform-reference-gbs-gbs-maintenance-models": {
						"id": "platform-reference-gbs-gbs-maintenance-models",
						"title": "Maintenance Models Supported by GBS",
						"categories": "",
						"url": " platform/reference/gbs/gbs-maintenance-models/",
						"content": "Maintenance Models Supported by GBS\n\nFrom a package maintenance point of view, packages can be divided into 2 categories:\n\n\n  Native packages, where you (Tizen) are the upstream and control the source code repository. An example in the context of Tizen could be power-manager. For native packages, you control the versioning and releasing, so package maintenance is simpler. You can release a new version basically whenever you want.\n  Non-native (or upstream) packages, for which you (Tizen) are not the upstream. For example, the Linux kernel or zlib. For these packages, you need to follow the releasing process and schedule of the upstream project. For example, from a developer and legal point of view, it is very beneficial to clearly track the local modifications (that is, separate upstream and local changes) both in the source code repository and on the packaging level.\n\n\nGBS divides packages into these 2 categories. GBS determines a package as non-native, if the Git repository has an upstream branch. The actual name of the upstream branch can be configured using the upstream_branch  option in the .gbs.conf file or with the --upstream-branch command line option.\n\nGBS build, remotebuild, and export commands behave differently for native and non-native packages. Namely, the preparation of the packaging files for building differs.\n\nGBS currently supports 2 different maintenance models for non-native packages: one with packaging and source code in the same branch and one with separate packaging and development branches.\n\nGBS and Native Packages\n\nGBS simply creates a monolithic source tarball from the HEAD of the current branch. Packaging files, from the packaging directory, are copied as is. No patch generation is done.\n\nThe Git repository layout looks like this:\n\n         v1.0    v2.0\n            |       |\no---A---B---C---D---E   master\n\n\nGBS and Non-native Packages with Joint-packaging\n\nIn the joint-packaging model (where packaging and development are in the same branch), packaging data (spec file etc) is kept in the same branch with the source code:\n\n              F---G---H   master (packaging + code changes)\n             /\no---A---B---C---D---E     upstream\n            |       |\n          v1.0    v2.0\n\n\nGBS tries to create a (real) upstream source tarball, auto-generate patches from the local changes, and auto-update the spec file accordingly. The logic is the following:\n\n\n  Generate patches\n    \n      Create patches between upstream-tag…HEAD, and remove possible old patches\n      Update the spec file: remove old Patch: tags and %patch macros and replace them with ones that correspond with the newly generated patches.\n    \n  \n  Create an upstream tarball if patch-generation was successful\n    \n      If the Git repository has a pristine-tar branch (and you have the pristine-tar tool installed), GBS tries to checkout the source tarball with pristine-tar.\n      If the previous step fails, GBS tries to create a source tarball from the correct upstream tag, matching the version taken from the .spec file.\n    \n  \n  If the source tarball or patch generation fails, GBS reverts back to the old method (that is, treats the package as native), creating just 1 monolithic tarball without patch generation.\n\n\nYou cannot have any pre-existing patches in the packaging directory or spec file. Otherwise, GBS refuses to create patches. For information on manually maintained patches, see Manually Maintained Patches.\n\nGBS and Non-native Packages with Orphan-packaging\n\nIn the orphan-packaging model (with separate packaging and development branches), packaging data is kept in a separate (orphan) branch with no source code or common history with the code development branches:\n\no---I---J---K---L         master (packaging)\n\n              F---G---H   development/master/1.0 (local source code changes)\n             /\no---A---B---C---D---E     upstream\n            |       |\n          v1.0    v2.0\n\n\nAll packaging data, including patches, is stored in the packaging branch. The development branch only contains upstream sources with no packaging data. The gbs devel command assists in working with the separate branches.\n\nDevelopers work on the development branch, making changes to the source code. When the package maintainer wants to release a new version of the package, they export changes (with gbs devel, 1 patch per commit) from the development branch to the packaging branch, commit the changes, update the change log, and submit a new version.\n\nWhen building/exporting the package, GBS creates a real upstream source tarball (similar to the joint-packaging model). Patches are auto-generated (and the spec file auto-modified) when working on the development branch. When working on the packaging branch, the packaging files are exported with no modifications.\n\nBuilding in the Joint-packaging Model\n\nFor GBS to see the package as non-native (which enables upstream source tarball and patch generation), you need to:\n\n\n  Have an upstream branch in the Git repository, with untouched upstream sources.\n  Have the upstream tag format configured correctly in the package-specific .gbs.conf file. The default is upstream/${upstreamversion}.\n  Have your development branch be based on the upstream version (indicated in the .spec file).\n  Have all your local manually maintained patches (in the packaging directory) applied to your development branch and removed from the packaging directory.\n\n\nAdditionally, you can have a pristine-tar branch in the Git repository for generating the upstream tarball with the pristine-tar tool.\n\nEdit, commit, and build code on your development branch. GBS handles the tarball and patch generation, as well as updating the .spec file. The following example demonstrates how GBS behaves in this situation (gbs export is being used as an example here for the truncated output):\n\n$ gbs export -o export\ninfo: Generating patches from git (v1.2.7..HEAD)\ninfo: Didn't find any old '%patch' macros, adding new patches after the last '%setup' macro at line %s\ninfo: Didn't find any old 'Patch' tags, adding new patches after the last 'Source' tag.\ninfo: zlib-1.2.7.tar.bz2 does not exist, creating from 'v1.2.7'\ninfo: package files have been exported to:\n/home/test/src/zlib/export/zlib-1.2.7-0\n\n\nWhen trying out the patch generation for the first time, first run the export command and examine the auto-updated spec file in the export directory to ensure that GBS updated it correctly. For information on manually maintained patches, see Manually Maintained Patches.\n\nThe upstream tarball and patch generation operation can fail for several reasons:\n\n\n  Upstream tag was not found\n    \n      Correct version is not present in the Git repository\n      Tag format is configured incorrectly\n    \n  \n  Current branch is not a descendant of the upstream version that it claims to be derived from\n\n\nBuilding in the Orphan-packaging Model\n\nIn order to use the orphan-packaging model with non-native packages, you need to:\n\n\n  Have an upstream branch in the Git repository, with untouched upstream sources.\n  Have the upstream tag format configured correctly in the package-specific .gbs.conf file. The default is upstream/${upstreamversion}.\n  Have an orphan packaging branch that only contains packaging files, including patches.\n  Have a development branch in which all patches have been applied on top of the upstream version.\n\n\nAgain, additionally, you can have a pristine-tar branch in the Git repository for generating the upstream tarball with the pristine-tar tool.\n\nCode development is done on the development branch: edit, commit, and build similarly to the joint-packaging model. However, all packaging changes are done in the packaging branch. And most importantly, submissions (releasing to integration) are done from the packaging branch. Before submitting, the package maintainer creates patches from the new changes in the development branch and commits these to the packaging branch. For more information on how to manage packaging and development branches, see gbs devel.\n\nManaging Upstream Sources\n\nTo maintain packages using the model described above, you need to keep unmodified upstream sources in a separate branch in your Git repository. GBS supports 2 models for this.\n\n\n  \n    Import upstream source archive to Git\n\n    In this model, you import source tarballs (or ZIP files) from the upstream release to your Git repository using the gbs import command. GBS commits the sources in the upstream branch and creates a tag for the upstream release. An example of starting from scratch, that is importing to an empty repo:\n\n    $ mkdir zlib &amp;&amp; cd zlib &amp;&amp; git init\n$ gbs import ../zlib-1.2.6.tar.gz\n...\n$ git branch\n* master\nupstream\n$ git tag\nupstream/1.2.6\n    \n\n    Now you can start development just by adding packaging files to the master branch. When you need to update to a newer upstream version, use the gbs import command again:\n\n    $ gbs import ../zlib-1.2.7.tar.gz\n$ git tag\nupstream/1.2.6\nupstream/1.2.7\n    \n\n    \n      Note\n\n      Currently, GBS automatically merges the new upstream version to your master branch. You need to update the version number in your spec file accordingly.\n    \n  \n  \n    Track the remote Git\n\n    In this model, you directly track a remote (Git) repository and the gbs import command is not used. GBS needs to know only the name of the upstream branch and the format of the upstream release tags. These are package-dependent information so you must configure them in a package-specific .gbs.conf in the master branch. For example, to start a package from scratch:\n\n    $ git clone git://github.com/madler/zlib.git &amp;&amp; cd zlib\n$ git branch -m master origin # to keep origin tracking the upstream\n$ git checkout -b master\n$ vim .gbs.conf\n$ git add .gbs.conf &amp;&amp; git commit -m\"Add gbs.conf\"\n    \n\n    The example .gbs.conf configuration file is:\n\n    [general]\nupstream_branch = origin\nupstream_tag = v${upstreamversion}\n    \n  \n\n\nPristine-tar Support\n\nYou can use the pristine-tar for storing and checking out the upstream tarballs (see http://joeyh.name/code/pristine-tar/). You can install pristine-tar from the Tizen tools repository. The tool guarantees that the tarball generated by GBS is bit-identical to the real upstream release source tarball. GBS uses pristine-tar automatically if you have it installed on your system. If you use gbs import to manage the upstream sources, it automatically commits new tarballs to the pristine-tar branch.\n\n\n  Note\n\n  The use of the pristine-tar tool is optional, but highly recommended.\n\n\nHowever, if you track a remote upstream repository directly, you need to commit the upstream source tarballs to the pristine-tar branch manually. For example:\n\n$ cd zlib\n$ git branch\n* master\norigin\n$ pristine-tar commit ../zlib-1.2.7.tar.gz v1.2.7\n$ git branch\n* master\norigin\npristine-tar\n\n\nConverting an Existing Repository to a Non-native Package\n\nTo convert an existing repository to a non-native package:\n\n\n  An upstream branch is required:\n    \n      If you are already tracking the upstream, just configure the upstream branch name and tag format in the package-specific .gbp.conf file.\n      If not, import the upstream source tarball with gbs import or add the upstream remote to your repository and start tracking that.\n        \n          Tip:\n\n          If you are tracking the upstream Git directly, consider running the pristine-tar commit &lt;tarball&gt; &lt;upstream-tag&gt; command.\n        \n      \n    \n  \n  Rebase your current development branch on the correct upstream version (that is, rebase on the upstream tag).\n  Remove all local patches: apply and commit them on top of your development branch and then remove the patches from the packaging directory and preferably from the spec file, too.\n  Optionally, if you want to maintain the package using the orphan-packaging model, you can create the packaging and development branches using the gbs devel convert command.\n\n\nAdvanced Usage\n\n\nManually Maintained Patches\n\nGBS supports patches that are maintained manually, outside the automatic patch generation. This can be needed for architecture-dependent patches, for example, as GBS patch generation does not yet support conditional patches. Another example are patches that are applied on top of a secondary source tree, whose sources are not maintained in your Git tree, but only as a tarball in your packaging directory.\n\nTo use this feature, you must have your patches in the packaging directory and listed in the spec file. In addition, you must mark the patch to be ignored by the patch generation/importing by putting the # Gbp-Ignore-Patches: &lt;patch numbers&gt; line into the spec file. This makes GBS ignore the Patch: tags and %patch macros of the listed patches when importing or generating patches. An excerpt of an example spec file:\n\n...\nSource0: %{name}-%{version}.tar.bz2\n# Gbp-Ignore-Patches: 0\nPatch0: my.patch\n\n%description\n...\n\n\nThe Gbp-Ignore-Patches marker can be placed anywhere in the file, and is case-insensitive. The GBP prefix comes from git-buildpackage (gbp), which is used by GBS as the backend for patch generation.\n\n\n  Note\n\n  Pay attention to patch generation when building or exporting. The gbs import tool also ignores patches marked for manual maintenance when importing source RPMs.\n\n\nPatch Macro Location\n\nGBS tries to automatically find the correct location to add the %patch macros in the spec file when updating it with the newly generated patches. This is usually successful, but GBS can also guess wrong. You can manually mark the location for auto-generated %patch macros by adding a # Gbp-Patch-Macros marker line into the spec file:\n\n...\n%prep\n%setup\n# do things here...\n\n# Gbp-Patch-Macros\n\n# do more things here...\n\n%build\n\n\nGBS places the new %patch macros after the marker line. This marker is case-insensitive, similar to # Gbp-Ignore-Patches.\n\nSquashing Commits\n\nWhen generating patches, GBS supports squashing several commits into 1 monolithic diff. Currently, you can only squash from upstream-tag up to a given commit-ish. An example use case is squashing commits from an upstream release up to a stable update into a single diff (commits on top of the stable generate multiple patches normally). You can enable this with the squash_patches_until config file option or with the --squash-patches-until command line option: the format for the option is &lt;commit-ish&gt;[:&lt;filename-base&gt;].\n\nFor example:\n\n$ git branch\n* master\nstable\nupstream\n$ gbs export --squash-patches-until=stable:stable-update\ninfo: Generating patches from git (upstream/0.1.2..HEAD)\ninfo: Squashing commits a2a7d82..9c0f5ba into one monolithic 'stable-update.diff'\ninfo: Didn't find any old 'Patch' tags, adding new patches after the last 'Source' tag.\ninfo: Didn't find any old '%patch' macros, adding new patches after the last '%setup' macro\ninfo: mypackage-0.1.2.tar.gz does not exist, creating from 'upstream/0.1.2'\ninfo: package files have been exported to:\n/home/user/src/mypackage/packaging/mypackage-0.1.2-1.21\n\n\n\n  Note\n\n  If you are planning to use this feature, configure it in the package-specific .gbs.conf file. This way, all users (including the automatic build machinery) build and export the package in a similar way."
					}
					
				
			
		
			
				
					,
					
					"iot-reference-gbs-gbs-maintenance-models": {
						"id": "iot-reference-gbs-gbs-maintenance-models",
						"title": "Maintenance Models Supported by GBS",
						"categories": "",
						"url": " iot/reference/gbs/gbs-maintenance-models/",
						"content": "Maintenance Models Supported by GBS\n\nFrom a package maintenance point of view, packages can be divided into 2 categories:\n\n\n  Native packages, where you (Tizen) are the upstream and control the source code repository. An example in the context of Tizen could be power-manager. For native packages, you control the versioning and releasing, so package maintenance is simpler. You can release a new version basically whenever you want.\n  Non-native (or upstream) packages, for which you (Tizen) are not the upstream. For example, the Linux kernel or zlib. For these packages, you need to follow the releasing process and schedule of the upstream project. For example, from a developer and legal point of view, it is very beneficial to clearly track the local modifications (that is, separate upstream and local changes) both in the source code repository and on the packaging level.\n\n\nGBS divides packages into these 2 categories. GBS determines a package as non-native, if the Git repository has an upstream branch. The actual name of the upstream branch can be configured using the upstream_branch  option in the .gbs.conf file or with the --upstream-branch command line option.\n\nGBS build, remotebuild, and export commands behave differently for native and non-native packages. Namely, the preparation of the packaging files for building differs.\n\nGBS currently supports 2 different maintenance models for non-native packages: one with packaging and source code in the same branch and one with separate packaging and development branches.\n\nGBS and Native Packages\n\nGBS simply creates a monolithic source tarball from the HEAD of the current branch. Packaging files, from the packaging directory, are copied as is. No patch generation is done.\n\nThe Git repository layout looks like this:\n\n         v1.0    v2.0\n            |       |\no---A---B---C---D---E   master\n\n\nGBS and Non-native Packages with Joint-packaging\n\nIn the joint-packaging model (where packaging and development are in the same branch), packaging data (spec file etc) is kept in the same branch with the source code:\n\n              F---G---H   master (packaging + code changes)\n             /\no---A---B---C---D---E     upstream\n            |       |\n          v1.0    v2.0\n\n\nGBS tries to create a (real) upstream source tarball, auto-generate patches from the local changes, and auto-update the spec file accordingly. The logic is the following:\n\n\n  Generate patches\n    \n      Create patches between upstream-tag…HEAD, and remove possible old patches\n      Update the spec file: remove old Patch: tags and %patch macros and replace them with ones that correspond with the newly generated patches.\n    \n  \n  Create an upstream tarball if patch-generation was successful\n    \n      If the Git repository has a pristine-tar branch (and you have the pristine-tar tool installed), GBS tries to checkout the source tarball with pristine-tar.\n      If the previous step fails, GBS tries to create a source tarball from the correct upstream tag, matching the version taken from the .spec file.\n    \n  \n  If the source tarball or patch generation fails, GBS reverts back to the old method (that is, treats the package as native), creating just 1 monolithic tarball without patch generation.\n\n\nYou cannot have any pre-existing patches in the packaging directory or spec file. Otherwise, GBS refuses to create patches. For information on manually maintained patches, see Manually Maintained Patches.\n\nGBS and Non-native Packages with Orphan-packaging\n\nIn the orphan-packaging model (with separate packaging and development branches), packaging data is kept in a separate (orphan) branch with no source code or common history with the code development branches:\n\no---I---J---K---L         master (packaging)\n\n              F---G---H   development/master/1.0 (local source code changes)\n             /\no---A---B---C---D---E     upstream\n            |       |\n          v1.0    v2.0\n\n\nAll packaging data, including patches, is stored in the packaging branch. The development branch only contains upstream sources with no packaging data. The gbs devel command assists in working with the separate branches.\n\nDevelopers work on the development branch, making changes to the source code. When the package maintainer wants to release a new version of the package, they export changes (with gbs devel, 1 patch per commit) from the development branch to the packaging branch, commit the changes, update the change log, and submit a new version.\n\nWhen building/exporting the package, GBS creates a real upstream source tarball (similar to the joint-packaging model). Patches are auto-generated (and the spec file auto-modified) when working on the development branch. When working on the packaging branch, the packaging files are exported with no modifications.\n\nBuilding in the Joint-packaging Model\n\nFor GBS to see the package as non-native (which enables upstream source tarball and patch generation), you need to:\n\n\n  Have an upstream branch in the Git repository, with untouched upstream sources.\n  Have the upstream tag format configured correctly in the package-specific .gbs.conf file. The default is upstream/${upstreamversion}.\n  Have your development branch be based on the upstream version (indicated in the .spec file).\n  Have all your local manually maintained patches (in the packaging directory) applied to your development branch and removed from the packaging directory.\n\n\nAdditionally, you can have a pristine-tar branch in the Git repository for generating the upstream tarball with the pristine-tar tool.\n\nEdit, commit, and build code on your development branch. GBS handles the tarball and patch generation, as well as updating the .spec file. The following example demonstrates how GBS behaves in this situation (gbs export is being used as an example here for the truncated output):\n\n$ gbs export -o export\ninfo: Generating patches from git (v1.2.7..HEAD)\ninfo: Didn't find any old '%patch' macros, adding new patches after the last '%setup' macro at line %s\ninfo: Didn't find any old 'Patch' tags, adding new patches after the last 'Source' tag.\ninfo: zlib-1.2.7.tar.bz2 does not exist, creating from 'v1.2.7'\ninfo: package files have been exported to:\n/home/test/src/zlib/export/zlib-1.2.7-0\n\n\nWhen trying out the patch generation for the first time, first run the export command and examine the auto-updated spec file in the export directory to ensure that GBS updated it correctly. For information on manually maintained patches, see Manually Maintained Patches.\n\nThe upstream tarball and patch generation operation can fail for several reasons:\n\n\n  Upstream tag was not found\n    \n      Correct version is not present in the Git repository\n      Tag format is configured incorrectly\n    \n  \n  Current branch is not a descendant of the upstream version that it claims to be derived from\n\n\nBuilding in the Orphan-packaging Model\n\nIn order to use the orphan-packaging model with non-native packages, you need to:\n\n\n  Have an upstream branch in the Git repository, with untouched upstream sources.\n  Have the upstream tag format configured correctly in the package-specific .gbs.conf file. The default is upstream/${upstreamversion}.\n  Have an orphan packaging branch that only contains packaging files, including patches.\n  Have a development branch in which all patches have been applied on top of the upstream version.\n\n\nAgain, additionally, you can have a pristine-tar branch in the Git repository for generating the upstream tarball with the pristine-tar tool.\n\nCode development is done on the development branch: edit, commit, and build similarly to the joint-packaging model. However, all packaging changes are done in the packaging branch. And most importantly, submissions (releasing to integration) are done from the packaging branch. Before submitting, the package maintainer creates patches from the new changes in the development branch and commits these to the packaging branch. For more information on how to manage packaging and development branches, see gbs devel.\n\nManaging Upstream Sources\n\nTo maintain packages using the model described above, you need to keep unmodified upstream sources in a separate branch in your Git repository. GBS supports 2 models for this.\n\n\n  \n    Import upstream source archive to Git\n\n    In this model, you import source tarballs (or ZIP files) from the upstream release to your Git repository using the gbs import command. GBS commits the sources in the upstream branch and creates a tag for the upstream release. An example of starting from scratch, that is importing to an empty repo:\n\n    $ mkdir zlib &amp;&amp; cd zlib &amp;&amp; git init\n$ gbs import ../zlib-1.2.6.tar.gz\n...\n$ git branch\n* master\nupstream\n$ git tag\nupstream/1.2.6\n    \n\n    Now you can start development just by adding packaging files to the master branch. When you need to update to a newer upstream version, use the gbs import command again:\n\n    $ gbs import ../zlib-1.2.7.tar.gz\n$ git tag\nupstream/1.2.6\nupstream/1.2.7\n    \n\n    \n      Note\n\n      Currently, GBS automatically merges the new upstream version to your master branch. You need to update the version number in your spec file accordingly.\n    \n  \n  \n    Track the remote Git\n\n    In this model, you directly track a remote (Git) repository and the gbs import command is not used. GBS needs to know only the name of the upstream branch and the format of the upstream release tags. These are package-dependent information so you must configure them in a package-specific .gbs.conf in the master branch. For example, to start a package from scratch:\n\n    $ git clone git://github.com/madler/zlib.git &amp;&amp; cd zlib\n$ git branch -m master origin # to keep origin tracking the upstream\n$ git checkout -b master\n$ vim .gbs.conf\n$ git add .gbs.conf &amp;&amp; git commit -m\"Add gbs.conf\"\n    \n\n    The example .gbs.conf configuration file is:\n\n    [general]\nupstream_branch = origin\nupstream_tag = v${upstreamversion}\n    \n  \n\n\nPristine-tar Support\n\nYou can use the pristine-tar for storing and checking out the upstream tarballs (see http://joeyh.name/code/pristine-tar/). You can install pristine-tar from the Tizen tools repository. The tool guarantees that the tarball generated by GBS is bit-identical to the real upstream release source tarball. GBS uses pristine-tar automatically if you have it installed on your system. If you use gbs import to manage the upstream sources, it automatically commits new tarballs to the pristine-tar branch.\n\n\n  Note\n\n  The use of the pristine-tar tool is optional, but highly recommended.\n\n\nHowever, if you track a remote upstream repository directly, you need to commit the upstream source tarballs to the pristine-tar branch manually. For example:\n\n$ cd zlib\n$ git branch\n* master\norigin\n$ pristine-tar commit ../zlib-1.2.7.tar.gz v1.2.7\n$ git branch\n* master\norigin\npristine-tar\n\n\nConverting an Existing Repository to a Non-native Package\n\nTo convert an existing repository to a non-native package:\n\n\n  An upstream branch is required:\n    \n      If you are already tracking the upstream, just configure the upstream branch name and tag format in the package-specific .gbp.conf file.\n      If not, import the upstream source tarball with gbs import or add the upstream remote to your repository and start tracking that.\n        \n          Tip:\n\n          If you are tracking the upstream Git directly, consider running the pristine-tar commit &lt;tarball&gt; &lt;upstream-tag&gt; command.\n        \n      \n    \n  \n  Rebase your current development branch on the correct upstream version (that is, rebase on the upstream tag).\n  Remove all local patches: apply and commit them on top of your development branch and then remove the patches from the packaging directory and preferably from the spec file, too.\n  Optionally, if you want to maintain the package using the orphan-packaging model, you can create the packaging and development branches using the gbs devel convert command.\n\n\nAdvanced Usage\n\n\nManually Maintained Patches\n\nGBS supports patches that are maintained manually, outside the automatic patch generation. This can be needed for architecture-dependent patches, for example, as GBS patch generation does not yet support conditional patches. Another example are patches that are applied on top of a secondary source tree, whose sources are not maintained in your Git tree, but only as a tarball in your packaging directory.\n\nTo use this feature, you must have your patches in the packaging directory and listed in the spec file. In addition, you must mark the patch to be ignored by the patch generation/importing by putting the # Gbp-Ignore-Patches: &lt;patch numbers&gt; line into the spec file. This makes GBS ignore the Patch: tags and %patch macros of the listed patches when importing or generating patches. An excerpt of an example spec file:\n\n...\nSource0: %{name}-%{version}.tar.bz2\n# Gbp-Ignore-Patches: 0\nPatch0: my.patch\n\n%description\n...\n\n\nThe Gbp-Ignore-Patches marker can be placed anywhere in the file, and is case-insensitive. The GBP prefix comes from git-buildpackage (gbp), which is used by GBS as the backend for patch generation.\n\n\n  Note\n\n  Pay attention to patch generation when building or exporting. The gbs import tool also ignores patches marked for manual maintenance when importing source RPMs.\n\n\nPatch Macro Location\n\nGBS tries to automatically find the correct location to add the %patch macros in the spec file when updating it with the newly generated patches. This is usually successful, but GBS can also guess wrong. You can manually mark the location for auto-generated %patch macros by adding a # Gbp-Patch-Macros marker line into the spec file:\n\n...\n%prep\n%setup\n# do things here...\n\n# Gbp-Patch-Macros\n\n# do more things here...\n\n%build\n\n\nGBS places the new %patch macros after the marker line. This marker is case-insensitive, similar to # Gbp-Ignore-Patches.\n\nSquashing Commits\n\nWhen generating patches, GBS supports squashing several commits into 1 monolithic diff. Currently, you can only squash from upstream-tag up to a given commit-ish. An example use case is squashing commits from an upstream release up to a stable update into a single diff (commits on top of the stable generate multiple patches normally). You can enable this with the squash_patches_until config file option or with the --squash-patches-until command line option: the format for the option is &lt;commit-ish&gt;[:&lt;filename-base&gt;].\n\nFor example:\n\n$ git branch\n* master\nstable\nupstream\n$ gbs export --squash-patches-until=stable:stable-update\ninfo: Generating patches from git (upstream/0.1.2..HEAD)\ninfo: Squashing commits a2a7d82..9c0f5ba into one monolithic 'stable-update.diff'\ninfo: Didn't find any old 'Patch' tags, adding new patches after the last 'Source' tag.\ninfo: Didn't find any old '%patch' macros, adding new patches after the last '%setup' macro\ninfo: mypackage-0.1.2.tar.gz does not exist, creating from 'upstream/0.1.2'\ninfo: package files have been exported to:\n/home/user/src/mypackage/packaging/mypackage-0.1.2-1.21\n\n\n\n  Note\n\n  If you are planning to use this feature, configure it in the package-specific .gbs.conf file. This way, all users (including the automatic build machinery) build and export the package in a similar way."
					}
					
				
			
		
			
				
					,
					
					"application-reference-gbs-gbs-overview": {
						"id": "application-reference-gbs-gbs-overview",
						"title": "GBS (Git Build System)",
						"categories": "",
						"url": " application/reference/gbs/gbs-overview/",
						"content": "GBS (Git Build System)\n\nGBS (git-build-system) is a command line tool that supports Tizen package development. It is used to generate tarballs based on Git repositories, to do local test buildings, and to submit code to OBS (Tizen’s main build service).\n\nBefore going into further GBS details, make sure you have set up the development environment and learned how to install and upgrade tools.\n\nAfterwards, become familiar with GBS by reading the following instructions:\n\n\n  GBS Configuration describes how to modify the GBS configuration.\n  GBS Reference describes, in more detail, how to use GBS.\n  GBS Frequently Asked Questions describes frequently asked questions.\n\n\nSource Code\n\nThe source code is tracked in the https://github.com/01org/gbs repository.\n\nLicense\nCopyright (c) 2012 Intel, Inc.\nThis program is free software; you can redistribute it and/or modify it\nunder the terms of the GNU General Public License as published by the Free\nSoftware Foundation; version 2 of the License\nThis program is distributed in the hope that it will be useful, but\nWITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\nor FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\nfor more details.\nYou should have received a copy of the GNU General Public License along\nwith this program; if not, write to the Free Software Foundation, Inc., 59\nTemple Place - Suite 330, Boston, MA 02111-1307, USA.\n\n\nReference\nThe gbs build references the scripts of the SUSE Linux RPM builds: https://github.com/openSUSE/obs-build."
					}
					
				
			
		
			
				
					,
					
					"platform-reference-gbs-gbs-overview": {
						"id": "platform-reference-gbs-gbs-overview",
						"title": "GBS (Git Build System)",
						"categories": "",
						"url": " platform/reference/gbs/gbs-overview/",
						"content": "GBS (Git Build System)\n\nGBS (git-build-system) is a command line tool that supports Tizen package development. It is used to generate tarballs based on Git repositories, to do local test buildings, and to submit code to OBS (Tizen’s main build service).\n\nBefore going into further GBS details, make sure you have set up the development environment and learned how to install and upgrade tools.\n\nAfterwards, become familiar with GBS by reading the following instructions:\n\n\n  GBS Configuration describes how to modify the GBS configuration.\n  GBS Reference describes, in more detail, how to use GBS.\n  GBS Frequently Asked Questions describes frequently asked questions.\n\n\nSource Code\n\nThe source code is tracked in the https://github.com/01org/gbs repository.\n\nLicense\nCopyright (c) 2012 Intel, Inc.\nThis program is free software; you can redistribute it and/or modify it\nunder the terms of the GNU General Public License as published by the Free\nSoftware Foundation; version 2 of the License\nThis program is distributed in the hope that it will be useful, but\nWITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\nor FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\nfor more details.\nYou should have received a copy of the GNU General Public License along\nwith this program; if not, write to the Free Software Foundation, Inc., 59\nTemple Place - Suite 330, Boston, MA 02111-1307, USA.\n\n\nReference\nThe gbs build references the scripts of the SUSE Linux RPM builds: https://github.com/openSUSE/obs-build."
					}
					
				
			
		
			
				
					,
					
					"iot-reference-gbs-gbs-overview": {
						"id": "iot-reference-gbs-gbs-overview",
						"title": "GBS (Git Build System)",
						"categories": "",
						"url": " iot/reference/gbs/gbs-overview/",
						"content": "GBS (Git Build System)\n\nGBS (git-build-system) is a command line tool that supports Tizen package development. It is used to generate tarballs based on Git repositories, to do local test buildings, and to submit code to OBS (Tizen’s main build service).\n\nBefore going into further GBS details, make sure you have set up the development environment and learned how to install and upgrade tools.\n\nAfterwards, become familiar with GBS by reading the following instructions:\n\n\n  GBS Configuration describes how to modify the GBS configuration.\n  GBS Reference describes, in more detail, how to use GBS.\n  GBS Frequently Asked Questions describes frequently asked questions.\n\n\nSource Code\n\nThe source code is tracked in the https://github.com/01org/gbs repository.\n\nLicense\nCopyright (c) 2012 Intel, Inc.\nThis program is free software; you can redistribute it and/or modify it\nunder the terms of the GNU General Public License as published by the Free\nSoftware Foundation; version 2 of the License\nThis program is distributed in the hope that it will be useful, but\nWITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\nor FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\nfor more details.\nYou should have received a copy of the GNU General Public License along\nwith this program; if not, write to the Free Software Foundation, Inc., 59\nTemple Place - Suite 330, Boston, MA 02111-1307, USA.\n\n\nReference\nThe gbs build references the scripts of the SUSE Linux RPM builds: https://github.com/openSUSE/obs-build."
					}
					
				
			
		
			
				
					,
					
					"application-reference-gbs-gbs-conf": {
						"id": "application-reference-gbs-gbs-conf",
						"title": "GBS Configuration",
						"categories": "",
						"url": " application/reference/gbs/gbs.conf/",
						"content": "GBS Configuration\n\nThe GBS configuration files are all simple INI-style files that record various choices and settings used by many GBS commands. Some settings represent purely personal preferences, while others are vital to a correctly-functioning build, and still others simply tweak command behavior a little.\n\n\n  Note\n\n  .conf is a common extension for an INI file, an informal standard for configuration files. INI files are simple text files with a basic structure composed of sections and properties. Like many tools, GBS supports a hierarchy of configuration files, which are shown below in decreasing precedence:\n  \n    $PWD/.gbs.conf: project-specific configuration settings that affect only the specific project in the specified working directory. These settings have the highest precedence.\n    /home/&lt;user&gt;/.gbs.conf: user-specific configuration settings that affect only the specified user.\n    /etc/gbs.conf: system-wide configuration settings that affect the entire system. These settings have the lowest precedence.\n  \n\n\nWhen specifying the configuration file by using the -c (--config) option, 1 of the above files is loaded and applied by GBS. If no configuration file can be found, GBS automatically generates a ~/.gbs.conf file. To specify a file among a hierarchy of configuration files:\n\n$ gbs -c ~/gbs-my.conf build -A ...\n\n\nProfile-oriented Configuration Style\n\nThis section provides information about the profile-oriented style in a GBS configuration file.\n\nBasic Structure\n\nThe basic structure of a configuration file is composed of properties and sections:\n\n\n  \n    Properties\n\n    The basic element contained in a configuration file is a property. Every property has a name and a value, delimited by an equal sign (=). The name appears to the left of the equal sign.\n  \n  \n    Sections\n\n    Properties can be grouped into various sections, named according to the naming conventions. The section name appears on a line by itself in square brackets ([ ]). All the properties after the section declaration are associated with that section. No explicit “end of section” delimiter is needed. Sections end at the next section declaration or the end of the file. Possible sections include:\n\n    \n      \n        General section\n\n        The default profile is defined in the general section and affect GBS behavior on a general basis. That is, upon the modification of the general section, all GBS behaviors are changed accordingly.\n\n        The supported properties include:\n\n        \n          \n            native\n\n            This property explicitly defines whether a package is native or non-native. Values yes, on, 1, true, and enabled are interpreted as True, directing GBS to export in the native packaging mode. All other non-empty values are interpreted as False, making GBS export in the non-native mode.\n          \n          \n            fallback_to_native\n\n            This property serves as an emergency option for non-native packages. When enabled for non-native packages, it forces GBS to fallback to the native packaging mode if export fails in the non-native packaging mode. This means that it directs GBS to ignore the upstream branch and create a tarball from HEAD (by default) or specified commit without generating any patch.\n          \n          tmpdir\n          upstream_branch\n          upstreamtag\n          buildroot\n          packaging_dir\n        \n      \n      \n        Profile section\n\n        Set common authentication information on the profile level, instead of repeating identical configurations in various sections. These settings can be automatically passed to OBS and repository sections.\n\n        Add authentication information to a specific repository or OBS section only when it is unique to the corresponding OBS or repository. In addition, multiple profile sections can exist in 1 configuration file, enabling the manipulation of GBS behaviors aimed at different devices (for example, mobile phone and IVI) in a central configuration file. For more information, see Configuring Multiple Profiles.\n\n        The supported properties include:\n        \n          user\n          passwd\n          repos\n          obs\n          \n            buildconf\n\n            The build config for the gbs buildcommand to build all profiles.\n          \n          \n            exclude_packages\n\n            A list of packages that do not participate in the building. This property can also be used to break the dependency circle.\n          \n        \n      \n      \n        OBS section\n\n        The OBS section specifies the configurations of the remote build server for a remote build. The supported properties include url, user, and password.\n      \n      \n        Repository section\n\n        As with the profile section, multiple repository sections can exist in 1 configuration file, allowing various repositories to be manipulated in “batch”. The supported properties include url, user, and password. The user and password properties can be omitted if the corresponding repository does not need authentication information.\n      \n    \n  \n\n\n\nNaming Conventions\n\nThe section names must follow these naming conventions:\n\n\n  Name the general section exactly as [general].\n  Start the profile section name with “profile.”. For example, [profile.tizen] or [profile.IVI].\n  Start the OBS section name with “obs.”. For example, [obs.tizen].\n  Start the repository section name with “repo.”.\n\n\n[general]\n#Current profile name which must match a profile section name\ntmpdir = /var/tmp\neditor =\npackaging_branch = master\nupstream_branch = upstream\nupstream_tag = upstream/${upstreamversion}\npackaging_dir = packaging\nprofile = profile.tizen\nbuildroot = ~/GBS-ROOT/\nwork_dir = .\n\n[profile.tizen]\nobs = obs.tizen\nrepos = repo.tizen_latest\n# If no buildroot for profile, the buildroot in general section will be used\nbuildroot = ~/GBS-ROOT-profile.tizen/\n# Specify build conf for a specific profile by using shell-style variable references\nbuildconf = ${work_dir}/tizen-conf/build.conf\n# Specify a list of packages that don't participate in the building, which\n# can also be used to break dependency circle\nexclude_packages=filesystem,aul,libmm-sound,libtool\n\n# Common authentication information\nuser = xxx\npasswd = xxx\n\n[obs.tizen]\nurl = https://api.tizen.org\n\n\nConfiguration Specification\n\nThis section provides information about the configuration specification.\n\nConfiguring Common Properties\n\nTypical common properties include buildroot, user, and password.\n\nTo configure the buildroot property to override the default ~/GBS-ROOT value:\n\nbuildroot=&lt;New_Build_Root&gt;\n\n\nThe reason you need to configure the passwd property is because the password line is automatically converted to an encoded version after running the GBS:\n\npasswdx = QlpoOTFBWSZTWVyCeo8AAAKIAHJAIAAhhoGaAlNOLuSKcKEguQT1\n\n\nTo reset the password, delete the passwdx line above and add a new assignment equation:\n\npasswd=&lt;New_Password&gt;\n\n\n\nConfiguring Multiple Profiles\n\nBy adding configuration specifications of multiple profiles aimed at various devices in 1 configuration file, the GBS behavior oriented for a variety of devices can be manipulated by using a central configuration file.\n\nTo configure multiple profiles:\n\n[general]\nprofile = profile.ivi\n\n[profile.mobile]\n...\n[profile.ivi]\n...\n\n\nWhen you specify the profile section with the -P (--profile) option in a GBS command, the specified profile configuration is applied:\n\n$ gbs build --profile=profile.mobile -A i586\n$ gbs remotebuild --profile=mobile\n\n\nConfiguring a Repository\n\nYou can configure a repository to adapt the GBS build. The repository configuration specification starts with the section declaration named “[repo.]\", and is followed by various properties, including:\n\n\n  \n    url\n\n    The url property specifies the URL of a remote repository, or the full path of a local or remote repository. The following 2 types of remote repositories are supported:\n\n    \n      Standard RPM repository that has a repodata/ subdirectory under the /repos/ directory.\n      Tizen repository that has a builddata/ subdirectory, for example, http://download.tizen.org/releases/daily/2.0alpha/common/latest/.\n    \n\n    \n      Note\n\n      To guarantee the quality of the GBS build, the release folder must be used instead the snapshot folder.\n    \n  \n  \n    user\n  \n  \n    passwd\n  \n\n\n[repo.tizen_latest]\nurl = http://download.tizen.org/releases/trunk/daily/ivi/latest/\nuser = xxx\npasswd = xxx\n[repo.my_local]\n#local repo must be an absolute path\nurl = &lt;Full_Path_of_Local_Repository&gt;\n\n\nShell-style Variable References\n\nProperties defined in the [general] section can be directly used in other sections by using shell-style variable references in GBS 0.17 and higher:\n\n[general]\ntmpdir=/var/tmp\nwork_dir=~/test\n[profile.tizen]\nbuildconf=${work_dir}/tizen.conf\nbuildroot=${tmpdir}/profile.tizen/"
					}
					
				
			
		
			
				
					,
					
					"platform-reference-gbs-gbs-conf": {
						"id": "platform-reference-gbs-gbs-conf",
						"title": "GBS Configuration",
						"categories": "",
						"url": " platform/reference/gbs/gbs.conf/",
						"content": "GBS Configuration\n\nThe GBS configuration files are all simple INI-style files that record various choices and settings used by many GBS commands. Some settings represent purely personal preferences, while others are vital to a correctly-functioning build, and still others simply tweak command behavior a little.\n\n\n  Note\n\n  .conf is a common extension for an INI file, an informal standard for configuration files. INI files are simple text files with a basic structure composed of sections and properties. Like many tools, GBS supports a hierarchy of configuration files, which are shown below in decreasing precedence:\n  \n    $PWD/.gbs.conf: project-specific configuration settings that affect only the specific project in the specified working directory. These settings have the highest precedence.\n    /home/&lt;user&gt;/.gbs.conf: user-specific configuration settings that affect only the specified user.\n    /etc/gbs.conf: system-wide configuration settings that affect the entire system. These settings have the lowest precedence.\n  \n\n\nWhen specifying the configuration file by using the -c (--config) option, 1 of the above files is loaded and applied by GBS. If no configuration file can be found, GBS automatically generates a ~/.gbs.conf file. To specify a file among a hierarchy of configuration files:\n\n$ gbs -c ~/gbs-my.conf build -A ...\n\n\nProfile-oriented Configuration Style\n\nThis section provides information about the profile-oriented style in a GBS configuration file.\n\nBasic Structure\n\nThe basic structure of a configuration file is composed of properties and sections:\n\n\n  \n    Properties\n\n    The basic element contained in a configuration file is a property. Every property has a name and a value, delimited by an equal sign (=). The name appears to the left of the equal sign.\n  \n  \n    Sections\n\n    Properties can be grouped into various sections, named according to the naming conventions. The section name appears on a line by itself in square brackets ([ ]). All the properties after the section declaration are associated with that section. No explicit “end of section” delimiter is needed. Sections end at the next section declaration or the end of the file. Possible sections include:\n\n    \n      \n        General section\n\n        The default profile is defined in the general section and affect GBS behavior on a general basis. That is, upon the modification of the general section, all GBS behaviors are changed accordingly.\n\n        The supported properties include:\n\n        \n          \n            native\n\n            This property explicitly defines whether a package is native or non-native. Values yes, on, 1, true, and enabled are interpreted as True, directing GBS to export in the native packaging mode. All other non-empty values are interpreted as False, making GBS export in the non-native mode.\n          \n          \n            fallback_to_native\n\n            This property serves as an emergency option for non-native packages. When enabled for non-native packages, it forces GBS to fallback to the native packaging mode if export fails in the non-native packaging mode. This means that it directs GBS to ignore the upstream branch and create a tarball from HEAD (by default) or specified commit without generating any patch.\n          \n          tmpdir\n          upstream_branch\n          upstreamtag\n          buildroot\n          packaging_dir\n        \n      \n      \n        Profile section\n\n        Set common authentication information on the profile level, instead of repeating identical configurations in various sections. These settings can be automatically passed to OBS and repository sections.\n\n        Add authentication information to a specific repository or OBS section only when it is unique to the corresponding OBS or repository. In addition, multiple profile sections can exist in 1 configuration file, enabling the manipulation of GBS behaviors aimed at different devices (for example, mobile phone and IVI) in a central configuration file. For more information, see Configuring Multiple Profiles.\n\n        The supported properties include:\n        \n          user\n          passwd\n          repos\n          obs\n          \n            buildconf\n\n            The build config for the gbs buildcommand to build all profiles.\n          \n          \n            exclude_packages\n\n            A list of packages that do not participate in the building. This property can also be used to break the dependency circle.\n          \n        \n      \n      \n        OBS section\n\n        The OBS section specifies the configurations of the remote build server for a remote build. The supported properties include url, user, and password.\n      \n      \n        Repository section\n\n        As with the profile section, multiple repository sections can exist in 1 configuration file, allowing various repositories to be manipulated in “batch”. The supported properties include url, user, and password. The user and password properties can be omitted if the corresponding repository does not need authentication information.\n      \n    \n  \n\n\n\nNaming Conventions\n\nThe section names must follow these naming conventions:\n\n\n  Name the general section exactly as [general].\n  Start the profile section name with “profile.”. For example, [profile.tizen] or [profile.IVI].\n  Start the OBS section name with “obs.”. For example, [obs.tizen].\n  Start the repository section name with “repo.”.\n\n\n[general]\n#Current profile name which must match a profile section name\ntmpdir = /var/tmp\neditor =\npackaging_branch = master\nupstream_branch = upstream\nupstream_tag = upstream/${upstreamversion}\npackaging_dir = packaging\nprofile = profile.tizen\nbuildroot = ~/GBS-ROOT/\nwork_dir = .\n\n[profile.tizen]\nobs = obs.tizen\nrepos = repo.tizen_latest\n# If no buildroot for profile, the buildroot in general section will be used\nbuildroot = ~/GBS-ROOT-profile.tizen/\n# Specify build conf for a specific profile by using shell-style variable references\nbuildconf = ${work_dir}/tizen-conf/build.conf\n# Specify a list of packages that don't participate in the building, which\n# can also be used to break dependency circle\nexclude_packages=filesystem,aul,libmm-sound,libtool\n\n# Common authentication information\nuser = xxx\npasswd = xxx\n\n[obs.tizen]\nurl = https://api.tizen.org\n\n\nConfiguration Specification\n\nThis section provides information about the configuration specification.\n\nConfiguring Common Properties\n\nTypical common properties include buildroot, user, and password.\n\nTo configure the buildroot property to override the default ~/GBS-ROOT value:\n\nbuildroot=&lt;New_Build_Root&gt;\n\n\nThe reason you need to configure the passwd property is because the password line is automatically converted to an encoded version after running the GBS:\n\npasswdx = QlpoOTFBWSZTWVyCeo8AAAKIAHJAIAAhhoGaAlNOLuSKcKEguQT1\n\n\nTo reset the password, delete the passwdx line above and add a new assignment equation:\n\npasswd=&lt;New_Password&gt;\n\n\n\nConfiguring Multiple Profiles\n\nBy adding configuration specifications of multiple profiles aimed at various devices in 1 configuration file, the GBS behavior oriented for a variety of devices can be manipulated by using a central configuration file.\n\nTo configure multiple profiles:\n\n[general]\nprofile = profile.ivi\n\n[profile.mobile]\n...\n[profile.ivi]\n...\n\n\nWhen you specify the profile section with the -P (--profile) option in a GBS command, the specified profile configuration is applied:\n\n$ gbs build --profile=profile.mobile -A i586\n$ gbs remotebuild --profile=mobile\n\n\nConfiguring a Repository\n\nYou can configure a repository to adapt the GBS build. The repository configuration specification starts with the section declaration named “[repo.]\", and is followed by various properties, including:\n\n\n  \n    url\n\n    The url property specifies the URL of a remote repository, or the full path of a local or remote repository. The following 2 types of remote repositories are supported:\n\n    \n      Standard RPM repository that has a repodata/ subdirectory under the /repos/ directory.\n      Tizen repository that has a builddata/ subdirectory, for example, http://download.tizen.org/releases/daily/2.0alpha/common/latest/.\n    \n\n    \n      Note\n\n      To guarantee the quality of the GBS build, the release folder must be used instead the snapshot folder.\n    \n  \n  \n    user\n  \n  \n    passwd\n  \n\n\n[repo.tizen_latest]\nurl = http://download.tizen.org/releases/trunk/daily/ivi/latest/\nuser = xxx\npasswd = xxx\n[repo.my_local]\n#local repo must be an absolute path\nurl = &lt;Full_Path_of_Local_Repository&gt;\n\n\nShell-style Variable References\n\nProperties defined in the [general] section can be directly used in other sections by using shell-style variable references in GBS 0.17 and higher:\n\n[general]\ntmpdir=/var/tmp\nwork_dir=~/test\n[profile.tizen]\nbuildconf=${work_dir}/tizen.conf\nbuildroot=${tmpdir}/profile.tizen/"
					}
					
				
			
		
			
				
					,
					
					"iot-reference-gbs-gbs-conf": {
						"id": "iot-reference-gbs-gbs-conf",
						"title": "GBS Configuration",
						"categories": "",
						"url": " iot/reference/gbs/gbs.conf/",
						"content": "GBS Configuration\n\nThe GBS configuration files are all simple INI-style files that record various choices and settings used by many GBS commands. Some settings represent purely personal preferences, while others are vital to a correctly-functioning build, and still others simply tweak command behavior a little.\n\n\n  Note\n\n  .conf is a common extension for an INI file, an informal standard for configuration files. INI files are simple text files with a basic structure composed of sections and properties. Like many tools, GBS supports a hierarchy of configuration files, which are shown below in decreasing precedence:\n  \n    $PWD/.gbs.conf: project-specific configuration settings that affect only the specific project in the specified working directory. These settings have the highest precedence.\n    /home/&lt;user&gt;/.gbs.conf: user-specific configuration settings that affect only the specified user.\n    /etc/gbs.conf: system-wide configuration settings that affect the entire system. These settings have the lowest precedence.\n  \n\n\nWhen specifying the configuration file by using the -c (--config) option, 1 of the above files is loaded and applied by GBS. If no configuration file can be found, GBS automatically generates a ~/.gbs.conf file. To specify a file among a hierarchy of configuration files:\n\n$ gbs -c ~/gbs-my.conf build -A ...\n\n\nProfile-oriented Configuration Style\n\nThis section provides information about the profile-oriented style in a GBS configuration file.\n\nBasic Structure\n\nThe basic structure of a configuration file is composed of properties and sections:\n\n\n  \n    Properties\n\n    The basic element contained in a configuration file is a property. Every property has a name and a value, delimited by an equal sign (=). The name appears to the left of the equal sign.\n  \n  \n    Sections\n\n    Properties can be grouped into various sections, named according to the naming conventions. The section name appears on a line by itself in square brackets ([ ]). All the properties after the section declaration are associated with that section. No explicit “end of section” delimiter is needed. Sections end at the next section declaration or the end of the file. Possible sections include:\n\n    \n      \n        General section\n\n        The default profile is defined in the general section and affect GBS behavior on a general basis. That is, upon the modification of the general section, all GBS behaviors are changed accordingly.\n\n        The supported properties include:\n\n        \n          \n            native\n\n            This property explicitly defines whether a package is native or non-native. Values yes, on, 1, true, and enabled are interpreted as True, directing GBS to export in the native packaging mode. All other non-empty values are interpreted as False, making GBS export in the non-native mode.\n          \n          \n            fallback_to_native\n\n            This property serves as an emergency option for non-native packages. When enabled for non-native packages, it forces GBS to fallback to the native packaging mode if export fails in the non-native packaging mode. This means that it directs GBS to ignore the upstream branch and create a tarball from HEAD (by default) or specified commit without generating any patch.\n          \n          tmpdir\n          upstream_branch\n          upstreamtag\n          buildroot\n          packaging_dir\n        \n      \n      \n        Profile section\n\n        Set common authentication information on the profile level, instead of repeating identical configurations in various sections. These settings can be automatically passed to OBS and repository sections.\n\n        Add authentication information to a specific repository or OBS section only when it is unique to the corresponding OBS or repository. In addition, multiple profile sections can exist in 1 configuration file, enabling the manipulation of GBS behaviors aimed at different devices (for example, mobile phone and IVI) in a central configuration file. For more information, see Configuring Multiple Profiles.\n\n        The supported properties include:\n        \n          user\n          passwd\n          repos\n          obs\n          \n            buildconf\n\n            The build config for the gbs buildcommand to build all profiles.\n          \n          \n            exclude_packages\n\n            A list of packages that do not participate in the building. This property can also be used to break the dependency circle.\n          \n        \n      \n      \n        OBS section\n\n        The OBS section specifies the configurations of the remote build server for a remote build. The supported properties include url, user, and password.\n      \n      \n        Repository section\n\n        As with the profile section, multiple repository sections can exist in 1 configuration file, allowing various repositories to be manipulated in “batch”. The supported properties include url, user, and password. The user and password properties can be omitted if the corresponding repository does not need authentication information.\n      \n    \n  \n\n\n\nNaming Conventions\n\nThe section names must follow these naming conventions:\n\n\n  Name the general section exactly as [general].\n  Start the profile section name with “profile.”. For example, [profile.tizen] or [profile.IVI].\n  Start the OBS section name with “obs.”. For example, [obs.tizen].\n  Start the repository section name with “repo.”.\n\n\n[general]\n#Current profile name which must match a profile section name\ntmpdir = /var/tmp\neditor =\npackaging_branch = master\nupstream_branch = upstream\nupstream_tag = upstream/${upstreamversion}\npackaging_dir = packaging\nprofile = profile.tizen\nbuildroot = ~/GBS-ROOT/\nwork_dir = .\n\n[profile.tizen]\nobs = obs.tizen\nrepos = repo.tizen_latest\n# If no buildroot for profile, the buildroot in general section will be used\nbuildroot = ~/GBS-ROOT-profile.tizen/\n# Specify build conf for a specific profile by using shell-style variable references\nbuildconf = ${work_dir}/tizen-conf/build.conf\n# Specify a list of packages that don't participate in the building, which\n# can also be used to break dependency circle\nexclude_packages=filesystem,aul,libmm-sound,libtool\n\n# Common authentication information\nuser = xxx\npasswd = xxx\n\n[obs.tizen]\nurl = https://api.tizen.org\n\n\nConfiguration Specification\n\nThis section provides information about the configuration specification.\n\nConfiguring Common Properties\n\nTypical common properties include buildroot, user, and password.\n\nTo configure the buildroot property to override the default ~/GBS-ROOT value:\n\nbuildroot=&lt;New_Build_Root&gt;\n\n\nThe reason you need to configure the passwd property is because the password line is automatically converted to an encoded version after running the GBS:\n\npasswdx = QlpoOTFBWSZTWVyCeo8AAAKIAHJAIAAhhoGaAlNOLuSKcKEguQT1\n\n\nTo reset the password, delete the passwdx line above and add a new assignment equation:\n\npasswd=&lt;New_Password&gt;\n\n\n\nConfiguring Multiple Profiles\n\nBy adding configuration specifications of multiple profiles aimed at various devices in 1 configuration file, the GBS behavior oriented for a variety of devices can be manipulated by using a central configuration file.\n\nTo configure multiple profiles:\n\n[general]\nprofile = profile.ivi\n\n[profile.mobile]\n...\n[profile.ivi]\n...\n\n\nWhen you specify the profile section with the -P (--profile) option in a GBS command, the specified profile configuration is applied:\n\n$ gbs build --profile=profile.mobile -A i586\n$ gbs remotebuild --profile=mobile\n\n\nConfiguring a Repository\n\nYou can configure a repository to adapt the GBS build. The repository configuration specification starts with the section declaration named “[repo.]\", and is followed by various properties, including:\n\n\n  \n    url\n\n    The url property specifies the URL of a remote repository, or the full path of a local or remote repository. The following 2 types of remote repositories are supported:\n\n    \n      Standard RPM repository that has a repodata/ subdirectory under the /repos/ directory.\n      Tizen repository that has a builddata/ subdirectory, for example, http://download.tizen.org/releases/daily/2.0alpha/common/latest/.\n    \n\n    \n      Note\n\n      To guarantee the quality of the GBS build, the release folder must be used instead the snapshot folder.\n    \n  \n  \n    user\n  \n  \n    passwd\n  \n\n\n[repo.tizen_latest]\nurl = http://download.tizen.org/releases/trunk/daily/ivi/latest/\nuser = xxx\npasswd = xxx\n[repo.my_local]\n#local repo must be an absolute path\nurl = &lt;Full_Path_of_Local_Repository&gt;\n\n\nShell-style Variable References\n\nProperties defined in the [general] section can be directly used in other sections by using shell-style variable references in GBS 0.17 and higher:\n\n[general]\ntmpdir=/var/tmp\nwork_dir=~/test\n[profile.tizen]\nbuildconf=${work_dir}/tizen.conf\nbuildroot=${tmpdir}/profile.tizen/"
					}
					
				
			
		
			
				
					,
					
					"application-reference-gerrit-usage": {
						"id": "application-reference-gerrit-usage",
						"title": "Gerrit",
						"categories": "",
						"url": " application/reference/gerrit-usage/",
						"content": "Gerrit\n\nYou can perform various operations in Gerrit:\n\n\n  \n    To watch a project\n\n    If you are interested in a package that has an important relation to yours, like a dependency, you can watch that package project. You receive notifications when a patchset for a watched project is uploaded to Gerrit.\n\n    To adjust the Watched Projects settings to monitor new projects, in the Gerrit Web UI, go to Settings (top right) &gt; Watched Projects, enter the project name, and click Watch.\n  \n  \n    To replace a patch set\n\n    You can add a new patch set that replaces an existing patch set with an updated version of the same logical modification, by sending a new commit to the change’s ref number. For example, to add a commit where the SHA-1 starts with “c0ffee”, as a new patch set for change number 1979, use the following command:\n\n    $ git push ssh://review.tizen.org/&lt;PROJECT_NAME&gt; c0ffee:refs/changes/1979\n    \n\n    \n      Tip:\n\n      Sometimes you can use the git commit --amend command to update an existing local commit, and then push to Gerrit using HEAD:refs/changes/1979, instead of having to use a hash ID.\n    \n  \n  \n    To use command line tools\n\n    You can use various command attributes to manage command line tools:\n\n    ssh -p &lt;port&gt; &lt;host&gt; gerrit review [--message &lt;MESSAGE&gt;] [--verified &lt;N&gt;] [--code-review &lt;N&gt;] [--abandon]{COMMIT | CHANGEID,PATCHSET}...\n    \n  \n  \n    To review a patch set\n\n    You can review patch sets by using the command line. For example, to verify, approve, and submit the patch “c0ff33”:\n\n    $ ssh review.tizen.org gerrit review --verified=+1 --code-review=+2 --submit c0ff33\n    \n  \n  \n    To abandon a patch set\n\n    You can drop an uploaded patch by clicking Abandon in the Gerrit Web UI or using a command:\n\n    $ ssh review.tizen.org gerrit review --abandon c0ff33\n    \n  \n  \n    To access more detailed instructions\n\n    For detailed instructions, use the --help command:\n\n    $ ssh review.tizen.org gerrit --help\n    \n\n    or see Gerrit Code Review - Command Line Tools."
					}
					
				
			
		
			
				
					,
					
					"platform-reference-gerrit-usage": {
						"id": "platform-reference-gerrit-usage",
						"title": "Gerrit",
						"categories": "",
						"url": " platform/reference/gerrit-usage/",
						"content": "Gerrit\n\nYou can perform various operations in Gerrit:\n\n\n  \n    To watch a project\n\n    If you are interested in a package that has an important relation to yours, like a dependency, you can watch that package project. You receive notifications when a patchset for a watched project is uploaded to Gerrit.\n\n    To adjust the Watched Projects settings to monitor new projects, in the Gerrit Web UI, go to Settings (top right) &gt; Watched Projects, enter the project name, and click Watch.\n  \n  \n    To replace a patch set\n\n    You can add a new patch set that replaces an existing patch set with an updated version of the same logical modification, by sending a new commit to the change’s ref number. For example, to add a commit where the SHA-1 starts with “c0ffee”, as a new patch set for change number 1979, use the following command:\n\n    $ git push ssh://review.tizen.org/&lt;PROJECT_NAME&gt; c0ffee:refs/changes/1979\n    \n\n    \n      Tip:\n\n      Sometimes you can use the git commit --amend command to update an existing local commit, and then push to Gerrit using HEAD:refs/changes/1979, instead of having to use a hash ID.\n    \n  \n  \n    To use command line tools\n\n    You can use various command attributes to manage command line tools:\n\n    ssh -p &lt;port&gt; &lt;host&gt; gerrit review [--message &lt;MESSAGE&gt;] [--verified &lt;N&gt;] [--code-review &lt;N&gt;] [--abandon]{COMMIT | CHANGEID,PATCHSET}...\n    \n  \n  \n    To review a patch set\n\n    You can review patch sets by using the command line. For example, to verify, approve, and submit the patch “c0ff33”:\n\n    $ ssh review.tizen.org gerrit review --verified=+1 --code-review=+2 --submit c0ff33\n    \n  \n  \n    To abandon a patch set\n\n    You can drop an uploaded patch by clicking Abandon in the Gerrit Web UI or using a command:\n\n    $ ssh review.tizen.org gerrit review --abandon c0ff33\n    \n  \n  \n    To access more detailed instructions\n\n    For detailed instructions, use the --help command:\n\n    $ ssh review.tizen.org gerrit --help\n    \n\n    or see Gerrit Code Review - Command Line Tools."
					}
					
				
			
		
			
				
					,
					
					"iot-reference-gerrit-usage": {
						"id": "iot-reference-gerrit-usage",
						"title": "Gerrit",
						"categories": "",
						"url": " iot/reference/gerrit-usage/",
						"content": "Gerrit\n\nYou can perform various operations in Gerrit:\n\n\n  \n    To watch a project\n\n    If you are interested in a package that has an important relation to yours, like a dependency, you can watch that package project. You receive notifications when a patchset for a watched project is uploaded to Gerrit.\n\n    To adjust the Watched Projects settings to monitor new projects, in the Gerrit Web UI, go to Settings (top right) &gt; Watched Projects, enter the project name, and click Watch.\n  \n  \n    To replace a patch set\n\n    You can add a new patch set that replaces an existing patch set with an updated version of the same logical modification, by sending a new commit to the change’s ref number. For example, to add a commit where the SHA-1 starts with “c0ffee”, as a new patch set for change number 1979, use the following command:\n\n    $ git push ssh://review.tizen.org/&lt;PROJECT_NAME&gt; c0ffee:refs/changes/1979\n    \n\n    \n      Tip:\n\n      Sometimes you can use the git commit --amend command to update an existing local commit, and then push to Gerrit using HEAD:refs/changes/1979, instead of having to use a hash ID.\n    \n  \n  \n    To use command line tools\n\n    You can use various command attributes to manage command line tools:\n\n    ssh -p &lt;port&gt; &lt;host&gt; gerrit review [--message &lt;MESSAGE&gt;] [--verified &lt;N&gt;] [--code-review &lt;N&gt;] [--abandon]{COMMIT | CHANGEID,PATCHSET}...\n    \n  \n  \n    To review a patch set\n\n    You can review patch sets by using the command line. For example, to verify, approve, and submit the patch “c0ff33”:\n\n    $ ssh review.tizen.org gerrit review --verified=+1 --code-review=+2 --submit c0ff33\n    \n  \n  \n    To abandon a patch set\n\n    You can drop an uploaded patch by clicking Abandon in the Gerrit Web UI or using a command:\n\n    $ ssh review.tizen.org gerrit review --abandon c0ff33\n    \n  \n  \n    To access more detailed instructions\n\n    For detailed instructions, use the --help command:\n\n    $ ssh review.tizen.org gerrit --help\n    \n\n    or see Gerrit Code Review - Command Line Tools."
					}
					
				
			
		
			
				
					,
					
					"get-started": {
						"id": "get-started",
						"title": "Get Started",
						"categories": "",
						"url": " get-started/",
						"content": "Get Started\n\nPlatform\n\n  What is Tizen?\n  \n    Developers can register for an account at: https://www.tizen.org/user/register\n\n     Download Tizen Source\n\n    &gt; More\n  \n\n\nIOT world on Craftroom\n\n  What is Tizen IoT?\n  \n    How to make IoT devices\n\n    &gt; Go to Craftroom\n  \n\n\nTizen .NET\n\n  What is Tizen .NET Application?\n  \n    Creating Tizen .NET Applications\n\n     Download Visual Studio Tools for Tizen\n\n    &gt; More\n  \n\n\nTizen Studio\n\n  What is Tizen Application?\n  Creating Tizen Native Applications\n  \n    Creating Tizen Web Applications\n\n     Download Tizen Studio\n\n    &gt; More"
					}
					
				
			
		
			
				
					,
					
					"application-about-git-repo-structure": {
						"id": "application-about-git-repo-structure",
						"title": "Git Repository Structure",
						"categories": "",
						"url": " application/about/git-repo-structure/",
						"content": "Git Repository Structure\nGIT\n\nThe following table describes the Git repository structure for Tizen 3.0 and higher.\n\nTable: Git repository structure for Tizen 3.0 and higher\n\n\n  \n    \n      First depth\n      Second depth\n      Third depth\n      Description\n    \n  \n  \n    \n      Platform\n       \n       \n      Platform component\n    \n    \n       \n      upstream\n       \n      Code from upstream open source (Wayland, GStreamer, .NET Engine)\n    \n    \n       \n      adaptation\n       \n      Adaptation layer for supporting various kind of devices\n    \n    \n       \n      framework\n       \n      Web Framework\n    \n    \n       \n       \n      web\n      Web Framework (Web Engine)\n    \n    \n       \n      core\n       \n      Core Framework\n    \n    \n       \n       \n      api\n      Native APIs for Core Framework\n    \n    \n       \n       \n      csapi\n      TizenFX API for Tizen .NET (C#)\n    \n    \n       \n       \n      webapi\n      Web APIs for Web Framework\n    \n    \n       \n      kernel\n       \n      Kernel for supporting various kind of devices\n    \n    \n      Apps\n       \n       \n      Common application\n    \n    \n       \n      native\n       \n      Common native application\n    \n    \n       \n      Web\n       \n      Common Web application\n    \n    \n      Tools\n       \n       \n      Tools constituting the Tizen platform development environment\n    \n    \n       \n      Upstream\n       \n      Code from upstream open source (valgrind, oprofile)\n    \n    \n      Services\n       \n       \n      Services constituting Tizen build services\n    \n    \n      SDK\n       \n       \n      SDK\n    \n    \n       \n      ide\n       \n      IDE tools with which you can develop Tizen applications\n    \n    \n      SCM\n       \n       \n      Privilege setting and metadata for configuration\n    \n    \n      Test\n       \n       \n      Code for testing a profile (ex Common)\n    \n    \n       \n      tools\n       \n      Tools for testing a profile\n    \n    \n      Profile\n       \n       \n      Profile-specific\n    \n    \n       \n      Mobile\n       \n      Mobile profile-specific\n    \n    \n       \n       \n      platform\n      Platform component\n    \n    \n       \n       \n      apps\n      Mobile profile-specific application\n    \n    \n       \n       \n      sdk\n      SDK\n    \n    \n       \n       \n      scm\n      Privilege setting and metadata for configuration\n    \n    \n       \n       \n      test\n      Code for testing a profile (ex Common)\n    \n    \n       \n      wearable\n       \n      Wearable profile-specific\n    \n    \n       \n       \n      platform\n      Platform component\n    \n    \n       \n       \n      apps\n      Wearable profile-specific application\n    \n    \n       \n       \n      sdk\n      SDK\n    \n    \n       \n       \n      scm\n      Privilege setting and metadata for configuration\n    \n    \n       \n       \n      test\n      Code for testing a profile (ex Common)\n    \n    \n       \n      common\n       \n      Common profile-specific\n    \n    \n       \n       \n      platform\n      Platform component\n    \n    \n       \n       \n      apps\n      Common profile-specific application\n    \n    \n       \n       \n      sdk\n      SDK\n    \n    \n       \n       \n      scm\n      Privilege setting and metadata for configuration\n    \n    \n       \n       \n      test\n      Code for testing a profile (ex Common)\n    \n    \n       \n      ivi\n       \n      IVI profile-specific\n    \n    \n       \n       \n      platform\n      Platform component\n    \n    \n       \n       \n      apps\n      IVI profile-specific application\n    \n    \n       \n       \n      sdk\n      SDK\n    \n    \n       \n       \n      scm\n      Privilege setting and metadata for configuration\n    \n    \n       \n       \n      test\n      Code for testing a profile (ex Common)\n    \n    \n      Product\n       \n       \n      Product-specific\n    \n    \n       \n      upstream\n       \n      Code from upstream open source\n    \n  \n\n\n\n  Note\n\n  If the Git repository is not listed above, it does not belong to Tizen 3.0 and higher."
					}
					
				
			
		
			
				
					,
					
					"platform-about-git-repo-structure": {
						"id": "platform-about-git-repo-structure",
						"title": "Git Repository Structure",
						"categories": "",
						"url": " platform/about/git-repo-structure/",
						"content": "Git Repository Structure\n\nThe following table describes the Git repository structure for Tizen 3.0 and higher.\n\nTable: Git repository structure for Tizen 3.0 and higher\n\n\n  \n    \n      First depth\n      Second depth\n      Third depth\n      Description\n    \n  \n  \n    \n      Platform\n       \n       \n      Platform component\n    \n    \n       \n      upstream\n       \n      Code from upstream open source (Wayland, GStreamer, .NET Engine)\n    \n    \n       \n      adaptation\n       \n      Adaptation layer for supporting various kind of devices\n    \n    \n       \n      framework\n       \n      Web Framework\n    \n    \n       \n       \n      web\n      Web Framework (Web Engine)\n    \n    \n       \n      core\n       \n      Core Framework\n    \n    \n       \n       \n      api\n      Native APIs for Core Framework\n    \n    \n       \n       \n      csapi\n      TizenFX API for Tizen .NET (C#)\n    \n    \n       \n       \n      webapi\n      Web APIs for Web Framework\n    \n    \n       \n      kernel\n       \n      Kernel for supporting various kind of devices\n    \n    \n      Apps\n       \n       \n      Common application\n    \n    \n       \n      native\n       \n      Common native application\n    \n    \n       \n      Web\n       \n      Common Web application\n    \n    \n      Tools\n       \n       \n      Tools constituting the Tizen platform development environment\n    \n    \n       \n      Upstream\n       \n      Code from upstream open source (valgrind, oprofile)\n    \n    \n      Services\n       \n       \n      Services constituting Tizen build services\n    \n    \n      SDK\n       \n       \n      SDK\n    \n    \n       \n      ide\n       \n      IDE tools with which you can develop Tizen applications\n    \n    \n      SCM\n       \n       \n      Privilege setting and metadata for configuration\n    \n    \n      Test\n       \n       \n      Code for testing a profile (ex Common)\n    \n    \n       \n      tools\n       \n      Tools for testing a profile\n    \n    \n      Profile\n       \n       \n      Profile-specific\n    \n    \n       \n      Mobile\n       \n      Mobile profile-specific\n    \n    \n       \n       \n      platform\n      Platform component\n    \n    \n       \n       \n      apps\n      Mobile profile-specific application\n    \n    \n       \n       \n      sdk\n      SDK\n    \n    \n       \n       \n      scm\n      Privilege setting and metadata for configuration\n    \n    \n       \n       \n      test\n      Code for testing a profile (ex Common)\n    \n    \n       \n      wearable\n       \n      Wearable profile-specific\n    \n    \n       \n       \n      platform\n      Platform component\n    \n    \n       \n       \n      apps\n      Wearable profile-specific application\n    \n    \n       \n       \n      sdk\n      SDK\n    \n    \n       \n       \n      scm\n      Privilege setting and metadata for configuration\n    \n    \n       \n       \n      test\n      Code for testing a profile (ex Common)\n    \n    \n       \n      common\n       \n      Common profile-specific\n    \n    \n       \n       \n      platform\n      Platform component\n    \n    \n       \n       \n      apps\n      Common profile-specific application\n    \n    \n       \n       \n      sdk\n      SDK\n    \n    \n       \n       \n      scm\n      Privilege setting and metadata for configuration\n    \n    \n       \n       \n      test\n      Code for testing a profile (ex Common)\n    \n    \n       \n      ivi\n       \n      IVI profile-specific\n    \n    \n       \n       \n      platform\n      Platform component\n    \n    \n       \n       \n      apps\n      IVI profile-specific application\n    \n    \n       \n       \n      sdk\n      SDK\n    \n    \n       \n       \n      scm\n      Privilege setting and metadata for configuration\n    \n    \n       \n       \n      test\n      Code for testing a profile (ex Common)\n    \n    \n      Product\n       \n       \n      Product-specific\n    \n    \n       \n      upstream\n       \n      Code from upstream open source\n    \n  \n\n\n\n  Note\n\n  If the Git repository is not listed above, it does not belong to Tizen 3.0 and higher."
					}
					
				
			
		
			
				
					,
					
					"iot-about-git-repo-structure": {
						"id": "iot-about-git-repo-structure",
						"title": "Git Repository Structure",
						"categories": "",
						"url": " iot/about/git-repo-structure/",
						"content": "Git Repository Structure\n\nThe following table describes the Git repository structure for Tizen 3.0 and higher.\n\nTable: Git repository structure for Tizen 3.0 and higher\n\n\n  \n    \n      First depth\n      Second depth\n      Third depth\n      Description\n    \n  \n  \n    \n      Platform\n       \n       \n      Platform component\n    \n    \n       \n      upstream\n       \n      Code from upstream open source (Wayland, GStreamer, .NET Engine)\n    \n    \n       \n      adaptation\n       \n      Adaptation layer for supporting various kind of devices\n    \n    \n       \n      framework\n       \n      Web Framework\n    \n    \n       \n       \n      web\n      Web Framework (Web Engine)\n    \n    \n       \n      core\n       \n      Core Framework\n    \n    \n       \n       \n      api\n      Native APIs for Core Framework\n    \n    \n       \n       \n      csapi\n      TizenFX API for Tizen .NET (C#)\n    \n    \n       \n       \n      webapi\n      Web APIs for Web Framework\n    \n    \n       \n      kernel\n       \n      Kernel for supporting various kind of devices\n    \n    \n      Apps\n       \n       \n      Common application\n    \n    \n       \n      native\n       \n      Common native application\n    \n    \n       \n      Web\n       \n      Common Web application\n    \n    \n      Tools\n       \n       \n      Tools constituting the Tizen platform development environment\n    \n    \n       \n      Upstream\n       \n      Code from upstream open source (valgrind, oprofile)\n    \n    \n      Services\n       \n       \n      Services constituting Tizen build services\n    \n    \n      SDK\n       \n       \n      SDK\n    \n    \n       \n      ide\n       \n      IDE tools with which you can develop Tizen applications\n    \n    \n      SCM\n       \n       \n      Privilege setting and metadata for configuration\n    \n    \n      Test\n       \n       \n      Code for testing a profile (ex Common)\n    \n    \n       \n      tools\n       \n      Tools for testing a profile\n    \n    \n      Profile\n       \n       \n      Profile-specific\n    \n    \n       \n      Mobile\n       \n      Mobile profile-specific\n    \n    \n       \n       \n      platform\n      Platform component\n    \n    \n       \n       \n      apps\n      Mobile profile-specific application\n    \n    \n       \n       \n      sdk\n      SDK\n    \n    \n       \n       \n      scm\n      Privilege setting and metadata for configuration\n    \n    \n       \n       \n      test\n      Code for testing a profile (ex Common)\n    \n    \n       \n      wearable\n       \n      Wearable profile-specific\n    \n    \n       \n       \n      platform\n      Platform component\n    \n    \n       \n       \n      apps\n      Wearable profile-specific application\n    \n    \n       \n       \n      sdk\n      SDK\n    \n    \n       \n       \n      scm\n      Privilege setting and metadata for configuration\n    \n    \n       \n       \n      test\n      Code for testing a profile (ex Common)\n    \n    \n       \n      common\n       \n      Common profile-specific\n    \n    \n       \n       \n      platform\n      Platform component\n    \n    \n       \n       \n      apps\n      Common profile-specific application\n    \n    \n       \n       \n      sdk\n      SDK\n    \n    \n       \n       \n      scm\n      Privilege setting and metadata for configuration\n    \n    \n       \n       \n      test\n      Code for testing a profile (ex Common)\n    \n    \n       \n      ivi\n       \n      IVI profile-specific\n    \n    \n       \n       \n      platform\n      Platform component\n    \n    \n       \n       \n      apps\n      IVI profile-specific application\n    \n    \n       \n       \n      sdk\n      SDK\n    \n    \n       \n       \n      scm\n      Privilege setting and metadata for configuration\n    \n    \n       \n       \n      test\n      Code for testing a profile (ex Common)\n    \n    \n      Product\n       \n       \n      Product-specific\n    \n    \n       \n      upstream\n       \n      Code from upstream open source\n    \n  \n\n\n\n  Note\n\n  If the Git repository is not listed above, it does not belong to Tizen 3.0 and higher."
					}
					
				
			
		
			
				
					,
					
					"glossary": {
						"id": "glossary",
						"title": "Glossary",
						"categories": "",
						"url": " glossary/",
						"content": "Glossary\n\nThe following table defines some basic terminology used in Tizen.\n\n\n  \n    \n      Term\n      Definition\n    \n  \n  \n    \n      .edc file\n      EDC (Edje Data Collection) file is a text script file that contains the code describing the position, size, and other parameters of graphical elements that compose the visual aspect of the Tizen native application. Using the Edje library tools, an EDC file must be compiled into a .edj file, which is a UI layout binary.\n    \n    \n      .edj file\n      Package file for Tizen native application themes (Edje).\n    \n    \n      .tpk file\n      TPK (tizen package) file is a package file for Tizen native applications. It contains the tizen-manifest.xml file that defines the package attributes. A TPK package can contain multiple Tizen native applications.Related terms: Native application\n    \n    \n      .wgt file\n      Package file for Tizen Web applications. A WGT package contains the config.xml file that defines the Web application attributes. The format of the WGT package is based on the W3C (World Wide Web Consortium) widgets standard.Related terms: Web application\n    \n    \n      Access token\n      Security credentials for a login session. They identify the user, the user’s groups and privileges, and, in some cases, a particular application.\n    \n    \n      Actor (in DALi)\n      Primary object that composes the entire scene and interacts in DALi applications. Actors are effective nodes that receive input (such as touch events) and act as a container for drawable elements and other actors. A DALi application uses a hierarchy of actor objects to position visible content. An actor inherits a position relative to its parent, and can be moved relative to this point. UI components can be built by combining multiple actors.\n    \n    \n      Author certificate\n      Developer signs an application package with their author certificate and signing key to specify who developed the application. The result of the signing is an author signature.Related terms: Tizen certificate\n    \n    \n      Author signature\n      Author signature specifies which entity alleges to have authored the package, that the integrity of the package is as the author intended, and whether a set of packages came from the same author.\n    \n    \n      Cairo\n      Open source library for 2D vector graphics with support for multiple output devices. In Tizen, Cairo can support output to 2 different backends: the image and GL backend.\n    \n    \n      config.xml\n      File that contains the Web application package information. It defines all the information about the package and applications in it.\n    \n    \n      DALi\n      DALi (Dynamic Animation Library) is a cross-platform 3D UI toolkit for embedded systems. Its 3D user interface engine enables you to create rich and high-performance UI applications. DALi is based on OpenGL ES 2.0, but provides a clean cross-platform C++ framework. This means that you can use high-level DALi APIs instead of accessing low-level OpenGL APIs directly.Related terms: OpenGL ES\n    \n    \n      Distributor certificate\n      Distributor, such as the Tizen Store, signs an application package with its distributor certificate and signing key to specify who distributes the application. The result of the signing is a distributor signature.Related terms: Tizen certificate\n    \n    \n      Distributor signature\n      Distributor signature specifies that a particular distributor has distributed a package, that the integrity of the package is as the distributor intended, and whether a set of packages came from the same distributor.\n    \n    \n      DUID\n      DUID (Device Unique ID) is assigned to the device by a device vendor. Based on the DUID, a vendor-specific test distributor certificate is generated.\n    \n    \n      EFL\n      Tizen platform provides EFL (Enlightenment Foundation Libraries) as one of the native UI toolkit frameworks for developing a native application. EFL is a collection of libraries that are independent or can build on top of each other to provide useful features that complement the OS’s existing environment, rather than wrap and abstract it, trying to be their own environment and OS in its entirety. This means that EFL expects you to use other system libraries and APIs in conjunction with EFL libraries to provide a whole working application or library. Simply use EFL as a set of convenient pre-made libraries to accomplish many complex or painful tasks.\n    \n    \n      EGL\n      EGL™ (Embedded-System Graphics Library) is an interface between rendering APIs, such as OpenGL ES, and the underlying native platform window system. It handles graphic context management, surface/buffer binding, and rendering synchronization, and enables high-performance, accelerated, mixed-mode 2D and 3D rendering using other APIs.\n    \n    \n      Elementary UI components\n      Elementary library is a set of fast, finger-friendly, scalable, and themeable UI component libraries. It provides several UI components that can be used to compose the user interface of Tizen native applications.Originally, the Elementary was developed as part of the Window manager development on desktop devices. For the mobile and wearable profile, Tizen platform reused the proper UI components and created new ones, and then enhanced the adjusted all of them for Tizen native applications.\n    \n    \n      Elm_GLView\n      The easiest way to use the OpenGL ES API in a Tizen application is to rely on the Elm_GLView component. The Elm_GLView component is one of the Elementary UI components, which creates an OpenGL ES (GL) target surface and a context. The Elm_GLView component can be embedded in any Tizen UI application. It is basically a wrapper of Evas_GL, the GL/EGL abstraction layer of EFL. By using the Elm_GLView component, you avoid having to consider how EGL environment is coupled with the native windowing systems.Related terms: OpenGL ES, Evas, EGL, EFL\n    \n    \n      EOS\n      EOS (End Of Stream) is a condition where no more data can be read from the stream.\n    \n    \n      Evas\n      Canvas engine responsible for managing the drawing of your content. All graphical objects that you create are Evas objects. Evas handles the entire window state by filling the canvas with objects and manipulating their states. In contrast to other canvas libraries, such as Cairo, OpenGL, and XRender, Evas is not a drawing library, but a scene graph library that retains the state of all objects.The Evas concept is explained in Evas Rendering Concept and Method. Evas objects are created and then manipulated until they are no longer needed, at which point they are deleted. This allows you to work in the same terms than a designer thinks in: it is a direct mapping, as opposed to having to convert the concepts into drawing commands in the right order, and calculate the minimum drawing calls needed to get the job done.\n    \n    \n      EXIF\n      EXIF (Exchangeable Image File) is a format used for images, sound, and tags in digital still cameras and other systems handling the image and sound files recorded by digital still cameras.\n    \n    \n      GDB\n      GDB (GNU Debugger) is the most popular debugger for UNIX systems to debug C and C++ programs.\n    \n    \n      Home screen\n      Main user interface on a device or operating system where the user can access a set of functions or applications available on the device.\n    \n    \n      Hybrid Web application\n      Tizen supports a WGT package that contains 1 Web application and multiple native service or widget applications. When you want to develop a Web application and also use powerful Tizen native APIs, you can develop a Web application and separate native service and widget applications, and package them all to a WGT package.\n    \n    \n      Layout\n      Container component that takes a standard Edje design file and wraps it very thinly in a UI component. Unlike other container components, which have predefined layouts, the layout component enables you to define the look and feel of the UI with animation and basic event response.\n    \n    \n      Media packet\n      AV packet buffer for interworking between multimedia framework modules.\n    \n    \n      Native API\n      Tizen Native API is a set of carefully selected and tightly managed APIs from the Tizen native subsystems. The Tizen Native API Specification available in the Tizen SDK shows a full list of the selected native subsystem APIs. The Native API is divided into dozens of API modules; each module represents a set of logically similar submodule APIs, which can be grouped into the same category.\n    \n    \n      Native application\n      Native application is developed using C/C++ and can use Tizen Native APIs. Usually, native applications can be developed using EFL or DALi to draw something to the screen. The Tizen Native API supports more advanced device-specific features, such as camera, GPS, and accelerometer, in addition to more advanced system settings and functionality.Related terms: EFL, DALi\n    \n    \n      OAuth\n      The OAuth 2.0 authorization framework enables a third-party application to obtain limited access to an HTTP service, either on behalf of a resource owner by orchestrating an approval interaction between the resource owner and the HTTP service, or by allowing the third-party application to obtain access on its own behalf.\n    \n    \n      OpenGL ES\n      OpenGL ES (Open Graphics Library embedded systems) is an interface to the GPU that consists of well-defined subsets of the desktop OpenGL API. Tizen native applications can use OpenGL ES not only for creating a 3D scene, but also for a 2D scene that requires fast interaction. OpenGL ES is also good for improving performance and reducing power consumption when the native application performs computation-intensive tasks that can be run in parallel.\n    \n    \n      Pbuffer surface\n      Pbuffers are typically allocated in off-screen (non-visible) graphics memory and intended only for accelerated off-screen rendering. For that, Evas_GL can support the creation of the pbuffer surface.Related terms: Evas\n    \n    \n      Privilege\n      Tizen provides API-level access control for security-sensitive operations which, if not used correctly, can harm user privacy and system stability. Therefore, applications that use such sensitive APIs must declare the required privileges in the tizen-manifest.xml or config.xml file.Privileges have a level according to their hierarchy. The public level is the minimum privilege level, and any application developed by using the SDK can use these privileges. The platform level is the highest privilege level, and an application that needs theses privileges requires a platform-signed certificate.Related terms: tizen-manifest.xml file\n    \n    \n      Push notification\n      Push notification is a message received from an application server through the push server. Once the application server sends a notification to the Tizen push server, the server forwards the notification to the destination device, and the push service (daemon) of the device delivers it to the application. Based on the selected option, the user can be notified by an alert message in the notification bar, or the application can be launched upon the arrival of the notification.\n    \n    \n      Push service\n      Tizen push service is used to provide push notifications for messages or updates for services. The push service can also refer to the push daemon itself running in the Tizen framework.\n    \n    \n      SDB\n      SDB (Smart Development Bridge) is a command line tool for emulator and device management. It acts as an intermediary between a device and your development system, and provides various device management capabilities, such as moving and syncing files to the emulator, or running a UNIX shell on the device or emulator.\n    \n    \n      Service application\n      Service application does not have a UI and runs in the background. It can support background jobs for a application that has a UI. Usually, it needs to be packaged with a native UI application.\n    \n    \n      SMACK\n      SMACK (Simplified Mandatory Access Control in Kernel) is one of the Mandatory Access Control (MAC) mechanisms available in the Linux kernel since 2.6.25. SMACK is designated as the access control mechanism for Tizen out of many technologies, such as SELINUX, TOMOYO and APPARMOR, because of the simplicity and ease of use.SMACK defines 3 components: subject, object, and access type. The subject represents the domain of the process, and the object represents the domain of the resource (such as file, process, IPC, or network), which the process tries to access. The access type is the parameter of the operation that the subject wants to perform with the object, for example, read, write, or execute.\n    \n    \n      Stage\n      Top-level node of the scene graph used for displaying a tree of actors. To display an actor, add it to the stage.Related terms: Actor\n    \n    \n      STT\n      STT (speech-to-text) features enable recognizing sound data recorded by the user and sending the result as text. When your application creates a handle and prepares the STT service with the API, the STT daemon is invoked and connected for background work. This daemon and your application communicate as the server and the client.\n    \n    \n      Surface\n      Object holding pixels that are being composited to the screen.There are 2 kind of surfaces: main surface and sub-surface. A main surface with its sub-surfaces forms a (compound) window. For window management purposes, this set of surface objects is to be considered as a single window, and it must also behave as such. The aim of sub-surfaces is to offload some of the compositing work within a window from clients to the compositor. A prime example is a video player with decorations and video in separate surface objects. This allows the compositor to pass YUV video buffer processing to dedicated overlay hardware, when possible.\n    \n    \n      Sync Manager\n      Sync Manager provides notifications for a service application to maintain data consistency between a server and the device. You can manage the synchronization schedule for applications.\n    \n    \n      TAU\n      TAU (Tizen Advanced UI) is a touch-optimized Web UI framework to create a Web application that runs on a wide variety of Tizen devices. It contains well-defined and efficient UI components, templates, and samples.In wearable devices especially, TAU provides a way to make a single application support multiple display shapes, such as square, rectangular, and circular.\n    \n    \n      TBM\n      TBM (Tizen Buffer Manager) provides a mechanism for allocating graphic buffers rendering images on Tizen.\n    \n    \n      Tizen certificate\n      Before you run the application, you must sign your application package by generating a Tizen certificate and registering it in the IDE. The Tizen certificate consists of an author and distributor certificate.The Tizen certificate can be generated by creating a new profile in the IDE. For commercial devices, the Tizen certificate can be issued by a device vendor.Related terms: Author certificate, Distributor certificate\n    \n    \n      tizen-manifest.xml\n      File that contains the native application package information. It defines all the information about the package and applications in it.\n    \n    \n      TTS\n      TTS (text-to-speech) features include synthesizing text into sound data as utterances and playing them. It is also possible to pause and stop playing. When your application creates a handle and prepares the TTS service with the API, the TTS daemon is invoked and connected for background work. This daemon and your application communicate as the server and the client.\n    \n    \n      UI components\n      UI components allow you to build a Tizen native application without having to reinvent basic objects, such as buttons, lists, or text entries.\n    \n    \n      UI container\n      EFL supports building layouts in the form of Elementary UI components. Those UI components are classified as containers. Elementary provides a set of UI containers which enable displaying UI components in an organized layout.Note that container UI components do not have their own visual identity. They only have logical structures for assignment or placement of the UI components.\n    \n    \n      vCalendar/iCalendar\n      Computer file format, which allows Internet users to send meeting requests and tasks to other Internet users through email or by sharing files with an extension of .vcs/.ics.iCalendar design is based on the previous file format, vCalendar, created by the IMC (Internet Mail Consortium).\n    \n    \n      vCard\n      File format standard for electronic business cards. It can contain name and address information, telephone numbers, email addresses, URLs, logos, photographs, and audio clips.\n    \n    \n      Voice control\n      Voice control features allow the user to control the device through voice commands. This feature is supported in mobile applications only.The Voice control API enables you to register voice commands, which trigger a callback when the user speaks them. The Voice control elementary API enables you to register voice commands for EFL-supported UI components to perform component-related actions, such as button clicks.\n    \n    \n      Wayland\n      Wayland window system is a windowing system based on the wayland protocol, which is both a protocol where a compositor talks to its clients, and a C library implementation of that protocol. The compositor can be a standalone display server running on the Linux kernel mode setting and evdev input devices, an X application, or a Wayland client itself.\n    \n    \n      Web application\n      Web application comprises HTML, JavaScript, and CSS combined in a package, which can be installed on the Tizen device. A Web application package includes all the support files that are needed by the Web application. Therefore, a Web application can run without any additional external resources or network connectivity after the installation.The application model supports a rich set of standard W3C/HTML5 features, which include various JavaScript APIs as well as additional HTML markups and CSS features. These features along with the Tizen Device APIs and UI framework support can be used to create rich Web applications in a variety of categories, such as contact, messaging, device information access, multimedia, graphics, and games.\n    \n    \n      Web Device API\n      Tizen Web Device API, based on JavaScript, provides you advanced access to the device platform capabilities.You can develop rich Web applications using the Tizen Web Device APIs. You can, for example, control the application life-cycle, manage your schedules, exchange data, or make payments using NFC.\n    \n    \n      Widget application\n      Tizen application that can be shown on the home screen as a widget. Usually, widget applications are launched by the home screen when the user selects them in the Add Widget menu.Widget applications are useful to provide simple information or control to users, because users can see the widget on the home screen without launching the application explicitly.\n    \n    \n      Window UI component\n      Bottom-most UI component in a Tizen native application. Basically, the way to build a Tizen native application is to add a window and set content in it. Window UI components are provided by the Elementary library, which is a high-level wrapper on the top-most layer.\n    \n    \n      X Window\n      X Window System (X11, or shortened to simply X, and sometimes informally X-Windows) is a windowing system for bitmap displays, common on UNIX-like computer operating systems.\n    \n    \n      YUV\n      YUV color model represents the human perception of color more closely than the standard RGB model used in computer graphics hardware. In YUV, Y is the luminance (brightness) component, while U and V are the chrominance (color) components."
					}
					
				
			
		
			
				
					,
					
					"application-porting-graphics-and-ui": {
						"id": "application-porting-graphics-and-ui",
						"title": "Graphics and UI",
						"categories": "",
						"url": " application/porting/graphics-and-ui/",
						"content": "Graphics and UI\n\nThe application composes the graphic user interface by creating a window with a toolkit. The display server composites an application’s windows and shows the result on the screen. For this procedure, the graphics and UI middleware offers the following 3 modules for both client and server:\n\n\n  Tizen Buffer Manager (TBM)\n  Tizen Display Manager (TDM)\n  TPL-EGL\n\n\nFigure: Graphics UI diagram\n\n\n\nThe modules are hardware abstraction layers for graphics and UI. They allow the client and server to render with the GPU, share buffers with other processes, and organize hardware output devices for various chipsets. Their backend module needs to be implemented for the new hardware device.\n\n\n  TBM provides an abstraction interface for the Tizen graphic buffer manager.\n  TDM provides an abstraction interface for a display server, such as X or Wayland, to allow direct access to graphics hardware in a safe and efficient manner as a display HAL.\n  TPL-EGL is an abstraction layer for surface and buffer management on the Tizen platform aimed to implement the EGL™ porting layer of the OpenGL® ES driver over various display protocols.\n\n\nFor an application to handle input device events, the Input Manager is provided, and is mainly comprised of libinput and a thin wrapper around it. It handles input events in Wayland compositors and communicates with Wayland clients.\n\nBuffer Management\n\nTBM has a frontend library and a backend module. The TBM frontend library is hardware-independent and provides a generic buffer interface. On the other hand, the TBM backend module is hardware-dependent and provides a buffer interface dependent on the target system. Chipset vendors have to provide their own backend modules in order for TBM to work well on the Tizen platform. This is because the way each vendor manages the graphic buffers can be different between various chipset devices. TBM already has several reference backends, such as libtbm-dumb, and libtbm-shm.\n\nFigure: TBM backend\n\n\n\nWith TBM, the client and server can allocate buffers and share buffers between them. For example, a client allocates a graphic buffer, draws something on it with GL and sends it to the display server for displaying it on the screen without buffer copying. The TBM backend module is implemented as a shared library and the TBM frontend finds the libtbm-default.so file and loads it from the /usr/lib/bufmgr directory at runtime.\n\nsh-3.2# ls -al\nlrwxrwxrwx  1 root root    14 Jul 28  2016 libtbm_default.so -&gt; libtbm_sprd.so\nlrwxrwxrwx  1 root root    20 Jul 28  2016 libtbm_sprd.so -&gt; libtbm_sprd.so.0.0.0\nlrwxrwxrwx  1 root root    20 Jul 28  2016 libtbm_sprd.so.0 -&gt; libtbm_sprd.so.0.0.0\n-rwxr-xr-x  1 root root 26728 Jun 29  2016 libtbm_sprd.so.0.0.0\n\n\nInitialing the TBM Backend Module\n\nThe TBMModuleData is for the entry point symbol to initialize the TBM backend module. The TBM backend module must define the global data symbol with the name of tbmModuleData. The TBM frontend loads the tbmModuleData global data symbol and calls the init() function at the initial time.\n\n\n  Note\n\n  Do not change the name of the symbol in the TBM backend module.\n\n\n/*\n   @brief tbm module data\n   Data type for the entry point of the backend module\n*/\ntypedef struct {\n    TBMModuleVersionInfo *vers;\t/* TBM module information */\n    ModuleInitProc init; /* init function of a backend module */\n} TBMModuleData;\n\ntypedef int (*ModuleInitProc) (tbm_bufmgr, int);\n\n\nThe TBM backend module initialization consists of allocating the tbm_bufmgr_backend instance (tbm_backend_alloc), entering the necessary information, and the initialization itself (tbm_backend_init).\n\ntbm_bufmgr_backend tbm_backend_alloc(void);\nvoid tbm_backend_free(tbm_bufmgr_backend backend);\nint tbm_backend_init(tbm_bufmgr bufmgr, tbm_bufmgr_backend backend);\n\n\nMODULEINITPPROTO (init_tbm_bufmgr_priv);\n\nstatic TBMModuleVersionInfo DumbVersRec = {\n    \"shm\",\n    \"Samsung\",\n    TBM_ABI_VERSION,\n};\n\nTBMModuleData tbmModuleData = {&amp;DumbVersRec, init_tbm_bufmgr_priv};\n\nint\ninit_tbm_bufmgr_priv(tbm_bufmgr bufmgr, int fd) {\n    tbm_bufmgr_backend bufmgr_backend;\n\n    bufmgr_shm = calloc(1, sizeof(struct _tbm_bufmgr_shm));\n\n    bufmgr_backend = tbm_backend_alloc();\n\n    bufmgr_backend-&gt;priv = (void *)bufmgr_shm;\n    bufmgr_backend-&gt;bufmgr_deinit = tbm_shm_bufmgr_deinit,\n    bufmgr_backend-&gt;bo_size = tbm_shm_bo_size,\n    bufmgr_backend-&gt;bo_alloc = tbm_shm_bo_alloc,\n    bufmgr_backend-&gt;bo_free = tbm_shm_bo_free,\n    bufmgr_backend-&gt;bo_import = tbm_shm_bo_import,\n    bufmgr_backend-&gt;bo_import_fd = NULL,\n    bufmgr_backend-&gt;bo_export = tbm_shm_bo_export,\n    bufmgr_backend-&gt;bo_export_fd = NULL,\n    bufmgr_backend-&gt;bo_get_handle = tbm_shm_bo_get_handle,\n    bufmgr_backend-&gt;bo_map = tbm_shm_bo_map,\n    bufmgr_backend-&gt;bo_unmap = tbm_shm_bo_unmap,\n    bufmgr_backend-&gt;bo_lock = NULL;\n    bufmgr_backend-&gt;bo_unlock = NULL;\n    bufmgr_backend-&gt;surface_get_plane_data = tbm_shm_surface_get_plane_data;\n    bufmgr_backend-&gt;surface_supported_format = tbm_shm_surface_supported_format;\n\n    if (!tbm_backend_init(bufmgr, bufmgr_backend)) {\n        tbm_backend_free(bufmgr_backend);\n        free(bufmgr_shm);\n\n        return 0;\n    }\n\n    return 1;\n}\n\n\nPorting the OAL Interface\n\nTBM provides the header files to implement the TBM backend module.\n\nTable: TBM backend module header files\n\n\n  \n    \n      Header file\n      Description\n    \n  \n  \n    \n      tbm_bufmgr_backend.h\n      This file includes information on implementing the TBM backend module.\n    \n    \n      tbm_drm_helper.h\n      This file includes helper functions for the DRM interface backend module.\n    \n    \n      tbm_bufmgr.h\n      This is the user header file including general information on how to use the TBM.\n    \n    \n      tbm_surface.h\n      This is the user header file including general information on how to use tbm_surface.\n    \n  \n\n\nTBM Backend Interface\n\nThe following table lists the TBM backend interface functions for initializing and deinitializing.\n\nTable: Initializing and deinitializing functions\n\n\n  \n    \n      Function\n      Description\n       \n    \n  \n  \n    \n      ModuleInitProc()\n      The init function of a backend module.\n      Mandatory\n    \n    \n      bufmgr_deinit()\n      Deinitialize the buffer manager privately.\n      Mandatory\n    \n    \n      bufmgr_bind_native_display()\n      If the backend needs to get the native display, use this backend function.\n      Optional\n    \n  \n\n\nThe following table lists the TBM backend interface functions for tbm_bo.\n\nTable: tbm_bo functions\n\n\n  \n    \n      Function\n      Description\n      Mandatory\n    \n  \n  \n    \n      bo_alloc()\n      Allocates the buffer object. If the backend wants to reuse the bo private at frontend, return the same pointer of the bo private.\n      Yes\n    \n    \n      bo_free()\n      Frees the buffer object. The frontend calls this function when it does not use the bo private.\n      Yes\n    \n    \n      bo_import()\n      Imports the buffer object associated with the key. If the backend does not support buffer sharing by the TBM key, the function pointer must be set to NULL.\n      No\n    \n    \n      bo_export()\n      Exports the buffer object. If the backend does not support buffer sharing by TBM key, the function pointer must be set to NULL.\n      No\n    \n    \n      bo_import_fd()\n      Imports the buffer object associated with the prime fd. The tbm_fd must be freed by the user. If the backend does not support buffer sharing by TBM fd, the function pointer must be set to NULL.\n      Yes (Must support buffer sharing by TBM fd.)\n    \n    \n      bo_export_fd()\n      Imports the buffer object associated with the prime fd. The tbm_fd must be freed by the user. If the backend does not support buffer sharing by TBM fd, the function pointer must be set to NULL.\n      Yes (Must support buffer sharing by TBM fd.)\n    \n    \n      bo_get_flags()\n      Gets the TBM flags of memory type.\n      Yes\n    \n    \n      bo_size()\n      Gets the size of a buffer object.\n      Yes\n    \n    \n      bo_get_handle()\n      Gets the tbm_bo_handle according to the device type.\n      Yes\n    \n    \n      bo_map()\n      Maps the buffer object according to the device type and the option.\n      Yes\n    \n    \n      bo_unmap()\n      Unmaps the buffer object.\n      Yes\n    \n    \n      bo_lock()\n      Locks the buffer object with a device and an opt.\n      No\n    \n    \n      bo_unlock()\n      Unlocks the buffer object.\n      No\n    \n  \n\n\nThe following table lists the TBM backend interface functions for tbm_surface.\n\nTable: tbm_surface functions\n\n\n  \n    \n      Function\n      Description\n      Mandatory\n    \n  \n  \n    \n      surface_supported_format()\n      Queries the format list and the number to be supported by backend.\n      Yes\n    \n    \n      surface_get_plane_data()\n      Gets the plane data, such as the size, offset, pitch, and buffer object index of the surface.\n      Yes\n    \n    \n      surface_bo_alloc()\n      Allocates the buffer object for the TBM surface with width, height, format, and buffer object index. If the backend does not want to allocate the buffer of the TBM surface with width, format, and height, the function pointer must be set to NULL. The TBM frontend allocation buffer of the TBM surface with data is gained from the surface_get_plane_data().\n      No\n    \n  \n\n\nThe following table lists the TBM buffer memory types.\n\nTable: TBM buffer memory types\n\n\n  \n    \n      Buffer memory type\n      Description\n    \n  \n  \n    \n      TBM_BO_DEFAULT\n      Default memory: it depends on the backend\n    \n    \n      TBM_BO_SCANOUT\n      Scanout memory\n    \n    \n      TBM_BO_NONCACHABLE\n      Non-cachable memory\n    \n    \n      TBM_BO_WC\n      Write-combine memory\n    \n    \n      TBM_BO_VENDOR\n      Vendor specific memory (depends on the backend)\n    \n  \n\n\nThe following table lists the TBM buffer device types.\n\nTable: TBM buffer device types\n\n\n  \n    \n      Device type\n      Description\n    \n  \n  \n    \n      TBM_DEVICE_DEFAULT\n      Device type to get the default handle\n    \n    \n      TBM_DEVICE_CPU\n      Device type to get the virtual memory\n    \n    \n      TBM_DEVICE_2D\n      Device type to get the 2D memory handle\n    \n    \n      TBM_DEVICE_3D\n      Device type to get the 3D memory handle\n    \n    \n      TBM_DEVICE_MM\n      Device type to get the multimedia handle\n    \n  \n\n\nThe following table lists the TBM buffer access options.\n\nTable: TBM buffer access options\n\n\n  \n    \n      Access option\n      Description\n    \n  \n  \n    \n      TBM_OPTION_READ\n      Access option to read\n    \n    \n      TBM_OPTION_WRITE\n      Access option to write\n    \n    \n      TBM_OPTION_VENDOR\n      Vendor-specific option that depends on the backend\n    \n  \n\n\nTBM DRM Helper Functions\n\nIf the target uses the drm interface, the client needs to get the authenticated fd from the display server and the display server must share the drm master fd with the TDM backend module. The TBM frontend provides the helper functions for drm authentication with the Wayland protocol and shares the master fd with the TDM backend module.\n\nTable: DRM helper functions\n\n\n  \n    \n      Function\n      Description\n    \n  \n  \n    \n      tbm_drm_helper_wl_auth_server_init()\n      If the TBM backend module need to use the authentication server, the backend module must call this function in the display server.\n    \n    \n      tbm_drm_helper_wl_auth_server_deinit()\n      Deinitializes the drm authentication in the display server.\n    \n    \n      tbm_drm_helper_get_master_fd()\n      If the TDM backend module already has a drm master fd, the TBM backend module can get the master fd from this function.\n    \n    \n      tbm_drm_helper_set_tbm_master_fd()\n      If the TBM backend module opens the drm master fd, this function has to be called for sharing the drm master fd with TDM.\n    \n    \n      tbm_drm_helper_unset_tbm_master_fd()\n      If the TBM backend module is opened and does not use the drm master fd, this function has to be called.\n    \n    \n      tbm_drm_helper_get_auth_info()\n      Client gets the authenticated fd and device info from the display server.\n    \n  \n\n\nTBM Backends\n\nThe following table lists the TBM backends.\n\nTable: TBM backends\n\n\n  \n    \n      Backend\n      Project (http://review.tizen.org)\n      Description\n    \n  \n  \n    \n      libtbm-shm\n      platform/adaptation/libtbm-shm\n      Backend for a target device which supports the SHM memory interface. The SHM backend module uses the XSI shared memory segment and does not have hardware dependencies.\n    \n    \n      libtbm-dumb\n      platform/adaptation/libtbm-dumb\n      Backend for a target device which supports the DUMB memory interface. If the target kernel supports the drm interface, the target can use the dumb backend because the DUMB memory interface is the default drm memory interface.\n    \n    \n      libtbm-sprd\n      platform/adaptation/spreadtrum/libtbm-sprd\n      Backend for a target device which uses the Spreadtrum chipset only. The sprd backend module uses the drm gem memory interface but some ioctl are only provided by the sprd drm kernel.\n    \n    \n      libtbm-exynos\n      platform/adaptation/samsung_exynos/libtbm-exynos\n      Backend for a target device which uses the exynos chipset only. The exynos backend module uses the drm gem memory interface but some ioctl are only provided by exynos drm kernel.\n    \n    \n      libtbm-vigs\n      platform/adaptation/emulator/libtbm-vigs\n      Backend for a target device which supports the VIGS interface. The vigs backend is used by the emulator target.\n    \n  \n\n\nReference\n\nFor more information about TBM and the TBM backend, see Tizen Buffer Manager (TBM).\n\nDisplay Management\n\nThe display server composites and shows the client’s buffers on screen. The display server sometimes needs to convert or scale an image to a different size or format. To make it possible for various chipset devices, the display server needs the display hardware resource information and control over the resources. Tizen Display Manager (TDM) offers these functionalities for the display server with the unified interface for various chipset devices.\n\nFigure: TDM backend\n\n\n\nWith TDM, the display server can perform mode setting, DPMS control, and showing a buffer (framebuffer or video buffer) on the screen in the most efficient way. If the hardware supports the m2m converting and capture device, the display server can also convert an image and dump a screen including all hardware overlays with no compositing.\n\nThe vendor has to implement the TDM backend module. The TDM backend module has the responsibility to let the TDM frontend know the display hardware resource information. The display server gets this information and controls hardware devices through the TDM frontend APIs. TDM already has several backends for reference, such as libtdm-drm and libtdm-fbdev.\n\nThe TDM backend is implemented as a shared library. The TDM frontend finds the libtdm-default.so file and loads it in the /usr/lib/tdm directory at runtime.\n\nsh-3.2# ls -l /usr/lib/tdm\ntotal 40\nlrwxrwxrwx 1 root root    14 Jul 28  2016 libtdm-default.so -&gt; libtdm-drm.so\n-rwxr-xr-x 1 root root 37152 Jul 12  2016 libtdm-drm.so\n\n\nThe TDM backend module must define the global data symbol with the name tdm_backend_module_data. The TDM frontend reads this symbol at the initialization time. TDM calls the init() function of the tdm_backend_module_data. For more information, see tdm_backend.h.\n\ntypedef struct _tdm_backend_module {\n    const char *name; /* The module name of the backend module */\n    const char *vendor; /* The vendor name of the backend module */\n    unsigned long abi_version; /* The ABI version of the backend module */\n    tdm_backend_data *(*init)(tdm_display *dpy, tdm_error *error);\n    void (*deinit)(tdm_backend_data *bdata);\n} tdm_backend_module;\n\n\n#include &lt;tdm_backend.h&gt;\n\nstatic tdm_drm_data *drm_data;\n\ntdm_backend_data*\ntdm_drm_init(tdm_display *dpy, tdm_error *error) {\n    drm_data = calloc(1, sizeof(tdm_drm_data));\n\n    return (tdm_backend_data*)drm_data;\n}\n\nvoid\ntdm_drm_deinit(tdm_backend_data *bdata) {\n    free(bdata);\n}\n\ntdm_backend_module tdm_backend_module_data = {\n    \"drm\",\n    \"Samsung\",\n    TDM_BACKEND_SET_ABI_VERSION(1,1),\n    tdm_drm_init,\n    tdm_drm_deinit\n};\n\n\nThe TDM backend must register the tdm_func_display(), tdm_func_output(), and tdm_func_layer() functions with the tdm_backend_register_func_display(), tdm_backend_register_func_output(), and tdm_backend_register_func_layer() functions in the tdm_backend_module_data init() function.\n\n#include &lt;tdm_backend.h&gt;\n\ntdm_backend_data*\ntdm_drm_init(tdm_display *dpy, tdm_error *error) {\n    memset(&amp;drm_func_display, 0, sizeof(drm_func_display));\n    drm_func_display.display_get_capability = drm_display_get_capability;\n    drm_func_display.display_get_pp_capability = drm_display_get_pp_capability;\n    drm_func_display.display_get_outputs = drm_display_get_outputs;\n    drm_func_display.display_get_fd = drm_display_get_fd;\n    drm_func_display.display_handle_events = drm_display_handle_events;\n    drm_func_display.display_create_pp = drm_display_create_pp;\n    ret = tdm_backend_register_func_display(dpy, &amp;drm_func_display);\n    if (ret != TDM_ERROR_NONE)\n        goto failed;\n\n    memset(&amp;drm_func_output, 0, sizeof(drm_func_output));\n    drm_func_output.output_get_capability = drm_output_get_capability;\n\n    ret = tdm_backend_register_func_output(dpy, &amp;drm_func_output);\n    if (ret != TDM_ERROR_NONE)\n        goto failed;\n\n    memset(&amp;drm_func_layer, 0, sizeof(drm_func_layer));\n    drm_func_layer.layer_get_capability = drm_layer_get_capability;\n\n    ret = tdm_backend_register_func_layer(dpy, &amp;drm_func_layer);\n    if (ret != TDM_ERROR_NONE)\n        goto failed;\n\n    return (tdm_backend_data*)drm_data;\n}\n\n\nAfter loading the TDM backend module, the TDM frontend calls the display_get_capability(), display_get_outputs(), output_get_capability(), output_get_layers(), and layer_get_capability() functions to get the hardware-specific information. That means that the TDM backend module must implement these 5 functions.\n\nIn addition, if a target has a memory-to-memory converting hardware device and the capture hardware device, the TDM backend module can register the tdm_func_pp() and tdm_func_capture() functions with the tdm_backend_register_func_pp() and tdm_backend_register_func_capture() functions.\n\nPorting the OAL Interface\n\nTDM provides the header files to implement the TDM backend module.\n\nTable: TDM backend module header files\n\n\n  \n    \n      Header file\n      Description\n    \n  \n  \n    \n      tdm_backend.h\n      This file defines the TDM backend interface.\n    \n    \n      tdm_log.h\n      This file includes functions to print logs in frontend and backend modules.\n    \n    \n      tdm_helper.h\n      This file includes helper functions for the TDM frontend and backend.\n    \n  \n\n\nThe display backend interface is mandatory. For more information, see tdm_backend.h.\n\nTable: Display backend interface functions\n\n\n  \n    \n      Function\n      Description\n      Mandatory\n    \n  \n  \n    \n      display_get_capability()\n      Gets the display capabilities of the backend module. TDM calls this function not only at initialization, but also when a new output is connected. If the hardware has a maximum usable layer count restriction, the backend module can set the max count in the max_layer_count element of the tdm_caps_display structure. Otherwise, it is set to -1.\n      Yes\n    \n    \n      display_get_pp_capability()\n      Gets the pp capabilities of the backend module. TDM calls this function not only at initialization, but also when a new output is connected. The backend module does not need to implement this function if the hardware does not have a memory-to-memory converting device. If it does, the backend module must fill the tdm_caps_pp data, which contains the hardware restriction information which a converting device can handle, such as format and size.\n      No\n    \n    \n      display_get_capture_capability()\n      Gets the capture capabilities of the backend module. TDM calls this function not only at initialization, but also when a new output is connected. The backend module does not need to implement this function if the hardware does not have a capture device. If it does, the backend module must fill the tdm_caps_capture data, which contains the hardware restriction information which a capture device can handle, such as format and size.\n      No\n    \n    \n      display_get_outputs()\n      Gets an output array of the backend module. TDM calls this function not only at initialization, but also when a new output is connected. The backend module must return the newly-allocated array which contains tdm_output* data. It is freed in the frontend.\n      Yes\n    \n    \n      display_get_fd()\n      Gets the file descriptor of the backend module. The backend module can return the epoll’s fd.\n      No\n    \n    \n      display_handle_events()\n      Handles the events which happen on the fd of the backend module.\n      No\n    \n    \n      display_create_pp()\n      Creates a pp object of the backend module. The backend module does not need to implement this function if the hardware does not have a memory-to-memory converting device\n      No\n    \n  \n\n\nThe output backend interface is mandatory. For more information, see tdm_backend.h.\n\nTable: Output backend interface functions\n\n\n  \n    \n      Function\n      Description\n      Mandatory\n    \n  \n  \n    \n      output_get_capability()\n      Gets the capabilities of an output object. TDM calls this function not only at initialization, but also when a new output is connected. The tdm_caps_output contains connection status, modes, available properties, and size restriction information.\n      Yes\n    \n    \n      output_get_layers()\n      Gets the layer array of an output object. TDM calls this function not only at initialization, but also when a new output is connected. The backend module must return the newly-allocated array which contains tdm_layer* data. It is freed in the frontend.\n      Yes\n    \n    \n      output_set_property()\n      Sets the property with a given ID.\n      No\n    \n    \n      output_get_property()\n      Gets the property with a given ID.\n      No\n    \n    \n      output_wait_vblank()\n      Waits for VBLANK. If this function returns TDM_ERROR_NONE, the backend module must call a user vblank handler with the user data of this function after vblanks interval.\n      Yes\n    \n    \n      output_set_vblank_handler()\n      Sets the user vblank handler.\n      Yes\n    \n    \n      output_commit()\n      Commits the changes for an output object. When this function is called, the backend module must apply all changes of the given output object to the screen as well as the layer changes of this output. If this function returns TDM_ERROR_NONE, the backend module must call a user commit handler with the user data of this function after all changes of the given output object are applied.\n      Yes\n    \n    \n      output_set_commit_handler()\n      Sets a user commit handler.\n      Yes\n    \n    \n      output_set_dpms()\n      Sets the DPMS of an output object.\n      No\n    \n    \n      output_get_dpms()\n      Gets the DPMS of an output object.\n      No\n    \n    \n      output_set_mode()\n      Sets 1 of the available modes of an output object.\n      Yes\n    \n    \n      output_create_capture()\n      Creates a capture object of an output object. The backend module does not need to implement this function if the hardware does not have a capture device.\n      No\n    \n    \n      output_set_status_handler()\n      Sets an output connection status handler. The backend module must call the output status handler when the output connection status has been changed to let the TDM frontend know of the change.\n      No\n    \n    \n      output_set_dpms_handler()\n      Sets an output DPMS handler. The backend module must call the output DPMS handler when the output DPMS has been changed to let the TDM frontend know of the change.\n      No\n    \n  \n\n\nThe layer backend interface is mandatory. For more information, see tdm_backend.h.\n\nTable: Layer backend interface functions\n\n\n  \n    \n      Function\n      Description\n      Mandatory\n    \n  \n  \n    \n      layer_get_capability()\n      Get the capabilities of a layer object. The backend module must implement this function. TDM calls this function not only at initialization, but also when a new output is connected. The tdm_caps_layer contains the available formats/properties and zpos information.\n      Yes\n    \n    \n      layer_set_property()\n      Sets the property with a given ID.\n      No\n    \n    \n      layer_get_property()\n      Gets the property with a given ID.\n      No\n    \n    \n      layer_set_info()\n      Sets the geometry information to a layer object. The backend module applies the geometry information when the output object of a layer object is committed.\n      Yes\n    \n    \n      layer_get_info()\n      Gets the geometry information of a layer object.\n      Yes\n    \n    \n      layer_set_buffer()\n      Sets a TDM buffer to a layer object. The backend module shows a TDM buffer on the screen when the output object of a layer object is committed.\n      Yes\n    \n    \n      layer_unset_buffer()\n      Unsets a TDM buffer from a layer object. The backend module must remove the currently-showing buffer from the screen.\n      Yes\n    \n    \n      layer_set_video_pos()\n      Sets the zpos for a video layer object. The backend module does not need to implement this function if the backend module does not have video layers. The zpos of the video layer is changeable.\n      No\n    \n    \n      layer_create_capture()\n      Creates a capture object of a layer object. The backend module does not need to implement this function if the hardware does not have a capture device.\n      No\n    \n    \n      layer_get_buffer_flags()\n      Gets the buffer flags which the layer can support.\n      No\n    \n  \n\n\nThe pp backend interface is optional. For more information, see tdm_backend.h.\n\nTable: pp backend interface functions\n\n\n  \n    \n      Function\n      Description\n    \n  \n  \n    \n      pp_destroy()\n      Destroys a pp object.\n    \n    \n      pp_set_info()\n      Sets the geometry information to a pp object. The backend module applies the geometry information when committed.\n    \n    \n      pp_attach()\n      Attaches a source buffer and a destination buffer to a pp object. The backend module converts the image of a source buffer to a destination buffer when committed. The size/crop/transform information is set using the pp_set_info() function of tdm_func_pp. When done, the backend module must return the source/destination buffer using the tdm_pp_done_handler() function.\n    \n    \n      pp_commit()\n      Commits changes for a pp object.\n    \n    \n      pp_set_done_handler()\n      Sets a user done handler to a pp object. The backend module must call the tdm_pp_done_handler() function when image conversion is done.\n    \n  \n\n\nThe capture backend interface is optional. For more information, see tdm_backend.h.\n\nTable: Capture backend interface functions\n\n\n  \n    \n      Function\n      Description\n    \n  \n  \n    \n      capture_destroy()\n      Destroys a capture object.\n    \n    \n      capture_set_info()\n      Sets the geometry information to a capture object. The backend module applies the geometry information when committed.\n    \n    \n      capture_attach()\n      Attaches a TDM buffer to a capture object. When the capture_commit() function is called, the backend module starts to dump an output or a layer to a TDM buffer. The backend module starts to dump an output or a layer to a TDM buffer when committed. The size/crop/transform information is set using the capture_set_info() function of the tdm_func_capture. When done, the backend module must return the TDM buffer using the tdm_capture_done_handler() function.\n    \n    \n      capture_commit()\n      Commits changes for a capture object.\n    \n    \n      capture_set_done_handler()\n      Sets a user done handler to a capture object. The backend module must call the tdm_capture_done_handler() function when the capture operation is done.\n    \n  \n\n\nTDM backends\n\nThere are several backends which can be used as reference when implementing the TDM backend.\n\nTable: TDM backends\n\n\n  \n    \n      Backend\n      Project (http://review.tizen.org)\n      Description\n    \n  \n  \n    \n      libtdm-drm\n      platform/adaptation/libtdm-drm\n      Backend for a target device which supports the DRM interface, such as the Tizen SDK emulator. No PP or capture capability.\n    \n    \n      libtdm-fbdev\n      platform/adaptation/libtdm-fbdev\n      Backend for a target device which supports the FBDEV interface. No PP or capture capability.\n    \n    \n      libtdm-exynos\n      platform/adaptation/samsung_exynos/libtdm-exynos\n      Backend for a target device which uses the exynos chipset using the DRM interface. Has PP and capture capability, using the exynos-specific DRM interface to support PP.\n    \n    \n      libtdm-sprd\n      platform/adaptation/spreadtrum/libtdm-sprd\n      Backend for a target device which uses the Spreadtrum chipset using the Spreadtrum-specific ioctl. Uses the DRM interface to support vblank. Has PP capability, but no capture capability.\n    \n  \n\n\nTesting the Porting Result\n\nTDM offers the tdm-test-server tool to allow you to easily test the porting result. The tdm-test-server tool is included in the libtdm-tools package, which can be downloaded from the platform binary’s snapshot repository. Make sure that TBM porting is done before using the following commands, because TDM works on top of TBM.\n\n$ systemctl stop display-manager  (stop the display server)\n$ export XDG_RUNTIME_DIR=/run\n$ export TBM_DISPLAY_SERVER=1\n$ tdm-test-server                 (show all options)\n$ tdm-test-server -a              (test all layers)\n$ tdm-test-server -a -v           (test all layers with vblank events)\n\n\nThe following image shows the result of a test performed using the tdm-test-server -a command. The fullscreen buffer is set to the PRIMARY layer, and the small buffer is set to the OVERLAY layer.\n\nFigure: Tdm-test-server results\n\n\n\nChecking TDM Log Messages\n\nTDM uses dlog to print debug messages. To show TDM runtime log messages:\n\n$ dlogutil -v threadtime TDM\n\n\nReferences\n\nFor detailed information about TDM and the TDM backend, see Tizen Display Manager (TDM).\n\nInput Management\n\nThe input manager supports a libinput-based input device backend. libinput is a common input library for the Wayland compositor. With libinput, the input stack is simpler without the Xorg input drivers. Since Tizen 3.0, the input manager is not a HAL component.\n\nFigure: Tizen 3.0 input management\n\n\n\nlibinput\n\nThe libinput library handles input devices for display servers and other applications that need to directly deal with input devices:\n\n\n  Device detection\n  Device handling\n  Input device event processing\n  Scaling touch coordinates\n  Generating pointer events from touchpads\n  Pointer acceleration\n\n\nFor more information, see the libinput wiki.\n\nlibevdev\n\nThe libevdev library handles evdev kernel devices. It abstracts the evdev ioctls through type-safe interfaces and provides functions to change the appearance of the device. For more information, see https://en.wikipedia.org/wiki/Evdev.\n\nmtdev\n\nThe mtdev standalone library transforms all variants of kernel MT events to the slotted type B protocol. For more information, see http://www.linuxfromscratch.org/blfs/view/svn/general/mtdev.html.\n\nlibinput Backends\n\nlibinput: platform/upstream/libinput\n\nOpenGL®\n\nThis section describes the essential elements of the Tizen platform-level graphics architecture related to OpenGL® ES and EGL™, and how it is used by the application framework and the display server. The focus is on how graphical data buffers move through the system.\n\nThe Tizen platform requires the OpenGL® ES driver for the acceleration of the Wayland display server and the wayland-egl client. This platform demands an OpenGL® ES and EGL™ driver which is implemented by the Tizen EGL Porting Layer.\n\nTizen OpenGL® ES and EGL™ Architecture\n\nThe following figure illustrates the Tizen OpenGL® ES and EGL™ architecture.\n\nFigure: Tizen OpenGL® ES architecture\n\n\n\n\n  \n    CoreGL\n\n    An injection layer of OpenGL® ES that provides the following capabilities:\n\n    \n      Support for driver-independent optimization (FastPath)\n      EGL™/OpenGL® ES debugging\n      Performance logging\n      Supported versions\n        \n          EGL™ 1.4\n          OpenGL® ES 1.1, 2.0, 3.0, 3.1\n        \n      \n    \n\n    CoreGL loads the manufacturer’s OpenGL® ES driver from the /usr/lib/driver directory. CoreGL provides the libEGL.so, libGLESv1_CM.so, and libGLESvs.so driver files in the /usr/lib directory.\n  \n  \n    GPU vendor GL/EGL™ driver\n\n    The Tizen platform demands that the GPU vendor implements the GL and EGL™ driver using libtpl-egl. The GPU vendor GL/EGL™ driver (libEGL.so, libGLESv1_CM.so, libGLESv2.so) must be installed in the /usr/lib/driver path.\n  \n\n\nTizen Porting Layer (TPL) for EGL™\n\nTPL-EGL is an abstraction layer for surface and buffer management on the Tizen platform. It is used for implementation of the EGL™ platform functions.\n\nFigure: TPL architecture\n\n\n\nThe background for the Tizen EGL Porting Layer for EGL™ is in various window system protocols in Tizen. There was a need for separating common layer and backend.\n\nTizen uses the Tizen Porting Layer for EGL™, as the TPL-EGL API prevents burdens of the EGL™ porting on various window system protocols. The GPU GL Driver’s Window System Porting Layer can be implemented by TPL-EGL APIs which are the corresponding window system APIs. The TBM, Wayland, and GBM backends are supported.\n\nTizen Porting Layer for the EGL™ Object Model\n\nTPL-EGL provides interfaces based on an object-driven model. Every TPL-EGL object can be represented as a generic tpl_object_t, which is reference-counted and provides common functions. Currently, display and surface types of TPL-EGL objects are provided. A display, like a normal display, represents a display system which is usually used for connecting to the server. A surface corresponds to a native surface, such as wl_surface. Surfaces can be configured to use N-buffers, but are usually double-buffered or triple-buffered. A buffer is what you render on, usually a set of pixels or a block of memory. For these 2 objects, the Wayland, GBM, TBM backend are defined, and they correspond to their own window systems. This means that you do not need to care about the window systems.\n\nThe TPL-EGL has the following core objects:\n\n\n  \n    TPL-EGL Object\n\n    Base class for all TPL-EGL objects.\n  \n  \n    TPL-EGL Display\n\n    Encapsulates the native display object (Display *, wl_display). Like a normal display, this represents a display system which is usually used for connecting to the server, scope for other objects.\n  \n  \n    TPL-EGL Surface\n\n    Encapsulates the native drawable object (Window, Pixmap, wl_surface). The surface corresponds to a native surface, such as tbm_surface_queue or wl_surface. A surface can be configured to use N-buffers, but they are usually double-buffered or triple-buffered.\n  \n\n\nTPL-EGL Objects and Corresponding EGL™ Objects\n\nBoth TPL-EGL and vendor OpenGL® ES/EGL™ driver handles a tbm_surface as the corresponding TPL surface buffer. It is represented by the TBM_Surface part in the following figure.\n\nFigure: TPL-EGL architecture\n\n\n\nThe following figure illustrates the OpenGL® ES drawing API flow.\n\nFigure: OpenGL® ES drawing API flow\n\n\n\nTPL-EGL Frontend API\n\nTPL-EGL Object is a base class for all TPL-EGL objects. It provides common functionalities to all TPL-EGL objects.\n\nTable: TPL-EGL Object functions\n\n\n  \n    \n      Function\n      Description\n    \n  \n  \n    \n      tpl_object_reference()\n      Increases the reference count of a TPL-EGL object. All TPL-EGL objects are reference-counted with a reference count 1 on creation. When the reference count drops to 0, the object is freed.\n    \n    \n      tpl_object_unreference()\n      Decreases the reference count and destroys the object if it becomes 0.\n    \n    \n      tpl_object_get_reference()\n      Gets the reference count of the given TPL-EGL object.\n    \n    \n      tpl_object_get_type()\n      Gets the type of the object (display, surface, or buffer).\n    \n    \n      tpl_object_set_user_data()\n      Sets the user data to a TPL-EGL object. If the user wants to relate some data with a TPL-EGL object, this function allows them to register a pointer to such data, which can be retrieved later using the tpl_object_get_user_data() function. The key is the pointer value itself as a key.\n    \n    \n      tpl_object_get_user_data()\n      Gets the registered user data of a TPL-EGL object.\n    \n  \n\n\nTPL-EGL Display encapsulates the native display object (Display *, wl_display). Any other objects created from TPL-EGL Display inherit its backend type.\n\nTable: TPL-EGL Display functions\n\n\n  \n    \n      Function\n      Description\n    \n  \n  \n    \n      tpl_display_create()\n      Creates the TPL-EGL display object for the given native display if there is no existing TPL-EGL display for that native display. If given NULL for native_dpy, this function returns the default display.\n    \n    \n      tpl_display_get()\n      Gets the TPL-EGL display object for the given native display if one exists for it.\n    \n    \n      tpl_display_get_native_handle()\n      Gets the native display handle which the given TPL-EGL display is created for.\n    \n    \n      tpl_display_query_config()\n      Queries the supported pixel formats for the given TPL-EGL display. If any pixel format values are acceptable, use the TPL_DONT_CARE value for the size values .\n    \n    \n      tpl_display_filter_config()\n      Filters the configuration according to a given TPL-EGL display. This function modifies current config specific to the current given TPL-EGL display.\n    \n    \n      tpl_display_get_native_window_info()\n      Queries information on the given native window.\n    \n    \n      tpl_display_get_native_pixmap_info()\n      Queries information on the given native pixmap.\n    \n    \n      tpl_display_get_buffer_from_native_pixmap()\n      Gets the native buffer from the given native pixmap.\n    \n  \n\n\nTPL-EGL Surface encapsulates the native drawable object (Window, Pixmap, wl_surface). The main features of the class are retrieving the buffer for a frame and posting the surface to a screen.\n\nTable: TPL-EGL Surface functions\n\n\n  \n    \n      Function\n      Description\n    \n  \n  \n    \n      tpl_surface_create()\n      Creates a TPL-EGL surface for the given native surface.\n    \n    \n      tpl_surface_get_display()\n      Gets the TPL-EGL display where the given TPL-EGL surface was created from.\n    \n    \n      tpl_surface_get_native_handle()\n      Gets the native surface handle of the given TPL-EGL surface.\n    \n    \n      tpl_surface_get_type()\n      Gets the type of the given TPL surface.\n    \n    \n      tpl_surface_get_size()\n      Gets the current size of the given TPL-EGL surface. The size of a surface can change when a user or the server resizes the window. TPL-EGL updates the size information every time when a buffer is queried using the tpl_surface_dequeue_buffer() function. Note that there can still be mismatch between actual surface size and the cached one.\n    \n    \n      tpl_surface_validate()\n      Validates the current frame of the given TPL-EGL surface. Call this function before getting the final render target buffer, as calling the tpl_surface_dequeue_buffer() function after calling this function can give output values different to earlier ones. A buffer returned after calling this function is guaranteed not to change further.\n    \n    \n      tpl_surface_dequeue_buffer()\n      Gets the buffer of the current frame for the given TPL-EGL surface. Depending on the backend, communication with the server can be required. Returned buffers are used for rendering the target to draw the current frame. Returned buffers are valid until the next tpl_surface_dequeue_buffer() function call. If the tpl_surface_validate() function returns TPL_FALSE, the previously returned buffers must no longer be used. Instead, this function must called again before drawing, returning a valid buffer.\n    \n    \n      tpl_surface_enqueue_buffer()\n      Posts a given tbm_surface. This function requests the display server to post a frame. This is the function which can enqueue a buffer to the tbm_surface_queue. Make sure this function is called exactly once for a frame. Scheduling post calls on a separate thread is recommended.\n    \n    \n      tpl_surface_enqueue_buffer_with_damage()\n      Posts a given tbm_surface with region of damage. Damage information is used for reducing number of pixels composited in the compositor. Setting the num_rects to 0 or rects to NULL means entire area is damaged. This function requests a server to post a frame. This function is identical with the tpl_surface_enqueue_buffer() function except for delivering the damage information for updating. Make sure this function is called exactly once for a frame. Scheduling post calls on a separate thread is recommended.\n    \n    \n      tpl_surface_set_post_interval()\n      Sets the frame interval of the given TPL-EGL surface, which ensures that only a single frame is posted within the specified vsync intervals. When a frame ends, the frame interval is set to the surface’s current interval.\n    \n    \n      tpl_surface_get_post_interval()\n      Gets the frame interval of the given TPL-EGL surface.\n    \n  \n\n\nThe following code snippet shows a simple example of the Tizen Porting Layer:\n\ndpy = tpl_display_create(...);\nsfc = tpl_surface_create(dpy, ...);\n\nwhile (1) {\n    buf = tpl_surface_dequeue_buffer(sfc);\n\n    /* Draw something */\n\n    tpl_surface_enqueue_buffer(sfc, buf);\n}\n\n\nIn the GPU vendor driver, the GPU frame builder handles the drawing. TPL-EGL exposes the native platform buffer identifiers and managers so that the buffer can be used in other modules. Currently, dma_buf/DRM is supported for these purposes. The EGL porting layer calls TPL-EGL functions to execute commands requested of it, and returns the results to the GPU vendor driver. TPL-EGL performs all protocol-dependent actions. Such protocol-dependent parts can be separated into TPL-EGL backends. TPL-EGL backend can also be configured at runtime, and you can specify which type of backend to use when initializing a display object.\n\nTPL-EGL and Wayland Server and Client\n\nTizen uses the wl_tbm protocol instead of wl_drm. The wl_tbm protocol is designed for sharing the buffer (tbm_surface) between the wayland_client and wayland_server. Although the wayland_tbm_server_init and wayland_tbm_client_init pair is a role for the eglBindWaylandDisplayWL, the EGL™ driver is required to implement the entry points for the eglBindWaylandDisplayWL and eglUnbindWaylandDisplayWL as dummy. For more information, see https://cgit.freedesktop.org/mesa/mesa/tree/docs/specs/WL_bind_wayland_display.spec.\n\nFigure: TPL-EGL and Wayland\n\n\n\nBuffer Flow Between the Wayland Server and OpenGL® ES/EGL™ Driver\n\nThe following figure shows the buffer flow between the Wayland server and the OpenGL® ES/EGL™ driver. The passed buffer is of the tbm_surface type.\n\nFigure: Buffer flow between Wayland server and OpenGL® ES/EGL™ driver\n\n\n\nProject Git Repository\n\nThe following table lists the available project Git repositories.\n\nTable: Git repositories\n\n\n  \n    \n      Project\n      Repository\n      Description\n    \n  \n  \n    \n      libtpl-egl\n      platform/core/uifw/libtpl-egl\n      Tizen Porting Layer for EGL™\n    \n    \n      libtbm\n      platform/core/uifw/libtbm\n      Library for the Tizen Buffer Manager\n    \n    \n      coregl\n      platform/core/uifw/coregl\n      Injection layer of OpenGL® ES / EGL™\n    \n    \n      wayland-tbm\n      platform/core/uifw/wayland-tbm\n      Protocol for graphics memory management for Tizen\n    \n    \n      emulator-yagl\n      platform/adaptation/emulator/emulator-yagl\n      OpenGL® ES / EGL™ driver for the emulator\n    \n    \n      tpl-novice\n      platform/core/uifw/ws-testcase\n      Novice test framework for TPL\n    \n  \n\n\nlibtpl-egl Reference Driver\n\nThe Emulator YAGL (OpenGL® ES / EGL™ driver for the emulator) is implemented by libtpl-egl.\n\nThe following commit explains how to port the driver with libtpl-egl from the traditional drm-based driver:\n\n\n  Porting YAGL to the Tizen platform https://review.tizen.org/gerrit/#/c/67921/\n\n\nTesting and Verifying the OpenGL® ES Driver\n\nThe Khronos OpenGL® ES CTS supports wayland-egl. libtpl-egl has a test case for the libtpl-egl. The ws-testcase’s tpl-novice has sample code for the libtpl-egl."
					}
					
				
			
		
			
				
					,
					
					"platform-porting-graphics-and-ui": {
						"id": "platform-porting-graphics-and-ui",
						"title": "Graphics and UI",
						"categories": "",
						"url": " platform/porting/graphics-and-ui/",
						"content": "Graphics and UI\n\nThe application composes the graphic user interface by creating a window with a toolkit. The display server composites an application’s windows and shows the result on the screen. For this procedure, the graphics and UI middleware offers the following 3 modules for both client and server:\n\n\n  Tizen Buffer Manager (TBM)\n  Tizen Display Manager (TDM)\n  TPL-EGL\n\n\nFigure: Graphics UI diagram\n\n\n\nThe modules are hardware abstraction layers for graphics and UI. They allow the client and server to render with the GPU, share buffers with other processes, and organize hardware output devices for various chipsets. Their backend module needs to be implemented for the new hardware device.\n\n\n  TBM provides an abstraction interface for the Tizen graphic buffer manager.\n  TDM provides an abstraction interface for a display server, such as X or Wayland, to allow direct access to graphics hardware in a safe and efficient manner as a display HAL.\n  TPL-EGL is an abstraction layer for surface and buffer management on the Tizen platform aimed to implement the EGL™ porting layer of the OpenGL® ES driver over various display protocols.\n\n\nFor an application to handle input device events, the Input Manager is provided, and is mainly comprised of libinput and a thin wrapper around it. It handles input events in Wayland compositors and communicates with Wayland clients.\n\nBuffer Management\n\nTBM has a frontend library and a backend module. The TBM frontend library is hardware-independent and provides a generic buffer interface. On the other hand, the TBM backend module is hardware-dependent and provides a buffer interface dependent on the target system. Chipset vendors have to provide their own backend modules in order for TBM to work well on the Tizen platform. This is because the way each vendor manages the graphic buffers can be different between various chipset devices. TBM already has several reference backends, such as libtbm-dumb, and libtbm-shm.\n\nFigure: TBM backend\n\n\n\nWith TBM, the client and server can allocate buffers and share buffers between them. For example, a client allocates a graphic buffer, draws something on it with GL and sends it to the display server for displaying it on the screen without buffer copying. The TBM backend module is implemented as a shared library and the TBM frontend finds the libtbm-default.so file and loads it from the /usr/lib/bufmgr directory at runtime.\n\nsh-3.2# ls -al\nlrwxrwxrwx  1 root root    14 Jul 28  2016 libtbm_default.so -&gt; libtbm_sprd.so\nlrwxrwxrwx  1 root root    20 Jul 28  2016 libtbm_sprd.so -&gt; libtbm_sprd.so.0.0.0\nlrwxrwxrwx  1 root root    20 Jul 28  2016 libtbm_sprd.so.0 -&gt; libtbm_sprd.so.0.0.0\n-rwxr-xr-x  1 root root 26728 Jun 29  2016 libtbm_sprd.so.0.0.0\n\n\nInitialing the TBM Backend Module\n\nThe TBMModuleData is for the entry point symbol to initialize the TBM backend module. The TBM backend module must define the global data symbol with the name of tbmModuleData. The TBM frontend loads the tbmModuleData global data symbol and calls the init() function at the initial time.\n\n\n  Note\n\n  Do not change the name of the symbol in the TBM backend module.\n\n\n/*\n   @brief tbm module data\n   Data type for the entry point of the backend module\n*/\ntypedef struct {\n    TBMModuleVersionInfo *vers;\t/* TBM module information */\n    ModuleInitProc init; /* init function of a backend module */\n} TBMModuleData;\n\ntypedef int (*ModuleInitProc) (tbm_bufmgr, int);\n\n\nThe TBM backend module initialization consists of allocating the tbm_bufmgr_backend instance (tbm_backend_alloc), entering the necessary information, and the initialization itself (tbm_backend_init).\n\ntbm_bufmgr_backend tbm_backend_alloc(void);\nvoid tbm_backend_free(tbm_bufmgr_backend backend);\nint tbm_backend_init(tbm_bufmgr bufmgr, tbm_bufmgr_backend backend);\n\n\nMODULEINITPPROTO (init_tbm_bufmgr_priv);\n\nstatic TBMModuleVersionInfo DumbVersRec = {\n    \"shm\",\n    \"Samsung\",\n    TBM_ABI_VERSION,\n};\n\nTBMModuleData tbmModuleData = {&amp;DumbVersRec, init_tbm_bufmgr_priv};\n\nint\ninit_tbm_bufmgr_priv(tbm_bufmgr bufmgr, int fd) {\n    tbm_bufmgr_backend bufmgr_backend;\n\n    bufmgr_shm = calloc(1, sizeof(struct _tbm_bufmgr_shm));\n\n    bufmgr_backend = tbm_backend_alloc();\n\n    bufmgr_backend-&gt;priv = (void *)bufmgr_shm;\n    bufmgr_backend-&gt;bufmgr_deinit = tbm_shm_bufmgr_deinit,\n    bufmgr_backend-&gt;bo_size = tbm_shm_bo_size,\n    bufmgr_backend-&gt;bo_alloc = tbm_shm_bo_alloc,\n    bufmgr_backend-&gt;bo_free = tbm_shm_bo_free,\n    bufmgr_backend-&gt;bo_import = tbm_shm_bo_import,\n    bufmgr_backend-&gt;bo_import_fd = NULL,\n    bufmgr_backend-&gt;bo_export = tbm_shm_bo_export,\n    bufmgr_backend-&gt;bo_export_fd = NULL,\n    bufmgr_backend-&gt;bo_get_handle = tbm_shm_bo_get_handle,\n    bufmgr_backend-&gt;bo_map = tbm_shm_bo_map,\n    bufmgr_backend-&gt;bo_unmap = tbm_shm_bo_unmap,\n    bufmgr_backend-&gt;bo_lock = NULL;\n    bufmgr_backend-&gt;bo_unlock = NULL;\n    bufmgr_backend-&gt;surface_get_plane_data = tbm_shm_surface_get_plane_data;\n    bufmgr_backend-&gt;surface_supported_format = tbm_shm_surface_supported_format;\n\n    if (!tbm_backend_init(bufmgr, bufmgr_backend)) {\n        tbm_backend_free(bufmgr_backend);\n        free(bufmgr_shm);\n\n        return 0;\n    }\n\n    return 1;\n}\n\n\nPorting the OAL Interface\n\nTBM provides the header files to implement the TBM backend module.\n\nTable: TBM backend module header files\n\n\n  \n    \n      Header file\n      Description\n    \n  \n  \n    \n      tbm_bufmgr_backend.h\n      This file includes information on implementing the TBM backend module.\n    \n    \n      tbm_drm_helper.h\n      This file includes helper functions for the DRM interface backend module.\n    \n    \n      tbm_bufmgr.h\n      This is the user header file including general information on how to use the TBM.\n    \n    \n      tbm_surface.h\n      This is the user header file including general information on how to use tbm_surface.\n    \n  \n\n\nTBM Backend Interface\n\nThe following table lists the TBM backend interface functions for initializing and deinitializing.\n\nTable: Initializing and deinitializing functions\n\n\n  \n    \n      Function\n      Description\n       \n    \n  \n  \n    \n      ModuleInitProc()\n      The init function of a backend module.\n      Mandatory\n    \n    \n      bufmgr_deinit()\n      Deinitialize the buffer manager privately.\n      Mandatory\n    \n    \n      bufmgr_bind_native_display()\n      If the backend needs to get the native display, use this backend function.\n      Optional\n    \n  \n\n\nThe following table lists the TBM backend interface functions for tbm_bo.\n\nTable: tbm_bo functions\n\n\n  \n    \n      Function\n      Description\n      Mandatory\n    \n  \n  \n    \n      bo_alloc()\n      Allocates the buffer object. If the backend wants to reuse the bo private at frontend, return the same pointer of the bo private.\n      Yes\n    \n    \n      bo_free()\n      Frees the buffer object. The frontend calls this function when it does not use the bo private.\n      Yes\n    \n    \n      bo_import()\n      Imports the buffer object associated with the key. If the backend does not support buffer sharing by the TBM key, the function pointer must be set to NULL.\n      No\n    \n    \n      bo_export()\n      Exports the buffer object. If the backend does not support buffer sharing by TBM key, the function pointer must be set to NULL.\n      No\n    \n    \n      bo_import_fd()\n      Imports the buffer object associated with the prime fd. The tbm_fd must be freed by the user. If the backend does not support buffer sharing by TBM fd, the function pointer must be set to NULL.\n      Yes (Must support buffer sharing by TBM fd.)\n    \n    \n      bo_export_fd()\n      Imports the buffer object associated with the prime fd. The tbm_fd must be freed by the user. If the backend does not support buffer sharing by TBM fd, the function pointer must be set to NULL.\n      Yes (Must support buffer sharing by TBM fd.)\n    \n    \n      bo_get_flags()\n      Gets the TBM flags of memory type.\n      Yes\n    \n    \n      bo_size()\n      Gets the size of a buffer object.\n      Yes\n    \n    \n      bo_get_handle()\n      Gets the tbm_bo_handle according to the device type.\n      Yes\n    \n    \n      bo_map()\n      Maps the buffer object according to the device type and the option.\n      Yes\n    \n    \n      bo_unmap()\n      Unmaps the buffer object.\n      Yes\n    \n    \n      bo_lock()\n      Locks the buffer object with a device and an opt.\n      No\n    \n    \n      bo_unlock()\n      Unlocks the buffer object.\n      No\n    \n  \n\n\nThe following table lists the TBM backend interface functions for tbm_surface.\n\nTable: tbm_surface functions\n\n\n  \n    \n      Function\n      Description\n      Mandatory\n    \n  \n  \n    \n      surface_supported_format()\n      Queries the format list and the number to be supported by backend.\n      Yes\n    \n    \n      surface_get_plane_data()\n      Gets the plane data, such as the size, offset, pitch, and buffer object index of the surface.\n      Yes\n    \n    \n      surface_bo_alloc()\n      Allocates the buffer object for the TBM surface with width, height, format, and buffer object index. If the backend does not want to allocate the buffer of the TBM surface with width, format, and height, the function pointer must be set to NULL. The TBM frontend allocation buffer of the TBM surface with data is gained from the surface_get_plane_data().\n      No\n    \n  \n\n\nThe following table lists the TBM buffer memory types.\n\nTable: TBM buffer memory types\n\n\n  \n    \n      Buffer memory type\n      Description\n    \n  \n  \n    \n      TBM_BO_DEFAULT\n      Default memory: it depends on the backend\n    \n    \n      TBM_BO_SCANOUT\n      Scanout memory\n    \n    \n      TBM_BO_NONCACHABLE\n      Non-cachable memory\n    \n    \n      TBM_BO_WC\n      Write-combine memory\n    \n    \n      TBM_BO_VENDOR\n      Vendor specific memory (depends on the backend)\n    \n  \n\n\nThe following table lists the TBM buffer device types.\n\nTable: TBM buffer device types\n\n\n  \n    \n      Device type\n      Description\n    \n  \n  \n    \n      TBM_DEVICE_DEFAULT\n      Device type to get the default handle\n    \n    \n      TBM_DEVICE_CPU\n      Device type to get the virtual memory\n    \n    \n      TBM_DEVICE_2D\n      Device type to get the 2D memory handle\n    \n    \n      TBM_DEVICE_3D\n      Device type to get the 3D memory handle\n    \n    \n      TBM_DEVICE_MM\n      Device type to get the multimedia handle\n    \n  \n\n\nThe following table lists the TBM buffer access options.\n\nTable: TBM buffer access options\n\n\n  \n    \n      Access option\n      Description\n    \n  \n  \n    \n      TBM_OPTION_READ\n      Access option to read\n    \n    \n      TBM_OPTION_WRITE\n      Access option to write\n    \n    \n      TBM_OPTION_VENDOR\n      Vendor-specific option that depends on the backend\n    \n  \n\n\nTBM DRM Helper Functions\n\nIf the target uses the drm interface, the client needs to get the authenticated fd from the display server and the display server must share the drm master fd with the TDM backend module. The TBM frontend provides the helper functions for drm authentication with the Wayland protocol and shares the master fd with the TDM backend module.\n\nTable: DRM helper functions\n\n\n  \n    \n      Function\n      Description\n    \n  \n  \n    \n      tbm_drm_helper_wl_auth_server_init()\n      If the TBM backend module need to use the authentication server, the backend module must call this function in the display server.\n    \n    \n      tbm_drm_helper_wl_auth_server_deinit()\n      Deinitializes the drm authentication in the display server.\n    \n    \n      tbm_drm_helper_get_master_fd()\n      If the TDM backend module already has a drm master fd, the TBM backend module can get the master fd from this function.\n    \n    \n      tbm_drm_helper_set_tbm_master_fd()\n      If the TBM backend module opens the drm master fd, this function has to be called for sharing the drm master fd with TDM.\n    \n    \n      tbm_drm_helper_unset_tbm_master_fd()\n      If the TBM backend module is opened and does not use the drm master fd, this function has to be called.\n    \n    \n      tbm_drm_helper_get_auth_info()\n      Client gets the authenticated fd and device info from the display server.\n    \n  \n\n\nTBM Backends\n\nThe following table lists the TBM backends.\n\nTable: TBM backends\n\n\n  \n    \n      Backend\n      Project (http://review.tizen.org)\n      Description\n    \n  \n  \n    \n      libtbm-shm\n      platform/adaptation/libtbm-shm\n      Backend for a target device which supports the SHM memory interface. The SHM backend module uses the XSI shared memory segment and does not have hardware dependencies.\n    \n    \n      libtbm-dumb\n      platform/adaptation/libtbm-dumb\n      Backend for a target device which supports the DUMB memory interface. If the target kernel supports the drm interface, the target can use the dumb backend because the DUMB memory interface is the default drm memory interface.\n    \n    \n      libtbm-sprd\n      platform/adaptation/spreadtrum/libtbm-sprd\n      Backend for a target device which uses the Spreadtrum chipset only. The sprd backend module uses the drm gem memory interface but some ioctl are only provided by the sprd drm kernel.\n    \n    \n      libtbm-exynos\n      platform/adaptation/samsung_exynos/libtbm-exynos\n      Backend for a target device which uses the exynos chipset only. The exynos backend module uses the drm gem memory interface but some ioctl are only provided by exynos drm kernel.\n    \n    \n      libtbm-vigs\n      platform/adaptation/emulator/libtbm-vigs\n      Backend for a target device which supports the VIGS interface. The vigs backend is used by the emulator target.\n    \n  \n\n\nReference\n\nFor more information about TBM and the TBM backend, see Tizen Buffer Manager (TBM).\n\nDisplay Management\n\nThe display server composites and shows the client’s buffers on screen. The display server sometimes needs to convert or scale an image to a different size or format. To make it possible for various chipset devices, the display server needs the display hardware resource information and control over the resources. Tizen Display Manager (TDM) offers these functionalities for the display server with the unified interface for various chipset devices.\n\nFigure: TDM backend\n\n\n\nWith TDM, the display server can perform mode setting, DPMS control, and showing a buffer (framebuffer or video buffer) on the screen in the most efficient way. If the hardware supports the m2m converting and capture device, the display server can also convert an image and dump a screen including all hardware overlays with no compositing.\n\nThe vendor has to implement the TDM backend module. The TDM backend module has the responsibility to let the TDM frontend know the display hardware resource information. The display server gets this information and controls hardware devices through the TDM frontend APIs. TDM already has several backends for reference, such as libtdm-drm and libtdm-fbdev.\n\nThe TDM backend is implemented as a shared library. The TDM frontend finds the libtdm-default.so file and loads it in the /usr/lib/tdm directory at runtime.\n\nsh-3.2# ls -l /usr/lib/tdm\ntotal 40\nlrwxrwxrwx 1 root root    14 Jul 28  2016 libtdm-default.so -&gt; libtdm-drm.so\n-rwxr-xr-x 1 root root 37152 Jul 12  2016 libtdm-drm.so\n\n\nThe TDM backend module must define the global data symbol with the name tdm_backend_module_data. The TDM frontend reads this symbol at the initialization time. TDM calls the init() function of the tdm_backend_module_data. For more information, see tdm_backend.h.\n\ntypedef struct _tdm_backend_module {\n    const char *name; /* The module name of the backend module */\n    const char *vendor; /* The vendor name of the backend module */\n    unsigned long abi_version; /* The ABI version of the backend module */\n    tdm_backend_data *(*init)(tdm_display *dpy, tdm_error *error);\n    void (*deinit)(tdm_backend_data *bdata);\n} tdm_backend_module;\n\n\n#include &lt;tdm_backend.h&gt;\n\nstatic tdm_drm_data *drm_data;\n\ntdm_backend_data*\ntdm_drm_init(tdm_display *dpy, tdm_error *error) {\n    drm_data = calloc(1, sizeof(tdm_drm_data));\n\n    return (tdm_backend_data*)drm_data;\n}\n\nvoid\ntdm_drm_deinit(tdm_backend_data *bdata) {\n    free(bdata);\n}\n\ntdm_backend_module tdm_backend_module_data = {\n    \"drm\",\n    \"Samsung\",\n    TDM_BACKEND_SET_ABI_VERSION(1,1),\n    tdm_drm_init,\n    tdm_drm_deinit\n};\n\n\nThe TDM backend must register the tdm_func_display(), tdm_func_output(), and tdm_func_layer() functions with the tdm_backend_register_func_display(), tdm_backend_register_func_output(), and tdm_backend_register_func_layer() functions in the tdm_backend_module_data init() function.\n\n#include &lt;tdm_backend.h&gt;\n\ntdm_backend_data*\ntdm_drm_init(tdm_display *dpy, tdm_error *error) {\n    memset(&amp;drm_func_display, 0, sizeof(drm_func_display));\n    drm_func_display.display_get_capability = drm_display_get_capability;\n    drm_func_display.display_get_pp_capability = drm_display_get_pp_capability;\n    drm_func_display.display_get_outputs = drm_display_get_outputs;\n    drm_func_display.display_get_fd = drm_display_get_fd;\n    drm_func_display.display_handle_events = drm_display_handle_events;\n    drm_func_display.display_create_pp = drm_display_create_pp;\n    ret = tdm_backend_register_func_display(dpy, &amp;drm_func_display);\n    if (ret != TDM_ERROR_NONE)\n        goto failed;\n\n    memset(&amp;drm_func_output, 0, sizeof(drm_func_output));\n    drm_func_output.output_get_capability = drm_output_get_capability;\n\n    ret = tdm_backend_register_func_output(dpy, &amp;drm_func_output);\n    if (ret != TDM_ERROR_NONE)\n        goto failed;\n\n    memset(&amp;drm_func_layer, 0, sizeof(drm_func_layer));\n    drm_func_layer.layer_get_capability = drm_layer_get_capability;\n\n    ret = tdm_backend_register_func_layer(dpy, &amp;drm_func_layer);\n    if (ret != TDM_ERROR_NONE)\n        goto failed;\n\n    return (tdm_backend_data*)drm_data;\n}\n\n\nAfter loading the TDM backend module, the TDM frontend calls the display_get_capability(), display_get_outputs(), output_get_capability(), output_get_layers(), and layer_get_capability() functions to get the hardware-specific information. That means that the TDM backend module must implement these 5 functions.\n\nIn addition, if a target has a memory-to-memory converting hardware device and the capture hardware device, the TDM backend module can register the tdm_func_pp() and tdm_func_capture() functions with the tdm_backend_register_func_pp() and tdm_backend_register_func_capture() functions.\n\nPorting the OAL Interface\n\nTDM provides the header files to implement the TDM backend module.\n\nTable: TDM backend module header files\n\n\n  \n    \n      Header file\n      Description\n    \n  \n  \n    \n      tdm_backend.h\n      This file defines the TDM backend interface.\n    \n    \n      tdm_log.h\n      This file includes functions to print logs in frontend and backend modules.\n    \n    \n      tdm_helper.h\n      This file includes helper functions for the TDM frontend and backend.\n    \n  \n\n\nThe display backend interface is mandatory. For more information, see tdm_backend.h.\n\nTable: Display backend interface functions\n\n\n  \n    \n      Function\n      Description\n      Mandatory\n    \n  \n  \n    \n      display_get_capability()\n      Gets the display capabilities of the backend module. TDM calls this function not only at initialization, but also when a new output is connected. If the hardware has a maximum usable layer count restriction, the backend module can set the max count in the max_layer_count element of the tdm_caps_display structure. Otherwise, it is set to -1.\n      Yes\n    \n    \n      display_get_pp_capability()\n      Gets the pp capabilities of the backend module. TDM calls this function not only at initialization, but also when a new output is connected. The backend module does not need to implement this function if the hardware does not have a memory-to-memory converting device. If it does, the backend module must fill the tdm_caps_pp data, which contains the hardware restriction information which a converting device can handle, such as format and size.\n      No\n    \n    \n      display_get_capture_capability()\n      Gets the capture capabilities of the backend module. TDM calls this function not only at initialization, but also when a new output is connected. The backend module does not need to implement this function if the hardware does not have a capture device. If it does, the backend module must fill the tdm_caps_capture data, which contains the hardware restriction information which a capture device can handle, such as format and size.\n      No\n    \n    \n      display_get_outputs()\n      Gets an output array of the backend module. TDM calls this function not only at initialization, but also when a new output is connected. The backend module must return the newly-allocated array which contains tdm_output* data. It is freed in the frontend.\n      Yes\n    \n    \n      display_get_fd()\n      Gets the file descriptor of the backend module. The backend module can return the epoll’s fd.\n      No\n    \n    \n      display_handle_events()\n      Handles the events which happen on the fd of the backend module.\n      No\n    \n    \n      display_create_pp()\n      Creates a pp object of the backend module. The backend module does not need to implement this function if the hardware does not have a memory-to-memory converting device\n      No\n    \n  \n\n\nThe output backend interface is mandatory. For more information, see tdm_backend.h.\n\nTable: Output backend interface functions\n\n\n  \n    \n      Function\n      Description\n      Mandatory\n    \n  \n  \n    \n      output_get_capability()\n      Gets the capabilities of an output object. TDM calls this function not only at initialization, but also when a new output is connected. The tdm_caps_output contains connection status, modes, available properties, and size restriction information.\n      Yes\n    \n    \n      output_get_layers()\n      Gets the layer array of an output object. TDM calls this function not only at initialization, but also when a new output is connected. The backend module must return the newly-allocated array which contains tdm_layer* data. It is freed in the frontend.\n      Yes\n    \n    \n      output_set_property()\n      Sets the property with a given ID.\n      No\n    \n    \n      output_get_property()\n      Gets the property with a given ID.\n      No\n    \n    \n      output_wait_vblank()\n      Waits for VBLANK. If this function returns TDM_ERROR_NONE, the backend module must call a user vblank handler with the user data of this function after vblanks interval.\n      Yes\n    \n    \n      output_set_vblank_handler()\n      Sets the user vblank handler.\n      Yes\n    \n    \n      output_commit()\n      Commits the changes for an output object. When this function is called, the backend module must apply all changes of the given output object to the screen as well as the layer changes of this output. If this function returns TDM_ERROR_NONE, the backend module must call a user commit handler with the user data of this function after all changes of the given output object are applied.\n      Yes\n    \n    \n      output_set_commit_handler()\n      Sets a user commit handler.\n      Yes\n    \n    \n      output_set_dpms()\n      Sets the DPMS of an output object.\n      No\n    \n    \n      output_get_dpms()\n      Gets the DPMS of an output object.\n      No\n    \n    \n      output_set_mode()\n      Sets 1 of the available modes of an output object.\n      Yes\n    \n    \n      output_create_capture()\n      Creates a capture object of an output object. The backend module does not need to implement this function if the hardware does not have a capture device.\n      No\n    \n    \n      output_set_status_handler()\n      Sets an output connection status handler. The backend module must call the output status handler when the output connection status has been changed to let the TDM frontend know of the change.\n      No\n    \n    \n      output_set_dpms_handler()\n      Sets an output DPMS handler. The backend module must call the output DPMS handler when the output DPMS has been changed to let the TDM frontend know of the change.\n      No\n    \n  \n\n\nThe layer backend interface is mandatory. For more information, see tdm_backend.h.\n\nTable: Layer backend interface functions\n\n\n  \n    \n      Function\n      Description\n      Mandatory\n    \n  \n  \n    \n      layer_get_capability()\n      Get the capabilities of a layer object. The backend module must implement this function. TDM calls this function not only at initialization, but also when a new output is connected. The tdm_caps_layer contains the available formats/properties and zpos information.\n      Yes\n    \n    \n      layer_set_property()\n      Sets the property with a given ID.\n      No\n    \n    \n      layer_get_property()\n      Gets the property with a given ID.\n      No\n    \n    \n      layer_set_info()\n      Sets the geometry information to a layer object. The backend module applies the geometry information when the output object of a layer object is committed.\n      Yes\n    \n    \n      layer_get_info()\n      Gets the geometry information of a layer object.\n      Yes\n    \n    \n      layer_set_buffer()\n      Sets a TDM buffer to a layer object. The backend module shows a TDM buffer on the screen when the output object of a layer object is committed.\n      Yes\n    \n    \n      layer_unset_buffer()\n      Unsets a TDM buffer from a layer object. The backend module must remove the currently-showing buffer from the screen.\n      Yes\n    \n    \n      layer_set_video_pos()\n      Sets the zpos for a video layer object. The backend module does not need to implement this function if the backend module does not have video layers. The zpos of the video layer is changeable.\n      No\n    \n    \n      layer_create_capture()\n      Creates a capture object of a layer object. The backend module does not need to implement this function if the hardware does not have a capture device.\n      No\n    \n    \n      layer_get_buffer_flags()\n      Gets the buffer flags which the layer can support.\n      No\n    \n  \n\n\nThe pp backend interface is optional. For more information, see tdm_backend.h.\n\nTable: pp backend interface functions\n\n\n  \n    \n      Function\n      Description\n    \n  \n  \n    \n      pp_destroy()\n      Destroys a pp object.\n    \n    \n      pp_set_info()\n      Sets the geometry information to a pp object. The backend module applies the geometry information when committed.\n    \n    \n      pp_attach()\n      Attaches a source buffer and a destination buffer to a pp object. The backend module converts the image of a source buffer to a destination buffer when committed. The size/crop/transform information is set using the pp_set_info() function of tdm_func_pp. When done, the backend module must return the source/destination buffer using the tdm_pp_done_handler() function.\n    \n    \n      pp_commit()\n      Commits changes for a pp object.\n    \n    \n      pp_set_done_handler()\n      Sets a user done handler to a pp object. The backend module must call the tdm_pp_done_handler() function when image conversion is done.\n    \n  \n\n\nThe capture backend interface is optional. For more information, see tdm_backend.h.\n\nTable: Capture backend interface functions\n\n\n  \n    \n      Function\n      Description\n    \n  \n  \n    \n      capture_destroy()\n      Destroys a capture object.\n    \n    \n      capture_set_info()\n      Sets the geometry information to a capture object. The backend module applies the geometry information when committed.\n    \n    \n      capture_attach()\n      Attaches a TDM buffer to a capture object. When the capture_commit() function is called, the backend module starts to dump an output or a layer to a TDM buffer. The backend module starts to dump an output or a layer to a TDM buffer when committed. The size/crop/transform information is set using the capture_set_info() function of the tdm_func_capture. When done, the backend module must return the TDM buffer using the tdm_capture_done_handler() function.\n    \n    \n      capture_commit()\n      Commits changes for a capture object.\n    \n    \n      capture_set_done_handler()\n      Sets a user done handler to a capture object. The backend module must call the tdm_capture_done_handler() function when the capture operation is done.\n    \n  \n\n\nTDM backends\n\nThere are several backends which can be used as reference when implementing the TDM backend.\n\nTable: TDM backends\n\n\n  \n    \n      Backend\n      Project (http://review.tizen.org)\n      Description\n    \n  \n  \n    \n      libtdm-drm\n      platform/adaptation/libtdm-drm\n      Backend for a target device which supports the DRM interface, such as the Tizen SDK emulator. No PP or capture capability.\n    \n    \n      libtdm-fbdev\n      platform/adaptation/libtdm-fbdev\n      Backend for a target device which supports the FBDEV interface. No PP or capture capability.\n    \n    \n      libtdm-exynos\n      platform/adaptation/samsung_exynos/libtdm-exynos\n      Backend for a target device which uses the exynos chipset using the DRM interface. Has PP and capture capability, using the exynos-specific DRM interface to support PP.\n    \n    \n      libtdm-sprd\n      platform/adaptation/spreadtrum/libtdm-sprd\n      Backend for a target device which uses the Spreadtrum chipset using the Spreadtrum-specific ioctl. Uses the DRM interface to support vblank. Has PP capability, but no capture capability.\n    \n  \n\n\nTesting the Porting Result\n\nTDM offers the tdm-test-server tool to allow you to easily test the porting result. The tdm-test-server tool is included in the libtdm-tools package, which can be downloaded from the platform binary’s snapshot repository. Make sure that TBM porting is done before using the following commands, because TDM works on top of TBM.\n\n$ systemctl stop display-manager  (stop the display server)\n$ export XDG_RUNTIME_DIR=/run\n$ export TBM_DISPLAY_SERVER=1\n$ tdm-test-server                 (show all options)\n$ tdm-test-server -a              (test all layers)\n$ tdm-test-server -a -v           (test all layers with vblank events)\n\n\nThe following image shows the result of a test performed using the tdm-test-server -a command. The fullscreen buffer is set to the PRIMARY layer, and the small buffer is set to the OVERLAY layer.\n\nFigure: Tdm-test-server results\n\n\n\nChecking TDM Log Messages\n\nTDM uses dlog to print debug messages. To show TDM runtime log messages:\n\n$ dlogutil -v threadtime TDM\n\n\nReferences\n\nFor detailed information about TDM and the TDM backend, see Tizen Display Manager (TDM).\n\nInput Management\n\nThe input manager supports a libinput-based input device backend. libinput is a common input library for the Wayland compositor. With libinput, the input stack is simpler without the Xorg input drivers. Since Tizen 3.0, the input manager is not a HAL component.\n\nFigure: Tizen 3.0 input management\n\n\n\nlibinput\n\nThe libinput library handles input devices for display servers and other applications that need to directly deal with input devices:\n\n\n  Device detection\n  Device handling\n  Input device event processing\n  Scaling touch coordinates\n  Generating pointer events from touchpads\n  Pointer acceleration\n\n\nFor more information, see the libinput wiki.\n\nlibevdev\n\nThe libevdev library handles evdev kernel devices. It abstracts the evdev ioctls through type-safe interfaces and provides functions to change the appearance of the device. For more information, see https://en.wikipedia.org/wiki/Evdev.\n\nmtdev\n\nThe mtdev standalone library transforms all variants of kernel MT events to the slotted type B protocol. For more information, see http://www.linuxfromscratch.org/blfs/view/svn/general/mtdev.html.\n\nlibinput Backends\n\nlibinput: platform/upstream/libinput\n\nOpenGL®\n\nThis section describes the essential elements of the Tizen platform-level graphics architecture related to OpenGL® ES and EGL™, and how it is used by the application framework and the display server. The focus is on how graphical data buffers move through the system.\n\nThe Tizen platform requires the OpenGL® ES driver for the acceleration of the Wayland display server and the wayland-egl client. This platform demands an OpenGL® ES and EGL™ driver which is implemented by the Tizen EGL Porting Layer.\n\nTizen OpenGL® ES and EGL™ Architecture\n\nThe following figure illustrates the Tizen OpenGL® ES and EGL™ architecture.\n\nFigure: Tizen OpenGL® ES architecture\n\n\n\n\n  \n    CoreGL\n\n    An injection layer of OpenGL® ES that provides the following capabilities:\n\n    \n      Support for driver-independent optimization (FastPath)\n      EGL™/OpenGL® ES debugging\n      Performance logging\n      Supported versions\n        \n          EGL™ 1.4\n          OpenGL® ES 1.1, 2.0, 3.0, 3.1\n        \n      \n    \n\n    CoreGL loads the manufacturer’s OpenGL® ES driver from the /usr/lib/driver directory. CoreGL provides the libEGL.so, libGLESv1_CM.so, and libGLESvs.so driver files in the /usr/lib directory.\n  \n  \n    GPU vendor GL/EGL™ driver\n\n    The Tizen platform demands that the GPU vendor implements the GL and EGL™ driver using libtpl-egl. The GPU vendor GL/EGL™ driver (libEGL.so, libGLESv1_CM.so, libGLESv2.so) must be installed in the /usr/lib/driver path.\n  \n\n\nTizen Porting Layer (TPL) for EGL™\n\nTPL-EGL is an abstraction layer for surface and buffer management on the Tizen platform. It is used for implementation of the EGL™ platform functions.\n\nFigure: TPL architecture\n\n\n\nThe background for the Tizen EGL Porting Layer for EGL™ is in various window system protocols in Tizen. There was a need for separating common layer and backend.\n\nTizen uses the Tizen Porting Layer for EGL™, as the TPL-EGL API prevents burdens of the EGL™ porting on various window system protocols. The GPU GL Driver’s Window System Porting Layer can be implemented by TPL-EGL APIs which are the corresponding window system APIs. The TBM, Wayland, and GBM backends are supported.\n\nTizen Porting Layer for the EGL™ Object Model\n\nTPL-EGL provides interfaces based on an object-driven model. Every TPL-EGL object can be represented as a generic tpl_object_t, which is reference-counted and provides common functions. Currently, display and surface types of TPL-EGL objects are provided. A display, like a normal display, represents a display system which is usually used for connecting to the server. A surface corresponds to a native surface, such as wl_surface. Surfaces can be configured to use N-buffers, but are usually double-buffered or triple-buffered. A buffer is what you render on, usually a set of pixels or a block of memory. For these 2 objects, the Wayland, GBM, TBM backend are defined, and they correspond to their own window systems. This means that you do not need to care about the window systems.\n\nThe TPL-EGL has the following core objects:\n\n\n  \n    TPL-EGL Object\n\n    Base class for all TPL-EGL objects.\n  \n  \n    TPL-EGL Display\n\n    Encapsulates the native display object (Display *, wl_display). Like a normal display, this represents a display system which is usually used for connecting to the server, scope for other objects.\n  \n  \n    TPL-EGL Surface\n\n    Encapsulates the native drawable object (Window, Pixmap, wl_surface). The surface corresponds to a native surface, such as tbm_surface_queue or wl_surface. A surface can be configured to use N-buffers, but they are usually double-buffered or triple-buffered.\n  \n\n\nTPL-EGL Objects and Corresponding EGL™ Objects\n\nBoth TPL-EGL and vendor OpenGL® ES/EGL™ driver handles a tbm_surface as the corresponding TPL surface buffer. It is represented by the TBM_Surface part in the following figure.\n\nFigure: TPL-EGL architecture\n\n\n\nThe following figure illustrates the OpenGL® ES drawing API flow.\n\nFigure: OpenGL® ES drawing API flow\n\n\n\nTPL-EGL Frontend API\n\nTPL-EGL Object is a base class for all TPL-EGL objects. It provides common functionalities to all TPL-EGL objects.\n\nTable: TPL-EGL Object functions\n\n\n  \n    \n      Function\n      Description\n    \n  \n  \n    \n      tpl_object_reference()\n      Increases the reference count of a TPL-EGL object. All TPL-EGL objects are reference-counted with a reference count 1 on creation. When the reference count drops to 0, the object is freed.\n    \n    \n      tpl_object_unreference()\n      Decreases the reference count and destroys the object if it becomes 0.\n    \n    \n      tpl_object_get_reference()\n      Gets the reference count of the given TPL-EGL object.\n    \n    \n      tpl_object_get_type()\n      Gets the type of the object (display, surface, or buffer).\n    \n    \n      tpl_object_set_user_data()\n      Sets the user data to a TPL-EGL object. If the user wants to relate some data with a TPL-EGL object, this function allows them to register a pointer to such data, which can be retrieved later using the tpl_object_get_user_data() function. The key is the pointer value itself as a key.\n    \n    \n      tpl_object_get_user_data()\n      Gets the registered user data of a TPL-EGL object.\n    \n  \n\n\nTPL-EGL Display encapsulates the native display object (Display *, wl_display). Any other objects created from TPL-EGL Display inherit its backend type.\n\nTable: TPL-EGL Display functions\n\n\n  \n    \n      Function\n      Description\n    \n  \n  \n    \n      tpl_display_create()\n      Creates the TPL-EGL display object for the given native display if there is no existing TPL-EGL display for that native display. If given NULL for native_dpy, this function returns the default display.\n    \n    \n      tpl_display_get()\n      Gets the TPL-EGL display object for the given native display if one exists for it.\n    \n    \n      tpl_display_get_native_handle()\n      Gets the native display handle which the given TPL-EGL display is created for.\n    \n    \n      tpl_display_query_config()\n      Queries the supported pixel formats for the given TPL-EGL display. If any pixel format values are acceptable, use the TPL_DONT_CARE value for the size values .\n    \n    \n      tpl_display_filter_config()\n      Filters the configuration according to a given TPL-EGL display. This function modifies current config specific to the current given TPL-EGL display.\n    \n    \n      tpl_display_get_native_window_info()\n      Queries information on the given native window.\n    \n    \n      tpl_display_get_native_pixmap_info()\n      Queries information on the given native pixmap.\n    \n    \n      tpl_display_get_buffer_from_native_pixmap()\n      Gets the native buffer from the given native pixmap.\n    \n  \n\n\nTPL-EGL Surface encapsulates the native drawable object (Window, Pixmap, wl_surface). The main features of the class are retrieving the buffer for a frame and posting the surface to a screen.\n\nTable: TPL-EGL Surface functions\n\n\n  \n    \n      Function\n      Description\n    \n  \n  \n    \n      tpl_surface_create()\n      Creates a TPL-EGL surface for the given native surface.\n    \n    \n      tpl_surface_get_display()\n      Gets the TPL-EGL display where the given TPL-EGL surface was created from.\n    \n    \n      tpl_surface_get_native_handle()\n      Gets the native surface handle of the given TPL-EGL surface.\n    \n    \n      tpl_surface_get_type()\n      Gets the type of the given TPL surface.\n    \n    \n      tpl_surface_get_size()\n      Gets the current size of the given TPL-EGL surface. The size of a surface can change when a user or the server resizes the window. TPL-EGL updates the size information every time when a buffer is queried using the tpl_surface_dequeue_buffer() function. Note that there can still be mismatch between actual surface size and the cached one.\n    \n    \n      tpl_surface_validate()\n      Validates the current frame of the given TPL-EGL surface. Call this function before getting the final render target buffer, as calling the tpl_surface_dequeue_buffer() function after calling this function can give output values different to earlier ones. A buffer returned after calling this function is guaranteed not to change further.\n    \n    \n      tpl_surface_dequeue_buffer()\n      Gets the buffer of the current frame for the given TPL-EGL surface. Depending on the backend, communication with the server can be required. Returned buffers are used for rendering the target to draw the current frame. Returned buffers are valid until the next tpl_surface_dequeue_buffer() function call. If the tpl_surface_validate() function returns TPL_FALSE, the previously returned buffers must no longer be used. Instead, this function must called again before drawing, returning a valid buffer.\n    \n    \n      tpl_surface_enqueue_buffer()\n      Posts a given tbm_surface. This function requests the display server to post a frame. This is the function which can enqueue a buffer to the tbm_surface_queue. Make sure this function is called exactly once for a frame. Scheduling post calls on a separate thread is recommended.\n    \n    \n      tpl_surface_enqueue_buffer_with_damage()\n      Posts a given tbm_surface with region of damage. Damage information is used for reducing number of pixels composited in the compositor. Setting the num_rects to 0 or rects to NULL means entire area is damaged. This function requests a server to post a frame. This function is identical with the tpl_surface_enqueue_buffer() function except for delivering the damage information for updating. Make sure this function is called exactly once for a frame. Scheduling post calls on a separate thread is recommended.\n    \n    \n      tpl_surface_set_post_interval()\n      Sets the frame interval of the given TPL-EGL surface, which ensures that only a single frame is posted within the specified vsync intervals. When a frame ends, the frame interval is set to the surface’s current interval.\n    \n    \n      tpl_surface_get_post_interval()\n      Gets the frame interval of the given TPL-EGL surface.\n    \n  \n\n\nThe following code snippet shows a simple example of the Tizen Porting Layer:\n\ndpy = tpl_display_create(...);\nsfc = tpl_surface_create(dpy, ...);\n\nwhile (1) {\n    buf = tpl_surface_dequeue_buffer(sfc);\n\n    /* Draw something */\n\n    tpl_surface_enqueue_buffer(sfc, buf);\n}\n\n\nIn the GPU vendor driver, the GPU frame builder handles the drawing. TPL-EGL exposes the native platform buffer identifiers and managers so that the buffer can be used in other modules. Currently, dma_buf/DRM is supported for these purposes. The EGL porting layer calls TPL-EGL functions to execute commands requested of it, and returns the results to the GPU vendor driver. TPL-EGL performs all protocol-dependent actions. Such protocol-dependent parts can be separated into TPL-EGL backends. TPL-EGL backend can also be configured at runtime, and you can specify which type of backend to use when initializing a display object.\n\nTPL-EGL and Wayland Server and Client\n\nTizen uses the wl_tbm protocol instead of wl_drm. The wl_tbm protocol is designed for sharing the buffer (tbm_surface) between the wayland_client and wayland_server. Although the wayland_tbm_server_init and wayland_tbm_client_init pair is a role for the eglBindWaylandDisplayWL, the EGL™ driver is required to implement the entry points for the eglBindWaylandDisplayWL and eglUnbindWaylandDisplayWL as dummy. For more information, see https://cgit.freedesktop.org/mesa/mesa/tree/docs/specs/WL_bind_wayland_display.spec.\n\nFigure: TPL-EGL and Wayland\n\n\n\nBuffer Flow Between the Wayland Server and OpenGL® ES/EGL™ Driver\n\nThe following figure shows the buffer flow between the Wayland server and the OpenGL® ES/EGL™ driver. The passed buffer is of the tbm_surface type.\n\nFigure: Buffer flow between Wayland server and OpenGL® ES/EGL™ driver\n\n\n\nProject Git Repository\n\nThe following table lists the available project Git repositories.\n\nTable: Git repositories\n\n\n  \n    \n      Project\n      Repository\n      Description\n    \n  \n  \n    \n      libtpl-egl\n      platform/core/uifw/libtpl-egl\n      Tizen Porting Layer for EGL™\n    \n    \n      libtbm\n      platform/core/uifw/libtbm\n      Library for the Tizen Buffer Manager\n    \n    \n      coregl\n      platform/core/uifw/coregl\n      Injection layer of OpenGL® ES / EGL™\n    \n    \n      wayland-tbm\n      platform/core/uifw/wayland-tbm\n      Protocol for graphics memory management for Tizen\n    \n    \n      emulator-yagl\n      platform/adaptation/emulator/emulator-yagl\n      OpenGL® ES / EGL™ driver for the emulator\n    \n    \n      tpl-novice\n      platform/core/uifw/ws-testcase\n      Novice test framework for TPL\n    \n  \n\n\nlibtpl-egl Reference Driver\n\nThe Emulator YAGL (OpenGL® ES / EGL™ driver for the emulator) is implemented by libtpl-egl.\n\nThe following commit explains how to port the driver with libtpl-egl from the traditional drm-based driver:\n\n\n  Porting YAGL to the Tizen platform https://review.tizen.org/gerrit/#/c/67921/\n\n\nTesting and Verifying the OpenGL® ES Driver\n\nThe Khronos OpenGL® ES CTS supports wayland-egl. libtpl-egl has a test case for the libtpl-egl. The ws-testcase’s tpl-novice has sample code for the libtpl-egl."
					}
					
				
			
		
			
				
					,
					
					"iot-porting-graphics-and-ui": {
						"id": "iot-porting-graphics-and-ui",
						"title": "Graphics and UI",
						"categories": "",
						"url": " iot/porting/graphics-and-ui/",
						"content": "Graphics and UI\n\nThe application composes the graphic user interface by creating a window with a toolkit. The display server composites an application’s windows and shows the result on the screen. For this procedure, the graphics and UI middleware offers the following 3 modules for both client and server:\n\n\n  Tizen Buffer Manager (TBM)\n  Tizen Display Manager (TDM)\n  TPL-EGL\n\n\nFigure: Graphics UI diagram\n\n\n\nThe modules are hardware abstraction layers for graphics and UI. They allow the client and server to render with the GPU, share buffers with other processes, and organize hardware output devices for various chipsets. Their backend module needs to be implemented for the new hardware device.\n\n\n  TBM provides an abstraction interface for the Tizen graphic buffer manager.\n  TDM provides an abstraction interface for a display server, such as X or Wayland, to allow direct access to graphics hardware in a safe and efficient manner as a display HAL.\n  TPL-EGL is an abstraction layer for surface and buffer management on the Tizen platform aimed to implement the EGL™ porting layer of the OpenGL® ES driver over various display protocols.\n\n\nFor an application to handle input device events, the Input Manager is provided, and is mainly comprised of libinput and a thin wrapper around it. It handles input events in Wayland compositors and communicates with Wayland clients.\n\nBuffer Management\n\nTBM has a frontend library and a backend module. The TBM frontend library is hardware-independent and provides a generic buffer interface. On the other hand, the TBM backend module is hardware-dependent and provides a buffer interface dependent on the target system. Chipset vendors have to provide their own backend modules in order for TBM to work well on the Tizen platform. This is because the way each vendor manages the graphic buffers can be different between various chipset devices. TBM already has several reference backends, such as libtbm-dumb, and libtbm-shm.\n\nFigure: TBM backend\n\n\n\nWith TBM, the client and server can allocate buffers and share buffers between them. For example, a client allocates a graphic buffer, draws something on it with GL and sends it to the display server for displaying it on the screen without buffer copying. The TBM backend module is implemented as a shared library and the TBM frontend finds the libtbm-default.so file and loads it from the /usr/lib/bufmgr directory at runtime.\n\nsh-3.2# ls -al\nlrwxrwxrwx  1 root root    14 Jul 28  2016 libtbm_default.so -&gt; libtbm_sprd.so\nlrwxrwxrwx  1 root root    20 Jul 28  2016 libtbm_sprd.so -&gt; libtbm_sprd.so.0.0.0\nlrwxrwxrwx  1 root root    20 Jul 28  2016 libtbm_sprd.so.0 -&gt; libtbm_sprd.so.0.0.0\n-rwxr-xr-x  1 root root 26728 Jun 29  2016 libtbm_sprd.so.0.0.0\n\n\nInitialing the TBM Backend Module\n\nThe TBMModuleData is for the entry point symbol to initialize the TBM backend module. The TBM backend module must define the global data symbol with the name of tbmModuleData. The TBM frontend loads the tbmModuleData global data symbol and calls the init() function at the initial time.\n\n\n  Note\n\n  Do not change the name of the symbol in the TBM backend module.\n\n\n/*\n   @brief tbm module data\n   Data type for the entry point of the backend module\n*/\ntypedef struct {\n    TBMModuleVersionInfo *vers;\t/* TBM module information */\n    ModuleInitProc init; /* init function of a backend module */\n} TBMModuleData;\n\ntypedef int (*ModuleInitProc) (tbm_bufmgr, int);\n\n\nThe TBM backend module initialization consists of allocating the tbm_bufmgr_backend instance (tbm_backend_alloc), entering the necessary information, and the initialization itself (tbm_backend_init).\n\ntbm_bufmgr_backend tbm_backend_alloc(void);\nvoid tbm_backend_free(tbm_bufmgr_backend backend);\nint tbm_backend_init(tbm_bufmgr bufmgr, tbm_bufmgr_backend backend);\n\n\nMODULEINITPPROTO (init_tbm_bufmgr_priv);\n\nstatic TBMModuleVersionInfo DumbVersRec = {\n    \"shm\",\n    \"Samsung\",\n    TBM_ABI_VERSION,\n};\n\nTBMModuleData tbmModuleData = {&amp;DumbVersRec, init_tbm_bufmgr_priv};\n\nint\ninit_tbm_bufmgr_priv(tbm_bufmgr bufmgr, int fd) {\n    tbm_bufmgr_backend bufmgr_backend;\n\n    bufmgr_shm = calloc(1, sizeof(struct _tbm_bufmgr_shm));\n\n    bufmgr_backend = tbm_backend_alloc();\n\n    bufmgr_backend-&gt;priv = (void *)bufmgr_shm;\n    bufmgr_backend-&gt;bufmgr_deinit = tbm_shm_bufmgr_deinit,\n    bufmgr_backend-&gt;bo_size = tbm_shm_bo_size,\n    bufmgr_backend-&gt;bo_alloc = tbm_shm_bo_alloc,\n    bufmgr_backend-&gt;bo_free = tbm_shm_bo_free,\n    bufmgr_backend-&gt;bo_import = tbm_shm_bo_import,\n    bufmgr_backend-&gt;bo_import_fd = NULL,\n    bufmgr_backend-&gt;bo_export = tbm_shm_bo_export,\n    bufmgr_backend-&gt;bo_export_fd = NULL,\n    bufmgr_backend-&gt;bo_get_handle = tbm_shm_bo_get_handle,\n    bufmgr_backend-&gt;bo_map = tbm_shm_bo_map,\n    bufmgr_backend-&gt;bo_unmap = tbm_shm_bo_unmap,\n    bufmgr_backend-&gt;bo_lock = NULL;\n    bufmgr_backend-&gt;bo_unlock = NULL;\n    bufmgr_backend-&gt;surface_get_plane_data = tbm_shm_surface_get_plane_data;\n    bufmgr_backend-&gt;surface_supported_format = tbm_shm_surface_supported_format;\n\n    if (!tbm_backend_init(bufmgr, bufmgr_backend)) {\n        tbm_backend_free(bufmgr_backend);\n        free(bufmgr_shm);\n\n        return 0;\n    }\n\n    return 1;\n}\n\n\nPorting the OAL Interface\n\nTBM provides the header files to implement the TBM backend module.\n\nTable: TBM backend module header files\n\n\n  \n    \n      Header file\n      Description\n    \n  \n  \n    \n      tbm_bufmgr_backend.h\n      This file includes information on implementing the TBM backend module.\n    \n    \n      tbm_drm_helper.h\n      This file includes helper functions for the DRM interface backend module.\n    \n    \n      tbm_bufmgr.h\n      This is the user header file including general information on how to use the TBM.\n    \n    \n      tbm_surface.h\n      This is the user header file including general information on how to use tbm_surface.\n    \n  \n\n\nTBM Backend Interface\n\nThe following table lists the TBM backend interface functions for initializing and deinitializing.\n\nTable: Initializing and deinitializing functions\n\n\n  \n    \n      Function\n      Description\n       \n    \n  \n  \n    \n      ModuleInitProc()\n      The init function of a backend module.\n      Mandatory\n    \n    \n      bufmgr_deinit()\n      Deinitialize the buffer manager privately.\n      Mandatory\n    \n    \n      bufmgr_bind_native_display()\n      If the backend needs to get the native display, use this backend function.\n      Optional\n    \n  \n\n\nThe following table lists the TBM backend interface functions for tbm_bo.\n\nTable: tbm_bo functions\n\n\n  \n    \n      Function\n      Description\n      Mandatory\n    \n  \n  \n    \n      bo_alloc()\n      Allocates the buffer object. If the backend wants to reuse the bo private at frontend, return the same pointer of the bo private.\n      Yes\n    \n    \n      bo_free()\n      Frees the buffer object. The frontend calls this function when it does not use the bo private.\n      Yes\n    \n    \n      bo_import()\n      Imports the buffer object associated with the key. If the backend does not support buffer sharing by the TBM key, the function pointer must be set to NULL.\n      No\n    \n    \n      bo_export()\n      Exports the buffer object. If the backend does not support buffer sharing by TBM key, the function pointer must be set to NULL.\n      No\n    \n    \n      bo_import_fd()\n      Imports the buffer object associated with the prime fd. The tbm_fd must be freed by the user. If the backend does not support buffer sharing by TBM fd, the function pointer must be set to NULL.\n      Yes (Must support buffer sharing by TBM fd.)\n    \n    \n      bo_export_fd()\n      Imports the buffer object associated with the prime fd. The tbm_fd must be freed by the user. If the backend does not support buffer sharing by TBM fd, the function pointer must be set to NULL.\n      Yes (Must support buffer sharing by TBM fd.)\n    \n    \n      bo_get_flags()\n      Gets the TBM flags of memory type.\n      Yes\n    \n    \n      bo_size()\n      Gets the size of a buffer object.\n      Yes\n    \n    \n      bo_get_handle()\n      Gets the tbm_bo_handle according to the device type.\n      Yes\n    \n    \n      bo_map()\n      Maps the buffer object according to the device type and the option.\n      Yes\n    \n    \n      bo_unmap()\n      Unmaps the buffer object.\n      Yes\n    \n    \n      bo_lock()\n      Locks the buffer object with a device and an opt.\n      No\n    \n    \n      bo_unlock()\n      Unlocks the buffer object.\n      No\n    \n  \n\n\nThe following table lists the TBM backend interface functions for tbm_surface.\n\nTable: tbm_surface functions\n\n\n  \n    \n      Function\n      Description\n      Mandatory\n    \n  \n  \n    \n      surface_supported_format()\n      Queries the format list and the number to be supported by backend.\n      Yes\n    \n    \n      surface_get_plane_data()\n      Gets the plane data, such as the size, offset, pitch, and buffer object index of the surface.\n      Yes\n    \n    \n      surface_bo_alloc()\n      Allocates the buffer object for the TBM surface with width, height, format, and buffer object index. If the backend does not want to allocate the buffer of the TBM surface with width, format, and height, the function pointer must be set to NULL. The TBM frontend allocation buffer of the TBM surface with data is gained from the surface_get_plane_data().\n      No\n    \n  \n\n\nThe following table lists the TBM buffer memory types.\n\nTable: TBM buffer memory types\n\n\n  \n    \n      Buffer memory type\n      Description\n    \n  \n  \n    \n      TBM_BO_DEFAULT\n      Default memory: it depends on the backend\n    \n    \n      TBM_BO_SCANOUT\n      Scanout memory\n    \n    \n      TBM_BO_NONCACHABLE\n      Non-cachable memory\n    \n    \n      TBM_BO_WC\n      Write-combine memory\n    \n    \n      TBM_BO_VENDOR\n      Vendor specific memory (depends on the backend)\n    \n  \n\n\nThe following table lists the TBM buffer device types.\n\nTable: TBM buffer device types\n\n\n  \n    \n      Device type\n      Description\n    \n  \n  \n    \n      TBM_DEVICE_DEFAULT\n      Device type to get the default handle\n    \n    \n      TBM_DEVICE_CPU\n      Device type to get the virtual memory\n    \n    \n      TBM_DEVICE_2D\n      Device type to get the 2D memory handle\n    \n    \n      TBM_DEVICE_3D\n      Device type to get the 3D memory handle\n    \n    \n      TBM_DEVICE_MM\n      Device type to get the multimedia handle\n    \n  \n\n\nThe following table lists the TBM buffer access options.\n\nTable: TBM buffer access options\n\n\n  \n    \n      Access option\n      Description\n    \n  \n  \n    \n      TBM_OPTION_READ\n      Access option to read\n    \n    \n      TBM_OPTION_WRITE\n      Access option to write\n    \n    \n      TBM_OPTION_VENDOR\n      Vendor-specific option that depends on the backend\n    \n  \n\n\nTBM DRM Helper Functions\n\nIf the target uses the drm interface, the client needs to get the authenticated fd from the display server and the display server must share the drm master fd with the TDM backend module. The TBM frontend provides the helper functions for drm authentication with the Wayland protocol and shares the master fd with the TDM backend module.\n\nTable: DRM helper functions\n\n\n  \n    \n      Function\n      Description\n    \n  \n  \n    \n      tbm_drm_helper_wl_auth_server_init()\n      If the TBM backend module need to use the authentication server, the backend module must call this function in the display server.\n    \n    \n      tbm_drm_helper_wl_auth_server_deinit()\n      Deinitializes the drm authentication in the display server.\n    \n    \n      tbm_drm_helper_get_master_fd()\n      If the TDM backend module already has a drm master fd, the TBM backend module can get the master fd from this function.\n    \n    \n      tbm_drm_helper_set_tbm_master_fd()\n      If the TBM backend module opens the drm master fd, this function has to be called for sharing the drm master fd with TDM.\n    \n    \n      tbm_drm_helper_unset_tbm_master_fd()\n      If the TBM backend module is opened and does not use the drm master fd, this function has to be called.\n    \n    \n      tbm_drm_helper_get_auth_info()\n      Client gets the authenticated fd and device info from the display server.\n    \n  \n\n\nTBM Backends\n\nThe following table lists the TBM backends.\n\nTable: TBM backends\n\n\n  \n    \n      Backend\n      Project (http://review.tizen.org)\n      Description\n    \n  \n  \n    \n      libtbm-shm\n      platform/adaptation/libtbm-shm\n      Backend for a target device which supports the SHM memory interface. The SHM backend module uses the XSI shared memory segment and does not have hardware dependencies.\n    \n    \n      libtbm-dumb\n      platform/adaptation/libtbm-dumb\n      Backend for a target device which supports the DUMB memory interface. If the target kernel supports the drm interface, the target can use the dumb backend because the DUMB memory interface is the default drm memory interface.\n    \n    \n      libtbm-sprd\n      platform/adaptation/spreadtrum/libtbm-sprd\n      Backend for a target device which uses the Spreadtrum chipset only. The sprd backend module uses the drm gem memory interface but some ioctl are only provided by the sprd drm kernel.\n    \n    \n      libtbm-exynos\n      platform/adaptation/samsung_exynos/libtbm-exynos\n      Backend for a target device which uses the exynos chipset only. The exynos backend module uses the drm gem memory interface but some ioctl are only provided by exynos drm kernel.\n    \n    \n      libtbm-vigs\n      platform/adaptation/emulator/libtbm-vigs\n      Backend for a target device which supports the VIGS interface. The vigs backend is used by the emulator target.\n    \n  \n\n\nReference\n\nFor more information about TBM and the TBM backend, see Tizen Buffer Manager (TBM).\n\nDisplay Management\n\nThe display server composites and shows the client’s buffers on screen. The display server sometimes needs to convert or scale an image to a different size or format. To make it possible for various chipset devices, the display server needs the display hardware resource information and control over the resources. Tizen Display Manager (TDM) offers these functionalities for the display server with the unified interface for various chipset devices.\n\nFigure: TDM backend\n\n\n\nWith TDM, the display server can perform mode setting, DPMS control, and showing a buffer (framebuffer or video buffer) on the screen in the most efficient way. If the hardware supports the m2m converting and capture device, the display server can also convert an image and dump a screen including all hardware overlays with no compositing.\n\nThe vendor has to implement the TDM backend module. The TDM backend module has the responsibility to let the TDM frontend know the display hardware resource information. The display server gets this information and controls hardware devices through the TDM frontend APIs. TDM already has several backends for reference, such as libtdm-drm and libtdm-fbdev.\n\nThe TDM backend is implemented as a shared library. The TDM frontend finds the libtdm-default.so file and loads it in the /usr/lib/tdm directory at runtime.\n\nsh-3.2# ls -l /usr/lib/tdm\ntotal 40\nlrwxrwxrwx 1 root root    14 Jul 28  2016 libtdm-default.so -&gt; libtdm-drm.so\n-rwxr-xr-x 1 root root 37152 Jul 12  2016 libtdm-drm.so\n\n\nThe TDM backend module must define the global data symbol with the name tdm_backend_module_data. The TDM frontend reads this symbol at the initialization time. TDM calls the init() function of the tdm_backend_module_data. For more information, see tdm_backend.h.\n\ntypedef struct _tdm_backend_module {\n    const char *name; /* The module name of the backend module */\n    const char *vendor; /* The vendor name of the backend module */\n    unsigned long abi_version; /* The ABI version of the backend module */\n    tdm_backend_data *(*init)(tdm_display *dpy, tdm_error *error);\n    void (*deinit)(tdm_backend_data *bdata);\n} tdm_backend_module;\n\n\n#include &lt;tdm_backend.h&gt;\n\nstatic tdm_drm_data *drm_data;\n\ntdm_backend_data*\ntdm_drm_init(tdm_display *dpy, tdm_error *error) {\n    drm_data = calloc(1, sizeof(tdm_drm_data));\n\n    return (tdm_backend_data*)drm_data;\n}\n\nvoid\ntdm_drm_deinit(tdm_backend_data *bdata) {\n    free(bdata);\n}\n\ntdm_backend_module tdm_backend_module_data = {\n    \"drm\",\n    \"Samsung\",\n    TDM_BACKEND_SET_ABI_VERSION(1,1),\n    tdm_drm_init,\n    tdm_drm_deinit\n};\n\n\nThe TDM backend must register the tdm_func_display(), tdm_func_output(), and tdm_func_layer() functions with the tdm_backend_register_func_display(), tdm_backend_register_func_output(), and tdm_backend_register_func_layer() functions in the tdm_backend_module_data init() function.\n\n#include &lt;tdm_backend.h&gt;\n\ntdm_backend_data*\ntdm_drm_init(tdm_display *dpy, tdm_error *error) {\n    memset(&amp;drm_func_display, 0, sizeof(drm_func_display));\n    drm_func_display.display_get_capability = drm_display_get_capability;\n    drm_func_display.display_get_pp_capability = drm_display_get_pp_capability;\n    drm_func_display.display_get_outputs = drm_display_get_outputs;\n    drm_func_display.display_get_fd = drm_display_get_fd;\n    drm_func_display.display_handle_events = drm_display_handle_events;\n    drm_func_display.display_create_pp = drm_display_create_pp;\n    ret = tdm_backend_register_func_display(dpy, &amp;drm_func_display);\n    if (ret != TDM_ERROR_NONE)\n        goto failed;\n\n    memset(&amp;drm_func_output, 0, sizeof(drm_func_output));\n    drm_func_output.output_get_capability = drm_output_get_capability;\n\n    ret = tdm_backend_register_func_output(dpy, &amp;drm_func_output);\n    if (ret != TDM_ERROR_NONE)\n        goto failed;\n\n    memset(&amp;drm_func_layer, 0, sizeof(drm_func_layer));\n    drm_func_layer.layer_get_capability = drm_layer_get_capability;\n\n    ret = tdm_backend_register_func_layer(dpy, &amp;drm_func_layer);\n    if (ret != TDM_ERROR_NONE)\n        goto failed;\n\n    return (tdm_backend_data*)drm_data;\n}\n\n\nAfter loading the TDM backend module, the TDM frontend calls the display_get_capability(), display_get_outputs(), output_get_capability(), output_get_layers(), and layer_get_capability() functions to get the hardware-specific information. That means that the TDM backend module must implement these 5 functions.\n\nIn addition, if a target has a memory-to-memory converting hardware device and the capture hardware device, the TDM backend module can register the tdm_func_pp() and tdm_func_capture() functions with the tdm_backend_register_func_pp() and tdm_backend_register_func_capture() functions.\n\nPorting the OAL Interface\n\nTDM provides the header files to implement the TDM backend module.\n\nTable: TDM backend module header files\n\n\n  \n    \n      Header file\n      Description\n    \n  \n  \n    \n      tdm_backend.h\n      This file defines the TDM backend interface.\n    \n    \n      tdm_log.h\n      This file includes functions to print logs in frontend and backend modules.\n    \n    \n      tdm_helper.h\n      This file includes helper functions for the TDM frontend and backend.\n    \n  \n\n\nThe display backend interface is mandatory. For more information, see tdm_backend.h.\n\nTable: Display backend interface functions\n\n\n  \n    \n      Function\n      Description\n      Mandatory\n    \n  \n  \n    \n      display_get_capability()\n      Gets the display capabilities of the backend module. TDM calls this function not only at initialization, but also when a new output is connected. If the hardware has a maximum usable layer count restriction, the backend module can set the max count in the max_layer_count element of the tdm_caps_display structure. Otherwise, it is set to -1.\n      Yes\n    \n    \n      display_get_pp_capability()\n      Gets the pp capabilities of the backend module. TDM calls this function not only at initialization, but also when a new output is connected. The backend module does not need to implement this function if the hardware does not have a memory-to-memory converting device. If it does, the backend module must fill the tdm_caps_pp data, which contains the hardware restriction information which a converting device can handle, such as format and size.\n      No\n    \n    \n      display_get_capture_capability()\n      Gets the capture capabilities of the backend module. TDM calls this function not only at initialization, but also when a new output is connected. The backend module does not need to implement this function if the hardware does not have a capture device. If it does, the backend module must fill the tdm_caps_capture data, which contains the hardware restriction information which a capture device can handle, such as format and size.\n      No\n    \n    \n      display_get_outputs()\n      Gets an output array of the backend module. TDM calls this function not only at initialization, but also when a new output is connected. The backend module must return the newly-allocated array which contains tdm_output* data. It is freed in the frontend.\n      Yes\n    \n    \n      display_get_fd()\n      Gets the file descriptor of the backend module. The backend module can return the epoll’s fd.\n      No\n    \n    \n      display_handle_events()\n      Handles the events which happen on the fd of the backend module.\n      No\n    \n    \n      display_create_pp()\n      Creates a pp object of the backend module. The backend module does not need to implement this function if the hardware does not have a memory-to-memory converting device\n      No\n    \n  \n\n\nThe output backend interface is mandatory. For more information, see tdm_backend.h.\n\nTable: Output backend interface functions\n\n\n  \n    \n      Function\n      Description\n      Mandatory\n    \n  \n  \n    \n      output_get_capability()\n      Gets the capabilities of an output object. TDM calls this function not only at initialization, but also when a new output is connected. The tdm_caps_output contains connection status, modes, available properties, and size restriction information.\n      Yes\n    \n    \n      output_get_layers()\n      Gets the layer array of an output object. TDM calls this function not only at initialization, but also when a new output is connected. The backend module must return the newly-allocated array which contains tdm_layer* data. It is freed in the frontend.\n      Yes\n    \n    \n      output_set_property()\n      Sets the property with a given ID.\n      No\n    \n    \n      output_get_property()\n      Gets the property with a given ID.\n      No\n    \n    \n      output_wait_vblank()\n      Waits for VBLANK. If this function returns TDM_ERROR_NONE, the backend module must call a user vblank handler with the user data of this function after vblanks interval.\n      Yes\n    \n    \n      output_set_vblank_handler()\n      Sets the user vblank handler.\n      Yes\n    \n    \n      output_commit()\n      Commits the changes for an output object. When this function is called, the backend module must apply all changes of the given output object to the screen as well as the layer changes of this output. If this function returns TDM_ERROR_NONE, the backend module must call a user commit handler with the user data of this function after all changes of the given output object are applied.\n      Yes\n    \n    \n      output_set_commit_handler()\n      Sets a user commit handler.\n      Yes\n    \n    \n      output_set_dpms()\n      Sets the DPMS of an output object.\n      No\n    \n    \n      output_get_dpms()\n      Gets the DPMS of an output object.\n      No\n    \n    \n      output_set_mode()\n      Sets 1 of the available modes of an output object.\n      Yes\n    \n    \n      output_create_capture()\n      Creates a capture object of an output object. The backend module does not need to implement this function if the hardware does not have a capture device.\n      No\n    \n    \n      output_set_status_handler()\n      Sets an output connection status handler. The backend module must call the output status handler when the output connection status has been changed to let the TDM frontend know of the change.\n      No\n    \n    \n      output_set_dpms_handler()\n      Sets an output DPMS handler. The backend module must call the output DPMS handler when the output DPMS has been changed to let the TDM frontend know of the change.\n      No\n    \n  \n\n\nThe layer backend interface is mandatory. For more information, see tdm_backend.h.\n\nTable: Layer backend interface functions\n\n\n  \n    \n      Function\n      Description\n      Mandatory\n    \n  \n  \n    \n      layer_get_capability()\n      Get the capabilities of a layer object. The backend module must implement this function. TDM calls this function not only at initialization, but also when a new output is connected. The tdm_caps_layer contains the available formats/properties and zpos information.\n      Yes\n    \n    \n      layer_set_property()\n      Sets the property with a given ID.\n      No\n    \n    \n      layer_get_property()\n      Gets the property with a given ID.\n      No\n    \n    \n      layer_set_info()\n      Sets the geometry information to a layer object. The backend module applies the geometry information when the output object of a layer object is committed.\n      Yes\n    \n    \n      layer_get_info()\n      Gets the geometry information of a layer object.\n      Yes\n    \n    \n      layer_set_buffer()\n      Sets a TDM buffer to a layer object. The backend module shows a TDM buffer on the screen when the output object of a layer object is committed.\n      Yes\n    \n    \n      layer_unset_buffer()\n      Unsets a TDM buffer from a layer object. The backend module must remove the currently-showing buffer from the screen.\n      Yes\n    \n    \n      layer_set_video_pos()\n      Sets the zpos for a video layer object. The backend module does not need to implement this function if the backend module does not have video layers. The zpos of the video layer is changeable.\n      No\n    \n    \n      layer_create_capture()\n      Creates a capture object of a layer object. The backend module does not need to implement this function if the hardware does not have a capture device.\n      No\n    \n    \n      layer_get_buffer_flags()\n      Gets the buffer flags which the layer can support.\n      No\n    \n  \n\n\nThe pp backend interface is optional. For more information, see tdm_backend.h.\n\nTable: pp backend interface functions\n\n\n  \n    \n      Function\n      Description\n    \n  \n  \n    \n      pp_destroy()\n      Destroys a pp object.\n    \n    \n      pp_set_info()\n      Sets the geometry information to a pp object. The backend module applies the geometry information when committed.\n    \n    \n      pp_attach()\n      Attaches a source buffer and a destination buffer to a pp object. The backend module converts the image of a source buffer to a destination buffer when committed. The size/crop/transform information is set using the pp_set_info() function of tdm_func_pp. When done, the backend module must return the source/destination buffer using the tdm_pp_done_handler() function.\n    \n    \n      pp_commit()\n      Commits changes for a pp object.\n    \n    \n      pp_set_done_handler()\n      Sets a user done handler to a pp object. The backend module must call the tdm_pp_done_handler() function when image conversion is done.\n    \n  \n\n\nThe capture backend interface is optional. For more information, see tdm_backend.h.\n\nTable: Capture backend interface functions\n\n\n  \n    \n      Function\n      Description\n    \n  \n  \n    \n      capture_destroy()\n      Destroys a capture object.\n    \n    \n      capture_set_info()\n      Sets the geometry information to a capture object. The backend module applies the geometry information when committed.\n    \n    \n      capture_attach()\n      Attaches a TDM buffer to a capture object. When the capture_commit() function is called, the backend module starts to dump an output or a layer to a TDM buffer. The backend module starts to dump an output or a layer to a TDM buffer when committed. The size/crop/transform information is set using the capture_set_info() function of the tdm_func_capture. When done, the backend module must return the TDM buffer using the tdm_capture_done_handler() function.\n    \n    \n      capture_commit()\n      Commits changes for a capture object.\n    \n    \n      capture_set_done_handler()\n      Sets a user done handler to a capture object. The backend module must call the tdm_capture_done_handler() function when the capture operation is done.\n    \n  \n\n\nTDM backends\n\nThere are several backends which can be used as reference when implementing the TDM backend.\n\nTable: TDM backends\n\n\n  \n    \n      Backend\n      Project (http://review.tizen.org)\n      Description\n    \n  \n  \n    \n      libtdm-drm\n      platform/adaptation/libtdm-drm\n      Backend for a target device which supports the DRM interface, such as the Tizen SDK emulator. No PP or capture capability.\n    \n    \n      libtdm-fbdev\n      platform/adaptation/libtdm-fbdev\n      Backend for a target device which supports the FBDEV interface. No PP or capture capability.\n    \n    \n      libtdm-exynos\n      platform/adaptation/samsung_exynos/libtdm-exynos\n      Backend for a target device which uses the exynos chipset using the DRM interface. Has PP and capture capability, using the exynos-specific DRM interface to support PP.\n    \n    \n      libtdm-sprd\n      platform/adaptation/spreadtrum/libtdm-sprd\n      Backend for a target device which uses the Spreadtrum chipset using the Spreadtrum-specific ioctl. Uses the DRM interface to support vblank. Has PP capability, but no capture capability.\n    \n  \n\n\nTesting the Porting Result\n\nTDM offers the tdm-test-server tool to allow you to easily test the porting result. The tdm-test-server tool is included in the libtdm-tools package, which can be downloaded from the platform binary’s snapshot repository. Make sure that TBM porting is done before using the following commands, because TDM works on top of TBM.\n\n$ systemctl stop display-manager  (stop the display server)\n$ export XDG_RUNTIME_DIR=/run\n$ export TBM_DISPLAY_SERVER=1\n$ tdm-test-server                 (show all options)\n$ tdm-test-server -a              (test all layers)\n$ tdm-test-server -a -v           (test all layers with vblank events)\n\n\nThe following image shows the result of a test performed using the tdm-test-server -a command. The fullscreen buffer is set to the PRIMARY layer, and the small buffer is set to the OVERLAY layer.\n\nFigure: Tdm-test-server results\n\n\n\nChecking TDM Log Messages\n\nTDM uses dlog to print debug messages. To show TDM runtime log messages:\n\n$ dlogutil -v threadtime TDM\n\n\nReferences\n\nFor detailed information about TDM and the TDM backend, see Tizen Display Manager (TDM).\n\nInput Management\n\nThe input manager supports a libinput-based input device backend. libinput is a common input library for the Wayland compositor. With libinput, the input stack is simpler without the Xorg input drivers. Since Tizen 3.0, the input manager is not a HAL component.\n\nFigure: Tizen 3.0 input management\n\n\n\nlibinput\n\nThe libinput library handles input devices for display servers and other applications that need to directly deal with input devices:\n\n\n  Device detection\n  Device handling\n  Input device event processing\n  Scaling touch coordinates\n  Generating pointer events from touchpads\n  Pointer acceleration\n\n\nFor more information, see the libinput wiki.\n\nlibevdev\n\nThe libevdev library handles evdev kernel devices. It abstracts the evdev ioctls through type-safe interfaces and provides functions to change the appearance of the device. For more information, see https://en.wikipedia.org/wiki/Evdev.\n\nmtdev\n\nThe mtdev standalone library transforms all variants of kernel MT events to the slotted type B protocol. For more information, see http://www.linuxfromscratch.org/blfs/view/svn/general/mtdev.html.\n\nlibinput Backends\n\nlibinput: platform/upstream/libinput\n\nOpenGL®\n\nThis section describes the essential elements of the Tizen platform-level graphics architecture related to OpenGL® ES and EGL™, and how it is used by the application framework and the display server. The focus is on how graphical data buffers move through the system.\n\nThe Tizen platform requires the OpenGL® ES driver for the acceleration of the Wayland display server and the wayland-egl client. This platform demands an OpenGL® ES and EGL™ driver which is implemented by the Tizen EGL Porting Layer.\n\nTizen OpenGL® ES and EGL™ Architecture\n\nThe following figure illustrates the Tizen OpenGL® ES and EGL™ architecture.\n\nFigure: Tizen OpenGL® ES architecture\n\n\n\n\n  \n    CoreGL\n\n    An injection layer of OpenGL® ES that provides the following capabilities:\n\n    \n      Support for driver-independent optimization (FastPath)\n      EGL™/OpenGL® ES debugging\n      Performance logging\n      Supported versions\n        \n          EGL™ 1.4\n          OpenGL® ES 1.1, 2.0, 3.0, 3.1\n        \n      \n    \n\n    CoreGL loads the manufacturer’s OpenGL® ES driver from the /usr/lib/driver directory. CoreGL provides the libEGL.so, libGLESv1_CM.so, and libGLESvs.so driver files in the /usr/lib directory.\n  \n  \n    GPU vendor GL/EGL™ driver\n\n    The Tizen platform demands that the GPU vendor implements the GL and EGL™ driver using libtpl-egl. The GPU vendor GL/EGL™ driver (libEGL.so, libGLESv1_CM.so, libGLESv2.so) must be installed in the /usr/lib/driver path.\n  \n\n\nTizen Porting Layer (TPL) for EGL™\n\nTPL-EGL is an abstraction layer for surface and buffer management on the Tizen platform. It is used for implementation of the EGL™ platform functions.\n\nFigure: TPL architecture\n\n\n\nThe background for the Tizen EGL Porting Layer for EGL™ is in various window system protocols in Tizen. There was a need for separating common layer and backend.\n\nTizen uses the Tizen Porting Layer for EGL™, as the TPL-EGL API prevents burdens of the EGL™ porting on various window system protocols. The GPU GL Driver’s Window System Porting Layer can be implemented by TPL-EGL APIs which are the corresponding window system APIs. The TBM, Wayland, and GBM backends are supported.\n\nTizen Porting Layer for the EGL™ Object Model\n\nTPL-EGL provides interfaces based on an object-driven model. Every TPL-EGL object can be represented as a generic tpl_object_t, which is reference-counted and provides common functions. Currently, display and surface types of TPL-EGL objects are provided. A display, like a normal display, represents a display system which is usually used for connecting to the server. A surface corresponds to a native surface, such as wl_surface. Surfaces can be configured to use N-buffers, but are usually double-buffered or triple-buffered. A buffer is what you render on, usually a set of pixels or a block of memory. For these 2 objects, the Wayland, GBM, TBM backend are defined, and they correspond to their own window systems. This means that you do not need to care about the window systems.\n\nThe TPL-EGL has the following core objects:\n\n\n  \n    TPL-EGL Object\n\n    Base class for all TPL-EGL objects.\n  \n  \n    TPL-EGL Display\n\n    Encapsulates the native display object (Display *, wl_display). Like a normal display, this represents a display system which is usually used for connecting to the server, scope for other objects.\n  \n  \n    TPL-EGL Surface\n\n    Encapsulates the native drawable object (Window, Pixmap, wl_surface). The surface corresponds to a native surface, such as tbm_surface_queue or wl_surface. A surface can be configured to use N-buffers, but they are usually double-buffered or triple-buffered.\n  \n\n\nTPL-EGL Objects and Corresponding EGL™ Objects\n\nBoth TPL-EGL and vendor OpenGL® ES/EGL™ driver handles a tbm_surface as the corresponding TPL surface buffer. It is represented by the TBM_Surface part in the following figure.\n\nFigure: TPL-EGL architecture\n\n\n\nThe following figure illustrates the OpenGL® ES drawing API flow.\n\nFigure: OpenGL® ES drawing API flow\n\n\n\nTPL-EGL Frontend API\n\nTPL-EGL Object is a base class for all TPL-EGL objects. It provides common functionalities to all TPL-EGL objects.\n\nTable: TPL-EGL Object functions\n\n\n  \n    \n      Function\n      Description\n    \n  \n  \n    \n      tpl_object_reference()\n      Increases the reference count of a TPL-EGL object. All TPL-EGL objects are reference-counted with a reference count 1 on creation. When the reference count drops to 0, the object is freed.\n    \n    \n      tpl_object_unreference()\n      Decreases the reference count and destroys the object if it becomes 0.\n    \n    \n      tpl_object_get_reference()\n      Gets the reference count of the given TPL-EGL object.\n    \n    \n      tpl_object_get_type()\n      Gets the type of the object (display, surface, or buffer).\n    \n    \n      tpl_object_set_user_data()\n      Sets the user data to a TPL-EGL object. If the user wants to relate some data with a TPL-EGL object, this function allows them to register a pointer to such data, which can be retrieved later using the tpl_object_get_user_data() function. The key is the pointer value itself as a key.\n    \n    \n      tpl_object_get_user_data()\n      Gets the registered user data of a TPL-EGL object.\n    \n  \n\n\nTPL-EGL Display encapsulates the native display object (Display *, wl_display). Any other objects created from TPL-EGL Display inherit its backend type.\n\nTable: TPL-EGL Display functions\n\n\n  \n    \n      Function\n      Description\n    \n  \n  \n    \n      tpl_display_create()\n      Creates the TPL-EGL display object for the given native display if there is no existing TPL-EGL display for that native display. If given NULL for native_dpy, this function returns the default display.\n    \n    \n      tpl_display_get()\n      Gets the TPL-EGL display object for the given native display if one exists for it.\n    \n    \n      tpl_display_get_native_handle()\n      Gets the native display handle which the given TPL-EGL display is created for.\n    \n    \n      tpl_display_query_config()\n      Queries the supported pixel formats for the given TPL-EGL display. If any pixel format values are acceptable, use the TPL_DONT_CARE value for the size values .\n    \n    \n      tpl_display_filter_config()\n      Filters the configuration according to a given TPL-EGL display. This function modifies current config specific to the current given TPL-EGL display.\n    \n    \n      tpl_display_get_native_window_info()\n      Queries information on the given native window.\n    \n    \n      tpl_display_get_native_pixmap_info()\n      Queries information on the given native pixmap.\n    \n    \n      tpl_display_get_buffer_from_native_pixmap()\n      Gets the native buffer from the given native pixmap.\n    \n  \n\n\nTPL-EGL Surface encapsulates the native drawable object (Window, Pixmap, wl_surface). The main features of the class are retrieving the buffer for a frame and posting the surface to a screen.\n\nTable: TPL-EGL Surface functions\n\n\n  \n    \n      Function\n      Description\n    \n  \n  \n    \n      tpl_surface_create()\n      Creates a TPL-EGL surface for the given native surface.\n    \n    \n      tpl_surface_get_display()\n      Gets the TPL-EGL display where the given TPL-EGL surface was created from.\n    \n    \n      tpl_surface_get_native_handle()\n      Gets the native surface handle of the given TPL-EGL surface.\n    \n    \n      tpl_surface_get_type()\n      Gets the type of the given TPL surface.\n    \n    \n      tpl_surface_get_size()\n      Gets the current size of the given TPL-EGL surface. The size of a surface can change when a user or the server resizes the window. TPL-EGL updates the size information every time when a buffer is queried using the tpl_surface_dequeue_buffer() function. Note that there can still be mismatch between actual surface size and the cached one.\n    \n    \n      tpl_surface_validate()\n      Validates the current frame of the given TPL-EGL surface. Call this function before getting the final render target buffer, as calling the tpl_surface_dequeue_buffer() function after calling this function can give output values different to earlier ones. A buffer returned after calling this function is guaranteed not to change further.\n    \n    \n      tpl_surface_dequeue_buffer()\n      Gets the buffer of the current frame for the given TPL-EGL surface. Depending on the backend, communication with the server can be required. Returned buffers are used for rendering the target to draw the current frame. Returned buffers are valid until the next tpl_surface_dequeue_buffer() function call. If the tpl_surface_validate() function returns TPL_FALSE, the previously returned buffers must no longer be used. Instead, this function must called again before drawing, returning a valid buffer.\n    \n    \n      tpl_surface_enqueue_buffer()\n      Posts a given tbm_surface. This function requests the display server to post a frame. This is the function which can enqueue a buffer to the tbm_surface_queue. Make sure this function is called exactly once for a frame. Scheduling post calls on a separate thread is recommended.\n    \n    \n      tpl_surface_enqueue_buffer_with_damage()\n      Posts a given tbm_surface with region of damage. Damage information is used for reducing number of pixels composited in the compositor. Setting the num_rects to 0 or rects to NULL means entire area is damaged. This function requests a server to post a frame. This function is identical with the tpl_surface_enqueue_buffer() function except for delivering the damage information for updating. Make sure this function is called exactly once for a frame. Scheduling post calls on a separate thread is recommended.\n    \n    \n      tpl_surface_set_post_interval()\n      Sets the frame interval of the given TPL-EGL surface, which ensures that only a single frame is posted within the specified vsync intervals. When a frame ends, the frame interval is set to the surface’s current interval.\n    \n    \n      tpl_surface_get_post_interval()\n      Gets the frame interval of the given TPL-EGL surface.\n    \n  \n\n\nThe following code snippet shows a simple example of the Tizen Porting Layer:\n\ndpy = tpl_display_create(...);\nsfc = tpl_surface_create(dpy, ...);\n\nwhile (1) {\n    buf = tpl_surface_dequeue_buffer(sfc);\n\n    /* Draw something */\n\n    tpl_surface_enqueue_buffer(sfc, buf);\n}\n\n\nIn the GPU vendor driver, the GPU frame builder handles the drawing. TPL-EGL exposes the native platform buffer identifiers and managers so that the buffer can be used in other modules. Currently, dma_buf/DRM is supported for these purposes. The EGL porting layer calls TPL-EGL functions to execute commands requested of it, and returns the results to the GPU vendor driver. TPL-EGL performs all protocol-dependent actions. Such protocol-dependent parts can be separated into TPL-EGL backends. TPL-EGL backend can also be configured at runtime, and you can specify which type of backend to use when initializing a display object.\n\nTPL-EGL and Wayland Server and Client\n\nTizen uses the wl_tbm protocol instead of wl_drm. The wl_tbm protocol is designed for sharing the buffer (tbm_surface) between the wayland_client and wayland_server. Although the wayland_tbm_server_init and wayland_tbm_client_init pair is a role for the eglBindWaylandDisplayWL, the EGL™ driver is required to implement the entry points for the eglBindWaylandDisplayWL and eglUnbindWaylandDisplayWL as dummy. For more information, see https://cgit.freedesktop.org/mesa/mesa/tree/docs/specs/WL_bind_wayland_display.spec.\n\nFigure: TPL-EGL and Wayland\n\n\n\nBuffer Flow Between the Wayland Server and OpenGL® ES/EGL™ Driver\n\nThe following figure shows the buffer flow between the Wayland server and the OpenGL® ES/EGL™ driver. The passed buffer is of the tbm_surface type.\n\nFigure: Buffer flow between Wayland server and OpenGL® ES/EGL™ driver\n\n\n\nProject Git Repository\n\nThe following table lists the available project Git repositories.\n\nTable: Git repositories\n\n\n  \n    \n      Project\n      Repository\n      Description\n    \n  \n  \n    \n      libtpl-egl\n      platform/core/uifw/libtpl-egl\n      Tizen Porting Layer for EGL™\n    \n    \n      libtbm\n      platform/core/uifw/libtbm\n      Library for the Tizen Buffer Manager\n    \n    \n      coregl\n      platform/core/uifw/coregl\n      Injection layer of OpenGL® ES / EGL™\n    \n    \n      wayland-tbm\n      platform/core/uifw/wayland-tbm\n      Protocol for graphics memory management for Tizen\n    \n    \n      emulator-yagl\n      platform/adaptation/emulator/emulator-yagl\n      OpenGL® ES / EGL™ driver for the emulator\n    \n    \n      tpl-novice\n      platform/core/uifw/ws-testcase\n      Novice test framework for TPL\n    \n  \n\n\nlibtpl-egl Reference Driver\n\nThe Emulator YAGL (OpenGL® ES / EGL™ driver for the emulator) is implemented by libtpl-egl.\n\nThe following commit explains how to port the driver with libtpl-egl from the traditional drm-based driver:\n\n\n  Porting YAGL to the Tizen platform https://review.tizen.org/gerrit/#/c/67921/\n\n\nTesting and Verifying the OpenGL® ES Driver\n\nThe Khronos OpenGL® ES CTS supports wayland-egl. libtpl-egl has a test case for the libtpl-egl. The ws-testcase’s tpl-novice has sample code for the libtpl-egl."
					}
					
				
			
		
			
				
					,
					
					"tizenstudio-setup-hardware-accelerated-execution-manager": {
						"id": "tizenstudio-setup-hardware-accelerated-execution-manager",
						"title": "Hardware Accelerated Execution Manager",
						"categories": "",
						"url": " tizenstudio/setup/hardware-accelerated-execution-manager/",
						"content": "Hardware Accelerated Execution Manager\n\nThe Intel Hardware Accelerated Execution Manager (Intel® HAXM) is a hardware-assisted virtualization engine (hypervisor). This hypervisor uses Intel Virtualization Technology (VT) to speed-up the Tizen application emulation on the Windows® and the macOS host machines. When you combine the Tizen x86 emulator images with Tizen Studio, Intel® HAXM speed-ups the Tizen emulation on the Intel-VT-enabled systems.\nIntel® HAXM significantly enhances the performance of the Tizen emulator. For more information on the emulator details, see Increasing the Application Execution Speed.\n\nThis page explains how to install HAXM on your Windows® or macOS development system.\n\nFollowing are the hardware requirements:\n\n\n  Intel processor with support for VT-x, EM64T, and Execute Disable Bit\n  Minimum 1 GB of available memory (2 GB or more is preferred)\n\n\n\n  Note\n\n  Intel® HAXM can only be used on the systems with an Intel processor that supports the Intel VT.\n\n\n\nHow to Install Intel® HAXM on Windows®?\n\nFollowing are the supported Windows® versions:\n\n  10/8.1/8/7 (32-bit/64-bit)\n  Vista (32-bit/64-bit)\n  XP SP2 or higher (32-bit only)\n\n\nHAXM is automatically installed as part of the Tizen Studio installation. To install HAXM separately, see http://download.tizen.org/sdk/haxm/7.0.0/win/ and download the Windows installer package.\n\nTable: Windows installer package\n\n\n  \n    \n      Windows installer\n      File description\n      File size\n      MD5 checksum\n    \n  \n  \n    \n      IntelHAXM_7.0.0.exe\n      System driver\n      2.89 MB\n      1587f7ae42e11c7b22dc674fd776ce252b6a19152e7ca416a748e2bdbf2b36c5\n    \n  \n\n\nTo install Intel® HAXM on Windows®, follow these steps:\n\n\n  Open the downloaded DMG file and run the installer.\n  \n    In the User Account Control dialog that appears, to accept the UAC prompt, click Yes.\n\n  \n  \n    To start the installation, click Install.\n![Start installation]./tizenstudio/setup/media/hardware_start_instal.png)\n\n    To access the documentation, click Intel® HAXM Documentation.\n\n    The following screen shows the installation in-progress:\n\n    \n  \n  \n    When the Intel® HAXM installation is completed, to exit the installer, click Finish.\n\n    \n  \n\n\nIntel® HAXM is successfully installed.\n\nExecute the following command, to verify whether Intel® HAXM is running:\n\nsc query intelhaxm \n\n\nIf Intel® HAXM is working, the command displays a status message indicating that the state is “4 RUNNING”.\n\n\nHow to Start and Stop Intel® HAXM?\n\nTo start or stop Intel® HAXM, open the command prompt window with administrator privileges and execute one of the following commands:\n\n\n  Start HAXM: sc start intelhaxm\n  Stop HAXM: sc stop intelhaxm\n\n\nHow to Remove Intel HAXM?\n\n\n  Warning\n\n  Close all instances of the Tizen emulator before removing Intel® HAXM.\n\n\nTo uninstall Intel® HAXM, either run the installer or use the control panel.\n\n\n  Note\n\n  If you remove Intel® HAXM, the acceleration of the Tizen emulator is disabled; however, the emulator is still enabled. To re-enable the acceleration, install Intel® HAXM again.\n\n\nTroubleshooting\n\nIf there is an installation failure because of the hardware requirements, check the following BIOS/OS settings:\n\n\n  Ensure that VT is enabled in BIOS.\n  Ensure that Execute Disable Bit is enabled in BIOS.\n  Ensure that Data Execution Prevention is enabled in Windows®. In the Windows® platform, click Control Panel &gt; System and then select Advanced system settings. In the Advanced tab that appears, select Performance section, Options (or Settings), and Data Execution Prevention. Ensure that DEP is enabled.\n  Ensure that Hyper-V is disabled in Windows® 8 or higher:\n    \n      In the Start menu, run Programs and Features.\n\n      In the Programs and Features window that appears, click Turn Windows features on or off.\n      In the Turn Windows features on or off window that appears, disable Hyper-V and click OK.\n\n      Reboot the computer.\n    \n  \n\n\n\nHow to Install Intel® HAXM on macOS?\n\nFollowing are the supported macOS versions:\n\n  10.12 Sierra (64-bit)\n  10.11 OS X El Capitan(64-bit)\n  10.10 Yosemite (64-bit)\n  10.9 Mavericks (64-bit)\n  10.8 Mountain Lion (64-bit)\n\n\nHAXM is automatically installed as part of the Tizen Studio installation. To install HAXM separately, see http://download.tizen.org/sdk/haxm/7.0.0/mac/ and download the macOS installer package.\n\nTable: Windows installer package\n\n\n  \n    \n      macOS installer\n      File description\n      File size\n      MD5 checksum\n    \n  \n  \n    \n      IntelHAXM_7.0.0.dmg\n      System driver\n      218 KB\n      fe7e4cd86b7a2b85591397fd6bf2ef43e7b088bfc72badab0c4d3532a65c2a2f\n    \n  \n\n\nTo install Intel® HAXM on macOS, follow these steps:\n\n\n  \n    Open the downloaded DMG file and run the installer.\n  \n  \n    To start the installation, click Continue.\n\n  \n  \n    Either adjust the amount of RAM to be allocated to Intel® HAXM or set it to 2048 MB as the default value.\n\nThe installer also functions as a configuration tool for Intel® HAXM. To change the memory settings later, run the installer again.\n  \n  \n    Verify your Intel® HAXM memory allocation settings, and click Continue.\n\n  \n  \n    Check the capacity and the disk location of the HAXM driver, and click Install.\n\n  \n  \n    Type your password.\n \n  \n  \n    When the Intel® HAXM installation is finished, to exit the installer, click Close.\n\n    \n  \n\n\nThe Intel® HAXM gets successfully installed.\n\nTo verify if Intel® HAXM is running, execute the following command:\n\nkextstat | grep intel \n\n\nIf Intel® HAXM is successful, the command displays a status message indicating that the kernel extension named “com.intel.kext.intelhaxm” is loaded.\n\nHow to Start and Stop Intel® HAXM?\n\nTo start or stop Intel® HAXM, open the terminal window with administrator privileges and execute one of the following commands:\n\n\n  Start HAXM: sudo kextload –b com.intel.kext.intelhaxm\n  Stop HAXM: sudo kextunload –b com.intel.kext.intelhaxm\n\n\nHow to Remove Intel HAXM?\n\n\n  Warning\n\n  Close all the instances of the Android emulator before removing Intel HAXM. Intel HAXM cannot be removed while in use.\n\n\n\n  \n    T o uninstall Intel HAXM, execute the following command in the terminal window:\n\n    sudo /Library/Extensions/intelhaxm.kext/Contents/Resources/uninstall.sh\n    \n  \n  \n    Enter your current user password. Follow the uninstaller prompts, to remove Intel HAXM.\n  \n\n\n\n  Note\n\n  If you remove Intel® HAXM, the acceleration of the Tizen emulator is disabled, however, the emulator is still enabled. Existing x86 and x86_64 Android Virtual Devices may no longer boot. To re-enable the acceleration, install Intel® HAXM again.\n\n\nTroubleshooting\n\n\n  \n    Intel Execute Disable (XD) Bit capability error:\n\n    When installing Intel HAXM, you may encounter an error regarding Intel XD support.\nThis error message can be triggered by one of the following conditions:\n\n    \n      Intel XD is not supported by your computer’s processor\n      Intel XD is not enabled\n    \n\n    Intel XD is not supported\n\n    Intel HAXM requires an Intel processor with Execute Disable (XD) Bit functionality and cannot be used on systems lacking this hardware feature. To determine the capabilities of your Intel processor, see http://ark.intel.com/.\n\n    Intel XD is not enabled\n    \n      Note\n\n      Apple computers have Intel XD permanently enabled if supported by the processor.\n    \n\n    If you receive an error message indicating that Intel XD is not enabled, your computer does not meet the minimum system requirements to use Intel HAXM. To determine the capabilities of your Intel processor, see http://ark.intel.com/.\n  \n  \n    Intel Virtualization Technology (VT-x) capability:\n\n    When installing Intel HAXM, you may encounter an error regarding Intel VT-x support. This error message can be triggered by the following conditions:\n\n    \n      Intel VT-x is not supported by your computer’s processor\n      Intel VT-x is not enabled\n    \n\n    Intel VT-x is not supported\n\n    Intel HAXM requires an Intel processor with Intel VT-x functionality and cannot be used on systems lacking this hardware feature. To determine the capabilities of your Intel processor, see http://ark.intel.com/.\n\n    Intel VT-x not enabled\n    \n      Note\n\n      Apple computers have Intel VT-x permanently enabled if supported by the processor.\n    \n\n    If you receive an error message indicating that Intel VT is not enabled, your computer does not meet the minimum system requirements to use Intel HAXM. To determine the capabilities of your Intel processor, see http://ark.intel.com/.\n  \n\n\nRelated Information\n\n  Dependencies\n    \n      Tizen Studio 1.0 and Higher"
					}
					
				
			
		
			
				
					,
					
					"tizenstudio-extension-sdk-in-app-purchase": {
						"id": "tizenstudio-extension-sdk-in-app-purchase",
						"title": "In-app Purchase Programming Guide",
						"categories": "",
						"url": " tizenstudio/extension-sdk/in-app-purchase/",
						"content": "In-app Purchase Programming Guide\n\nBy selling items from within your application, you can get a large revenue. You can implement In-Application Purchases (IAP) in your application using the AppControl mechanism for Tizen native and Web applications.\n\nYou can use the IAP in the following scenarios, for example:\n\n\n  An application that enables additional features\n  Any application that allows the user to remove ads\n  An audio-book application that allows the user to purchase and download new books\n  A game which offers new levels to play\n  An RPG game that allows to buy virtual items\n\n\nWhat is the In-App Purchase AppControl Mechanism?\n\nTo sell items inside your applications such as in-game coins, levels and others, you need to set servers up to communicate with billing server and user authentications server, and many other infra servers. In-App Purchase simply handles all those things for you. To use In-App Purchase, you need to prepare your applications for communicating with it. For example, with in-app purchase of items, your application finds the proper AppControl, starts the purchase method, and receives the result of the purchase in the method of the listener method. IAP shows dialogs in case of errors, communicates with the Tizen Stores server, and invokes the listener methods to return the result of the request.\n\nThis document explains the process of using the IAP. Read this document thoroughly before using the IAP.\n\nSupported Item Types\n\nIAP supports the following item types:\n\nTable: Supported item types\n\n\n  \n    \n      Table\n      Description\n    \n  \n  \n    \n      Consumable\n      If you purchase an item of this type and use it, it is consumed. These items can be repurchased.Example: Consumable items, such as bullets in games.\n    \n    \n      Non-consumable\n      Once purchased, you can use an item of this type permanently. These items cannot be repurchased.Example: Non-consumable items, including books, that do not need to be repurchased.\n    \n  \n\n\nTerms and Abbreviations\n\nThe following table lists the terminology used in the context of IAP.\n\nTable: Terms and abbreviations\n\n\n  \n    \n      Term\n      Description\n    \n  \n  \n    \n      IAP\n      In-App Purchase\n    \n    \n      MCC\n      This code (3 digits) identifies the mobile country code.\n    \n    \n      MNC\n      This code (characters or digits) identifies the carrier in the current country.\n    \n    \n      AppControl\n      A standard mechanism in Tizen for using specific operations exported by other applications.\n    \n    \n      Operation ID\n      Defines the behavior of the AppControl.\n    \n    \n      Application ID\n      Used to identify each application control supplier.\n    \n    \n      Item Group ID\n      Collection of items identified by a single ID (item list).\n    \n    \n      Item\n      A single piece of content.\n    \n  \n\n\nApplying IAP to Your Application\n\nApplying IAP to your application is easy. The process contains the following steps:\n\n\n  Register your items to the Tizen Store Seller Office.\n  Program your application to work with IAP.\n  Test and upload your application.\n\n\nThe following sections describe the process in more detail.\n\n1. Registering Your Items to Tizen Store Seller Office\n\nBefore you set up and program your application for IAP, you need to register your item group and items to the Tizen Store Seller Office.\n\nAn item group is a collection of items connected to your application in the Tizen Store Seller Office. For example, if there are 10 kinds of special items you need for your game, you need to create 1 item group for your game and 10 individual items. Registering the items is really simple.\n\n1.1. Connect to Tizen Store Seller Office\n\nLog in to the Tizen Store Seller Office. If you do not have an account for the Tizen Store Seller Office, create a new account. After you have logged in to the Tizen Store, register as a private seller if you want to sell applications under your personal name, or as a corporate seller if you want to sell applications under your company name.\n\n1.2. Register a New Item Group\n\nThe following steps explain how to register a new item group on Seller Office:\n\n\n  Click Applications &gt; Item to navigate to the selected menu option.\n  Click Add Item Group.\n  Fill in the fields for the Item Group Title and Description, and click OK to register your item group.\n  When the item group is registered, you can click Edit to modify its information.\n  Select a checkbox and click Delete to delete an item group. When you delete an item group, all items included in that group are also deleted.\n  You can copy registered item groups from the item group list. When you copy an item group, all items included in that group are also copied.\n\n\nAn item group can be modified, deleted, or copied when the application has the temporary status.\n\n1.3. Add a New Item (Temporary Status)\n\nFrom the item list, select the name of a registered item group to navigate to its information page. After an item group is created, a list of temporary tabs appears on the information screen when you first access it.\n\n\n  Click Add Item on the temporary tab on the view page to enter basic information, such as title, price, and description. Click OK to add items. For more information on price setting, see the Application Registration Guide.\n  You can batch register items by clicking Item Bulk Upload to upload an Excel file.\n\n\nWhen the item has been added, you can click its title in the item list to view the added content.\n\n1.3.1. Edit an Item (Temporary Status)\n\nYou can add, modify, or delete an item if there is an application listed in the item group, or if registered or revised applications in the item group are listed under Pre-Certification.\n\n\n  To view and edit the item title, price, description, and image, click the title of the item on the temporary tab list in the View popup window.\n  If all the applications containing the item are listed under Pre-Certification, select the checkbox and click Delete to delete the item from all of them. However, if the statuses of items mapped for applications are for sale, it cannot be deleted.\n  All changes are applied when all the mapped applications are validated. The On Standby button is displayed until validation is complete.\n\n\n1.3.2. Item Sales (Sales Status)\n\nTo register the item with the sales status:\n\n\n  Items are registered and modified and you can view them in sales.\n  If all the mapped applications that are being registered or revised in the item group are listed under Pre-Certification, click the Modify Item(s) button to create a temporary tab that allows you to modify the applications.\n\n\n2. Setting Your Application Project up to Use IAP\n\nIAP uses an AppControl mechanism, and as such requires no updates to the application project. Working with IAP means simply getting the proper AppControl.\n\nFor more information, see the Application Controls guide (in native and Web applications) and AppControl API (in native and Web applications).\n\n3. Programming Your Application to Work with IAP\n\nProgramming with IAP is very similar to programming with the Tizen native API and other AppControls supported in the system. Before you implement your code you must edit the configuration file (tizen-manifest.xml in native applications or config.xml in Web applications) first.\n\nSection 3.1. explains more about the configuration file.\n\nNote that the IAP allows 2 modes of operation (key name \"_mode\"):\n\n\n  Normal mode or commercial mode: To be used with the finished application that is released on the market. Proper data is obtained and returned from the IAP server.\n  Developer mode: This can be used while development of the application for testing purpose. Payment always succeeds.\n\n\nThe following table describes the interfaces list.\n\nTable: Interfaces list\n\n\t\n\t\t\n\t\t\tApplication ID\n\t\t\tOperation ID\n\t\t\tDescription\n\t\t\n\t\n\t\n\t\t\n\t\t\torg.tizen.inapppurchase.iapclient\n\t\t\thttp://tizen.org/appcontrol/operation/iapv2/purchase\n\t\t\tThe operation purchases the item.\n\t\t\tDuring this step a purchase screen is displayed, and the user needs to provide details (e-mail, password) to make a purchase.\n\t\t\tThe output value indicates the result of purchase (success or failure), and is used to verify the purchase.\n\t\t\t\n\t\t\n\t\t\n\t\t\torg.tizen.inapppurchase.iapservice\n\t\t\thttp://tizen.org/appcontrol/operation/iapv2/get_item_list\n\t\t\tThe operation returns a list of items available for purchase.\n\t\t\tThe output data values are used to send a list of items available for purchase.\n\t\t\t\n\t\t\n\t\t\n\t\t\thttp://tizen.org/appcontrol/operation/iapv2/get_purchased_item_list\n\t\t\tThe operation returns a list of already purchased items.\n\t\t\n\t\t\n\t\t\thttp://tizen.org/appcontrol/operation/iapv2/get_country_list\n\t\t\tThe operation returns a list of countries' MCC and MNC codes to be used in developer mode during testing in-app purchases.\n\t\t\n\t\n\n\nPurchasing Items\n\nThe following steps describe the process of item purchase:\n\n\n  \n    Get the item list.\n\n    Use the org.tizen.inapppurchase.iapservice application ID to retrieve a list items from the Tizen Store IAP server for a given group ID:\n\n    \n  \n  \n    Display a list of items in your In-App Purchase application.\n  \n  \n    Purchase the item.\n\n    Use the org.tizen.inapppurchase.iapclient application ID to make a purchase of a particular item:\n\n    \n  \n\n\nGetting a List of Countries\n\nIn developer mode, you are able to test In-App Purchase with different country servers. To get a list of available servers, you can use the http://tizen.org/appcontrol/operation/iapv2/get_country_list operation.\n\nFigure: Country list\n\n\n\n3.1. Adding Permissions to the Configuration File\n\nIAP uses AppControl interface to handle purchases. You need to add the http://tizen.org/privilege/appmanager.launch privilege to your application’s configuration file:\n\n\n  \n    In native applications:\n\n    The following example shows the tizen-manifest.xml file which contains the required permissions:\n\n    &lt;?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?&gt;\n&lt;manifest xmlns=\"http://tizen.org/ns/packages\" package=\"org.tizen.iapsample\" version=\"1.0.0\"&gt;\n   &lt;privileges&gt;\n      &lt;privilege&gt;http://tizen.org/privilege/appmanager.launch&lt;/privilege&gt;\n   &lt;/privileges&gt;\n&lt;/manifest&gt;\n    \n  \n  \n    In Web applications:\n\n    The following example shows the config.xml file which contains the required permissions:\n\n    &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;widget xmlns=\"http://www.w3.org/ns/widgets\" xmlns:tizen=\"http://tizen.org/ns/widgets\" id=...&gt;\n   &lt;tizen:privilege name = \"http://tizen.org/privilege/application.launch\"/&gt;\n&lt;/widget&gt;\n    \n  \n\n\n3.2. IAP Service Control (Get Item List, Purchased Item List, Country List)\n\nThe IAP Service instance allows you to get a list of items available for purchase and to get a list of already purchased item. It also allows you to get a list of countries available for testing in developer mode.\n\n\n  \n    Application ID\n\n    This application control can be accessed using an aliased application ID of the org.tizen.inapppurchase.iapservice application ID.\n  \n  \n    Operation ID\n\n    This application supports the http://tizen.org/appcontrol/operation/iapv2/get_item_list and http://tizen.org/appcontrol/operation/iapv2/get_purchased_item_list operations. It also supports the http://tizen.org/appcontrol/operation/iapv2/get_country_list operation.\n  \n  \n    Get item list operation\n\n    This operation returns a list of items available for purchase.\n  \n  \n    Input data\n\n    The following table shows the key-value pairs required in the input extra data for the http://tizen.org/appcontrol/operation/iapv2/get_item_list operation.\n  \n\n\nTable: Input data for getting a list of items\n\n\t\t\n\t\t\t\n\t\t\t\tKey\n\t\t\t\tValue\n\t\t\t\tDescription\n\t\t\t\n\t\t\n\t\t\n\t\t\t\n\t\t\t\t_mode\n\t\t\t\t0 or 1\n\t\t\t\t\n\t\t\t\tMode type:\n\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\t0: Normal (commercial) mode\n\t\t\t\t\tThis mode needs to be used in an application submitted to the Tizen Store.\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\t1: Developer mode\n\t\t\t\t\tThis mode can be used for testing purposes while developing the application. Payment always succeeds.\n\t\t\t\t\t\n\t\t\t\t\n\t\t\t\tThe default value is 0.\n\t\t\t\tThis information is optional.\n\t\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\t_transactionId\n\t\t\t\tTransaction ID\n\t\t\t\t\n\t\t\t\tTransaction ID, such as 1 or 2.\n\t\t\t\tThe ID is used to track a transaction between requests.\n\t\t\t\tThis information is mandatory.\n\t\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\t_startNumber\n\t\t\t\tStart number\n\t\t\t\t\n\t\t\t\tIndex of the first item in the list.\n\t\t\t\tStart downloading items from this index number.\n\t\t\t\tThis information is mandatory.\n\t\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\t_endNumber\n\t\t\t\tEnd number\n\t\t\t\t\n\t\t\t\tIndex of the last item in the list.\n\t\t\t\tStop downloading items after this index number.\n\t\t\t\tThis information is mandatory.\n\t\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\t_itemGroupId\n\t\t\t\tGroup ID\n\t\t\t\t\n\t\t\t\tGroup ID, such as 100000001455.\n\t\t\t\tA group ID is associated with a specific collection of items in Tizen Store Seller Office. You need to register your group ID in Tizen Store Seller Office first.\n\t\t\t\tThis information is mandatory.\n\t\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\t_languageCd\n\t\t\t\tLanguage code\n\t\t\t\t\n\t\t\t\tLanguage code, such as eng or rus.\n\t\t\t\tThe language code conforms to ISO 639-2, which uses 3-character codes.\n\t\t\t\tThe language code is associated with the display language of the item details in Tizen Store Seller Office.\n\t\t\t\tThe output parameters (itemName, itemDescription, reserved1, reserved2) are changed according to the language code.\n\t\t\t\tThis information is optional.\n\t\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\t_itemTypeCd\n\t\t\t\t00, 01, 02, or 10\n\t\t\t\t\n\t\t\t\tItem type code:\n\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\t00: Non-consumable\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\t01: Consumable\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\t10: All\n\t\t\t\t\t\n\t\t\t\t\n\t\t\t\tThis information is optional.\n\t\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\t\n\t\t\t\t&nbsp;\n\t\t\t\t_mcc\n\t\t\t\t(deprecated)\n\t\t\t\t\n\t\t\t\tMobile country code (MCC)\n\t\t\t\t\n\t\t\t\tMobile country code, such as 250.\n\t\t\t\tMMCs can only be used in developer mode. You can retrieve a list of available MCCs using the get country list operation.\n\t\t\t\tThis information is optional.\n\t\t\t\t(18th Oct. by Tizen Store Dev. - deprecated parameter)\n\t\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\t\n\t\t\t\t_mnc\n\t\t\t\t(deprecated)\n\t\t\t\t\n\t\t\t\tMobile network code (MNC)\n\t\t\t\t\n\t\t\t\tMobile network code, such as 01.\n\t\t\t\tMNCs can only be used in developer mode.\n\t\t\t\tThis information is optional.\n\t\t\t\t(18th Oct. by Tizen Store Dev. - deprecated parameter)\n\t\t\t\t\n\t\t\t\n\t\t\n\t\n\n\n  Example code for get item list\n    app_control_h app_control;\nint rt = app_control_create(&amp;app_control);\n  \nif (rt == APP_CONTROL_ERROR_NONE) {\n    app_control_set_app_id(app_control, \" org.tizen.inapppurchase.iapservice\");\n    app_control_set_operation(app_control, \"http://tizen.org/appcontrol/operation/iapv2/get_item_list\");\n    app_control_add_extra_data(app_control, \"_mode\", \"0\");\n    app_control_add_extra_data(app_control, \"_transactionId\", \"123\");\n    app_control_add_extra_data(app_control, \"_startNumber\", \"1\");\n    app_control_add_extra_data(app_control, \"_endNumber\", \"10\");\n    app_control_add_extra_data(app_control, \"_itemGroupId\", \"100000000012\");\n    app_control_add_extra_data(app_control, \"_languageCd\", \"ENG\");\n    app_control_add_extra_data(app_control, \"_itemTypeCd\", \"00\");\n\n    rt = app_control_send_launch_request(app_control, get_item_list_cb, NULL);\n}\nif (app_control != NULL)\n    app_control_destroy(app_control);\n    \n  \n  \n    Output Data\n\n    The results of the operation are returned in the app control callback.\n\n    The following table shows the output data for the http://tizen.org/appcontrol/operation/iapv2/get_item_list operation.\n\n    Table: Output data for getting a list of items\n\n    \n      \n        \n          Key\n          Value\n          Description\n        \n      \n      \n        \n          _method\n          OnItemInformationListReceived\n          Method to be called as a purchase request result.\n        \n        \n          _result\n          Result code\n          Result codes are described at the end of this section.\n        \n        \n          _resultDescription\n          Result code/Function ID\n          Result code/Function ID when _result value is not 0 (success). Result codes are described at the end of this section.\n        \n        \n          _transactionId\n          Transaction ID\n          This is the same ID as the transaction ID that is used in the request.\n        \n        \n          _startNumber\n          Start number\n          Index of the first item in the list.\n        \n        \n          _endNumber\n          End number\n          Index of the last item in the list.\n        \n        \n          _totalCount\n          Total items count\n          Total number of items based on the start number and end number.\n        \n        \n          _itemTotalCount\n          Total registered items count\n          Total number of registered items in the group ID.\n        \n      \n    \n\n    There is also a _totalCount number of items in the output data. Each key consists of a PREFIX (list item index value) and a key (such as 12_itemId).\n\n    Table: Item keys in the output data\n\n    \n      \n          \n              Key\n              Value\n              Description\n          \n      \n      \n          \n              PREFIX_itemId\n              Item ID\n              This is the same number as an item ID that is used in the request.\n          \n          \n              PREFIX_itemGroupId\n              Item group ID\n              ID of a collection of items. The collection is linked to your application in Tizen Store Seller Office.\n          \n          \n              PREFIX_itemName\n              Item name\n              Name provided during item registration in Tizen Store Seller Office.\n          \n          \n              PREFIX_currencyUnit\n              Currency unit\n              Device user's currency unit, such as $, Won, or Pound.\n          \n          \n              PREFIX_unitPrecedes\n              0 or 1\n              Currency unit position:\n                  \n                      0: Tail (2.99 TL)\n                      1: Front ($ 2.99)\n                  \n              \n          \n          \n              PREFIX_hasPenny\n              0 or 1\n              Information whether the currency unit has penny representation:\n                  \n                      0: No\n                      1: Yes\n                  \n              \n          \n          \n              PREFIX_itemPrice\n              Item price\n              Price of the item in the local currency.\n          \n          \n              PREFIX_itemDownloadUrl\n              Item download URL\n              URL provided during item registration in Tizen Store Seller Office.\n          \n          \n              PREFIX_itemImageUrl\n              Item image URL\n              URL provided during item registration in Tizen Store Seller Office.\n          \n          \n              PREFIX_itemDescription\n              Item description\n              A description provided during item registration.\n          \n          \n              PREFIX_reserved1\n              Reserved field 1\n              Reserved field 1\n          \n          \n              PREFIX_reserved2\n              Reserved field 2\n              Reserved field 2\n          \n          \n              PREFIX_itemTypeCd\n              00, 01, or 02\n              Item type code:\n                  \n                      00: Non-consumable\n                      01: Consumable\n                      02: Subscription (non-renewing - to be developed)\n                  \n              \n          \n          \n              PREFIX_itemSubsBillDurationCd\n              00, 01, 02, or 03\n              To be developed (reserved field)\n          \n          \n              PREFIX_subscriptionDurationMultiplier\n              Subscription duration multiplier\n              To be developed (reserved field)\n          \n          \n              PREFIX_timeStamp\n              Time stamp\n              Based on GMT +0, server time.\n                  (yyyyMMddHHmmss)\n              \n          \n      \n  \n  \n  \n    Example code for retrieving a list of items\n\n    void\nget_item_list_cb(app_control_h request, app_control_h reply, app_control_result_e result, void *user_data)\n{\n    char* rt_method = NULL;\n    char* rt_result = NULL;\n    char* rt_resultDescription = NULL;\n    char* rt_transactionId = NULL;\n    char* rt_startNumber = NULL;\n    char* rt_endNumber = NULL;\n    char* rt_totalCount = NULL;\n    char* rt_itemTotalCount = NULL;\n    char* rt_itemId = NULL;\n    char* rt_itemGroupId = NULL;\n    char* rt_itemName = NULL;\n    char* rt_currencyUnit = NULL;\n    char* rt_unitPrecedes = NULL;\n    char* rt_hasPenny = NULL;\n    char* rt_itemPrice = NULL;\n    char* rt_itemDownloadUrl = NULL;\n    char* rt_itemImageUrl = NULL;\n    char* rt_itemDescription = NULL;\n    char* rt_reserved1 = NULL;\n    char* rt_reserved2 = NULL;\n    char* rt_itemTypeCd = NULL;\n    char* rt_itemSubsBillDurationCd = NULL;\n    char* rt_subscriptionDurationMultiplier = NULL;\n    char* rt_timeStamp = NULL;\n\n    if (result == APP_CONTROL_RESULT_SUCCEEDED) {\n        rt = app_control_get_extra_data(reply, \"_method\", &amp;rt_method);\n        rt = app_control_get_extra_data(reply, \"_result\", &amp;rt_result);\n\n        /* Success */\n        if (!strcmp(\"0\", rt_result)) {\n            rt = app_control_get_extra_data(reply, \"_resultDescription\", &amp;rt_resultDescription);\n            rt = app_control_get_extra_data(reply, \"_transactionId\", &amp;rt_transactionId);\n            rt = app_control_get_extra_data(reply, \"_startNumber\", &amp;rt_startNumber);\n            rt = app_control_get_extra_data(reply, \"_endNumber\", &amp;rt_endNumber);\n            rt = app_control_get_extra_data(reply, \"_totalCount\", &amp;rt_totalCount);\n            rt = app_control_get_extra_data(reply, \"_itemTotalCount\", &amp;rt_itemTotalCount);\n\n            int start = atoi(rt_startNumber);\n            int end = atoi(rt_endNumber);\n\n            char keyId[100] = {0,};\n            for (; start &lt;= end; start++) {\n                snprintf(key_id, sizeof(keyId), \"%d%s\", start, \"_itemId\");\n                rt = app_control_get_extra_data(reply, key_id, &amp;rt_itemId);\n\n                snprintf(key_id, sizeof(keyId), \"%d%s\", start, \"_itemGroupId);\");\n                rt = app_control_get_extra_data(reply, key_id, &amp;rt_itemGroupId);\n\n                snprintf(key_id, sizeof(keyId), \"%d%s\", start, \"_itemName\");\n                rt = app_control_get_extra_data(reply, keyId, &amp;rt_itemName);\n\n                snprintf(key_id, sizeof(keyId), \"%d%s\", start, \"_currencyUnit\");\n                rt = app_control_get_extra_data(reply, keyId, &amp;rt_currencyUnit);\n\n                snprintf(key_id, sizeof(keyId), \"%d%s\", start, \"_unitPrecedes\");\n                rt = app_control_get_extra_data(reply, keyId, &amp;rt_unitPrecedes);\n\n                snprintf(key_id, sizeof(keyId), \"%d%s\", start, \"_hasPenny\");\n                rt = app_control_get_extra_data(reply, keyId, &amp;rt_hasPenny);\n\n                snprintf(key_id, sizeof(keyId), \"%d%s\", start, \"_itemPrice\");\n                rt = app_control_get_extra_data(reply, keyId, &amp;rt_itemPrice);\n\n                snprintf(key_id, sizeof(keyId), \"%d%s\", start, \"_itemDownloadUrl\");\n                rt = app_control_get_extra_data(reply, keyId, &amp;rt_itemDownloadUrl);\n\n                snprintf(key_id, sizeof(keyId), \"%d%s\", start, \"_itemImageUrl\");\n                rt = app_control_get_extra_data(reply, keyId, &amp;rt_itemImageUrl);\n\n                snprintf(key_id, sizeof(keyId), \"%d%s\", start, \"_itemDescription\");\n                rt = app_control_get_extra_data(reply, keyId, &amp;rt_itemDescription);\n\n                snprintf(key_id, sizeof(keyId), \"%d%s\", start, \"_reserved1\");\n                rt = app_control_get_extra_data(reply, keyId, &amp;rt_reserved1);\n\n                snprintf(key_id, sizeof(keyId), \"%d%s\", start, \"_reserved2\");\n                rt = app_control_get_extra_data(reply, keyId, &amp;rt_reserved2);\n\n                snprintf(key_id, sizeof(keyId), \"%d%s\", start, \"_itemTypeCd\");\n                rt = app_control_get_extra_data(reply, keyId, &amp;rt_itemTypeCd);\n\n                snprintf(key_id, sizeof(keyId), \"%d%s\", start, \"_itemSubsBillDurationCd\");\n                rt = app_control_get_extra_data(reply, keyId, &amp;rt_itemSubsBillDurationCd);\n\n                snprintf(key_id, sizeof(keyId), \"%d%s\", start, \"_subscriptionDurationMultiplier\");\n                rt = app_control_get_extra_data(reply, keyId, &amp;rt_subscriptionDurationMultiplier);\n\n                snprintf(key_id, sizeof(keyId), \"%d%s\", start, \"_timeStamp\");\n                rt = app_control_get_extra_data(reply, keyId, &amp;rt_timeStamp);\n            }\n        }\n    }\n}\n    \n  \n  \n    GetPurchasedItemList operation\n\n    This operation returns a list of already purchased items.\n  \n  \n    Input data\n\n    The following table shows the key and value pairs required in the input extra data for the http://tizen.org/appcontrol/operation/iapv2/get_purchased_item_list operation.\n\n    Table: Input data for getting a list of purchased items\n\n    \n      \n          \n              Key\n              Value\n              Description\n          \n      \n      \n          \n              _mode\n              0 or 1\n              \n              Mode type:\n              \n                  \n                  0: Normal (commercial) mode\n                  This mode needs to be used in an application submitted to the Tizen Store.\n                  \n                  \n                  1: Developer mode\n                  This mode can be used for testing purposes while developing the application. Payment always succeeds.\n                  \n              \n              The default value is 0.\n              This information is optional.\n              \n          \n          \n              _transactionId\n              Transaction ID\n              \n              Transaction ID, such as 1 or 2.\n              The ID is used to track a transaction between requests.\n              This information is mandatory.\n              \n          \n          \n              _startNumber\n              Start number\n              \n              Index of the first item in the list.\n              Start downloading items from this index number.\n              This information is mandatory.\n              \n          \n          \n              _endNumber\n              End number\n              \n              Index of the last item in the list.\n              Stop downloading items after this index number.\n              This information is mandatory.\n              \n          \n          \n              _startDate\n              Start date\n              \n              The start date of the requested inbox list, such as 20131031.\n              This information is optional.\n              \n          \n          \n              _endDate\n              End date\n              \n              The end date of the requested inbox list, such as 20131031.\n              This information is optional.\n              \n          \n          \n              _itemGroupId\n              Group ID\n              \n              Group ID, such as 100000002501.\n              A group ID is associated with a specific collection of items in Tizen Store Seller Office. You need to register your group ID in Tizen Store Seller Office first.\n              This information is mandatory.\n              \n          \n          \n              _languageCd\n              Language code\n              \n              Language code, such as eng or rus.\n              The language code conforms to ISO 639-2, which uses 3-character codes.\n              The language code is associated with the display language of the item details in Tizen Store Seller Office.\n              The output parameters (itemName, itemDescription, reserved1, reserved2) are changed according to the language code.\n              This information is optional.\n              \n          \n          \n              \n              _mcc\n              (deprecated)\n              \n              Mobile country code (MCC)\n              \n              Mobile country code, such as 250.\n              MMCs can only be used in developer mode. You can retrieve a list of available MCCs using the get country list operation.\n              This information is optional.\n              (18th Oct. by Tizen Store Dev. - deprecated parameter)\n              \n          \n          \n              \n              _mnc\n              (deprecated)\n              \n              Mobile network code (MNC)\n              \n              Mobile network code, such as 01.\n              MNCs can only be used in developer mode.\n              This information is optional.\n              (18th Oct. by Tizen Store Dev. - deprecated parameter)\n              \n          \n      \n  \n  \n  Example code for retrieving a list of purchased items\n    app_control_h app_control;\nint rt = app_control_create(&amp;app_control);\n\nif (rt == APP_CONTROL_ERROR_NONE) {\n    app_control_set_app_id(app_control, \" org.tizen.inapppurchase.iapservice\");\n    app_control_set_operation(app_control, \"http://tizen.org/appcontrol/operation/iapv2/get_purchased_item_list\");\n    app_control_add_extra_data(app_control, \"_mode\", \"0\");\n    app_control_add_extra_data(app_control, \"_transactionId\", \"123\");\n    app_control_add_extra_data(app_control, \"_startNumber\", \"1\");\n    app_control_add_extra_data(app_control, \"_endNumber\", \"10\");\n    app_control_add_extra_data(app_control, \"_startDate\", \"20140101\");\n    app_control_add_extra_data(app_control, \"_endDate\", \"20141231\");\n    app_control_add_extra_data(app_control, \"_itemGroupId\", \"100000000012\");\n    app_control_add_extra_data(app_control, \"_languageCd\", \"ENG\");\n\n    rt = app_control_send_launch_request(app_control, get_purchased_item_list_cb, NULL);\n}\n\nif (app_control != NULL)\n    app_control_destroy(app_control);\n    \n  \n  \n    Output Data\n\n    The results of the operation are returned in the app control callback.\n\n    The following table shows the output data for the http://tizen.org/appcontrol/operation/iapv2/get_purchased_item_list operation.\n\n    Table: Output data for getting a list of purchased items\n\n    \n      \n        \n          Key\n          Value\n          Description\n        \n      \n      \n        \n          _method\n          OnPurchasedItem or InformationListReceived\n          Method to be called as a purchase request result.\n        \n        \n          _result\n          Result code\n          Result codes are described at the end of this section.\n        \n        \n          _resultDescription\n          Result code/Function ID\n          Result code/Function ID when _result value is not 0 (success). Result codes are described at the end of this section.\n        \n        \n          _transactionId\n          Transaction ID\n          This is the same ID as the transaction ID that is used in the request.\n        \n        \n          _startNumber\n          Start number\n          Index of the first item in the list.\n        \n        \n          _endNumber\n          End number\n          Index of the last item in the list.\n        \n        \n          _totalCount\n          Total items count\n          Total number of items based on the start number and end number.\n        \n        \n          _itemTotalCount\n          Total purchased items count\n          Total number of purchased items in the group ID.\n        \n      \n    \n\n    There is also a _totalCount number of items in the output data. Each key consists of a PREFIX (list item index value) and a key (such as 12_itemId).\n\n    Table: Item keys in the output data\n    \n      \n          \n              Key\n              Value\n              Description\n          \n      \n      \n          \n              PREFIX_itemId\n              Item ID\n              This is the same number as an Item ID that is used in the request.\n          \n          \n              PREFIX_itemGroupId\n              Item group ID\n              ID of a collection of items. The collection is linked to your application in Tizen Store Seller Office.\n          \n          \n              PREFIX_itemName\n              Item name\n              Name provided during item registration in Tizen Store Seller Office.\n          \n          \n              PREFIX_currencyUnit\n              Currency unit\n              Device user's currency unit, such as $, Won, or Pound.\n          \n          \n              PREFIX_unitPrecedes\n              0 or 1\n              Currency unit position:\n              \n                  0: Tail (2.99 TL)\n                  1: Front ($ 2.99)\n              \n              \n          \n          \n              PREFIX_hasPenny\n              0 or 1\n              Information whether the currency unit has penny representation:\n              \n                  0: No\n                  1: Yes\n              \n              \n          \n          \n              PREFIX_itemPrice\n              Item price\n              Price of the item in the local currency.\n          \n          \n              PREFIX_itemDownloadUrl\n              Item download URL\n              URL provided during item registration in Tizen Store Seller Office.\n          \n          \n              PREFIX_itemImageUrl\n              Item image URL\n              URL provided during item registration in Tizen Store Seller Office.\n          \n          \n              PREFIX_itemDescription\n              Item description\n              A description provided during item registration.\n          \n          \n              PREFIX_reserved1\n              Reserved field 1\n              Reserved field 1\n          \n          \n              PREFIX_reserved2\n              Reserved field 2\n              Reserved field 2\n          \n          \n              PREFIX_paymentId\n              Payment ID\n              Payment ID\n          \n          \n              PREFIX_purchaseDate\n              Date of purchase\n              Date of purchase\n          \n          \n              PREFIX_itemTypeCd\n              00, 01, or 02\n              Item type code:\n              \n                  00: Non-consumable\n                  01: Consumable\n                  02: Subscription (non-renewing)\n              \n              \n          \n          \n              PREFIX_itemSubsBillDurationCd\n              00, 01, 02, or 03\n              Item subs bill duration code:\n              \n                  00: Year\n                  01: Month\n                  02: Week\n                  03: Day\n              \n              The _itemTypeCd value is 02.\n              If the product type is subscription, the available 4 units for the validity period of the product are YEAR, MONTH, WEEK, and DAY. The units must be typed in capitals.\n              \n          \n          \n              PREFIX_subscriptionDurationMultiplier\n              Subscription duration multiplier\n              If the _itemTypeCd is subscription (02), this is the item duration. Combined with PREFIX_itemSubsBillDurationCd, it means 1 month.\n          \n          \n              PREFIX_timeStamp\n              Time stamp\n              Based on GMT +0, server time.\n              (yyyyMMddHHmmss)\n              \n          \n      \n  \n  \n  \n    Example code for retrieving a list of purchased items\n\n    void\nget_purchased_item_list_cb(app_control_h request, app_control_h reply, app_control_result_e result, void *user_data)\n{\n    char* rt_method = NULL;\n    char* rt_result = NULL;\n    char* rt_resultDescription = NULL;\n    char* rt_transactionId = NULL;\n    char* rt_startNumber = NULL;\n    char* rt_endNumber = NULL;\n    char* rt_totalCount = NULL;\n    char* rt_itemTotalCount = NULL;\n    char* rt_itemId = NULL;\n    char* rt_itemGroupId = NULL;\n    char* rt_itemName = NULL;\n    char* rt_currencyUnit = NULL;\n    char* rt_unitPrecedes = NULL;\n    char* rt_hasPenny = NULL;\n    char* rt_itemPrice = NULL;\n    char* rt_itemDownloadUrl = NULL;\n    char* rt_itemImageUrl = NULL;\n    char* rt_itemDescription = NULL;\n    char* rt_reserved1 = NULL;\n    char* rt_reserved2 = NULL;\n    char* rt_paymentId = NULL;\n    char* rt_purchaseDate = NULL;\n    char* rt_itemTypeCd = NULL;\n    char* rt_itemSubsBillDurationCd = NULL;\n    char* rt_subscriptionDurationMultiplier = NULL;\n    char* rt_timeStamp = NULL;\n\n    if (result == APP_CONTROL_RESULT_SUCCEEDED) {\n        rt = app_control_get_extra_data(reply, \"_method\", &amp;rt_method);\n        rt = app_control_get_extra_data(reply, \"_result\", &amp;rt_result);\n\n        /* Success */\n        if (!strcmp(\"0\", rt_result)) {\n            rt = app_control_get_extra_data(reply, \"_resultDescription\", &amp;rt_resultDescription);\n            rt = app_control_get_extra_data(reply, \"_transactionId\", &amp;rt_transactionId);\n            rt = app_control_get_extra_data(reply, \"_startNumber\", &amp;rt_startNumber);\n            rt = app_control_get_extra_data(reply, \"_endNumber\", &amp;rt_endNumber);\n            rt = app_control_get_extra_data(reply, \"_totalCount\", &amp;rt_totalCount);\n            rt = app_control_get_extra_data(reply, \"_itemTotalCount\", &amp;rt_itemTotalCount);\n\n            int start = atoi(rt_startNumber);\n            int end = atoi(rt_endNumber);\n\n            char keyId[100] = {0,};\n            for (; start &lt;= end; start++) {\n                snprintf(key_id, sizeof(keyId), \"%d%s\", start, \"_itemId\");\n                rt = app_control_get_extra_data(reply, key_id, &amp;rt_itemId);\n\n                snprintf(key_id, sizeof(keyId), \"%d%s\", start, \"_itemGroupId);\");\n                rt = app_control_get_extra_data(reply, key_id, &amp;rt_itemGroupId);\n\n                snprintf(key_id, sizeof(keyId), \"%d%s\", start, \"_itemName\");\n                rt = app_control_get_extra_data(reply, keyId, &amp;rt_itemName);\n\n                snprintf(key_id, sizeof(keyId), \"%d%s\", start, \"_currencyUnit\");\n                rt = app_control_get_extra_data(reply, keyId, &amp;rt_currencyUnit);\n\n                snprintf(key_id, sizeof(keyId), \"%d%s\", start, \"_unitPrecedes\");\n                rt = app_control_get_extra_data(reply, keyId, &amp;rt_unitPrecedes);\n\n                snprintf(key_id, sizeof(keyId), \"%d%s\", start, \"_hasPenny\");\n                rt = app_control_get_extra_data(reply, keyId, &amp;rt_hasPenny);\n\n                snprintf(key_id, sizeof(keyId), \"%d%s\", start, \"_itemPrice\");\n                rt = app_control_get_extra_data(reply, keyId, &amp;rt_itemPrice);\n\n                snprintf(key_id, sizeof(keyId), \"%d%s\", start, \"_itemDownloadUrl\");\n                rt = app_control_get_extra_data(reply, keyId, &amp;rt_itemDownloadUrl);\n\n                snprintf(key_id, sizeof(keyId), \"%d%s\", start, \"_itemImageUrl\");\n                rt = app_control_get_extra_data(reply, keyId, &amp;rt_itemImageUrl);\n\n                snprintf(key_id, sizeof(keyId), \"%d%s\", start, \"_itemDescription\");\n                rt = app_control_get_extra_data(reply, keyId, &amp;rt_itemDescription);\n\n                snprintf(key_id, sizeof(keyId), \"%d%s\", start, \"_reserved1\");\n                rt = app_control_get_extra_data(reply, keyId, &amp;rt_reserved1);\n\n                snprintf(key_id, sizeof(keyId), \"%d%s\", start, \"_reserved2\");\n                rt = app_control_get_extra_data(reply, keyId, &amp;rt_reserved2);\n\n                snprintf(key_id, sizeof(keyId), \"%d%s\", start, \"_paymentId\");\n                rt = app_control_get_extra_data(reply, keyId, &amp;rt_paymentId);\n\n                snprintf(key_id, sizeof(keyId), \"%d%s\", start, \"_purchaseDate\");\n                rt = app_control_get_extra_data(reply, keyId, &amp;rt_purchaseDate);\n\n                snprintf(key_id, sizeof(keyId), \"%d%s\", start, \"_itemTypeCd\");\n                rt = app_control_get_extra_data(reply, keyId, &amp;rt_itemTypeCd);\n\n                snprintf(key_id, sizeof(keyId), \"%d%s\", start, \"_itemSubsBillDurationCd\");\n                rt = app_control_get_extra_data(reply, keyId, &amp;rt_itemSubsBillDurationCd);\n\n                snprintf(key_id, sizeof(keyId), \"%d%s\", start, \"_subscriptionDurationMultiplier\");\n                rt = app_control_get_extra_data(reply, keyId, &amp;rt_subscriptionDurationMultiplier);\n\n                snprintf(key_id, sizeof(keyId), \"%d%s\", start, \"_timeStamp\");\n                rt = app_control_get_extra_data(reply, keyId, &amp;rt_timeStamp);\n            }\n        }\n    }\n}\n    \n  \n  \n    GetCountryList operation\n\n    This operation returns a list of countries available for testing in-application purchase.\n  \n  \n    Input data\n\n    The following table show the key and value pairs required in the input extra data for the http://tizen.org/appcontrol/operation/iapv2/get_country_list operation.\n\n    Table: Input data for getting a list of countries\n\n    \n      \n        \n          Key\n          Value\n          Description\n        \n      \n      \n        \n          _transactionId\n          Transaction ID\n          Transaction ID, such as 1 or 2.This information is mandatory.The ID is used to track a transaction between requests.\n        \n      \n    \n  \n  \n    Example code for get country list\n\n     app_control_h app_control;\n int rt = app_control_create(&amp;app_control);\n   \n if (rt == APP_CONTROL_ERROR_NONE) {\n     app_control_set_app_id(app_control, \" org.tizen.inapppurchase.iapservice\");\n     app_control_set_operation(app_control, \"http://tizen.org/appcontrol/operation/iapv2/get_country_list\");\n     app_control_add_extra_data(app_control, \"_mode\", \"0\");\n     app_control_add_extra_data(app_control, \"_transactionId\", \"123\");\n   \n     rt = app_control_send_launch_request(app_control, get_country_list_cb, NULL);\n }\n   \n if (app_control != NULL)\n     app_control_destroy(app_control);\n    \n  \n  \n    Output Data\n\n    The results of the operation are returned in the app control callback.\n\n    The following table shows the output data for the http://tizen.org/appcontrol/operation/iapv2/get_country_list operation.\n\n    Table: Output data for getting a list of countries\n\n    \n      \n        \n          Key\n          Value\n          Description\n        \n      \n      \n        \n          _method\n          OnCountryListReceived\n          Method to be called as a purchase request result.\n        \n        \n          _result\n          Result code\n          Result codes are described at the end of this section.\n        \n        \n          _resultDescription\n          Result code/Function ID\n          Result code/Function ID when _result value is not 0 (success). Result codes are described at the end of this section.\n        \n        \n          _transactionId\n          Transaction ID\n          This is the same ID as the transaction ID that is used in the request.\n        \n        \n          _startNumber\n          Start number\n          Index of the first item on the list.\n        \n        \n          _endNumber\n          End number\n          Index of the last item on the list.\n        \n        \n          _totalCount\n          Total items count\n          Total number of items based on the start number and end number.\n        \n      \n    \n\n    There is also a _totalCount number of countries in the output data. Each key consists of a PREFIX (list item index value) and a key (such as 1_countryName).\n\n    Table: Country keys in the output data\n\n    \n      \n        \n          Key\n          Value\n          Description\n        \n      \n      \n        \n          PREFIX_countryName\n          Country name\n          Name of a country.\n        \n        \n          PREFIX_mcc\n          MCC (mobile country code)\n          MCC (mobile country code) as a string value.\n        \n      \n    \n  \n  \n    Example code for retrieving a list of get country list\n\n    void\nget_country_list_cb(app_control_h request, app_control_h reply, app_control_result_e result, void *user_data)\n{\n    char* rt_method = NULL;\n    char* rt_result = NULL;\n    char* rt_resultDescription = NULL;\n    char* rt_transactionId = NULL;\n    char* rt_startNumber = NULL;\n    char* rt_endNumber = NULL;\n    char* rt_totalCount = NULL;\n    char* rt_countryName = NULL;\n    char* rt_mcc = NULL;\n  \n    if (result == APP_CONTROL_RESULT_SUCCEEDED) {\n        rt = app_control_get_extra_data(reply, \"_method\", &amp;rt_method);\n        rt = app_control_get_extra_data(reply, \"_result\", &amp;rt_result);\n\n        /* Success */\n        if (!strcmp(\"0\", rt_result)) {\n            rt = app_control_get_extra_data(reply, \"_resultDescription\", &amp;rt_resultDescription);\n            rt = app_control_get_extra_data(reply, \"_transactionId\", &amp;rt_transactionId);\n            rt = app_control_get_extra_data(reply, \"_startNumber\", &amp;rt_startNumber);\n            rt = app_control_get_extra_data(reply, \"_endNumber\", &amp;rt_endNumber);\n            rt = app_control_get_extra_data(reply, \"_totalCount\", &amp;rt_totalCount);\n  \n            int start = atoi(rt_startNumber);\n            int end = atoi(rt_endNumber);\n  \n            char keyId[100] = {0,};\n            for (; start &lt;= end; start++) {\n                snprintf(key_id, sizeof(keyId), \"%d%s\", start, \"_countryName\");\n                rt = app_control_get_extra_data(reply, key_id, &amp;rt_countryName);\n  \n                snprintf(key_id, sizeof(keyId), \"%d%s\", start, \"_mcc\");\n                rt = app_control_get_extra_data(reply, key_id, &amp;rt_mcc);\n            }\n        }\n    }\n}\n    \n  \n\n\n\n\n  \n    Result code values\n\n    The following table lists the possible values of the _result key for the org.tizen.inapppurchase.iapservice application ID.\n\n    Table: Result code values\n\n    \n      \n        \n          Value\n          String Representation\n          Description\n        \n      \n      \n        \n          0\n          Succeed\n          The status code for success.\n        \n        \n          200\n          NetworkError\n          The status code for network errors.\n        \n        \n          1000\n          ProcessError\n          The status code for process errors.\n        \n        \n          2001\n          NoApplicationStore\n          The status code if application store not present for the country.\n        \n        \n          9201\n          ItemGroupIdNotFound\n          The status code if the item group ID is not found.\n        \n        \n          9207\n          ItemIdNotFound\n          The status code if the item ID is not found.\n        \n        \n          9502\n          InvalidRequestParameter\n          The status code if the wrong request parameter is passed.\n        \n      \n    \n  \n\n\n3.3. IAP Client Control (Purchase of Item)\n\nThe IAP Client instance allows you to initialize a purchase of item and to complete the purchase.\n\n\n  \n    Application ID\n\n    This application control can be accessed using aliased application ID of org.tizen.inapppurchase.iapclient.\n  \n  \n    Operation ID\n\n    This application supports the http://tizen.org/appcontrol/operation/iapv2/purchase operation only.\n  \n  \n    Purchase operation\n\n    This operation launches the purchase application and allows purchasing of In-App items. The input data passed in this operation are used to display a purchase form for particular item. The device user can choose between available payment methods, register his credit card, and confirm the purchase.\n  \n  \n    Input data\n\n    The following table shows the key and value pairs required in the input extra data for the http://tizen.org/appcontrol/operation/iapv2/purchase operation.\n\n    Table: Input data for launching the purchase application\n    \n      \n          \n              Key\n              Value\n              Description\n          \n      \n      \n          \n              _mode\n              0 or 1\n              \n              Mode type:\n              \n                  \n                  0: Normal (commercial) mode\n                  This mode needs to be used in an application submitted to the Tizen Store.\n                  \n                  \n                  1: Developer mode\n                  This mode can be used for testing purposes while developing the application. Payment always succeeds.\n                  \n              \n              The default value is 0.\n              This information is optional.\n              \n          \n          \n              _transactionId\n              Transaction ID\n              \n              Transaction ID, such as 1 or 2.\n              The ID is used to track a transaction between requests.\n              This information is mandatory.\n              \n          \n          \n              _itemId\n              Item ID\n              \n              Item ID, such as 000000003501.\n              An item ID is associated with a specific item in Tizen Store Seller Office.\n              You can retrieve a list of items available for purchase using the org.tizen.inapppurchase.iapservice application ID.\n              This information is mandatory.\n              \n          \n          \n              _itemGroupId\n              Group ID\n              \n              Group ID, such as 100000001455.\n              A group ID is associated with a specific collection of items in Tizen Store Seller Office. You need to register your group ID in Tizen Store Seller Office first.\n              This information is mandatory.\n              \n          \n          \n              _languageCd\n              Language code\n              \n              Language code, such as eng or rus.\n              The language code conforms to ISO 639-2, which uses 3-character codes.\n              The language code is associated with the display language of the item details in Tizen Store Seller Office.\n              This information is optional.\n              Note_itemName is higher priority than _languageCd.\n              \n          \n          \n              _itemName\n              Item name\n              \n              Item name, such as \"Sword\" or \"칼\".\n              Specify your item name with this key, or leave the key empty to use the default name on the seller site's purchase page.\n              This information is optional.\n              \n          \n          \n              \n              _mcc\n              (deprecated)\n              \n              Mobile country code (MCC)\n              \n              Mobile country code, such as 250.\n              MMCs can only be used in developer mode. You can retrieve a list of available MCCs using the get country list operation.\n              This information is optional.\n              (18th Oct. by Tizen Store Dev. - deprecated parameter)\n              \n          \n          \n              \n              _mnc\n              (deprecated)\n              \n              Mobile network code (MNC)\n              \n              Mobile network code, such as 01.\n              MNCs can only be used in developer mode.\n              This information is optional.\n              (18th Oct. by Tizen Store Dev. - deprecated parameter)\n              \n          \n      \n  \n  \n  \n    Example code for Purchase\n\n    app_control_h app_control;\nint rt = app_control_create(&amp;app_control);\n  \nif (rt == APP_CONTROL_ERROR_NONE) {\n    app_control_set_app_id(app_control, \" org.tizen.inapppurchase.iapclient\");\n    app_control_set_operation(app_control, \"http://tizen.org/appcontrol/operation/iapv2/purchase\");\n    app_control_add_extra_data(app_control, \"_mode\", \"0\");\n    app_control_add_extra_data(app_control, \"_itemId\", \"000000000001\");\n    app_control_add_extra_data(app_control, \"_itemGroupId\", \"100000000012\");\n    app_control_add_extra_data(app_control, \"_languageCd\", \"ENG\"); /* Optional */\n    app_control_add_extra_data(app_control, \"_itemName\", \"Item 1\"); /* Optional */\n  \n    rt = app_control_send_launch_request(app_control, get_purchase_cb, NULL);\n}\n  \nif (app_control != NULL)\n    app_control_destroy(app_control);\n    \n  \n  \n    Output Data\n\n    The results of the operation are returned in the app control callback.\n\n    This data can be used to verify the payment with Tizen Store IAP Server.\n\n    The following table shows the output data for the http://tizen.org/appcontrol/operation/iapv2/purchase operation during process of purchase.\n\n    Table: Output data for launching the purchase application\n\n    \n      \n          \n              Key\n              Value\n              Description\n          \n      \n      \n          \n              _method\n              OnPurchaseItemReceived\n              Method to be called as a purchase request result.\n          \n          \n              _result\n              Result code\n              Result codes are described at the end of this section.\n          \n          \n              _resultDescription\n              Result code/Function ID or HTML tags\n              Display the _resultDescription value as a pop-up using Web-Control when you receive a _result value of 5600.\n                  Result codes are described at the end of this section.\n              \n          \n          \n              _itemId\n              Item ID\n              This is the same number as an item ID that is used in the request.\n          \n          \n              _itemGroupId\n              Item group ID\n              ID of a collection of items. The collection is linked to your application in Tizen Store Seller Office.\n          \n          \n              _itemName\n              Item name\n              Name provided during item registration in Tizen Store Seller Office.\n          \n          \n              _ticketPurchaseId\n              Purchased ticket ID\n              This ID can be used to verify the purchase with Tizen Store IAP Server.\n          \n          \n              _currencyUnit\n              Currency unit\n              Device user's currency unit, such as $, Won, or Pound.\n          \n          \n              _unitPrecedes\n              0 or 1\n              Currency unit position:\n                  \n                      0: Tail (2.99 TL)\n                      1: Front ($ 2.99)\n                  \n              \n          \n          \n              _hasPenny\n              0 or 1\n              Information whether the currency unit has penny representation:\n                  \n                      0: No\n                      1: Yes\n                  \n              \n          \n          \n              _itemPrice\n              Item price\n              Price of the item in the local currency.\n          \n          \n              _itemDownloadUrl\n              Item download URL\n              URL provided during item registration in Tizen Store Seller Office.\n          \n          \n              _itemImageUrl\n              Item image URL\n              URL provided during item registration in Tizen Store Seller Office.\n          \n          \n              _itemDescription\n              Item description\n              A description provided during item registration.\n          \n          \n              _reserved1\n              Reserved field 1\n              Reserved field 1\n          \n          \n              _reserved2\n              Reserved field 2\n              Reserved field 2\n          \n          \n              _paymentId\n              Payment ID\n              Payment ID\n          \n          \n              _ticketVerifyUrl\n              Server URL\n              Server URL, such as http://tizen.org/appcontrol/operation/iap/purchase.\n                  This URL can be used in combination with other parameters to verify the purchase with Tizen Store IAP Server.\n              \n          \n          \n              _ticketPurchaseId\n              Purchased ticket ID\n              This ID can be used to verify the purchase with Tizen Store IAP Server.\n          \n          \n              _ticketParam1\n              Ticket parameter 1\n              This parameter is used with the server URL.\n          \n          \n              _ticketParam2\n              Ticket parameter 2\n              This parameter is used with the server URL.\n          \n          \n              _ticketParam3\n              Ticket parameter 3\n              This parameter is used with the server URL.\n          \n          \n              _ticketParam4\n              Ticket parameter 4\n              This parameter is used with the server URL.\n          \n          \n              _ticketParam5\n              Ticket parameter 5\n              This parameter is used with the server URL.\n          \n          \n              _purchaseDate\n              Date of purchase\n              Date of purchase\n          \n          \n              _timeStamp\n              Time stamp\n              Based on GMT +0, server time.\n              (yyyyMMddHHmmss)\n              \n          \n      \n  \n  \n  \n    Example code for Purchase result\n    void\nget_purchase_cb(app_control_h request, app_control_h reply, app_control_result_e result, void *user_data)\n{\n    char* rt_method = NULL;\n    char* rt_result = NULL;\n    char* rt_resultDescription = NULL;\n    char* rt_transactionId = NULL;\n    char* rt_itemId = NULL;\n    char* rt_itemGroupId = NULL;\n    char* rt_itemName = NULL;\n    char* rt_currencyUnit = NULL;\n    char* rt_unitPrecedes = NULL;\n    char* rt_hasPenny = NULL;\n    char* rt_itemPrice = NULL;\n    char* rt_itemDownloadUrl = NULL;\n    char* rt_itemImageUrl = NULL;\n    char* rt_itemDescription = NULL;\n    char* rt_reserved1 = NULL;\n    char* rt_reserved2 = NULL;\n    char* rt_paymentId = NULL;\n    char* rt_ticketVerifyUrl = NULL;\n    char* rt_ticketPurchaseId = NULL;\n    char* rt_ticketParam1 = NULL;\n    char* rt_ticketParam2 = NULL;\n    char* rt_ticketParam3 = NULL;\n    char* rt_ticketParam4 = NULL;\n    char* rt_ticketParam5 = NULL;\n    char* rt_purchaseDate = NULL;\n    char* rt_itemTypeCd = NULL;\n    char* rt_itemSubsBillDurationCd = NULL;\n    char* rt_subscriptionDurationMultiplier = NULL;\n    char* rt_timeStamp = NULL;\n\n    if (result == APP_CONTROL_RESULT_SUCCEEDED) {\n        rt = app_control_get_extra_data(reply, \"_method\", &amp;rt_method);\n        rt = app_control_get_extra_data(reply, \"_result\", &amp;rt_result);\n\n        /* Success */\n        if (!strcmp(\"0\", rt_result)) {\n            rt = app_control_get_extra_data(reply, \"_resultDescription\", &amp;rt_resultDescription);\n            rt = app_control_get_extra_data(reply, \"_transactionId\", &amp;rt_transactionId);\n            rt = app_control_get_extra_data(reply, \"_itemId\", &amp;rt_itemId);\n            rt = app_control_get_extra_data(reply, \"_itemGroupId\", &amp;rt_itemGroupId);\n            rt = app_control_get_extra_data(reply, \"_itemName\", &amp;rt_itemName);\n            rt = app_control_get_extra_data(reply, \"_currencyUnit\", &amp;rt_currencyUnit);\n            rt = app_control_get_extra_data(reply, \"_unitPrecedes\", &amp;rt_unitPrecedes);\n            rt = app_control_get_extra_data(reply, \"_itemPrice\", &amp;rt_itemPrice);\n            rt = app_control_get_extra_data(reply, \"_itemDownloadUrl\", &amp;rt_itemDownloadUrl);\n            rt = app_control_get_extra_data(reply, \"_itemImageUrl\", &amp;rt_itemImageUrl);\n            rt = app_control_get_extra_data(reply, \"_itemDescription\", &amp;rt_itemDescription);\n            rt = app_control_get_extra_data(reply, \"_reserved1\", &amp;amp;rt_reserved1);\n            rt = app_control_get_extra_data(reply, \"_reserved2\", &amp;rt_reserved2);\n            rt = app_control_get_extra_data(reply, \"_paymentId\", &amp;rt_paymentId);\n            rt = app_control_get_extra_data(reply, \"_ticketVerifyUrl\", &amp;rt_ticketVerifyUrl);\n            rt = app_control_get_extra_data(reply, \"_ticketPurchaseId\", &amp;rt_ticketPurchaseId);\n            rt = app_control_get_extra_data(reply, \"_ticketParam1\", &amp;rt_ticketParam1);\n            rt = app_control_get_extra_data(reply, \"_ticketParam2\", &amp;rt_ticketParam2);\n            rt = app_control_get_extra_data(reply, \"_ticketParam3\", &amp;rt_ticketParam3);\n            rt = app_control_get_extra_data(reply, \"_ticketParam4\", &amp;rt_ticketParam4);\n            rt = app_control_get_extra_data(reply, \"_ticketParam5\", &amp;rt_ticketParam5);\n            rt = app_control_get_extra_data(reply, \"_purchaseDate\", &amp;rt_purchaseDate);\n            rt = app_control_get_extra_data(reply, \"_itemTypeCd\", &amp;rt_itemTypeCd);\n            rt = app_control_get_extra_data(reply, \"_itemSubsBillDurationCd\", &amp;rt_itemSubsBillDurationCd);\n            rt = app_control_get_extra_data(reply, \"_subscriptionDurationMultiplier\", &amp;rt_subscriptionDurationMultiplier);\n            rt = app_control_get_extra_data(reply, \"_timeStamp\", &amp;rt_timeStamp);\n        }\n    }\n}\n    \n  \n\n\n\n\n  \n    Result code values\n\n    The following table lists the possible values of the _result key for the org.tizen.inapppurchase.iapclient application ID.\n\n    Table: Result code values\n\n    \n      \n        \n          Value\n          String Representation\n          Description\n        \n      \n      \n        \n          0\n          Succeed\n          The status code for success.\n        \n        \n          100\n          Cancel\n          The status code if the user cancels.\n        \n        \n          200\n          NetworkError\n          The status code for network errors.\n        \n        \n          1000\n          ProcessError\n          The status code for process errors.\n        \n        \n          5600\n          PGError\n          The status code for the payment gateway error. Display the pop-up by using web-control.\n        \n        \n          9201\n          ItemGroupIdNotFound\n          The status code if the item group ID is not found.\n        \n        \n          9207\n          ItemIdNotFound\n          The status code if the item ID is not found.\n        \n        \n          9502\n          InvalidRequestParameter\n          The status code if the request parameter is invalid.\n        \n        \n          9291\n          RepurchaseError\n          The status code for the repurchase error. This error occurs only on consumable items.\n        \n        \n          9292\n          Update is progressing\n          The status code if the application is updating.\n        \n        \n          9293\n          Account validation is not Completed\n          The status code if the Samsung account validation is not completed.\n        \n      \n    \n  \n\n\n4. Verifying with Tizen Store IAP Server\n\nAfter the purchase operation, http://tizen.org/appcontrol/operation/iapv2/purchase, you can use the values in the output data to verify a purchase on the Tizen Store IAP Server in a simple process. You can send a query to the output data’s _ticketVerifyUrl address. The query can be made with a combination of the output data’s _ticketPurchaseId, _ticketParam1, _ticketParam2, ticketParam3, _ticketParam4, and _ticketParam5 parameters.\n\nThe following example shows the syntax. In the above syntax, (_parameterName) indicates the value of the parameter.\n\n(_ticketVerifyUrl)?purchaseID=(_ticketPurchaseId)&amp;param1=(_ticketParam1)&amp;param2=(_ticketParam2)&amp;param3=(_ticketParam3)&amp;param4=(_ticketParam4)&amp;param5=(_ticketParam5)\n\n\nThe following code shows an example request:\n\nhttp://iap.tizenstore.com/appsItemVerifyIAPReceipt.as?purchaseID=2bf8fe4fdef1dae29974e5400c106bfced6a650793efa3ce68a79e026481193d&amp;param1=abe87f635bf41aae0178b5384cbc09c1083026e93e44bd0efd69e66a9cc2ace6&amp;param2=d49e3385783366868999e17bae3410597c0b6bcf69a92cd74cab17454cf9d4d6&amp;param3=af8050beb9c0f63c773fb86f7218bb6cbd6cf78a5cdff281c2e22a229f9a1485&amp;param4=1&amp;param5=I20131115RU00001243\n\n\nIf a request is processed successfully, the JSON response is received as shown. The status value of true means a verifying the purchase is successful and false when it has failed.\n\nIf your application uses a server-client model, the following server-to-server purchase verification is recommended.\n\nThe JSON example of successful result:\n\n{\n    \"paymentID\":\"TPMTID20131115RU00001243\",\n    \"paymentAmount\":\"105.02\",\n    \"itemName\":\"ttttttt\",\"itemID\":\"000000000072\",\n    \"status\":\"true\",\n    \"purchaseDate\":\"2013-11-15 10:31:23\",\n    \"itemDesc\":\"dkfldfldkfl\",\n    \"paymentMethod\":\"Tizen RBS Russia CreditCard\",\n    \"mode\":\"1\"\n}\n\n\nThe following code shows a JSON example of a failed result:\n\n{\"status\":\"false\"}\n\n\nAppendixes\n\n1. Sample Native Application\n\nThe sample native application allows a user to show a list of items for purchase, purchase an item, show purchased items, and make a purchase.\n\nIn developer mode, the top of the screen, it is possible to scroll up and down direction.\n\nDownload the sample native application.\n\n2. Sample Web Application\n\nThe sample Web application allows a user to show a list of items for purchase, purchase an item, show purchased items, and make a purchase.\n\nDownload the sample Web application."
					}
					
				
			
		
			
				
					,
					
					"application-about": {
						"id": "application-about",
						"title": "About",
						"categories": "",
						"url": " application/about/",
						"content": "About Page"
					}
					
				
			
		
			
				
					,
					
					"application": {
						"id": "application",
						"title": "Application",
						"categories": "",
						"url": " application/",
						"content": "Tizen Open Source Project\n\nTizen is an open source software stack created for a wide array of devices with different form factors. The primary objectives of Tizen are to create an open software platform available for carriers, OEMs, and developers to make their innovative ideas a reality, and to introduce a successful, real-world product that improves the mobile experience for users. We have also wanted to make sure there is no central point of failure, where 1 industry player can restrict or control the innovations of another. The result is a full, production-quality consumer product with source code open for customization and porting.\n\nThe Tizen operating system is available in multiple profiles to serve different industry requirements. The current Tizen profiles are Tizen IVI (in-vehicle infotainment), Tizen Mobile, Tizen TV, and Tizen Wearable. Additionally, as of Tizen 3.0, all profiles are built on top of a common, shared infrastructure called Tizen Common.\n\nWith Tizen:\n\n\n  Device manufacturers can begin with 1 of the profiles and modify it to serve their own needs, or use the Tizen Common base to develop a new profile to meet the memory, processing, and power requirements of any device and quickly bring it to market.\n  Mobile operators can work with device partners to customize the operating system and user experience to meet the needs of specific customer segments or demographics.\n  Application developers and ISVs can take advantage of the power of native application development with the flexibility of unparalleled HTML5 support. Tizen also offers the potential for application developers to extend their reach to new “smart devices” running Tizen, including wearables, consumer electronics (such as TVs, gaming consoles, and DVRs), cars, and appliances.\n\n\nThe Tizen project is a part of the Linux Foundation and is governed by a Technical Steering Group, which is the primary decision-making body for the open source project, with a focus on platform development and delivery, along with the formation of working groups to support device verticals.\n\nThe Tizen Association has been formed to guide the industry role of Tizen, including gathering of requirements, identification and facilitation of service models, and overall industry marketing and education.\n\nGet Started with Tizen\n\nTo get started with Tizen development:\n\n\n  \n    Get access\n\n    You can register for an account at https://www.tizen.org/user/register.\n  \n  \n    Study the development workflow\n\n    Tizen developers use the Git and GBS command-line tools for most of their work. Tizen source code is managed by Gerrit, a code review system for Git-based projects. Source code cloning, development, and review are done under ACL (Access Control Lists). Make sure you have access rights to them.\n  \n\n\nStart by reading the Development Workflow page."
					}
					
				
			
		
			
				
					,
					
					"platform": {
						"id": "platform",
						"title": "Tizen Open Source Project",
						"categories": "",
						"url": " platform/",
						"content": "Platform Folder\nTizen Open Source Project\n\nTizen is an open source software stack created for a wide array of devices with different form factors. The primary objectives of Tizen are to create an open software platform available for carriers, OEMs, and developers to make their innovative ideas a reality, and to introduce a successful, real-world product that improves the mobile experience for users. We have also wanted to make sure there is no central point of failure, where 1 industry player can restrict or control the innovations of another. The result is a full, production-quality consumer product with source code open for customization and porting.\n\nThe Tizen operating system is available in multiple profiles to serve different industry requirements. The current Tizen profiles are Tizen IVI (in-vehicle infotainment), Tizen Mobile, Tizen TV, and Tizen Wearable. Additionally, as of Tizen 3.0, all profiles are built on top of a common, shared infrastructure called Tizen Common.\n\nWith Tizen:\n\n\n  Device manufacturers can begin with 1 of the profiles and modify it to serve their own needs, or use the Tizen Common base to develop a new profile to meet the memory, processing, and power requirements of any device and quickly bring it to market.\n  Mobile operators can work with device partners to customize the operating system and user experience to meet the needs of specific customer segments or demographics.\n  Application developers and ISVs can take advantage of the power of native application development with the flexibility of unparalleled HTML5 support. Tizen also offers the potential for application developers to extend their reach to new “smart devices” running Tizen, including wearables, consumer electronics (such as TVs, gaming consoles, and DVRs), cars, and appliances.\n\n\nThe Tizen project is a part of the Linux Foundation and is governed by a Technical Steering Group, which is the primary decision-making body for the open source project, with a focus on platform development and delivery, along with the formation of working groups to support device verticals.\n\nThe Tizen Association has been formed to guide the industry role of Tizen, including gathering of requirements, identification and facilitation of service models, and overall industry marketing and education.\n\nGet Started with Tizen\n\nTo get started with Tizen development:\n\n\n  \n    Get access\n\n    You can register for an account at https://www.tizen.org/user/register.\n  \n  \n    Study the development workflow\n\n    Tizen developers use the Git and GBS command-line tools for most of their work. Tizen source code is managed by Gerrit, a code review system for Git-based projects. Source code cloning, development, and review are done under ACL (Access Control Lists). Make sure you have access rights to them.\n  \n\n\nStart by reading the Development Workflow page."
					}
					
				
			
		
			
				
					,
					
					"design-introduction": {
						"id": "design-introduction",
						"title": "Tizen Design",
						"categories": "",
						"url": " design/introduction/",
						"content": "Introduction\n\nThe guidelines we provide will show you how to design useful and aesthetically pleasing Tizen apps that users will enjoy.\n\nLet’s begin by sharing our vision for Tizen app design and the visual language we use. These concepts will help you provide users with an enjoyable Tizen experience.\n \nVisions\n\nTizen is a platform built for the future. It was developed to foster openness, which is essential for creating a rich user experience on mobile devices and the devices they connect to. Tizen nourishes users’ curiosity, allows them to easily reach their goals, and lets them express their personality. Tizen is a platform designed to grow with users, enriching their daily life.\ndesign\\mobile\n\n\nMobile\n\nTizen design principles explained in this section of the document are provided to suggest clear guidelines for developers, to design simple and easy-to-use apps for everyone.\n\n\n  Design Principles\n\n\nTV\n\nThe Tizen 4.0 TV design principles provide a clear and comfortable\nvisual identity for your application. The harmonious and delightful\nelements help the user get information easily and enjoy content fully.\n\nThere are three design principles used in Tizen 4.0 TVs:\n\n\n  Simplicity\n  Natural intuitiveness\n  Breathing space\n\n\nWearable\n\nYou can see the Wearable design guidelines on SAMSUNG Developers site."
					}
					
				
			
		
			
				
					,
					
					"design": {
						"id": "design",
						"title": "Tizen Design",
						"categories": "",
						"url": " design/",
						"content": "Introduction\n\nThe guidelines we provide will show you how to design useful and aesthetically pleasing Tizen apps that users will enjoy.\n\nLet’s begin by sharing our vision for Tizen app design and the visual language we use. These concepts will help you provide users with an enjoyable Tizen experience.\n \nVisions\n\nTizen is a platform built for the future. It was developed to foster openness, which is essential for creating a rich user experience on mobile devices and the devices they connect to. Tizen nourishes users’ curiosity, allows them to easily reach their goals, and lets them express their personality. Tizen is a platform designed to grow with users, enriching their daily life.\ndesign\\mobile\n\n\nMobile\n\nTizen design principles explained in this section of the document are provided to suggest clear guidelines for developers, to design simple and easy-to-use apps for everyone.\n\n\n  Design Principles\n\n\nTV\n\nThe Tizen 4.0 TV design principles provide a clear and comfortable\nvisual identity for your application. The harmonious and delightful\nelements help the user get information easily and enjoy content fully.\n\nThere are three design principles used in Tizen 4.0 TVs:\n\n\n  Simplicity\n  Natural intuitiveness\n  Breathing space\n\n\nWearable\n\nYou can see the Wearable design guidelines on SAMSUNG Developers site."
					}
					
				
			
		
			
				
					,
					
					"iot": {
						"id": "iot",
						"title": "Tizen Open Source Project",
						"categories": "",
						"url": " iot/",
						"content": "Tizen Open Source Project\n\nTizen is an open source software stack created for a wide array of devices with different form factors. The primary objectives of Tizen are to create an open software platform available for carriers, OEMs, and developers to make their innovative ideas a reality, and to introduce a successful, real-world product that improves the mobile experience for users. We have also wanted to make sure there is no central point of failure, where 1 industry player can restrict or control the innovations of another. The result is a full, production-quality consumer product with source code open for customization and porting.\n\nThe Tizen operating system is available in multiple profiles to serve different industry requirements. The current Tizen profiles are Tizen IVI (in-vehicle infotainment), Tizen Mobile, Tizen TV, and Tizen Wearable. Additionally, as of Tizen 3.0, all profiles are built on top of a common, shared infrastructure called Tizen Common.\n\nWith Tizen:\n\n\n  Device manufacturers can begin with 1 of the profiles and modify it to serve their own needs, or use the Tizen Common base to develop a new profile to meet the memory, processing, and power requirements of any device and quickly bring it to market.\n  Mobile operators can work with device partners to customize the operating system and user experience to meet the needs of specific customer segments or demographics.\n  Application developers and ISVs can take advantage of the power of native application development with the flexibility of unparalleled HTML5 support. Tizen also offers the potential for application developers to extend their reach to new “smart devices” running Tizen, including wearables, consumer electronics (such as TVs, gaming consoles, and DVRs), cars, and appliances.\n\n\nThe Tizen project is a part of the Linux Foundation and is governed by a Technical Steering Group, which is the primary decision-making body for the open source project, with a focus on platform development and delivery, along with the formation of working groups to support device verticals.\n\nThe Tizen Association has been formed to guide the industry role of Tizen, including gathering of requirements, identification and facilitation of service models, and overall industry marketing and education.\n\nGet Started with Tizen\n\nTo get started with Tizen development:\n\n\n  \n    Get access\n\n    You can register for an account at https://www.tizen.org/user/register.\n  \n  \n    Study the development workflow\n\n    Tizen developers use the Git and GBS command-line tools for most of their work. Tizen source code is managed by Gerrit, a code review system for Git-based projects. Source code cloning, development, and review are done under ACL (Access Control Lists). Make sure you have access rights to them.\n  \n\n\nStart by reading the Development Workflow page."
					}
					
				
			
		
			
				
					,
					
					"tizenstudio-native-tools": {
						"id": "tizenstudio-native-tools",
						"title": "Native tools",
						"categories": "",
						"url": " tizenstudio/native-tools/",
						"content": "Native Tools\n\nThis page explains about various native application development tools supported in Tizen Studio. With Tizen Studio IDE, the native app development is simplified, as it supports app development using languages such as C and C++.\nIn addition, Tizen Studio provides enhanced tools for building the UI, debugging, and for compiling and building the native app code.\n\nTizen Studio and its native application tools enable you to:\n\n  Maximize the performance of a device to achieve higher throughput for time-sensitive apps, and run computationally intensive applications such as simulations and games.\n  Provide access to platform libraries to manage native activities and access physical device components such as sensors, touch input panels, and Wi-Fi.\n  Provide enhanced debugging, compilation, and integrated build tools.\n\n\nThe native application development phases and the tools used in each phase are as follows:\n\n  Create and manage application\n  Write and Edit Code\n  Configure\n  Debug\n  Run and Test Your Application\n\n\n\nFor advanced users, see Command Line Interface (CLI).\n\nFor a list of keyboard shortcuts related to the Tizen Studio and its tools, see Keyboard Shortcuts.\n\nRelated Information\n\n  Dependencies\n    \n      Tizen Studio 1.0 and Higher"
					}
					
				
			
		
			
				
					,
					
					"tizenstudio-web-tools": {
						"id": "tizenstudio-web-tools",
						"title": "Web Tools",
						"categories": "",
						"url": " tizenstudio/web-tools/",
						"content": "Web Tools\n\nThis page explains about various web application development tools supported in Tizen Studio. Tizen Studio IDE provides powerful tool chains to ease web-based app development and provides a platform that is consistent and fast.\n\nUsing Tizen Studio IDE and the web tools, you can create the web app that is:\n\n  Reliable: Loads instantly\n  Intuitive: Gives seamless and immersive user experience\n  Responsive: Responds quickly to user interactions on any device\n  Discoverable: Found easily through search engines\n\n\n\n  Note\n\n  Most of the web features discussed in this section are supported in TV Web application development as well. However, TV-specific details are not included in this section. For more information on TV application development tools, see Samsung Developers Smart TV site.\n\n\nThe web application development phases and the tools used in each phase are as follows:\n\n\n  Create and Manage Application\n  Write and Edit Code\n  Configure\n  Debug\n  Run and Test Application \n  Web Simulator\n\n\n\n\nFor advanced users, see Command Line Interface (CLI).\n\nFor a list of keyboard shortcuts related to Tizen Studio and its tools, see Keyboard Shortcuts.\n\nRelated information\n\n  Dependencies\n    \n      Tizen Studio 1.0 and Higher"
					}
					
				
			
		
			
				
					,
					
					"tizenstudio": {
						"id": "tizenstudio",
						"title": "Tizen Studio",
						"categories": "",
						"url": " tizenstudio/",
						"content": ""
					}
					
				
			
		
			
				
					,
					
					"": {
						"id": "",
						"title": "Documentation",
						"categories": "",
						"url": " ",
						"content": "Open Source Project\n\n    Tizen is an open source software stack created for a wide array of devices with different form factors. The primary objectives of Tizen are to create an open software platform available for carriers, OEMs, and developers to make their innovative ideas a reality, and to introduce a successful, real-world product that improves the mobile experience for users.\n\n    More\n\n  \n\n\n    Tizen .NET\n\n    Tizen .NET is an exciting new way to develop applications for the Tizen operating system, running on 50 million Samsung devices, including TVs, wearables, mobile phones, and many other IoT devices around the world.\n\n    More\n\n  \n\n\n\n\n\n    IOT world on Craftroom\n\n    The Internet of Things (IoT) is connected networks of various types of things, such as sensors, actuators, electronic devices, home appliances, and so on. These networks of end-devices, hubs, and servers enable exchange of data and execution of operations among things for specific purposes. Communications and executions through the connections are designed to happen without human interventions. In the broad sense, the IoT means a combination of software and platforms for automatic and intelligent services, as well as the networks itself.\n\n    More\n\n  \n\n\n    Tizen Studio\n\n    Tizen is a user-interactive and service-oriented open source project that allows you to create feature-rich applications for multiple device categories.\n\n    More"
					}
					
				
			
		
			
				
					,
					
					"tizenstudio-extension-sdk-inmobi": {
						"id": "tizenstudio-extension-sdk-inmobi",
						"title": "InMobi Tizen Ad SDK",
						"categories": "",
						"url": " tizenstudio/extension-sdk/inmobi/",
						"content": "InMobi Tizen Ad SDK\n\nThe InMobi Tizen Ad SDK allows you to monetize your Tizen application with a wide range of advertisement formats. From banner ads to full-screen interstitial ads, you can deliver ads from the InMobi network for a better user experience.\n\nThis site introduces InMobi Tizen Ads for Tizen Web applications, native applications, and Unity games.\n\n\n  Tizen Web application: Tizen Web applications use the Tizen Web Framework to interact with the Web subsystems. The application is built using Web languages, such as HTML5, CSS, and JavaScript.\n  Tizen Native application: Tizen Native application uses EFL (Enlightenment Foundation Libraries) for the application UI. The application is developed using C and it can access advanced device-specific features.\n  Unity game on Tizen: To use Tizen Ads in your Unity game, you need the Unity SDK version 5.4.1 or above for privilege addition support. The game is developed using C#.\n\n\nInMobi Tizen Ads allows application sellers to monetize Tizen applications and games with the ads provided by InMobi. The following ad sizes are supported:\n\n\n  Small banner: 320 X 50 pixels (InMobi slot #15)\n  Big banner: 300 X 250 pixels (InMobi slot #10)\n  Interstitial: 320 X 480 pixels (InMobi slot #14)\n\n\nYou can download the attached zip file which has inmobi-tizen-adsdk_1.0.3.zip, api references for native, unity, and web adlibraries, 3 sample apps, and Unityadlib.unitypackage at the end of this page.\n\nGetting Started with InMobi Tizen Ads\n\nTo start off, please follow the below steps to create account and register your app with Inmobi.\n\nStep 1 - Send an email to tizen.onboarding@inmobi.com\n\nStep 2 - You will receive a document stating the terms and conditions for app monetization with InMobi along with a list of details required for account creation and site ids approval\n\nStep 3 - Fill in the required details (only to be TYPED, not handwritten) and share a signed copy with InMobi. A scanned copy should be shared on the above mentioned email id and a hard copy should be mailed to the below mentioned address\n  Legal Team, INMOBI, 7th Floor, Cessna Business Park,\n  Kadubishanahalli, Sarjapur - Outer Ring Road,\n  BANGALORE, KARNATAKA 560103\n  India\n\n\nStep 4 - Once the details are approved, the InMobi team will get back to you within 2 working days with account details and site ids.\n\nStep 5 - Proceed with technical integration as mentioned in the sections below\n\nAdding the SDK to Your Project\n\nTo add the SDK to your project:\n\n\n  Download the attached zip file which has inmobi-tizen-adsdk_1.0.3.zip, api references for native, unity, and web adlibraries, 3 sample apps, and Unityadlib.unitypackage.\n\n\n\n  Choose the InMobi Tizen Ads SDK depending on your application type: native application, Web application, or Unity game:\n    \n      Tizen Web applications: Include the InMobi JavaScript file in the application\n      Native applications: The InMobi Tizen Ads extension SDK (inmobi-tizen-adsdk_1.0.3.zip)\n      Unity games: The InMobi Tizen Ads asset (Unityadlib.unitypackage)\n    \n  \n  Check the following sample applications and games and refer to the code snippets in this tutorial.\n    \n      Unity game sample (UnityAdSample.7z)\n      Native application sample (NativeAdSample.7z)\n      Web application sample (WebAdSample.7z)\n    \n  \n  We recommend you to use the blog on Tizen Ads on Tizen community for any issues. If you still face issues, send them to tizen.ads@samsung.com. The API version of the tizen applications using AdSDK should be mandatorily 2.4 or more, otherwise the tizenstore will reject the applications.\n\n\nInMobi Tizen Ads for Web Applications\n\nTo use InMobi Tizen Ads in Web applications:\n\n\n  \n    For Web applications, include the InMobi JavaScript file to use InMobi Tizen ads:\n\n    &lt;script type=\"text/javascript\" src=\"https://i.l.inmobicdn.net/sdk/jsac/p1/inmobi.js\"&gt;&lt;/script&gt;\n    \n  \n  Request permission by adding the following privileges and access feature to the config.xml file:\n    &lt;!--To fetch ads from the InMobi Tizen Ads server--&gt;\n&lt;tizen:privilege name=\"http://tizen.org/privilege/internet\"/&gt;\n&lt;!--To launch the browser for showing ads--&gt;\n&lt;tizen:privilege name=\"http://tizen.org/privilege/application.launch\"/&gt;\n&lt;!--To access cross domains--&gt;\n&lt;access origin=\"*\" subdomains=\"true\"&gt;&lt;/access&gt;\n    \n  \n  Configure the parameters for the InMobi Tizen ad &lt;div&gt; element:\n    \n      siteid: Two IDs are provided during registration, one for banner ads and one for interstitial ads. Use the respective IDs for the type of ad to be created (Mandatory)\n      slot: Corresponds to the dimensions of the slot or box where the ads appear in your application. (Mandatory)\nCurrently supported slot numbers are 10 (300x250), 14 (320x480), and 15 (320x50).\n      test: This parameter must be true during development and testing phase. It must be made false before publishing the application to receive the live ads.\n      manual: This parameter must be set to true, otherwise it takes the default false value and the ad is rendered before the Web application page is rendered.\n      autoRefresh: This is the auto refresh time in seconds. The minimum accepted value is 20.\n      uIdMap: InMobi Tizen ad id as per user settings for personalized ads.\n    \n\n    &lt;script type=\"text/javascript\"&gt;\n    var ad_id = '00000000-0000-0000-000000000000';\n&lt;/script&gt;\n   \n&lt;script type=\"text/javascript\"&gt;\n    function requestAd() {\n        var inmobi_conf = {\n            siteid: \"YOUR BANNER SITEID\", /* Your banner site ID from InMobi registration */\n            slot: '15',\n            test: false,\n            manual: true,\n            autoRefresh: 20, /* In seconds, the minimum accepted value is 20 */\n            uIdMap: {TI: ad_id}\n        };\n        _inmobi.getNewAd(document.getElementById('tizen_15'), inmobi_conf);\n    }\n   \n    function onSuccess(ad) {\n        ad_id = ad.id;\n        requestAd();\n    }\n   \n    function onError(error) {\n        ad_id = '00000000-0000-0000-0000-000000000000';\n        requestAd();\n    }\n   \n    function getAdId() {\n        try {\n            tizen.systeminfo.getPropertyValue('ADS', onSuccess, onError);\n        } catch (err) {\n            ad_id = '00000000-0000-0000-0000-000000000000';\n            requestAd();\n        }\n    }\n&lt;/script&gt;\n   \n&lt;body onload=\"getAdId()\"&gt;\n  &lt;div id=\"tizen_15\"&gt;\n   &lt;script type=\"text/javascript\" src=\"https://i.l.inmobicdn.net/sdk/jsac/p1/inmobi.js\"&gt;&lt;/script&gt;\n&lt;/div&gt;\n    \n  \n\n\nInMobi Tizen Ads for Native Applications\n\nThis section describes the InMobi Tizen Ads APIs for Tizen native (EFL) applications. Familiarize yourself with Tizen native application development and EFL UI development before attempting to integrate the Ads SDK.\n\nThe InMobi Tizen Ads SDK (inmobi-tizen-adsdk_1.0.3.zip) includes 1 library (Adlib) and 1 header file. To get started, download the Tizen studio. For more information on adding extension SDKs, see Extension SDKs.\n\nTo create InMobi Tizen ads in native applications:\n\n\n  \n    Request permission by adding the following privileges to the tizen-manifest.xml file:\n\n    &lt;privileges&gt;\n   &lt;privilege&gt;http://tizen.org/privilege/network.get&lt;/privilege&gt;\n   &lt;privilege&gt;http://tizen.org/privilege/internet&lt;/privilege&gt;\n   &lt;privilege&gt;http://tizen.org/privilege/appmanager.launch&lt;/privilege&gt;\n&lt;/privileges&gt;\n    \n  \n  \n    Enums that are defined in header to set position, set ad size and error codes.\n\n    enum banner_adposition_e;\n\nenum banner_ad_size_e;\n\nenum adlib_err;\n    \n  \n  \n    Initialize Adlib.\n\n    To use the functions and data types of Adlib, include the  header file in your application and give reference of adlib library in C++ Linker libraries under project settings.\n\n    The Adlib has to be initialized by passing valid banner and interstitial site IDs obtained in the InMobi registration.\n\n    #include &lt;adlib.h&gt;\n\nadlib_err ret;\nret = adlib_init(const char *banner_site_id, const char *interstitial_site_id, const char *js_namespace, const char *js_src_url, const char *ad_conf_str_name);\nbanner_site_id: \"YOUR BANNER SITEID\" /* Your banner site id from InMobi*/\ninterstitial_site_id: \"YOUR INTERSTITIAL SITEID\" /* Your interstitial site id from InMobi*/\njs_namespace: \"_inmobi\" /*same string has to be passed*/\njs_src_url: \"https://i.l.inmobicdn.net/sdk/jsac/p1/inmobi.js\" /*same string has to be passed*/\nad_conf_str_name: \"inmobi_conf\" /*same string has to be passed*/\n    \n\n    To deinitialize Adlib, call the adlib_deinit() function. This is required when exiting the application to free the resources.\n\n    ret = adlib_deinit();\n    \n  \n  \n    Create banner ad:\n\n    \n      \n        Create ad:\n\n        \n          \n            Ad object can be added on applications main window or on user defined layout as per application requirement. Add the banner ad by specifying the type of ad along with the layout or window in which the banner ad must be displayed:\n\n            Evas_Object *ad_obj = NULL;\n\nadlib_err result = adview_ad_banner_ad(&amp;ad_obj, ad-&gt;layout, BANNER_AD_SIZE_BIG);\n            \n          \n          \n            Load the created banner ad by calling the adview_banner_load() function:\n\n            result = adview_banner_load(ad_obj);\n            \n          \n          \n            Adlib has a callback mechanism to update the application about the ad state. The following example shows the callbacks the application has to register.\n\n            void\nset_listeners(void *appdata)\n{\n    banner_ad_event_callback_s callback = {0,};\n    callback.banner_ad_opened = on_ad_opened;\n    callback.banner_ad_load_request_failed = on_request_failed;\n    callback.banner_ad_load_request_succeeded = on_request_succeeded;\n    adview_banner_ad_register_callbacks(banner_ad_obj, &amp;callback, appdata);\n}\n            \n          \n          \n            The adview can be swallowed in to the layout or can be shown as an overlay above the current layout. In the later case, application has to manage the show state of the adview explicitly. On successful load of bannerad, banner_ad_load_request_succeeded callback will be triggered in which application needs to call the show of bannerad object using native api evas_object_show(). Also while navigating between the views or during loadFailure, application can choose to handle based on its logic, for example it can hide the adview by calling evas_object_hide() or it can show the adview with the old ad.\n\n            void on_request_succeeded(Evas_Object *obj, void *userdata)\n{\n\tevas_object_show(obj);\n}\nvoid on_request_failed(Evas_Object *obj, adlib_err err, void *userdata)\n{\n\tevas_object_hide(obj);\n}\nvoid on_ad_opened(Evas_Object *obj, void *userdata)\n{\n\t// Application logic\n}\n            \n          \n        \n      \n      \n        Manage ad:\n\n        \n          \n            By default, the auto refresh option is enabled for banner ads and the ads are refreshed every 30 seconds provided a new ad is downloaded from the server. The application can control the refresh timer as well as disable the auto refresh option as shown in the following example.\n\n            result = adview_banner_set_enable_auto_refresh(ad_obj, EINA_FALSE);\nresult = adview_banner_set_refresh_interval(ad_obj, 40);\n            \n          \n          \n            If the application has not swallowed the banner_ad_obj object into the edc part, it can position the ad at predefined positions using the banner_adposition_e enumeration:\n\n            result = adview_banner_ad_set_position(ad_obj, BANNER_AD_POSITION_TOP_CENTER);\n            \n\n            Adlib handles the repositioning of the ad object when the device orientation changes. If the application changes the position of the banner_ad_obj object using Evas functions, such as evas_object_move(), the application is responsible for handling device orientation changes.\n\n            By default, the ad object is placed at BANNER_AD_POSITION_BOTTOM_CENTER.\n          \n        \n      \n    \n  \n  \n    Create an interstitial ad:\n\n    \n      \n        Create ad:\n\n        \n          \n            Add the interstitial ad by specifying the layout or window on which interstitial ad has to be displayed:\n\n            adlib_err result = adview_add_interstitial_ad(ad-&gt;layout);\n            \n          \n          The application needs to load the interstitial ad, and on successful load, it needs to call show. Once the load is successful, the interstitial_ad_load_request_succeeded callback is triggered. After this, the interstitial ad is ready to be shown.\n            result = adview_interstitial_load();\n            \n            After receiving the interstitial_ad_load_request_succeeded callback, the application can show the ad at any time as per application logic.\n            result = adview_interstitial_show(); /* Show the interstitial ad */\n            \n            Contrary to the banner ad, the call to load does not take care of showing the interstitial ad.\n          \n          \n            Adlib has a callback mechanism to update the application about the interstitial ad state. The following example shows the callbacks the application has to register.\n\n            void\nset_listeners(void *appdata)\n{\n    interstitial_ad_event_callback_s callback = {0,};\n    callback.interstitial_ad_opened = on_ad_opened;\n    callback.interstitial_ad_closed = on_ad_closed;\n    callback.interstitial_ad_load_request_failed = on_request_failed;\n    callback.interstitial_ad_load_request_succeeded = on_request_succeeded;\n    adlib_interstitial_ad_register_callbacks(&amp;callback, appdata);\n}\nvoid on_request_succeeded(void *userdata)\n{\n\t// Application logic\n}\nvoid on_request_failed(adlib_err err, void *userdata)\n{\n\t// Application logic\n}\nvoid on_ad_opened(void *userdata)\n{\n\t// Application logic\n}\nvoid on_ad_closed(void *userdata)\n{\n\t// Application logic\n}\n            \n          \n        \n      \n    \n  \n\n\nInMobi Tizen Ads for Unity Games\n\nThis section describes the InMobi Tizen Ads APIs for Tizen Unity games.\n\nTo get started, the Unity package (‘Unityadlib.unitypackage’ in the attached zip file) is needed. For more information on setting up the Unity SDK for Tizen, see the Unity documentation. The minimum Unity SDK version for integrating with Tizen is 5.4.1.\n\nTo create InMobi Tizen ads for Unity games:\n\n\n  \n    The game needs the following capabilities for the Unity game in the Tizen build settings:\n\n    \n      Network Get\n      Internet\n      AppManagerLaunch\n    \n  \n  \n    Enums that are defined in header to set position, set ad size and error codes:\n\n    public enum ErrorType\n\npublic enum BannerAdSize\n\npublic enum BannerAdPosition\n    \n  \n  \n    Initialize Adlib.\n\n    To use the functions of Adlib, get the AdProvider instance by writing the following code in the script file:\n\n    Using Tizen.AdLib;\nAdProvider adobject = AdProvider.Instance;\n    \n\n    Initialize Adlib by passing valid banner and interstitial site IDs obtained from the InMobi registration.\n\n    ErrorType result = adobject.InitAdlib(\"YOUR BANNER SITEID\",\"YOUR INTERSTITIAL SITEID\",\"_inmobi\",\"https://i.l.inmobicdn.net/sdk/jsac/p1/inmobi.js\",\"inmobi_conf\"); // Your banner and interstitial site IDs from InMobi\n    \n\n    To deinitialize Adlib, call the following function. This is required when exiting the game to free the resources and to destroy the created adviews.\n\n    result = adobject.DeinitAdlib();\n    \n  \n  \n    Create banner ads:\n\n    \n      \n        Create ad:\n\n        \n          \n            Add the banner ad by calling the following function:\n\n            IntPtr adhandle;\nresult = adobject.AddBannerAd(BANNER_AD_SIZE_SMALL, out adhandle);\n            \n          \n          \n            Load the created banner ad using the BannerAdLoad() function:\n\n            result = adobject.BannerAdLoad(adhandle);\n            \n          \n          \n            The visibility of the ad view has to be managed by the game while switching between views using the following function:\n\n            result = adobject.BannerAdSetVisibility(adhandle, false);\n            \n          \n          \n            Adlib has a callback mechanism to update the game about the ad state. The game has to register the callbacks with Adlib using the following functions:\n\n            // Implement the BannerAdListener interface\n\npublic class AdListener:BannerAdListener\n{\n    public void OnAdLoadSucceeded(IntPtr handle)\n    {\n        Debug.Log(\"Entered in to OnAdLoadSucceeded handle is\" + handle);\n        adobject.BannerAdSetVisibility(handle, true);\n    }\n    public void OnAdLoadFailed(IntPtr handle, ErrorType error)\n    {\n        Debug.Log(\"Entered in to OnAdLoadFailed\");\n        adobject.BannerAdSetVisibility(handle, false);\n    }\n    public void OnAdClicked(IntPtr handle)\n    {\n        Debug.Log(\"Entered in to OnAdClicked handle is\" + handle);\n    }\n}\n\n// Pass the listener object to the AdProvider\n\npublic AdListener adListener = new AdListener();\nErrorType ret = adobject.SetBannerAdListener(adhandle, adlistener);\n            \n          \n        \n      \n      \n        Manage ad:\n\n        \n          \n            By default, the auto refresh option is enabled for banner ads and the ads are refreshed every 30 seconds provided a new ad is downloaded from the server. The game can control the refresh timer as well as disable the auto refresh option as shown in the following example.\n\n            result = adobject.BannerAdEnableAutoRefresh(adhandle, false);\nresult = adobject.BannerAdSetRefreshInterval(adhandle, 40);\n            \n          \n          \n            The game can position ads at predefined positions using the BannerAdSetPosition() function. Adlib takes care of device orientation changes.\n\n            result = adobject.BannerAdSetPosition(adhandle, BANNER_AD_POS_TOP_CENTER);\n            \n\n            The game can position the ad to any (x, y) position using the BannerAdSetMove() function. The game is responsible for handling the device orientation changes in this situation.\n\n            result = adobject.BannerAdSetMove(adhandle, 100, 200);\n            \n\n            By default, the ad object is placed at BANNER_AD_POS_BOTTOM_CENTER.\n          \n        \n      \n    \n  \n  \n    Create an interstitial ad:\n\n    \n      \n        Create ad:\n\n        \n          \n            Add an interstitial ad by calling the following function:\n\n            ErrorType result = adobject.AddInterstitialAd();\n            \n          \n          The game needs to load the interstitial ad and on successful load, it needs to call show. Once the load is successful, the OnAdLoadSucceeded callback is triggered by the Adlib. After this the interstitial ad is ready to be shown.\n            result = adobject.InterstitialAdLoad();\n            \n            After receiving the OnAdLoadSucceeded callback, the game can show the ad at any time.\n            result = adobject.InterstitialAdShow(); // Show the interstitial ad\n            \n            Contrary to the banner ad, the call to load does not take care of showing the interstitial ad.\n          \n          \n            Adlib has a callback mechanism to update the game about the interstitial ad state. The game has to register listener callbacks with Adlib using the following functions:\n\n            // Implement the InterstitialAdListener interface\n\npublic class AdListener:InterstitialAdListener\n{\n    public void OnAdLoadSucceeded(IntPtr handle)\n    {\n        Debug.Log(\"Entered in to OnAdLoadSucceeded handle is\" + handle);\n    }\n        public void OnAdLoadFailed(IntPtr handle, ErrorType error)\n    {\n        Debug.Log(\"Entered in to OnAdLoadFailed\");\n    }\n    public void OnAdOpened(IntPtr handle)\n    {\n        Debug.Log(\"Entered in to OnAdOpened handle is\" + handle);\n    }\n    public void OnAdClosed(IntPtr handle)\n    {\n        Debug.Log(\"Entered in to OnAdClicked handle is\"+ handle);\n    }\n}\n\n// Create the listener object and set it to AdObject\nAdListener myListener = new AdListener();\nresult = adobject.SetInterstitialAdListener(myListener);\n            \n          \n        \n      \n    \n  \n\n\nDeveloper Testcases\n\nPlease use the testcases for sanity testing after integrating the adlib to your app.\n\nCategory: AdFunctionality\n\n\n  Clicking on the Ad should open details in Browser window separately.\n  If the orientation of the application changes, the adview should be resized according to current orientation.\n  While loading interstitial ads or interacting with them no sluggish behavior should be observed.\n\n\nCategory: User Experience\n\n\n  Sample ads resolution should be proper. They should not be stretched or skewed.\n  Application layout should be designed in such a way that user experience should not be disturbed when ads are not loaded (no white patches).\n  If network is not available and when ads are not displayed, app’s user experience should not be impacted.\n  Banner ad position should be handled by app in such a way that it should not cause any hinderance to the buttons or menus.\n  Application should manage to show the banner ad once it receives the adloadsuccess callback. Navigation between views should maintain the showstate as per app design.\n  Ensure that interstitial ad load is successful and then only call show of the adview and pause application events.\n  While navigating between different views of the application, the ads should be hidden/shown properly as per app design.\n  Terminating the application in any scenario (with or without mobile data) should not cause any force closure of the app.\n  During the app pause and resume the ads rendering should be proper.\n  Incase of a list shown in the app, ensure that the list items are not hidden by the ads.\n\n\nSDK update\n\nThis page will always host the latest version of the Inmobi Tizen Ad SDK. Advertizement service for older versions of the Ad SDK will be supported for only 90 days. When developer receives an email notice to udpate the Ad SDK, it is adviced to update quickly."
					}
					
				
			
		
			
				
					,
					
					"tizenstudio-setup-install-sdk": {
						"id": "tizenstudio-setup-install-sdk",
						"title": "Installation",
						"categories": "",
						"url": " tizenstudio/setup/install-sdk/",
						"content": "Installation\n\nThis page explains about options available to install Tizen Studio on your development hardware. Tizen Studio runs on all major operating systems like Windows, macOS, Ubuntu.You can install any release of the Tizen Studio. However, it is recommended that you install the most recent release and ensure the following:\n\n\n  Plan your installation: check for the necessary hardware and software requirements.\n  Install Tizen Studio:  follow the installation guides for each operating system.\n  Configure: After installation, to have optimal development experience, configure various Tizen Studio components.\n\n\nSelect the following as per target operating system and follow the installation instructions:\n\n\n    \n    \n        \n            \n                \n                      \n                  \n                \n                Mac\n            \n        \n        \n            \n                \n                      \n                 \n                \n                Windows\n             \n        \n        \n            \n                \n                      \n                  \n                \n                Ubuntu"
					}
					
				
			
		
			
				
					,
					
					"application-developing-installing": {
						"id": "application-developing-installing",
						"title": "Installing Development Tools",
						"categories": "",
						"url": " application/developing/installing/",
						"content": "Installing Development Tools\n\nTizen SCM tools support the following Linux distribution versions:\n\n\n  Ubuntu 16.04/14.04/12.04\n  openSUSE 13.2/13.1/12.3/Leap 42.1\n  Fedora 23/22/21/20\n  CentOS 7/6\n  Debian 8/7\n\n\nYou can install a variety of development tools, including:\n\n\n  Git Build System (GBS) command line tool that supports Tizen package building.\n  Image Creator (MIC) command line tool that supports Tizen image creation.\n\n\n\n  Note\n\n  GBS and MIC are used as examples because they are mandatory development tools for Tizen developers.\n\n\nInstalling Development Tools in Ubuntu or Debian\n\nTo install a development tool in Ubuntu or Debian:\n\n\n  Note\n\n  The apt-get install &lt;Package_Name&gt; command is recommended because it upgrades 1 or more already installed packages without upgrading every package installed, whereas the apt-get upgrade command installs the newest version of all currently installed packages. In addition, apt-get update must always be executed before apt-get install &lt;Package_Name&gt; or apt-get upgrade, to resynchronize the package index files.\n\n\n\n  \n    Open the package manager source list using a text editor.\n\n    VIM is used in the following example:\n\n    $ sudo vim /etc/apt/sources.list\n    \n  \n  \n    Add the Tizen tools repository to the source list.\n\n    For example:\n\n    \n      \n        In Ubuntu 16.04, append the following line to the source list:\n\n        deb [trusted=yes] http://download.tizen.org/tools/latest-release/Ubuntu_16.04/ /\n        \n      \n      \n        In Ubuntu 14.04, append the following line to the source list:\n\n        deb http://download.tizen.org/tools/latest-release/Ubuntu_14.04/ /\n        \n      \n    \n\n    \n      Note\n\n      Pay special attention to the space between the URL and “/”.\n    \n  \n  \n    Resynchronize the package index files from the sources specified in the source list:\n\n    $ sudo apt-get update\n    \n  \n  \n    Install a development tool:\n\n    $ sudo apt-get install &lt;Package_Name&gt;\n    \n\n    For example, to install GBS and MIC:\n\n    $ sudo apt-get install gbs mic\n    \n  \n\n\nYou can upgrade a development tool using 1 of following methods, as appropriate:\n\n$ sudo apt-get update &amp;&amp; sudo apt-get install &lt;Package_Name&gt;\n$ sudo apt-get update &amp;&amp; sudo apt-get upgrade\n\n\nInstalling Development Tools in openSUSE\n\nTo install a development tool in openSUSE:\n\n\n  \n    Add the Tizen tools repository to the package manager source list.\n\n    In openSUSE 13.2, for example:\n\n    $ sudo zypper addrepo http://download.tizen.org/tools/latest-release/openSUSE_13.2/ tools\n    \n\n    \n      Note\n\n      Pay special attention to the space between the URL and “tools”.\n    \n  \n  \n    Install a development tool:\n\n    $ sudo zypper refresh$ sudo zypper install &lt;Package_Name&gt;\n    \n\n    For example, to install GBS and MIC:\n\n    $ sudo zypper refresh\n$ sudo zypper install gbs mic\n    \n  \n\n\nYou can upgrade a development tool with the following commands:\n\n$ sudo zypper refresh\n$ sudo zypper update &lt;Package_Name&gt;\n\n\nInstalling Development Tools in Fedora or CentOS\n\nTo install a development tool in Fedora or CentOS:\n\n\n  \n    Add the Tizen tools repository to the package manager source list.\n\n    In Fedora 23, for example:\n\n    $ sudo wget -O /etc/yum.repos.d/tools.repo http://download.tizen.org/tools/latest-release/Fedora_23/tools.repo\n    \n  \n  \n    Install a development tool:\n\n    $ sudo yum makecache\n$ sudo yum install &lt;Package_Name&gt;\n    \n\n    For example, to install GBS and MIC:\n\n    $ sudo yum makecache\n$ sudo yum install gbs mic\n    \n  \n\n\nYou can upgrade a development tool with the following commands:\n\n$ sudo yum makecache\n$ sudo yum update &lt;Package_Name&gt;"
					}
					
				
			
		
			
				
					,
					
					"platform-developing-installing": {
						"id": "platform-developing-installing",
						"title": "Installing Development Tools",
						"categories": "",
						"url": " platform/developing/installing/",
						"content": "Installing Development Tools\n\nTizen SCM tools support the following Linux distribution versions:\n\n\n  Ubuntu 16.04/14.04/12.04\n  openSUSE 13.2/13.1/12.3/Leap 42.1\n  Fedora 23/22/21/20\n  CentOS 7/6\n  Debian 8/7\n\n\nYou can install a variety of development tools, including:\n\n\n  Git Build System (GBS) command line tool that supports Tizen package building.\n  Image Creator (MIC) command line tool that supports Tizen image creation.\n\n\n\n  Note\n\n  GBS and MIC are used as examples because they are mandatory development tools for Tizen developers.\n\n\nInstalling Development Tools in Ubuntu or Debian\n\nTo install a development tool in Ubuntu or Debian:\n\n\n  Note\n\n  The apt-get install &lt;Package_Name&gt; command is recommended because it upgrades 1 or more already installed packages without upgrading every package installed, whereas the apt-get upgrade command installs the newest version of all currently installed packages. In addition, apt-get update must always be executed before apt-get install &lt;Package_Name&gt; or apt-get upgrade, to resynchronize the package index files.\n\n\n\n  \n    Open the package manager source list using a text editor.\n\n    VIM is used in the following example:\n\n    $ sudo vim /etc/apt/sources.list\n    \n  \n  \n    Add the Tizen tools repository to the source list.\n\n    For example:\n\n    \n      \n        In Ubuntu 16.04, append the following line to the source list:\n\n        deb [trusted=yes] http://download.tizen.org/tools/latest-release/Ubuntu_16.04/ /\n        \n      \n      \n        In Ubuntu 14.04, append the following line to the source list:\n\n        deb http://download.tizen.org/tools/latest-release/Ubuntu_14.04/ /\n        \n      \n    \n\n    \n      Note\n\n      Pay special attention to the space between the URL and “/”.\n    \n  \n  \n    Resynchronize the package index files from the sources specified in the source list:\n\n    $ sudo apt-get update\n    \n  \n  \n    Install a development tool:\n\n    $ sudo apt-get install &lt;Package_Name&gt;\n    \n\n    For example, to install GBS and MIC:\n\n    $ sudo apt-get install gbs mic\n    \n  \n\n\nYou can upgrade a development tool using 1 of following methods, as appropriate:\n\n$ sudo apt-get update &amp;&amp; sudo apt-get install &lt;Package_Name&gt;\n$ sudo apt-get update &amp;&amp; sudo apt-get upgrade\n\n\nInstalling Development Tools in openSUSE\n\nTo install a development tool in openSUSE:\n\n\n  \n    Add the Tizen tools repository to the package manager source list.\n\n    In openSUSE 13.2, for example:\n\n    $ sudo zypper addrepo http://download.tizen.org/tools/latest-release/openSUSE_13.2/ tools\n    \n\n    \n      Note\n\n      Pay special attention to the space between the URL and “tools”.\n    \n  \n  \n    Install a development tool:\n\n    $ sudo zypper refresh$ sudo zypper install &lt;Package_Name&gt;\n    \n\n    For example, to install GBS and MIC:\n\n    $ sudo zypper refresh\n$ sudo zypper install gbs mic\n    \n  \n\n\nYou can upgrade a development tool with the following commands:\n\n$ sudo zypper refresh\n$ sudo zypper update &lt;Package_Name&gt;\n\n\nInstalling Development Tools in Fedora or CentOS\n\nTo install a development tool in Fedora or CentOS:\n\n\n  \n    Add the Tizen tools repository to the package manager source list.\n\n    In Fedora 23, for example:\n\n    $ sudo wget -O /etc/yum.repos.d/tools.repo http://download.tizen.org/tools/latest-release/Fedora_23/tools.repo\n    \n  \n  \n    Install a development tool:\n\n    $ sudo yum makecache\n$ sudo yum install &lt;Package_Name&gt;\n    \n\n    For example, to install GBS and MIC:\n\n    $ sudo yum makecache\n$ sudo yum install gbs mic\n    \n  \n\n\nYou can upgrade a development tool with the following commands:\n\n$ sudo yum makecache\n$ sudo yum update &lt;Package_Name&gt;"
					}
					
				
			
		
			
				
					,
					
					"iot-developing-installing": {
						"id": "iot-developing-installing",
						"title": "Installing Development Tools",
						"categories": "",
						"url": " iot/developing/installing/",
						"content": "Installing Development Tools\n\nTizen SCM tools support the following Linux distribution versions:\n\n\n  Ubuntu 16.04/14.04/12.04\n  openSUSE 13.2/13.1/12.3/Leap 42.1\n  Fedora 23/22/21/20\n  CentOS 7/6\n  Debian 8/7\n\n\nYou can install a variety of development tools, including:\n\n\n  Git Build System (GBS) command line tool that supports Tizen package building.\n  Image Creator (MIC) command line tool that supports Tizen image creation.\n\n\n\n  Note\n\n  GBS and MIC are used as examples because they are mandatory development tools for Tizen developers.\n\n\nInstalling Development Tools in Ubuntu or Debian\n\nTo install a development tool in Ubuntu or Debian:\n\n\n  Note\n\n  The apt-get install &lt;Package_Name&gt; command is recommended because it upgrades 1 or more already installed packages without upgrading every package installed, whereas the apt-get upgrade command installs the newest version of all currently installed packages. In addition, apt-get update must always be executed before apt-get install &lt;Package_Name&gt; or apt-get upgrade, to resynchronize the package index files.\n\n\n\n  \n    Open the package manager source list using a text editor.\n\n    VIM is used in the following example:\n\n    $ sudo vim /etc/apt/sources.list\n    \n  \n  \n    Add the Tizen tools repository to the source list.\n\n    For example:\n\n    \n      \n        In Ubuntu 16.04, append the following line to the source list:\n\n        deb [trusted=yes] http://download.tizen.org/tools/latest-release/Ubuntu_16.04/ /\n        \n      \n      \n        In Ubuntu 14.04, append the following line to the source list:\n\n        deb http://download.tizen.org/tools/latest-release/Ubuntu_14.04/ /\n        \n      \n    \n\n    \n      Note\n\n      Pay special attention to the space between the URL and “/”.\n    \n  \n  \n    Resynchronize the package index files from the sources specified in the source list:\n\n    $ sudo apt-get update\n    \n  \n  \n    Install a development tool:\n\n    $ sudo apt-get install &lt;Package_Name&gt;\n    \n\n    For example, to install GBS and MIC:\n\n    $ sudo apt-get install gbs mic\n    \n  \n\n\nYou can upgrade a development tool using 1 of following methods, as appropriate:\n\n$ sudo apt-get update &amp;&amp; sudo apt-get install &lt;Package_Name&gt;\n$ sudo apt-get update &amp;&amp; sudo apt-get upgrade\n\n\nInstalling Development Tools in openSUSE\n\nTo install a development tool in openSUSE:\n\n\n  \n    Add the Tizen tools repository to the package manager source list.\n\n    In openSUSE 13.2, for example:\n\n    $ sudo zypper addrepo http://download.tizen.org/tools/latest-release/openSUSE_13.2/ tools\n    \n\n    \n      Note\n\n      Pay special attention to the space between the URL and “tools”.\n    \n  \n  \n    Install a development tool:\n\n    $ sudo zypper refresh$ sudo zypper install &lt;Package_Name&gt;\n    \n\n    For example, to install GBS and MIC:\n\n    $ sudo zypper refresh\n$ sudo zypper install gbs mic\n    \n  \n\n\nYou can upgrade a development tool with the following commands:\n\n$ sudo zypper refresh\n$ sudo zypper update &lt;Package_Name&gt;\n\n\nInstalling Development Tools in Fedora or CentOS\n\nTo install a development tool in Fedora or CentOS:\n\n\n  \n    Add the Tizen tools repository to the package manager source list.\n\n    In Fedora 23, for example:\n\n    $ sudo wget -O /etc/yum.repos.d/tools.repo http://download.tizen.org/tools/latest-release/Fedora_23/tools.repo\n    \n  \n  \n    Install a development tool:\n\n    $ sudo yum makecache\n$ sudo yum install &lt;Package_Name&gt;\n    \n\n    For example, to install GBS and MIC:\n\n    $ sudo yum makecache\n$ sudo yum install gbs mic\n    \n  \n\n\nYou can upgrade a development tool with the following commands:\n\n$ sudo yum makecache\n$ sudo yum update &lt;Package_Name&gt;"
					}
					
				
			
		
			
				
					,
					
					"application-porting-kernel": {
						"id": "application-porting-kernel",
						"title": "Kernel",
						"categories": "",
						"url": " application/porting/kernel/",
						"content": "Kernel\n\nFor information on how to set up the Tizen OS development environment, see Setting up the Development Environment.\n\nKernel Build\n\nTo build the Tizen kernel for the TM1 board:\n\n\n  Install and set up cross-compile tools on your system if the host has a different architecture than the target (such as x86).\n  Prepare the kernel source code for TM1 from profile/mobile/platform/kernel/linux-3.10-sc7730:\n    git: https://review.tizen.org/git/?p=profile/mobile/platform/kernel/linux-3.10-sc7730.git\nbranch: accepted/tizen_mobile\n    \n  \n  If your kernel source has been used to create binaries for another architecture, start by cleaning them up.\n  Set up the .config file for TM1:\n    $ make ARCH=arm tizen_tm1_defconfig\n    \n  \n  After reconfiguring your needs (such as make ARCH=arm menuconfig) or using the stock configuration (no modifications), build it:\n    $ make ARCH=arm zImage\n$ make ARCH=arm dtbs\n    \n  \n  Create a devicetree and zImage merged image with the image tools:\n    $ scripts/sprd_dtbtool.sh -o arch/arm/boot/merged-dtb -p scripts/dtc/ -v arch/arm/boot/dts/\n$ scripts/sprd_mkdzimage.sh -o arch/arm/boot/dzImage -k arch/arm/boot/zImage -d arch/arm/boot/merged-dtb\n    \n  \n  Build and make the kernel module image as well. Note that you may need to do sudo first to let sudo -n work in the script:\n    $ sudo ls\n$ scripts/mkmodimg.sh\n    \n  \n  Make a .tar archive from dzImage and modules.img. You can make your own .tar file from the 2 files:\n    $ tar cf FILENAME_YOU_WANT.tar -C arch/arm/boot dzImage -C ../../../usr/tmp-mod modules.img\n    \n  \n  Send the .tar image to the target using lthor:\n    $ lthor FILENAME_YOU_WANT.tar\n    \n  \n\n\nFor information on how to create an image using MIC, see MIC Image Creator.\n\nTizen Bootup Overview\n\nThis section provides a brief overview of the typical booting sequence, starting from the boot loader to the kernel and the platform.\n\nFigure: Tizen bootup sequence\n\n\n\nThe Tizen bootup process is the same as any other Linux kernel. Make sure that the correct machine ID and the boot arguments are passed from the boot loader.\n\nAfter mounting the initial RAM disk image, initramfs hands over control to systemd as the Tizen platform system manager daemon. From this point, systemd is responsible for probing all remaining hardware, mounting all necessary file systems, and spawning all configured services. The system bootup process is split up into discrete steps. To synchronize point during start-up, target units (files whose names end in .target) are used for grouping units. The bootup process is highly parallelized in each target so that the order in which specific target units are reached is not determined. The system-plugin-slp is an OAL plugin for configuration settings, such as the mount point (/etc/fstab).\n\nThe following figure shows the early boot sequence after starting the kernel.\n\nFigure: Early boot sequence\n\n\n\n\n  \n    sysinit.target\n\n    Special target unit for early boot-up scripts. It has dependencies on necessary services and targets, such as local-fs.target. At this point, most of the file systems, such as /opt, /tmp, and /media, are mounted and the systemd-related daemons, such as systemd-journald, are launched.\n  \n  \n    basic.target\n\n    Special target unit for basic bootup. At this point, all necessary initialization for general purpose daemons, such as mount points, sockets, timers, and path units, is completed. Tizen-specific services (such as vconf-setup and tizen-debug-level) are also executed.\n  \n  \n    bootmode.target\n\n    Special target unit for selecting the boot mode. If the kernel boot parameter (/proc/cmdline) has the charger_detect_boot option passed by a boot loader, such as uboot, the platform boots up in charging mode. In this mode, the system enters the low power mode and charges the battery. If the charger_detect_boot option is not included as a kernel boot parameter, a normal boot is started.\n  \n\n\nThe following figure shows the overview of normal booting sequence in Tizen platform.\n\nFigure: Tizen platform boot sequence\n\n\n\n\n  \n    multi-user.target\n\n    Special target unit for setting up a multi-user system with non-graphical support. On the Tizen platform, this target is used for launching platform infrastructure daemons, such as dbus (system session), power manager, GPS manager, telephony daemon, WRT (Web Run Time) security daemon, and the media server. Some systemd-related daemons (such as systemd-logind) are also started in this phase.\n  \n  \n    graphical.target\n\n    Special target unit for setting up a graphical environment. Some important daemons (such as the access control and OMA DS agent servers) that must have root permission are launched at this point. The Tizen platform uses the systemd user session for App privilege daemons. Some daemons related to the graphics system, such as Enlightenment (window manager), are launched with the App privilege in this phase. The Tizen platform has its special target for middleware and mobile service: tizen-middleware.target starts the platform service daemons, such as calendar, contacts, email, message, sound, and download provider. tizen-mobile-session.target starts some service daemons related with the mobile session.\n  \n\n\nBSP Customization\n\nThis section covers the basic configuration, setup, and build procedure required for building the boot loader and the kernel image for ARM.\n\nBoot Loader\n\nThe boot loader is a small piece of software that is needed to perform the basic hardware and peripheral initialization and load the kernel and proper device tree binary for the device to RAM. For the Tizen platform, the boot loader comes in 2 parts, the primary boot loader and the secondary boot loader. The primary boot loader is proprietary, and the secondary boot loader is the open source u-boot, customized for the Tizen platform.\n\nIf your platform is already loaded with the compatible boot loader software, you can skip this section and move directly to the kernel section.\n\nBoot Loader Setup and Build\n\nTo build the Tizen TM1 boot loader:\n\n\n  Install and set up cross-compile tools on your system if the host has a different architecture than the target (such as x86).\n  Start with cleaning up the u-boot-tm1 source. Download the source from the u-boot-tm1 repository.\n    $ make distclean`\n    \n  \n  Set up the configuration for TM1.\n  Build u-boot:\n    $ make ARCH=arm\n    \n  \n  Once the build is successful, the u-boot.bin file is created. (This step is for preventing from flashing the other u-boot.bin file.)\n    $ tools/mkimage_signed.sh u-boot.bin \"tizen_tm1\"\n    \n\n    After the script is run, the u-boot-mmc.bin file is created.\n  \n  Create a boot loader tarball to download the u-boot binary onto the target.\n    $ tar cvf bootloader.tar u-boot-mmc.bin`\n    \n    \n      Note\n\n      Be careful when modifying the boot loader: incorrect configuration can damage the device permanently.\n    \n  \n\n\nBoot Loader Kernel Parameters\n\nCommand line parameters, such as the following example, can be passed from the boot loader to the Linux kernel:\n\nconsole=ttyS1,115200n8\nmem=1024M\nloglevel=1\n\n\nKernel\n\nThe kernel is the operating system that drives the platform. In this case, the kernel refers to the open source Linux kernel that is customized for the Tizen platform. The following section gives a brief overview about the Tizen kernel setup, configuration, and the build procedure for building a Linux kernel for your Tizen platform. The output of the kernel binary is a uImage that is suitable only for a u-boot boot loader. If you have chosen a secure booting configuration in your boot loader, this uImage must be compatible with your boot loader.\n\nKernel Configurations\n\nTo download the Tizen kernel source package, see Getting Source Code and Build. To set up or modify your kernel configuration, use the appropriate defconfig file from arch/arm/configs/ (ARM CPU).\n\nFor more information on the Tizen kernel configuration and kernel building, see Kernel Build.\n\n\n  Note\n\n  Tizen uses INOTIFY instead of DNOTIFY. You must disable DNOTIFY from your kernel configuration.\n\n\nIf you want to use initramfs, you can use these configurations:\n\n\n  CONFIG_INITRAMFS_SOURCE\n  CONFIG_INITRAMFS_ROOT_UID\n  CONFIG_INITRAMFS_ROOT_GID\n  CONFIG_INITRAMFS_COMPRESSION_NONE/GZIP/BZIP2/LZNA/LZO\n\n\nTizen File System\n\nVirtual Filesystem (VFS)\n\nThe virtual file system (VFS) is an abstraction layer on top of a physical file system (such as ext2, jfs, and ext4). The VFS provides a switching layer between the SCI (system call interface) and the file systems supported by the kernel, as shown in the following figure.\n\nFigure: Tizen file system\n\n\n\nAt the top of the VFS is a common API abstraction of functions, such as open, close, read, and write. At the bottom of the VFS are the file system abstractions that define how the upper-layer functions are implemented with respect to a specific file system.\n\nBelow the file system layer is the page cache, which provides a common set of functions to the file system layer (independent of any particular file system). This caching layer optimizes access to the physical devices by keeping data around for a short time (or speculatively reading ahead, so that the data is available when needed). Below the page cache are the device drivers, which implement the interface for the particular physical device.\n\nTizen Partition Layout\n\nThe following description is an example of the Tizen partition layout. The product vendor can modify the sequence or partition layout for their devices, as needed.\n\nFigure: Tizen partition layout\n\n\n\nThe boot partition is mounted in the /boot directory of rootfs. Here s-boot, u-boot, and the kernel image are saved as a file format, provided as system.tar.\n\n\n  The CSA (Configuration Saved Area) partition is for non-volatile data, such as the calibration value of modem.\n  The boot partition includes the kernel image, boot loader image, and modem image. Additionally, it can have device driver modules.\n  Third partition is reserved for the future.\n  The CSC (Customer Software Configuration) partition is mounted in the /mnt/csc directory. It can store the customer’s software configuration, such as the default language and time zone.\n  The platform partition is mounted on the root directory. It contains fundamental frameworks for Tizen and some general utility for Linux. It can be provided as a platform.img file.\n  The data partition is mounted in the /opt directory and it includes applications, libraries of applications, and the platform database. It can be provided as a data.img file.\n  The UMS (USB Mass Storage) partition is mounted in the /opt/media directory and it includes default (media) contents. It can be provided as ums.img.\n\n\nEach image file, platform.img, data.img, and ums.img can be zipped for downloading, for example, &lt;IMAGE_NAME&gt;.tar.gz.\n\nEach partition has the hierarchy illustrated in the following figure.\n\nFigure: Tizen file system hierarchy\n\n\n\nSupported File Systems\n\nTizen supports the Extended 4 (ext4) file system. The Tizen kernel has to be compiled to enable support for other file systems, such as JFS, XFS, BTRFS, and Reiserfs.\n\nThe Extended 4 (ext4) file system is configured as a default file system for Tizen.\n\nConfiguration\n\nThe following ext4 configuration options can be enabled in the kernel configuration file:\n\n\n  CONFIG_EXT4_FS=y\n  CONFIG_EXT4_FS_XATTR=y\n  CONFIG_EXT4_USE_FOR_EXT23=y\n  CONFIG_EXT4_FS_SECURITY=y\n\n\nMMC/SD/SDIO\n\nTizen supports MultiMediaCard, Secure Digital, and Secure Digital I/O Support. The MMC driver is implemented on top of a host controller (such as the SDHCI controller driver) and supports MMC, SD, SD High Speed, and SDHC cards.\n\nIf MMC is your booting device, read-write APIs, partition management, and flashing must be provided at the boot loader.\n\nFigure: Tizen MMC architecture\n\n\n\nThe MMC/SD/SDIO driver supports the following features:\n\n\n  Driver is built in-kernel\n  MMC cards, including high speed cards\n  SD cards, including SD high speed and SDHC cards\n\n\nThe MMC subsystem code structure in the kernel is located at /driver/mmc and divided into 3 parts:\n\n\n  MMC block device driver located at /driver/mmc/card/\n  Protocol stack for MMC, SD, SDIO located at /driver/mmc/core/\n  Host controller driver located at /driver/mmc/host/\n\n\nHotplug MMC Event Handling\n\nBased on the hotplug event handling, a notification is passed to deviced for device status changes. It detects, mounts, and monitors the status of the SD card.\n\nReference\n\nThe SDHCI controller is supported in the MMC/SD/SDIO interface. The Mobile Storage Host controller is only supported in the MMC interface.\n\n\n  \n    Kernel configuration for MMC Interface\n\n    CONFIG_MMC_BLOCK, CONFIG_MMC, CONFIG_MSHCI (for Mobile Storage Interface enable)\nsys interface: /dev/mmcblk0pX\n  \n  \n    Kernel configuration for SD/SDIO Interface\n\n    CONFIG_MMC_BLOCK, CONFIG_MMC\nCONFIG_MMC_SDHCI (for SDHCI host Interface enable)\nCONFIG_MMC_SDHCI_S3C (for Samsung SoC)\nsys interface: /dev/mmcblk1pX\n  \n\n\nThe X denotes the MMC partition number. Details of the partition mount point for Tizen are covered under Tizen Partition Layout."
					}
					
				
			
		
			
				
					,
					
					"platform-porting-kernel": {
						"id": "platform-porting-kernel",
						"title": "Kernel",
						"categories": "",
						"url": " platform/porting/kernel/",
						"content": "Kernel\n\nFor information on how to set up the Tizen OS development environment, see Setting up the Development Environment.\n\nKernel Build\n\nTo build the Tizen kernel for the TM1 board:\n\n\n  Install and set up cross-compile tools on your system if the host has a different architecture than the target (such as x86).\n  Prepare the kernel source code for TM1 from profile/mobile/platform/kernel/linux-3.10-sc7730:\n    git: https://review.tizen.org/git/?p=profile/mobile/platform/kernel/linux-3.10-sc7730.git\nbranch: accepted/tizen_mobile\n    \n  \n  If your kernel source has been used to create binaries for another architecture, start by cleaning them up.\n  Set up the .config file for TM1:\n    $ make ARCH=arm tizen_tm1_defconfig\n    \n  \n  After reconfiguring your needs (such as make ARCH=arm menuconfig) or using the stock configuration (no modifications), build it:\n    $ make ARCH=arm zImage\n$ make ARCH=arm dtbs\n    \n  \n  Create a devicetree and zImage merged image with the image tools:\n    $ scripts/sprd_dtbtool.sh -o arch/arm/boot/merged-dtb -p scripts/dtc/ -v arch/arm/boot/dts/\n$ scripts/sprd_mkdzimage.sh -o arch/arm/boot/dzImage -k arch/arm/boot/zImage -d arch/arm/boot/merged-dtb\n    \n  \n  Build and make the kernel module image as well. Note that you may need to do sudo first to let sudo -n work in the script:\n    $ sudo ls\n$ scripts/mkmodimg.sh\n    \n  \n  Make a .tar archive from dzImage and modules.img. You can make your own .tar file from the 2 files:\n    $ tar cf FILENAME_YOU_WANT.tar -C arch/arm/boot dzImage -C ../../../usr/tmp-mod modules.img\n    \n  \n  Send the .tar image to the target using lthor:\n    $ lthor FILENAME_YOU_WANT.tar\n    \n  \n\n\nFor information on how to create an image using MIC, see MIC Image Creator.\n\nTizen Bootup Overview\n\nThis section provides a brief overview of the typical booting sequence, starting from the boot loader to the kernel and the platform.\n\nFigure: Tizen bootup sequence\n\n\n\nThe Tizen bootup process is the same as any other Linux kernel. Make sure that the correct machine ID and the boot arguments are passed from the boot loader.\n\nAfter mounting the initial RAM disk image, initramfs hands over control to systemd as the Tizen platform system manager daemon. From this point, systemd is responsible for probing all remaining hardware, mounting all necessary file systems, and spawning all configured services. The system bootup process is split up into discrete steps. To synchronize point during start-up, target units (files whose names end in .target) are used for grouping units. The bootup process is highly parallelized in each target so that the order in which specific target units are reached is not determined. The system-plugin-slp is an OAL plugin for configuration settings, such as the mount point (/etc/fstab).\n\nThe following figure shows the early boot sequence after starting the kernel.\n\nFigure: Early boot sequence\n\n\n\n\n  \n    sysinit.target\n\n    Special target unit for early boot-up scripts. It has dependencies on necessary services and targets, such as local-fs.target. At this point, most of the file systems, such as /opt, /tmp, and /media, are mounted and the systemd-related daemons, such as systemd-journald, are launched.\n  \n  \n    basic.target\n\n    Special target unit for basic bootup. At this point, all necessary initialization for general purpose daemons, such as mount points, sockets, timers, and path units, is completed. Tizen-specific services (such as vconf-setup and tizen-debug-level) are also executed.\n  \n  \n    bootmode.target\n\n    Special target unit for selecting the boot mode. If the kernel boot parameter (/proc/cmdline) has the charger_detect_boot option passed by a boot loader, such as uboot, the platform boots up in charging mode. In this mode, the system enters the low power mode and charges the battery. If the charger_detect_boot option is not included as a kernel boot parameter, a normal boot is started.\n  \n\n\nThe following figure shows the overview of normal booting sequence in Tizen platform.\n\nFigure: Tizen platform boot sequence\n\n\n\n\n  \n    multi-user.target\n\n    Special target unit for setting up a multi-user system with non-graphical support. On the Tizen platform, this target is used for launching platform infrastructure daemons, such as dbus (system session), power manager, GPS manager, telephony daemon, WRT (Web Run Time) security daemon, and the media server. Some systemd-related daemons (such as systemd-logind) are also started in this phase.\n  \n  \n    graphical.target\n\n    Special target unit for setting up a graphical environment. Some important daemons (such as the access control and OMA DS agent servers) that must have root permission are launched at this point. The Tizen platform uses the systemd user session for App privilege daemons. Some daemons related to the graphics system, such as Enlightenment (window manager), are launched with the App privilege in this phase. The Tizen platform has its special target for middleware and mobile service: tizen-middleware.target starts the platform service daemons, such as calendar, contacts, email, message, sound, and download provider. tizen-mobile-session.target starts some service daemons related with the mobile session.\n  \n\n\nBSP Customization\n\nThis section covers the basic configuration, setup, and build procedure required for building the boot loader and the kernel image for ARM.\n\nBoot Loader\n\nThe boot loader is a small piece of software that is needed to perform the basic hardware and peripheral initialization and load the kernel and proper device tree binary for the device to RAM. For the Tizen platform, the boot loader comes in 2 parts, the primary boot loader and the secondary boot loader. The primary boot loader is proprietary, and the secondary boot loader is the open source u-boot, customized for the Tizen platform.\n\nIf your platform is already loaded with the compatible boot loader software, you can skip this section and move directly to the kernel section.\n\nBoot Loader Setup and Build\n\nTo build the Tizen TM1 boot loader:\n\n\n  Install and set up cross-compile tools on your system if the host has a different architecture than the target (such as x86).\n  Start with cleaning up the u-boot-tm1 source. Download the source from the u-boot-tm1 repository.\n    $ make distclean`\n    \n  \n  Set up the configuration for TM1.\n  Build u-boot:\n    $ make ARCH=arm\n    \n  \n  Once the build is successful, the u-boot.bin file is created. (This step is for preventing from flashing the other u-boot.bin file.)\n    $ tools/mkimage_signed.sh u-boot.bin \"tizen_tm1\"\n    \n\n    After the script is run, the u-boot-mmc.bin file is created.\n  \n  Create a boot loader tarball to download the u-boot binary onto the target.\n    $ tar cvf bootloader.tar u-boot-mmc.bin`\n    \n    \n      Note\n\n      Be careful when modifying the boot loader: incorrect configuration can damage the device permanently.\n    \n  \n\n\nBoot Loader Kernel Parameters\n\nCommand line parameters, such as the following example, can be passed from the boot loader to the Linux kernel:\n\nconsole=ttyS1,115200n8\nmem=1024M\nloglevel=1\n\n\nKernel\n\nThe kernel is the operating system that drives the platform. In this case, the kernel refers to the open source Linux kernel that is customized for the Tizen platform. The following section gives a brief overview about the Tizen kernel setup, configuration, and the build procedure for building a Linux kernel for your Tizen platform. The output of the kernel binary is a uImage that is suitable only for a u-boot boot loader. If you have chosen a secure booting configuration in your boot loader, this uImage must be compatible with your boot loader.\n\nKernel Configurations\n\nTo download the Tizen kernel source package, see Getting Source Code and Build. To set up or modify your kernel configuration, use the appropriate defconfig file from arch/arm/configs/ (ARM CPU).\n\nFor more information on the Tizen kernel configuration and kernel building, see Kernel Build.\n\n\n  Note\n\n  Tizen uses INOTIFY instead of DNOTIFY. You must disable DNOTIFY from your kernel configuration.\n\n\nIf you want to use initramfs, you can use these configurations:\n\n\n  CONFIG_INITRAMFS_SOURCE\n  CONFIG_INITRAMFS_ROOT_UID\n  CONFIG_INITRAMFS_ROOT_GID\n  CONFIG_INITRAMFS_COMPRESSION_NONE/GZIP/BZIP2/LZNA/LZO\n\n\nTizen File System\n\nVirtual Filesystem (VFS)\n\nThe virtual file system (VFS) is an abstraction layer on top of a physical file system (such as ext2, jfs, and ext4). The VFS provides a switching layer between the SCI (system call interface) and the file systems supported by the kernel, as shown in the following figure.\n\nFigure: Tizen file system\n\n\n\nAt the top of the VFS is a common API abstraction of functions, such as open, close, read, and write. At the bottom of the VFS are the file system abstractions that define how the upper-layer functions are implemented with respect to a specific file system.\n\nBelow the file system layer is the page cache, which provides a common set of functions to the file system layer (independent of any particular file system). This caching layer optimizes access to the physical devices by keeping data around for a short time (or speculatively reading ahead, so that the data is available when needed). Below the page cache are the device drivers, which implement the interface for the particular physical device.\n\nTizen Partition Layout\n\nThe following description is an example of the Tizen partition layout. The product vendor can modify the sequence or partition layout for their devices, as needed.\n\nFigure: Tizen partition layout\n\n\n\nThe boot partition is mounted in the /boot directory of rootfs. Here s-boot, u-boot, and the kernel image are saved as a file format, provided as system.tar.\n\n\n  The CSA (Configuration Saved Area) partition is for non-volatile data, such as the calibration value of modem.\n  The boot partition includes the kernel image, boot loader image, and modem image. Additionally, it can have device driver modules.\n  Third partition is reserved for the future.\n  The CSC (Customer Software Configuration) partition is mounted in the /mnt/csc directory. It can store the customer’s software configuration, such as the default language and time zone.\n  The platform partition is mounted on the root directory. It contains fundamental frameworks for Tizen and some general utility for Linux. It can be provided as a platform.img file.\n  The data partition is mounted in the /opt directory and it includes applications, libraries of applications, and the platform database. It can be provided as a data.img file.\n  The UMS (USB Mass Storage) partition is mounted in the /opt/media directory and it includes default (media) contents. It can be provided as ums.img.\n\n\nEach image file, platform.img, data.img, and ums.img can be zipped for downloading, for example, &lt;IMAGE_NAME&gt;.tar.gz.\n\nEach partition has the hierarchy illustrated in the following figure.\n\nFigure: Tizen file system hierarchy\n\n\n\nSupported File Systems\n\nTizen supports the Extended 4 (ext4) file system. The Tizen kernel has to be compiled to enable support for other file systems, such as JFS, XFS, BTRFS, and Reiserfs.\n\nThe Extended 4 (ext4) file system is configured as a default file system for Tizen.\n\nConfiguration\n\nThe following ext4 configuration options can be enabled in the kernel configuration file:\n\n\n  CONFIG_EXT4_FS=y\n  CONFIG_EXT4_FS_XATTR=y\n  CONFIG_EXT4_USE_FOR_EXT23=y\n  CONFIG_EXT4_FS_SECURITY=y\n\n\nMMC/SD/SDIO\n\nTizen supports MultiMediaCard, Secure Digital, and Secure Digital I/O Support. The MMC driver is implemented on top of a host controller (such as the SDHCI controller driver) and supports MMC, SD, SD High Speed, and SDHC cards.\n\nIf MMC is your booting device, read-write APIs, partition management, and flashing must be provided at the boot loader.\n\nFigure: Tizen MMC architecture\n\n\n\nThe MMC/SD/SDIO driver supports the following features:\n\n\n  Driver is built in-kernel\n  MMC cards, including high speed cards\n  SD cards, including SD high speed and SDHC cards\n\n\nThe MMC subsystem code structure in the kernel is located at /driver/mmc and divided into 3 parts:\n\n\n  MMC block device driver located at /driver/mmc/card/\n  Protocol stack for MMC, SD, SDIO located at /driver/mmc/core/\n  Host controller driver located at /driver/mmc/host/\n\n\nHotplug MMC Event Handling\n\nBased on the hotplug event handling, a notification is passed to deviced for device status changes. It detects, mounts, and monitors the status of the SD card.\n\nReference\n\nThe SDHCI controller is supported in the MMC/SD/SDIO interface. The Mobile Storage Host controller is only supported in the MMC interface.\n\n\n  \n    Kernel configuration for MMC Interface\n\n    CONFIG_MMC_BLOCK, CONFIG_MMC, CONFIG_MSHCI (for Mobile Storage Interface enable)\nsys interface: /dev/mmcblk0pX\n  \n  \n    Kernel configuration for SD/SDIO Interface\n\n    CONFIG_MMC_BLOCK, CONFIG_MMC\nCONFIG_MMC_SDHCI (for SDHCI host Interface enable)\nCONFIG_MMC_SDHCI_S3C (for Samsung SoC)\nsys interface: /dev/mmcblk1pX\n  \n\n\nThe X denotes the MMC partition number. Details of the partition mount point for Tizen are covered under Tizen Partition Layout."
					}
					
				
			
		
			
				
					,
					
					"iot-porting-kernel": {
						"id": "iot-porting-kernel",
						"title": "Kernel",
						"categories": "",
						"url": " iot/porting/kernel/",
						"content": "Kernel\n\nFor information on how to set up the Tizen OS development environment, see Setting up the Development Environment.\n\nKernel Build\n\nTo build the Tizen kernel for the TM1 board:\n\n\n  Install and set up cross-compile tools on your system if the host has a different architecture than the target (such as x86).\n  Prepare the kernel source code for TM1 from profile/mobile/platform/kernel/linux-3.10-sc7730:\n    git: https://review.tizen.org/git/?p=profile/mobile/platform/kernel/linux-3.10-sc7730.git\nbranch: accepted/tizen_mobile\n    \n  \n  If your kernel source has been used to create binaries for another architecture, start by cleaning them up.\n  Set up the .config file for TM1:\n    $ make ARCH=arm tizen_tm1_defconfig\n    \n  \n  After reconfiguring your needs (such as make ARCH=arm menuconfig) or using the stock configuration (no modifications), build it:\n    $ make ARCH=arm zImage\n$ make ARCH=arm dtbs\n    \n  \n  Create a devicetree and zImage merged image with the image tools:\n    $ scripts/sprd_dtbtool.sh -o arch/arm/boot/merged-dtb -p scripts/dtc/ -v arch/arm/boot/dts/\n$ scripts/sprd_mkdzimage.sh -o arch/arm/boot/dzImage -k arch/arm/boot/zImage -d arch/arm/boot/merged-dtb\n    \n  \n  Build and make the kernel module image as well. Note that you may need to do sudo first to let sudo -n work in the script:\n    $ sudo ls\n$ scripts/mkmodimg.sh\n    \n  \n  Make a .tar archive from dzImage and modules.img. You can make your own .tar file from the 2 files:\n    $ tar cf FILENAME_YOU_WANT.tar -C arch/arm/boot dzImage -C ../../../usr/tmp-mod modules.img\n    \n  \n  Send the .tar image to the target using lthor:\n    $ lthor FILENAME_YOU_WANT.tar\n    \n  \n\n\nFor information on how to create an image using MIC, see MIC Image Creator.\n\nTizen Bootup Overview\n\nThis section provides a brief overview of the typical booting sequence, starting from the boot loader to the kernel and the platform.\n\nFigure: Tizen bootup sequence\n\n\n\nThe Tizen bootup process is the same as any other Linux kernel. Make sure that the correct machine ID and the boot arguments are passed from the boot loader.\n\nAfter mounting the initial RAM disk image, initramfs hands over control to systemd as the Tizen platform system manager daemon. From this point, systemd is responsible for probing all remaining hardware, mounting all necessary file systems, and spawning all configured services. The system bootup process is split up into discrete steps. To synchronize point during start-up, target units (files whose names end in .target) are used for grouping units. The bootup process is highly parallelized in each target so that the order in which specific target units are reached is not determined. The system-plugin-slp is an OAL plugin for configuration settings, such as the mount point (/etc/fstab).\n\nThe following figure shows the early boot sequence after starting the kernel.\n\nFigure: Early boot sequence\n\n\n\n\n  \n    sysinit.target\n\n    Special target unit for early boot-up scripts. It has dependencies on necessary services and targets, such as local-fs.target. At this point, most of the file systems, such as /opt, /tmp, and /media, are mounted and the systemd-related daemons, such as systemd-journald, are launched.\n  \n  \n    basic.target\n\n    Special target unit for basic bootup. At this point, all necessary initialization for general purpose daemons, such as mount points, sockets, timers, and path units, is completed. Tizen-specific services (such as vconf-setup and tizen-debug-level) are also executed.\n  \n  \n    bootmode.target\n\n    Special target unit for selecting the boot mode. If the kernel boot parameter (/proc/cmdline) has the charger_detect_boot option passed by a boot loader, such as uboot, the platform boots up in charging mode. In this mode, the system enters the low power mode and charges the battery. If the charger_detect_boot option is not included as a kernel boot parameter, a normal boot is started.\n  \n\n\nThe following figure shows the overview of normal booting sequence in Tizen platform.\n\nFigure: Tizen platform boot sequence\n\n\n\n\n  \n    multi-user.target\n\n    Special target unit for setting up a multi-user system with non-graphical support. On the Tizen platform, this target is used for launching platform infrastructure daemons, such as dbus (system session), power manager, GPS manager, telephony daemon, WRT (Web Run Time) security daemon, and the media server. Some systemd-related daemons (such as systemd-logind) are also started in this phase.\n  \n  \n    graphical.target\n\n    Special target unit for setting up a graphical environment. Some important daemons (such as the access control and OMA DS agent servers) that must have root permission are launched at this point. The Tizen platform uses the systemd user session for App privilege daemons. Some daemons related to the graphics system, such as Enlightenment (window manager), are launched with the App privilege in this phase. The Tizen platform has its special target for middleware and mobile service: tizen-middleware.target starts the platform service daemons, such as calendar, contacts, email, message, sound, and download provider. tizen-mobile-session.target starts some service daemons related with the mobile session.\n  \n\n\nBSP Customization\n\nThis section covers the basic configuration, setup, and build procedure required for building the boot loader and the kernel image for ARM.\n\nBoot Loader\n\nThe boot loader is a small piece of software that is needed to perform the basic hardware and peripheral initialization and load the kernel and proper device tree binary for the device to RAM. For the Tizen platform, the boot loader comes in 2 parts, the primary boot loader and the secondary boot loader. The primary boot loader is proprietary, and the secondary boot loader is the open source u-boot, customized for the Tizen platform.\n\nIf your platform is already loaded with the compatible boot loader software, you can skip this section and move directly to the kernel section.\n\nBoot Loader Setup and Build\n\nTo build the Tizen TM1 boot loader:\n\n\n  Install and set up cross-compile tools on your system if the host has a different architecture than the target (such as x86).\n  Start with cleaning up the u-boot-tm1 source. Download the source from the u-boot-tm1 repository.\n    $ make distclean`\n    \n  \n  Set up the configuration for TM1.\n  Build u-boot:\n    $ make ARCH=arm\n    \n  \n  Once the build is successful, the u-boot.bin file is created. (This step is for preventing from flashing the other u-boot.bin file.)\n    $ tools/mkimage_signed.sh u-boot.bin \"tizen_tm1\"\n    \n\n    After the script is run, the u-boot-mmc.bin file is created.\n  \n  Create a boot loader tarball to download the u-boot binary onto the target.\n    $ tar cvf bootloader.tar u-boot-mmc.bin`\n    \n    \n      Note\n\n      Be careful when modifying the boot loader: incorrect configuration can damage the device permanently.\n    \n  \n\n\nBoot Loader Kernel Parameters\n\nCommand line parameters, such as the following example, can be passed from the boot loader to the Linux kernel:\n\nconsole=ttyS1,115200n8\nmem=1024M\nloglevel=1\n\n\nKernel\n\nThe kernel is the operating system that drives the platform. In this case, the kernel refers to the open source Linux kernel that is customized for the Tizen platform. The following section gives a brief overview about the Tizen kernel setup, configuration, and the build procedure for building a Linux kernel for your Tizen platform. The output of the kernel binary is a uImage that is suitable only for a u-boot boot loader. If you have chosen a secure booting configuration in your boot loader, this uImage must be compatible with your boot loader.\n\nKernel Configurations\n\nTo download the Tizen kernel source package, see Getting Source Code and Build. To set up or modify your kernel configuration, use the appropriate defconfig file from arch/arm/configs/ (ARM CPU).\n\nFor more information on the Tizen kernel configuration and kernel building, see Kernel Build.\n\n\n  Note\n\n  Tizen uses INOTIFY instead of DNOTIFY. You must disable DNOTIFY from your kernel configuration.\n\n\nIf you want to use initramfs, you can use these configurations:\n\n\n  CONFIG_INITRAMFS_SOURCE\n  CONFIG_INITRAMFS_ROOT_UID\n  CONFIG_INITRAMFS_ROOT_GID\n  CONFIG_INITRAMFS_COMPRESSION_NONE/GZIP/BZIP2/LZNA/LZO\n\n\nTizen File System\n\nVirtual Filesystem (VFS)\n\nThe virtual file system (VFS) is an abstraction layer on top of a physical file system (such as ext2, jfs, and ext4). The VFS provides a switching layer between the SCI (system call interface) and the file systems supported by the kernel, as shown in the following figure.\n\nFigure: Tizen file system\n\n\n\nAt the top of the VFS is a common API abstraction of functions, such as open, close, read, and write. At the bottom of the VFS are the file system abstractions that define how the upper-layer functions are implemented with respect to a specific file system.\n\nBelow the file system layer is the page cache, which provides a common set of functions to the file system layer (independent of any particular file system). This caching layer optimizes access to the physical devices by keeping data around for a short time (or speculatively reading ahead, so that the data is available when needed). Below the page cache are the device drivers, which implement the interface for the particular physical device.\n\nTizen Partition Layout\n\nThe following description is an example of the Tizen partition layout. The product vendor can modify the sequence or partition layout for their devices, as needed.\n\nFigure: Tizen partition layout\n\n\n\nThe boot partition is mounted in the /boot directory of rootfs. Here s-boot, u-boot, and the kernel image are saved as a file format, provided as system.tar.\n\n\n  The CSA (Configuration Saved Area) partition is for non-volatile data, such as the calibration value of modem.\n  The boot partition includes the kernel image, boot loader image, and modem image. Additionally, it can have device driver modules.\n  Third partition is reserved for the future.\n  The CSC (Customer Software Configuration) partition is mounted in the /mnt/csc directory. It can store the customer’s software configuration, such as the default language and time zone.\n  The platform partition is mounted on the root directory. It contains fundamental frameworks for Tizen and some general utility for Linux. It can be provided as a platform.img file.\n  The data partition is mounted in the /opt directory and it includes applications, libraries of applications, and the platform database. It can be provided as a data.img file.\n  The UMS (USB Mass Storage) partition is mounted in the /opt/media directory and it includes default (media) contents. It can be provided as ums.img.\n\n\nEach image file, platform.img, data.img, and ums.img can be zipped for downloading, for example, &lt;IMAGE_NAME&gt;.tar.gz.\n\nEach partition has the hierarchy illustrated in the following figure.\n\nFigure: Tizen file system hierarchy\n\n\n\nSupported File Systems\n\nTizen supports the Extended 4 (ext4) file system. The Tizen kernel has to be compiled to enable support for other file systems, such as JFS, XFS, BTRFS, and Reiserfs.\n\nThe Extended 4 (ext4) file system is configured as a default file system for Tizen.\n\nConfiguration\n\nThe following ext4 configuration options can be enabled in the kernel configuration file:\n\n\n  CONFIG_EXT4_FS=y\n  CONFIG_EXT4_FS_XATTR=y\n  CONFIG_EXT4_USE_FOR_EXT23=y\n  CONFIG_EXT4_FS_SECURITY=y\n\n\nMMC/SD/SDIO\n\nTizen supports MultiMediaCard, Secure Digital, and Secure Digital I/O Support. The MMC driver is implemented on top of a host controller (such as the SDHCI controller driver) and supports MMC, SD, SD High Speed, and SDHC cards.\n\nIf MMC is your booting device, read-write APIs, partition management, and flashing must be provided at the boot loader.\n\nFigure: Tizen MMC architecture\n\n\n\nThe MMC/SD/SDIO driver supports the following features:\n\n\n  Driver is built in-kernel\n  MMC cards, including high speed cards\n  SD cards, including SD high speed and SDHC cards\n\n\nThe MMC subsystem code structure in the kernel is located at /driver/mmc and divided into 3 parts:\n\n\n  MMC block device driver located at /driver/mmc/card/\n  Protocol stack for MMC, SD, SDIO located at /driver/mmc/core/\n  Host controller driver located at /driver/mmc/host/\n\n\nHotplug MMC Event Handling\n\nBased on the hotplug event handling, a notification is passed to deviced for device status changes. It detects, mounts, and monitors the status of the SD card.\n\nReference\n\nThe SDHCI controller is supported in the MMC/SD/SDIO interface. The Mobile Storage Host controller is only supported in the MMC interface.\n\n\n  \n    Kernel configuration for MMC Interface\n\n    CONFIG_MMC_BLOCK, CONFIG_MMC, CONFIG_MSHCI (for Mobile Storage Interface enable)\nsys interface: /dev/mmcblk0pX\n  \n  \n    Kernel configuration for SD/SDIO Interface\n\n    CONFIG_MMC_BLOCK, CONFIG_MMC\nCONFIG_MMC_SDHCI (for SDHCI host Interface enable)\nCONFIG_MMC_SDHCI_S3C (for Samsung SoC)\nsys interface: /dev/mmcblk1pX\n  \n\n\nThe X denotes the MMC partition number. Details of the partition mount point for Tizen are covered under Tizen Partition Layout."
					}
					
				
			
		
			
				
					,
					
					"application-porting-location": {
						"id": "application-porting-location",
						"title": "Location",
						"categories": "",
						"url": " application/porting/location/",
						"content": "Location\n\nThe Location framework provides location-based services (LBS), including the position information, satellite information and GPS status.\n\nYou can use the following location features:\n\n\n  Getting the current position, last known position, accuracy, distance, and velocity of the device\n  Getting satellite information from GPS and GLONASS\n  Notifying a user when they enter or exit a predefined set of boundaries, known as geofence, like school attendance zones or neighborhood boundaries\n\n\nFigure: Tizen location architecture\n\n\n\nThe main location service components are:\n\n\n  Location framework\n  Location manager\n  Location library, which contains the location providers that can be used by the location manager to get services\n  GPS (global positioning system), which provides position information, velocity, and satellite information. It is used to get the current position of a device.\n  dbus, which is the IPC used to communicate between the location module and the Location daemon.\n  lbs-server, which provides position, velocity, NMEA, and satellite information by communicating with a GPS chip. It has the following functionalities:\n    \n      Initializes and deinitializes the GPS, opens and closes GPS applications.\n      Provides the position result for the location library.\n      Manages location sessions; determines session termination based on session status.\n      Provides a serial interface with the GPS receiver.\n      Enables the GPS chipset to support standalone GPS positioning methods.\n      Supports the standalone operation mode.\n    \n  \n\n\nPorting the OAL Interface\n\nThe GPS plugin is implemented for vendor-specific GPS devices based on the Tizen lbs-server. The GPS plugin is implemented as a shared library and the lbs-server loads a specific GPS plugin at runtime. A GPS plugin must be written with predefined interfaces.\n\nThe lbs-server-plugin-dev source package is installed on OBS by adding the following command in the package spec file:\n\nBuildRequires: pkgconfig(lbs-server-plugin)\n\n\nThe lbs-server-plugin-dev package source files can be found in the following directories:\n\n/usr/include/lbs-server-plugin/*.h\n/usr/lib/pkgconfig/lbs-server-plugin.pc\n\n\nThe gps_plugin_intf.h header file includes the API interfaces for the communication between the lbs-server and its GPS plugin.\n\ntypedef struct {\n    /* Initialize the plugin module and register callback function for event delivery */\n    int (*init) (gps_event_cb gps_event_cb, void *user_data);\n    /* Deinitialize the plugin module */\n    int (*deinit) (gps_failure_reason_t *reason_code);\n    /* Request specific action to plugin module */\n    int (*request) (gps_action_t gps_action, void *gps_action_data, gps_failure_reason_t *reason_code);\n} gps_plugin_interface;\n\n\nconst gps_plugin_interface *get_gps_plugin_interface();\n\n\nThe get_gps_plugin_interface() function must be exported in the GPS plugin. It gives the gps_plugin_interface structure to the lbs-server, and the lbs-server communicates through these interfaces. When the lbs-server is started, the GPS plugin is loaded and the init() function is called. At this moment, a GPS device must be initialized.\n\nint (*init) (gps_event_cb gps_event_cb, void *user_data);\n\n\nWhen the init() function is called, the gps_event_cb callback is set. GPS events and data from a GPS device are delivered through the callback.\n\ntypedef int (*gps_event_cb) (gps_event_info_t *gps_event_info, void *user_data);\n\n\nThe following example describes the GPS events:\n\ntypedef enum {\n    GPS_EVENT_START_SESSION = 0x0000, /* The session is started */\n    GPS_EVENT_STOP_SESSION, /* The session is stopped */\n    GPS_EVENT_CHANGE_INTERVAL, /* Change updating interval */\n    GPS_EVENT_REPORT_POSITION = 0x0100, /* Bring up GPS position data */\n    GPS_EVENT_REPORT_SATELLITE, /* Bring up GPS SV data */\n    GPS_EVENT_REPORT_NMEA, /* Bring up GPS NMEA data */\n    GPS_EVENT_SET_OPTION = 0x0200, /* The option is set */\n    GPS_EVENT_GET_REF_LOCATION = 0x0300, /* Get the reference location for AGPS */\n    GPS_EVENT_GET_IMSI, /* Get IMSI for identification */\n    GPS_EVENT_OPEN_DATA_CONNECTION = 0x0400, /* Request opening data network connection */\n    GPS_EVENT_CLOSE_DATA_CONNECTION, /* Request closing data network connection */\n    GPS_EVENT_DNS_LOOKUP_IND, /* Request resolving host name */\n    GPS_EVENT_AGPS_VERIFICATION_INDI, /* Verification indicator for AGPS is required */\n    GPS_EVENT_FACTORY_TEST = 0x0500,/* Factory test is done */\n    GPS_EVENT_ERR_CAUSE = 0xFFFF /* Some error is occurred */\n} gps_event_id_t;\n\n\nThe GPS events contain specific GPS event data which is part of the delivered gps_event_data_t (see the gps_plugin_intf.h file). When the lbs-server wants to make a request to a GPS device, the request() function is called:\n\nint (*request) (gps_action_t gps_action, void *gps_action_data, gps_failure_reason_t *reason_code);\n\n\nEach request is classified by gps_action_t.\n\ntypedef enum {\n    GPS_ACTION_SEND_PARAMS = 0x00,\n    GPS_ACTION_START_SESSION,\n    GPS_ACTION_STOP_SESSION,\n    GPS_ACTION_CHANGE_INTERVAL,\n    GPS_INDI_SUPL_VERIFICATION,\n    GPS_INDI_SUPL_DNSQUERY,\n    GPS_ACTION_START_FACTTEST,\n    GPS_ACTION_STOP_FACTTEST,\n    GPS_ACTION_REQUEST_SUPL_NI,\n    GPS_ACTION_DELETE_GPS_DATA,\n} gps_action_t;\n\n\nWith the standalone GPS (unassisted GPS), the GPS_ACTION_START_SESSION and GPS_ACTION_STOP_SESSION are mandatory actions. If the GPS_ACTION_START_SESSION is delivered, the GPS plugin starts the acquisition of satellites and reports the GPS_EVENT_START_SESSION event to the lbs-server through the gps_event_cb callback. Once the acquisition is completed and position is fixed, the position must be delivered by the gps_event_cb callback with the GPS_EVENT_REPORT_POSITION event ID and the position data.\n\nTo shut down the lbs-server, deinitialize the GPS device with the deinit() function:\n\nint (*deinit) (gps_failure_reason_t *reason_code);\n\n\nAdding a new GPS plugin\n\nThe check_plugin_module(char* module_name) function checks the access to the available plugin in the /sys/devices/platform directory and the load_plugin_module loads the plugin during the boot up time.\n\nAdd the necessary path definitions:\n\n#define PLATFORM_PATH \"/sys/devices/platform\"\n#define PLUGIN_PATH PLATFORM_PATH\"/xxxxx_gps\"\n\n\nGeofence\n\nThe Geofence Manager API provides a service related to geofence. A geofence is a virtual perimeter for a real-world geographic area.\n\nFigure: Tizen geofence architecture\n\n\n\nYou can set a geofence based on a geopoint, a Wi-Fi MAC address, or a Bluetooth address. Notifications are provided for events, such as changes in the service status.\n\nThere are 2 kinds of places and fences:\n\n\n  Public places and fences that are created by the MyPlace application can be used by all applications.\n  Private places and fences that are created by a specific application can only be used by that same application.\n\n\nNotifications can be received about the following events:\n\n\n  Zone in event when a device enters a specific area\n  Zone out event when a device exits a specific area\n  Results and errors for each event requested by the geofence module\n\n\nMap Service\n\nThe Location Maps API (Maps API) allows you to create map-aware applications.\n\nFigure: Tizen Maps API\n\n\n\nThe Maps API has the following features:\n\n\n  Geocoder (geocoding and reverse geocoding)\n  Places (search places)\n  Routes (search directions)\n  Map Widget (rendering map images)\n\n\nThe Maps API allows you to select a map service provider to be included in the plugins.\n\nPorting the OAL Interface\n\nThe Maps plugin is implemented as a shared library and the Maps framework loads a specific Maps plugin at runtime. A Maps plugin must be written with predefined interfaces.\n\nThe capi-maps-service-plugin-devel source package is installed on OBS by adding the following command in the package specification file:\n\nBuildRequires: pkgconfig(capi-maps-service-plugin-devel)\n\n\nThe capi-maps-service-plugin-devel package source files can be found in the following directories:\n\n/usr/include/maps/maps_plugin*.h\n/usr/include/maps/maps_*_plugin.h\n/usr/include/maps/maps_extra_types.h\n\n\nThe module.h header file includes the API interfaces for the communication between the Maps and its plugin.\n\ntypedef struct _interface_s {\n    /* Plugin dedicated functions */\n    maps_plugin_init_f maps_plugin_init;\n    maps_plugin_shutdown_f maps_plugin_shutdown;\n    maps_plugin_get_info_f maps_plugin_get_info;\n    maps_plugin_init_module_f maps_plugin_init_module;\n\n    /* Maps Provider access key, preference, and capabilities */\n    maps_plugin_set_provider_key_f maps_plugin_set_provider_key;\n    maps_plugin_get_provider_key_f maps_plugin_get_provider_key;\n    maps_plugin_set_preference_f maps_plugin_set_preference;\n    maps_plugin_get_preference_f maps_plugin_get_preference;\n    maps_plugin_is_service_supported_f maps_plugin_is_service_supported;\n    maps_plugin_is_data_supported_f maps_plugin_is_data_supported;\n\n    /* Geocode */\n    maps_plugin_geocode_f maps_plugin_geocode;\n    maps_plugin_geocode_inside_area_f maps_plugin_geocode_inside_area;\n    maps_plugin_geocode_by_structured_address_f maps_plugin_geocode_by_structured_address;\n    maps_plugin_reverse_geocode_f maps_plugin_reverse_geocode;\n    maps_plugin_multi_reverse_geocode_f maps_plugin_multi_reverse_geocode;\n\n    /* Place */\n    maps_plugin_search_place_f maps_plugin_search_place;\n    maps_plugin_search_place_by_area_f maps_plugin_search_place_by_area;\n    maps_plugin_search_place_by_address_f maps_plugin_search_place_by_address;\n    maps_plugin_search_place_list_f maps_plugin_search_place_list;\n    maps_plugin_get_place_details_f maps_plugin_get_place_details;\n\n    /* Route */\n    maps_plugin_search_route_f maps_plugin_search_route;\n    maps_plugin_search_route_waypoints_f maps_plugin_search_route_waypoints;\n\n    /* Cancel request */\n    maps_plugin_cancel_request_f maps_plugin_cancel_request;\n\n    /* Mapping */\n    maps_plugin_create_map_view_f maps_plugin_create_map_view;\n    maps_plugin_destroy_map_view_f maps_plugin_destroy_map_view;\n    maps_plugin_render_map_f maps_plugin_render_map;\n    maps_plugin_move_center_f maps_plugin_move_center;\n    maps_plugin_set_scalebar_f maps_plugin_set_scalebar;\n    maps_plugin_get_scalebar_f maps_plugin_get_scalebar;\n    maps_plugin_on_object_f maps_plugin_on_object;\n    maps_plugin_screen_to_geography_f maps_plugin_screen_to_geography;\n    maps_plugin_geography_to_screen_f maps_plugin_geography_to_screen;\n    maps_plugin_get_min_zoom_level_f maps_plugin_get_min_zoom_level;\n    maps_plugin_get_max_zoom_level_f maps_plugin_get_max_zoom_level;\n    maps_plugin_get_center_f maps_plugin_get_center;\n    maps_plugin_capture_snapshot_f maps_plugin_capture_snapshot;\n} interface_s;\n\n\nThese functions must be implemented and exported in the Maps plugin. To create a Maps handle classified by a provider name string, the maps_plugin_get_info() function must provide the name. The name is recommended to be capitalized.\n\nThe Maps plugins are located in the /usr/lib/maps/plugins directory.\n\nHERE Maps Plugin\n\nFor now, the HERE Maps plugin is embedded in the platform, with the provider name “HERE”. To use this plugin, you must get the credential keys from the HERE developers site. You may need to pay a fee depending on the expected map service usage.\n\nTo get the user consent required by HERE, a user consent application included in the HERE Maps plugin is launched the first time the user attempts to access the map services, if consent has not been given before that time."
					}
					
				
			
		
			
				
					,
					
					"platform-porting-location": {
						"id": "platform-porting-location",
						"title": "Location",
						"categories": "",
						"url": " platform/porting/location/",
						"content": "Location\n\nThe Location framework provides location-based services (LBS), including the position information, satellite information and GPS status.\n\nYou can use the following location features:\n\n\n  Getting the current position, last known position, accuracy, distance, and velocity of the device\n  Getting satellite information from GPS and GLONASS\n  Notifying a user when they enter or exit a predefined set of boundaries, known as geofence, like school attendance zones or neighborhood boundaries\n\n\nFigure: Tizen location architecture\n\n\n\nThe main location service components are:\n\n\n  Location framework\n  Location manager\n  Location library, which contains the location providers that can be used by the location manager to get services\n  GPS (global positioning system), which provides position information, velocity, and satellite information. It is used to get the current position of a device.\n  dbus, which is the IPC used to communicate between the location module and the Location daemon.\n  lbs-server, which provides position, velocity, NMEA, and satellite information by communicating with a GPS chip. It has the following functionalities:\n    \n      Initializes and deinitializes the GPS, opens and closes GPS applications.\n      Provides the position result for the location library.\n      Manages location sessions; determines session termination based on session status.\n      Provides a serial interface with the GPS receiver.\n      Enables the GPS chipset to support standalone GPS positioning methods.\n      Supports the standalone operation mode.\n    \n  \n\n\nPorting the OAL Interface\n\nThe GPS plugin is implemented for vendor-specific GPS devices based on the Tizen lbs-server. The GPS plugin is implemented as a shared library and the lbs-server loads a specific GPS plugin at runtime. A GPS plugin must be written with predefined interfaces.\n\nThe lbs-server-plugin-dev source package is installed on OBS by adding the following command in the package spec file:\n\nBuildRequires: pkgconfig(lbs-server-plugin)\n\n\nThe lbs-server-plugin-dev package source files can be found in the following directories:\n\n/usr/include/lbs-server-plugin/*.h\n/usr/lib/pkgconfig/lbs-server-plugin.pc\n\n\nThe gps_plugin_intf.h header file includes the API interfaces for the communication between the lbs-server and its GPS plugin.\n\ntypedef struct {\n    /* Initialize the plugin module and register callback function for event delivery */\n    int (*init) (gps_event_cb gps_event_cb, void *user_data);\n    /* Deinitialize the plugin module */\n    int (*deinit) (gps_failure_reason_t *reason_code);\n    /* Request specific action to plugin module */\n    int (*request) (gps_action_t gps_action, void *gps_action_data, gps_failure_reason_t *reason_code);\n} gps_plugin_interface;\n\n\nconst gps_plugin_interface *get_gps_plugin_interface();\n\n\nThe get_gps_plugin_interface() function must be exported in the GPS plugin. It gives the gps_plugin_interface structure to the lbs-server, and the lbs-server communicates through these interfaces. When the lbs-server is started, the GPS plugin is loaded and the init() function is called. At this moment, a GPS device must be initialized.\n\nint (*init) (gps_event_cb gps_event_cb, void *user_data);\n\n\nWhen the init() function is called, the gps_event_cb callback is set. GPS events and data from a GPS device are delivered through the callback.\n\ntypedef int (*gps_event_cb) (gps_event_info_t *gps_event_info, void *user_data);\n\n\nThe following example describes the GPS events:\n\ntypedef enum {\n    GPS_EVENT_START_SESSION = 0x0000, /* The session is started */\n    GPS_EVENT_STOP_SESSION, /* The session is stopped */\n    GPS_EVENT_CHANGE_INTERVAL, /* Change updating interval */\n    GPS_EVENT_REPORT_POSITION = 0x0100, /* Bring up GPS position data */\n    GPS_EVENT_REPORT_SATELLITE, /* Bring up GPS SV data */\n    GPS_EVENT_REPORT_NMEA, /* Bring up GPS NMEA data */\n    GPS_EVENT_SET_OPTION = 0x0200, /* The option is set */\n    GPS_EVENT_GET_REF_LOCATION = 0x0300, /* Get the reference location for AGPS */\n    GPS_EVENT_GET_IMSI, /* Get IMSI for identification */\n    GPS_EVENT_OPEN_DATA_CONNECTION = 0x0400, /* Request opening data network connection */\n    GPS_EVENT_CLOSE_DATA_CONNECTION, /* Request closing data network connection */\n    GPS_EVENT_DNS_LOOKUP_IND, /* Request resolving host name */\n    GPS_EVENT_AGPS_VERIFICATION_INDI, /* Verification indicator for AGPS is required */\n    GPS_EVENT_FACTORY_TEST = 0x0500,/* Factory test is done */\n    GPS_EVENT_ERR_CAUSE = 0xFFFF /* Some error is occurred */\n} gps_event_id_t;\n\n\nThe GPS events contain specific GPS event data which is part of the delivered gps_event_data_t (see the gps_plugin_intf.h file). When the lbs-server wants to make a request to a GPS device, the request() function is called:\n\nint (*request) (gps_action_t gps_action, void *gps_action_data, gps_failure_reason_t *reason_code);\n\n\nEach request is classified by gps_action_t.\n\ntypedef enum {\n    GPS_ACTION_SEND_PARAMS = 0x00,\n    GPS_ACTION_START_SESSION,\n    GPS_ACTION_STOP_SESSION,\n    GPS_ACTION_CHANGE_INTERVAL,\n    GPS_INDI_SUPL_VERIFICATION,\n    GPS_INDI_SUPL_DNSQUERY,\n    GPS_ACTION_START_FACTTEST,\n    GPS_ACTION_STOP_FACTTEST,\n    GPS_ACTION_REQUEST_SUPL_NI,\n    GPS_ACTION_DELETE_GPS_DATA,\n} gps_action_t;\n\n\nWith the standalone GPS (unassisted GPS), the GPS_ACTION_START_SESSION and GPS_ACTION_STOP_SESSION are mandatory actions. If the GPS_ACTION_START_SESSION is delivered, the GPS plugin starts the acquisition of satellites and reports the GPS_EVENT_START_SESSION event to the lbs-server through the gps_event_cb callback. Once the acquisition is completed and position is fixed, the position must be delivered by the gps_event_cb callback with the GPS_EVENT_REPORT_POSITION event ID and the position data.\n\nTo shut down the lbs-server, deinitialize the GPS device with the deinit() function:\n\nint (*deinit) (gps_failure_reason_t *reason_code);\n\n\nAdding a new GPS plugin\n\nThe check_plugin_module(char* module_name) function checks the access to the available plugin in the /sys/devices/platform directory and the load_plugin_module loads the plugin during the boot up time.\n\nAdd the necessary path definitions:\n\n#define PLATFORM_PATH \"/sys/devices/platform\"\n#define PLUGIN_PATH PLATFORM_PATH\"/xxxxx_gps\"\n\n\nGeofence\n\nThe Geofence Manager API provides a service related to geofence. A geofence is a virtual perimeter for a real-world geographic area.\n\nFigure: Tizen geofence architecture\n\n\n\nYou can set a geofence based on a geopoint, a Wi-Fi MAC address, or a Bluetooth address. Notifications are provided for events, such as changes in the service status.\n\nThere are 2 kinds of places and fences:\n\n\n  Public places and fences that are created by the MyPlace application can be used by all applications.\n  Private places and fences that are created by a specific application can only be used by that same application.\n\n\nNotifications can be received about the following events:\n\n\n  Zone in event when a device enters a specific area\n  Zone out event when a device exits a specific area\n  Results and errors for each event requested by the geofence module\n\n\nMap Service\n\nThe Location Maps API (Maps API) allows you to create map-aware applications.\n\nFigure: Tizen Maps API\n\n\n\nThe Maps API has the following features:\n\n\n  Geocoder (geocoding and reverse geocoding)\n  Places (search places)\n  Routes (search directions)\n  Map Widget (rendering map images)\n\n\nThe Maps API allows you to select a map service provider to be included in the plugins.\n\nPorting the OAL Interface\n\nThe Maps plugin is implemented as a shared library and the Maps framework loads a specific Maps plugin at runtime. A Maps plugin must be written with predefined interfaces.\n\nThe capi-maps-service-plugin-devel source package is installed on OBS by adding the following command in the package specification file:\n\nBuildRequires: pkgconfig(capi-maps-service-plugin-devel)\n\n\nThe capi-maps-service-plugin-devel package source files can be found in the following directories:\n\n/usr/include/maps/maps_plugin*.h\n/usr/include/maps/maps_*_plugin.h\n/usr/include/maps/maps_extra_types.h\n\n\nThe module.h header file includes the API interfaces for the communication between the Maps and its plugin.\n\ntypedef struct _interface_s {\n    /* Plugin dedicated functions */\n    maps_plugin_init_f maps_plugin_init;\n    maps_plugin_shutdown_f maps_plugin_shutdown;\n    maps_plugin_get_info_f maps_plugin_get_info;\n    maps_plugin_init_module_f maps_plugin_init_module;\n\n    /* Maps Provider access key, preference, and capabilities */\n    maps_plugin_set_provider_key_f maps_plugin_set_provider_key;\n    maps_plugin_get_provider_key_f maps_plugin_get_provider_key;\n    maps_plugin_set_preference_f maps_plugin_set_preference;\n    maps_plugin_get_preference_f maps_plugin_get_preference;\n    maps_plugin_is_service_supported_f maps_plugin_is_service_supported;\n    maps_plugin_is_data_supported_f maps_plugin_is_data_supported;\n\n    /* Geocode */\n    maps_plugin_geocode_f maps_plugin_geocode;\n    maps_plugin_geocode_inside_area_f maps_plugin_geocode_inside_area;\n    maps_plugin_geocode_by_structured_address_f maps_plugin_geocode_by_structured_address;\n    maps_plugin_reverse_geocode_f maps_plugin_reverse_geocode;\n    maps_plugin_multi_reverse_geocode_f maps_plugin_multi_reverse_geocode;\n\n    /* Place */\n    maps_plugin_search_place_f maps_plugin_search_place;\n    maps_plugin_search_place_by_area_f maps_plugin_search_place_by_area;\n    maps_plugin_search_place_by_address_f maps_plugin_search_place_by_address;\n    maps_plugin_search_place_list_f maps_plugin_search_place_list;\n    maps_plugin_get_place_details_f maps_plugin_get_place_details;\n\n    /* Route */\n    maps_plugin_search_route_f maps_plugin_search_route;\n    maps_plugin_search_route_waypoints_f maps_plugin_search_route_waypoints;\n\n    /* Cancel request */\n    maps_plugin_cancel_request_f maps_plugin_cancel_request;\n\n    /* Mapping */\n    maps_plugin_create_map_view_f maps_plugin_create_map_view;\n    maps_plugin_destroy_map_view_f maps_plugin_destroy_map_view;\n    maps_plugin_render_map_f maps_plugin_render_map;\n    maps_plugin_move_center_f maps_plugin_move_center;\n    maps_plugin_set_scalebar_f maps_plugin_set_scalebar;\n    maps_plugin_get_scalebar_f maps_plugin_get_scalebar;\n    maps_plugin_on_object_f maps_plugin_on_object;\n    maps_plugin_screen_to_geography_f maps_plugin_screen_to_geography;\n    maps_plugin_geography_to_screen_f maps_plugin_geography_to_screen;\n    maps_plugin_get_min_zoom_level_f maps_plugin_get_min_zoom_level;\n    maps_plugin_get_max_zoom_level_f maps_plugin_get_max_zoom_level;\n    maps_plugin_get_center_f maps_plugin_get_center;\n    maps_plugin_capture_snapshot_f maps_plugin_capture_snapshot;\n} interface_s;\n\n\nThese functions must be implemented and exported in the Maps plugin. To create a Maps handle classified by a provider name string, the maps_plugin_get_info() function must provide the name. The name is recommended to be capitalized.\n\nThe Maps plugins are located in the /usr/lib/maps/plugins directory.\n\nHERE Maps Plugin\n\nFor now, the HERE Maps plugin is embedded in the platform, with the provider name “HERE”. To use this plugin, you must get the credential keys from the HERE developers site. You may need to pay a fee depending on the expected map service usage.\n\nTo get the user consent required by HERE, a user consent application included in the HERE Maps plugin is launched the first time the user attempts to access the map services, if consent has not been given before that time."
					}
					
				
			
		
			
				
					,
					
					"iot-porting-location": {
						"id": "iot-porting-location",
						"title": "Location",
						"categories": "",
						"url": " iot/porting/location/",
						"content": "Location\n\nThe Location framework provides location-based services (LBS), including the position information, satellite information and GPS status.\n\nYou can use the following location features:\n\n\n  Getting the current position, last known position, accuracy, distance, and velocity of the device\n  Getting satellite information from GPS and GLONASS\n  Notifying a user when they enter or exit a predefined set of boundaries, known as geofence, like school attendance zones or neighborhood boundaries\n\n\nFigure: Tizen location architecture\n\n\n\nThe main location service components are:\n\n\n  Location framework\n  Location manager\n  Location library, which contains the location providers that can be used by the location manager to get services\n  GPS (global positioning system), which provides position information, velocity, and satellite information. It is used to get the current position of a device.\n  dbus, which is the IPC used to communicate between the location module and the Location daemon.\n  lbs-server, which provides position, velocity, NMEA, and satellite information by communicating with a GPS chip. It has the following functionalities:\n    \n      Initializes and deinitializes the GPS, opens and closes GPS applications.\n      Provides the position result for the location library.\n      Manages location sessions; determines session termination based on session status.\n      Provides a serial interface with the GPS receiver.\n      Enables the GPS chipset to support standalone GPS positioning methods.\n      Supports the standalone operation mode.\n    \n  \n\n\nPorting the OAL Interface\n\nThe GPS plugin is implemented for vendor-specific GPS devices based on the Tizen lbs-server. The GPS plugin is implemented as a shared library and the lbs-server loads a specific GPS plugin at runtime. A GPS plugin must be written with predefined interfaces.\n\nThe lbs-server-plugin-dev source package is installed on OBS by adding the following command in the package spec file:\n\nBuildRequires: pkgconfig(lbs-server-plugin)\n\n\nThe lbs-server-plugin-dev package source files can be found in the following directories:\n\n/usr/include/lbs-server-plugin/*.h\n/usr/lib/pkgconfig/lbs-server-plugin.pc\n\n\nThe gps_plugin_intf.h header file includes the API interfaces for the communication between the lbs-server and its GPS plugin.\n\ntypedef struct {\n    /* Initialize the plugin module and register callback function for event delivery */\n    int (*init) (gps_event_cb gps_event_cb, void *user_data);\n    /* Deinitialize the plugin module */\n    int (*deinit) (gps_failure_reason_t *reason_code);\n    /* Request specific action to plugin module */\n    int (*request) (gps_action_t gps_action, void *gps_action_data, gps_failure_reason_t *reason_code);\n} gps_plugin_interface;\n\n\nconst gps_plugin_interface *get_gps_plugin_interface();\n\n\nThe get_gps_plugin_interface() function must be exported in the GPS plugin. It gives the gps_plugin_interface structure to the lbs-server, and the lbs-server communicates through these interfaces. When the lbs-server is started, the GPS plugin is loaded and the init() function is called. At this moment, a GPS device must be initialized.\n\nint (*init) (gps_event_cb gps_event_cb, void *user_data);\n\n\nWhen the init() function is called, the gps_event_cb callback is set. GPS events and data from a GPS device are delivered through the callback.\n\ntypedef int (*gps_event_cb) (gps_event_info_t *gps_event_info, void *user_data);\n\n\nThe following example describes the GPS events:\n\ntypedef enum {\n    GPS_EVENT_START_SESSION = 0x0000, /* The session is started */\n    GPS_EVENT_STOP_SESSION, /* The session is stopped */\n    GPS_EVENT_CHANGE_INTERVAL, /* Change updating interval */\n    GPS_EVENT_REPORT_POSITION = 0x0100, /* Bring up GPS position data */\n    GPS_EVENT_REPORT_SATELLITE, /* Bring up GPS SV data */\n    GPS_EVENT_REPORT_NMEA, /* Bring up GPS NMEA data */\n    GPS_EVENT_SET_OPTION = 0x0200, /* The option is set */\n    GPS_EVENT_GET_REF_LOCATION = 0x0300, /* Get the reference location for AGPS */\n    GPS_EVENT_GET_IMSI, /* Get IMSI for identification */\n    GPS_EVENT_OPEN_DATA_CONNECTION = 0x0400, /* Request opening data network connection */\n    GPS_EVENT_CLOSE_DATA_CONNECTION, /* Request closing data network connection */\n    GPS_EVENT_DNS_LOOKUP_IND, /* Request resolving host name */\n    GPS_EVENT_AGPS_VERIFICATION_INDI, /* Verification indicator for AGPS is required */\n    GPS_EVENT_FACTORY_TEST = 0x0500,/* Factory test is done */\n    GPS_EVENT_ERR_CAUSE = 0xFFFF /* Some error is occurred */\n} gps_event_id_t;\n\n\nThe GPS events contain specific GPS event data which is part of the delivered gps_event_data_t (see the gps_plugin_intf.h file). When the lbs-server wants to make a request to a GPS device, the request() function is called:\n\nint (*request) (gps_action_t gps_action, void *gps_action_data, gps_failure_reason_t *reason_code);\n\n\nEach request is classified by gps_action_t.\n\ntypedef enum {\n    GPS_ACTION_SEND_PARAMS = 0x00,\n    GPS_ACTION_START_SESSION,\n    GPS_ACTION_STOP_SESSION,\n    GPS_ACTION_CHANGE_INTERVAL,\n    GPS_INDI_SUPL_VERIFICATION,\n    GPS_INDI_SUPL_DNSQUERY,\n    GPS_ACTION_START_FACTTEST,\n    GPS_ACTION_STOP_FACTTEST,\n    GPS_ACTION_REQUEST_SUPL_NI,\n    GPS_ACTION_DELETE_GPS_DATA,\n} gps_action_t;\n\n\nWith the standalone GPS (unassisted GPS), the GPS_ACTION_START_SESSION and GPS_ACTION_STOP_SESSION are mandatory actions. If the GPS_ACTION_START_SESSION is delivered, the GPS plugin starts the acquisition of satellites and reports the GPS_EVENT_START_SESSION event to the lbs-server through the gps_event_cb callback. Once the acquisition is completed and position is fixed, the position must be delivered by the gps_event_cb callback with the GPS_EVENT_REPORT_POSITION event ID and the position data.\n\nTo shut down the lbs-server, deinitialize the GPS device with the deinit() function:\n\nint (*deinit) (gps_failure_reason_t *reason_code);\n\n\nAdding a new GPS plugin\n\nThe check_plugin_module(char* module_name) function checks the access to the available plugin in the /sys/devices/platform directory and the load_plugin_module loads the plugin during the boot up time.\n\nAdd the necessary path definitions:\n\n#define PLATFORM_PATH \"/sys/devices/platform\"\n#define PLUGIN_PATH PLATFORM_PATH\"/xxxxx_gps\"\n\n\nGeofence\n\nThe Geofence Manager API provides a service related to geofence. A geofence is a virtual perimeter for a real-world geographic area.\n\nFigure: Tizen geofence architecture\n\n\n\nYou can set a geofence based on a geopoint, a Wi-Fi MAC address, or a Bluetooth address. Notifications are provided for events, such as changes in the service status.\n\nThere are 2 kinds of places and fences:\n\n\n  Public places and fences that are created by the MyPlace application can be used by all applications.\n  Private places and fences that are created by a specific application can only be used by that same application.\n\n\nNotifications can be received about the following events:\n\n\n  Zone in event when a device enters a specific area\n  Zone out event when a device exits a specific area\n  Results and errors for each event requested by the geofence module\n\n\nMap Service\n\nThe Location Maps API (Maps API) allows you to create map-aware applications.\n\nFigure: Tizen Maps API\n\n\n\nThe Maps API has the following features:\n\n\n  Geocoder (geocoding and reverse geocoding)\n  Places (search places)\n  Routes (search directions)\n  Map Widget (rendering map images)\n\n\nThe Maps API allows you to select a map service provider to be included in the plugins.\n\nPorting the OAL Interface\n\nThe Maps plugin is implemented as a shared library and the Maps framework loads a specific Maps plugin at runtime. A Maps plugin must be written with predefined interfaces.\n\nThe capi-maps-service-plugin-devel source package is installed on OBS by adding the following command in the package specification file:\n\nBuildRequires: pkgconfig(capi-maps-service-plugin-devel)\n\n\nThe capi-maps-service-plugin-devel package source files can be found in the following directories:\n\n/usr/include/maps/maps_plugin*.h\n/usr/include/maps/maps_*_plugin.h\n/usr/include/maps/maps_extra_types.h\n\n\nThe module.h header file includes the API interfaces for the communication between the Maps and its plugin.\n\ntypedef struct _interface_s {\n    /* Plugin dedicated functions */\n    maps_plugin_init_f maps_plugin_init;\n    maps_plugin_shutdown_f maps_plugin_shutdown;\n    maps_plugin_get_info_f maps_plugin_get_info;\n    maps_plugin_init_module_f maps_plugin_init_module;\n\n    /* Maps Provider access key, preference, and capabilities */\n    maps_plugin_set_provider_key_f maps_plugin_set_provider_key;\n    maps_plugin_get_provider_key_f maps_plugin_get_provider_key;\n    maps_plugin_set_preference_f maps_plugin_set_preference;\n    maps_plugin_get_preference_f maps_plugin_get_preference;\n    maps_plugin_is_service_supported_f maps_plugin_is_service_supported;\n    maps_plugin_is_data_supported_f maps_plugin_is_data_supported;\n\n    /* Geocode */\n    maps_plugin_geocode_f maps_plugin_geocode;\n    maps_plugin_geocode_inside_area_f maps_plugin_geocode_inside_area;\n    maps_plugin_geocode_by_structured_address_f maps_plugin_geocode_by_structured_address;\n    maps_plugin_reverse_geocode_f maps_plugin_reverse_geocode;\n    maps_plugin_multi_reverse_geocode_f maps_plugin_multi_reverse_geocode;\n\n    /* Place */\n    maps_plugin_search_place_f maps_plugin_search_place;\n    maps_plugin_search_place_by_area_f maps_plugin_search_place_by_area;\n    maps_plugin_search_place_by_address_f maps_plugin_search_place_by_address;\n    maps_plugin_search_place_list_f maps_plugin_search_place_list;\n    maps_plugin_get_place_details_f maps_plugin_get_place_details;\n\n    /* Route */\n    maps_plugin_search_route_f maps_plugin_search_route;\n    maps_plugin_search_route_waypoints_f maps_plugin_search_route_waypoints;\n\n    /* Cancel request */\n    maps_plugin_cancel_request_f maps_plugin_cancel_request;\n\n    /* Mapping */\n    maps_plugin_create_map_view_f maps_plugin_create_map_view;\n    maps_plugin_destroy_map_view_f maps_plugin_destroy_map_view;\n    maps_plugin_render_map_f maps_plugin_render_map;\n    maps_plugin_move_center_f maps_plugin_move_center;\n    maps_plugin_set_scalebar_f maps_plugin_set_scalebar;\n    maps_plugin_get_scalebar_f maps_plugin_get_scalebar;\n    maps_plugin_on_object_f maps_plugin_on_object;\n    maps_plugin_screen_to_geography_f maps_plugin_screen_to_geography;\n    maps_plugin_geography_to_screen_f maps_plugin_geography_to_screen;\n    maps_plugin_get_min_zoom_level_f maps_plugin_get_min_zoom_level;\n    maps_plugin_get_max_zoom_level_f maps_plugin_get_max_zoom_level;\n    maps_plugin_get_center_f maps_plugin_get_center;\n    maps_plugin_capture_snapshot_f maps_plugin_capture_snapshot;\n} interface_s;\n\n\nThese functions must be implemented and exported in the Maps plugin. To create a Maps handle classified by a provider name string, the maps_plugin_get_info() function must provide the name. The name is recommended to be capitalized.\n\nThe Maps plugins are located in the /usr/lib/maps/plugins directory.\n\nHERE Maps Plugin\n\nFor now, the HERE Maps plugin is embedded in the platform, with the provider name “HERE”. To use this plugin, you must get the credential keys from the HERE developers site. You may need to pay a fee depending on the expected map service usage.\n\nTo get the user consent required by HERE, a user consent application included in the HERE Maps plugin is launched the first time the user attempts to access the map services, if consent has not been given before that time."
					}
					
				
			
		
			
				
					,
					
					"tizenstudio-setup-mac": {
						"id": "tizenstudio-setup-mac",
						"title": "MacOS",
						"categories": "",
						"url": " tizenstudio/setup/mac/",
						"content": "Install Tizen Studio on MacOS\n\nThis page explains the process to download and install Tizen Studio on your development hardware.\n\nTo have the optimal installation experience, follow these steps chronologically:\n\n\n  System prerequisites\n    \n      Hardware requirements\n      Software requirements\n      Additional requirements\n    \n  \n  Setup OpenJDK in Macintosh\n  Launch installer\n  Verify installation\n\n\nSystem Prerequisites\n\nEnsure that the following system prerequisites are met:\n\nHardware Requirements\n\n\n  \n      CPU\n    Dual Core, 2Ghz or faster\n  \n  \n    Architecture\n    x64 only\n  \n  \n    Memory\n    3GB or more \n  \n  \n    Disk Space\n    6 GB or more \n  \n\n\nSoftware Requirements\n\n\n  \n\t  MacOSX\n  \n  \n    Version\n    10.13 (High Sierra)10.12 (Sierra)10.11 (El Captain)\n  \n  \n    Bit\n    64 bit only\n  \n\n\n\n  \n    Software\n    Download Link \n  \n  \n    Open JDK\n     Click to download \n  \n  \n    OpenJavaFX\n    Click to download\n  \n  \n    Tizen Studio setup file\n    Click to download     \n  \n\n\n\n  Note:\n\n  \n    Download the relevant version based on the target device operating system, for example: openjdk-10_osx-x64_bin.tar.gz.\n    Ensure that you download the JavaFX  SDK product only, for example: JavaFX Mac OS X SDK.\n  \n\n\nDisclaimer: The third party download links are subjected to change. Search and download the appropriate software.\n\nAdditional Requirements\n\n\n\n\nComponent\nRequirement\n\n\n\n\nPrerequisite packages (msgfmt) to build PO files\n\nOn the terminal prompt, type the following commands:\n$ brew install gettext\n$ brew link gettext -force\n$ which msgfmt\n/usr/local/bin/msgfmt\n\nNote\nTo install Homebrew, see theHomebrew documentation.\n\n\n\n\n\nSet Up Open JDK\n\nTo set up Open JDK, follow these steps:\n\n\n  Extract the downloaded openjdk-10_osx-x64_bin.tar.gz file at your preferred location.\n    \n      \n        Locate the jdk directory where you extracted the openjdk-10_osx-x64_bin.tar.gz file.\n\n        \n          Note:\n\n          The jdk directory is created as a result of extraction.\n        \n      \n    \n  \n  \n    Copy the jdk folder, paste it in the Library/Java/JavaVirtualMachines location.\n\n    \n      Note:\n\n      This is the system default location, for all JDK files.\n    \n  \n  Open terminal.\n  Type the java –version command to verify whether the OpenJDK version 10 is installed.\n    \n      Note:\n\n      If the OpenJDK version 10 is not installed, proceed with step 5.\n    \n  \n  Open the .profile or the .bash_profile file, add the export JAVA_HOME =/Library/Java/JavaVirtualMachines/jdk-10.jdk/Contents/Home line.\n  Type java –version command to verify whether the OpenJDK version 10 is installed.\n    \n      Note:\n\n      \n        In this installation guide, setting up OpenJDK is covered. However,  Oracle JDK versions until version 10 are also supported.\n        For Oracle JDK 10 installation steps, see the Oracle official site.\n        If you have installed Oracle JDK 10 or below already, you can skip the step.\n      \n    \n  \n\n\nLaunch Installer\n\nTo launch the installer, follow these steps:\n\n\n  Double click on the downloaded installer file web-ide_Tizen_Studio_x.x-64.dmg.\n    \n      Note:\n\n      x.x represents the latest version of Tizen Studio, for example:web-ide_Tizen_Studio_3.2-64.dmg.\n    \n  \n  Accept the software license.\n    \n      Note:\n\n      The license contains important legal notices for using Tizen Studio. Read it fully, and click Accept only if you agree with the license terms.\n    \n\n    \n  \n  \n    Click Browse and specify a new directory to set the SDK location and the data location.\n\n    \n\n    \n      Note:\n\n      If the new directory is valid, it shows no errors.\n    \n  \n  Click Install.\n  \n    Click Finish and close the installer.\n\n    \n    \n      Note:\n\n      \n        If you want to install additional platforms and tools, launch  Package Manager by selecting the Launch Package Manager check box and click Finish.\n        Use Tizen Studio Package Manager, to install and update additional tools.\n        For more information on the Package Manager, see Updating Tizen Studio.\n      \n    \n  \n\n\nVerify Installation\n\nTo verify whether the installation is successful or not, click Tizen Studio icon. The Tizen Studio startup window must appear."
					}
					
				
			
		
			
				
					,
					
					"application-reference-mic-mic-customize-image": {
						"id": "application-reference-mic-mic-customize-image",
						"title": "Customizing Images",
						"categories": "",
						"url": " application/reference/mic/mic-customize-image/",
						"content": "Customizing Images\n\nYou can customize your image by downloading and editing the kickstart file. For more information on kickstart, see Kickstart Options.\n\nSpecifying the Repository\n\nYou can specify which repository must be used to create a package, including a local repository.\n\nrepo --name=Tizen-main --baseurl=https://download.tizen.org/snapshots/trunk/common/@BUILD_ID@/repos/main/armv7l/packages/ --save  --ssl_verify=no\n\nrepo --name=Tizen-base --baseurl=https://download.tizen.org/snapshots/trunk/common/@BUILD_ID@/repos/base/armv7l/packages/ --save  --ssl_verify=no\n\nrepo --name=mylocal--baseurl=/local/repo/path/\n\n\nSpecifying the User and Password to Access the Repository\n\nIf remote repository access requires a password, you can specify the user and password for the repository in the .ks file:\n\nrepo --name=REPO-NAME --baseurl=https://username:passwd@yourrepo.com/ia32/packages/ --save  --ssl_verify=no\n\n\nAdding and Removing Packages\n\nYou can specify the packages which you plan to install in the %packages section of the .ks file. Packages can be specified by a group/pattern or by an individual package name. The definition of the group/pattern can be referred to in the repodata/*comps.xml or repodata/pattern.xml file, which are both released on the download server.\n\nThe %packages section is required to end with %end. Also, multiple %packages sections are allowed. Additionally, individual packages can be specified by using globs. For example:\n\n%packages\n...\n@Tizen Core            # add a group named Tizen Core, and all the packages in this group are added\ne17-*                  # add all the packages whose name starts with \"e17-\"\nkernel                 # add a kernel package\nnss-server.armv7hl     # add nss-server with arch armv7hl\n-passwd                # remove the package passwd\n...\n%end\n\n\nSpecifying the Post-scripts\n\nUse the following command:\n\nrpm -rebuilddb\n%end"
					}
					
				
			
		
			
				
					,
					
					"platform-reference-mic-mic-customize-image": {
						"id": "platform-reference-mic-mic-customize-image",
						"title": "Customizing Images",
						"categories": "",
						"url": " platform/reference/mic/mic-customize-image/",
						"content": "Customizing Images\n\nYou can customize your image by downloading and editing the kickstart file. For more information on kickstart, see Kickstart Options.\n\nSpecifying the Repository\n\nYou can specify which repository must be used to create a package, including a local repository.\n\nrepo --name=Tizen-main --baseurl=https://download.tizen.org/snapshots/trunk/common/@BUILD_ID@/repos/main/armv7l/packages/ --save  --ssl_verify=no\n\nrepo --name=Tizen-base --baseurl=https://download.tizen.org/snapshots/trunk/common/@BUILD_ID@/repos/base/armv7l/packages/ --save  --ssl_verify=no\n\nrepo --name=mylocal--baseurl=/local/repo/path/\n\n\nSpecifying the User and Password to Access the Repository\n\nIf remote repository access requires a password, you can specify the user and password for the repository in the .ks file:\n\nrepo --name=REPO-NAME --baseurl=https://username:passwd@yourrepo.com/ia32/packages/ --save  --ssl_verify=no\n\n\nAdding and Removing Packages\n\nYou can specify the packages which you plan to install in the %packages section of the .ks file. Packages can be specified by a group/pattern or by an individual package name. The definition of the group/pattern can be referred to in the repodata/*comps.xml or repodata/pattern.xml file, which are both released on the download server.\n\nThe %packages section is required to end with %end. Also, multiple %packages sections are allowed. Additionally, individual packages can be specified by using globs. For example:\n\n%packages\n...\n@Tizen Core            # add a group named Tizen Core, and all the packages in this group are added\ne17-*                  # add all the packages whose name starts with \"e17-\"\nkernel                 # add a kernel package\nnss-server.armv7hl     # add nss-server with arch armv7hl\n-passwd                # remove the package passwd\n...\n%end\n\n\nSpecifying the Post-scripts\n\nUse the following command:\n\nrpm -rebuilddb\n%end"
					}
					
				
			
		
			
				
					,
					
					"iot-reference-mic-mic-customize-image": {
						"id": "iot-reference-mic-mic-customize-image",
						"title": "Customizing Images",
						"categories": "",
						"url": " iot/reference/mic/mic-customize-image/",
						"content": "Customizing Images\n\nYou can customize your image by downloading and editing the kickstart file. For more information on kickstart, see Kickstart Options.\n\nSpecifying the Repository\n\nYou can specify which repository must be used to create a package, including a local repository.\n\nrepo --name=Tizen-main --baseurl=https://download.tizen.org/snapshots/trunk/common/@BUILD_ID@/repos/main/armv7l/packages/ --save  --ssl_verify=no\n\nrepo --name=Tizen-base --baseurl=https://download.tizen.org/snapshots/trunk/common/@BUILD_ID@/repos/base/armv7l/packages/ --save  --ssl_verify=no\n\nrepo --name=mylocal--baseurl=/local/repo/path/\n\n\nSpecifying the User and Password to Access the Repository\n\nIf remote repository access requires a password, you can specify the user and password for the repository in the .ks file:\n\nrepo --name=REPO-NAME --baseurl=https://username:passwd@yourrepo.com/ia32/packages/ --save  --ssl_verify=no\n\n\nAdding and Removing Packages\n\nYou can specify the packages which you plan to install in the %packages section of the .ks file. Packages can be specified by a group/pattern or by an individual package name. The definition of the group/pattern can be referred to in the repodata/*comps.xml or repodata/pattern.xml file, which are both released on the download server.\n\nThe %packages section is required to end with %end. Also, multiple %packages sections are allowed. Additionally, individual packages can be specified by using globs. For example:\n\n%packages\n...\n@Tizen Core            # add a group named Tizen Core, and all the packages in this group are added\ne17-*                  # add all the packages whose name starts with \"e17-\"\nkernel                 # add a kernel package\nnss-server.armv7hl     # add nss-server with arch armv7hl\n-passwd                # remove the package passwd\n...\n%end\n\n\nSpecifying the Post-scripts\n\nUse the following command:\n\nrpm -rebuilddb\n%end"
					}
					
				
			
		
			
				
					,
					
					"application-reference-mic-mic-faq": {
						"id": "application-reference-mic-mic-faq",
						"title": "MIC Frequently Asked Questions",
						"categories": "",
						"url": " application/reference/mic/mic-faq/",
						"content": "MIC Frequently Asked Questions\n\nQ: When creating an image, MIC shows “Error &lt;creator&gt;: URLGrabber error: http://www.example.com/latest/repos/oss/ia32/packages/repodata/repomd.xml”. What does it mean?\n\nA: Your network can have some issues, or your proxy does not work. Try another proxy and check the network status.\n\nQ: MIC shows “Error &lt;repository&gt;: found 1 resolver problem, abort!” What does it mean?\n\nA: This is not an issue with MIC, but with the repository you used. Make sure the packages in the used repository have proper dependencies. Try using the repository under the release folder, instead of the snapshot folder.\n\nQ: I used -A i586 to create an i586 image, but MIC showed “nothing provided ….”. What is wrong?\n\nA: Use -A i686. i586 is lower than i686, causing many packages to be missing from the installation.\n\nQ: MIC shows in the log: “file /usr/share/whatever conflicts between attempted installs of packageA and packageB”. What does it mean?\n\nA: There are conflicts between some packages in the repository you used, but this is not an issue with MIC. Make sure you are using a proper repository. Try using the repository under the release folder, instead of the snapshot folder.\n\nQ: MIC shows an error: “Command ‘modprobe’ is not available.” What is wrong?\n\nA: In some distributions, when you use sudo, the PATH variable is changed and you lose some important paths. Run export PATH=/sbin:$PATH before running MIC.\n\nQ: MIC shows an error: “Command ‘modprobe’ is not available in Fedora 17.” What is wrong?\n\nA: In Fedora 17, when you use sudo, the PATH variable is changed and you lose some important paths. Run export PATH=/sbin:$PATH before running MIC.\n\nQ: MIC lost some packages which are specified in --includepkgs/--excludepkgs. What happened?\n\nA: If you want to include or exclude some packages in a repository, use the --includepkgs/--excludepkgs option in the proper repository command line. However, you must also list these packages in the %packages section; otherwise, the --includepkgs/--excludepkgs option has no effect.\n\nQ: How does MIC select packages? And how do I set the priority of a repository?\n\nA: In general, MIC selects a higher version if 2 or more are available in all repositories. If the version is the same, a higher release number is preferred.\nIf you assign a priority to a repository, MIC prefers to select packages from a repository with a higher priority, even if a higher version is available in a repository with a lower priority. The default priority for a repository is 99, the range of repository priorities is 1~99, and the larger number has the lower priority.\nTo set the priority:\nrepo --name=base --baseurl=[http://whateverurl](http://whateverurl/) --priority=1\n\n\nKnown Issues\n\nMIC has the following known issues:\n\n\n  \n    ‘zypp’ backend is not supported in Fedora 17\n\n    libsat-solver changed to libsolv in Fedora 17, so the zypp backend cannot work well for some dependency issues. Use ‘yum’ as the backend in the Fedora 17 distribution.\n  \n  \n    Unable to install syslinux bootloader\n\n    In some new Linux distributions, the “syslinux” package in their official software repositories is version 4.04. It causes a segfault, which is a fatal bug, and MIC fails with syslinux installation errors. The solution is to install the patched “syslinux” package in Tizen’s tools repositories, until the officially released one has been fixed.\n  \n  \n    Failed to create btrfs image in OpenSUSE\n\n    When creating a btrfs image in OpenSUSE, it hangs, showing image kernel panic. This issue impacts OpenSUSE distributions, such as 12.1.\n  \n  \n    Failed to create an image when password in the repository URL contains “@”\n\n    MIC cannot support passwords that contain the “@” character. This issue is to be fixed soon. For example:\n    repo --name=Tizen-base --baseurl=https://username:passwd@example.com/arch/packages/ --save  --ssl_verify=no\n    \n  \n\n\nReporting MIC Issues\n\nReport bugs or make feature requests at JIRA:\n\n\n  Click create issue.\n  Select the Development Tools project.\n  Select the MIC component."
					}
					
				
			
		
			
				
					,
					
					"platform-reference-mic-mic-faq": {
						"id": "platform-reference-mic-mic-faq",
						"title": "MIC Frequently Asked Questions",
						"categories": "",
						"url": " platform/reference/mic/mic-faq/",
						"content": "MIC Frequently Asked Questions\n\nQ: When creating an image, MIC shows “Error &lt;creator&gt;: URLGrabber error: http://www.example.com/latest/repos/oss/ia32/packages/repodata/repomd.xml”. What does it mean?\n\nA: Your network can have some issues, or your proxy does not work. Try another proxy and check the network status.\n\nQ: MIC shows “Error &lt;repository&gt;: found 1 resolver problem, abort!” What does it mean?\n\nA: This is not an issue with MIC, but with the repository you used. Make sure the packages in the used repository have proper dependencies. Try using the repository under the release folder, instead of the snapshot folder.\n\nQ: I used -A i586 to create an i586 image, but MIC showed “nothing provided ….”. What is wrong?\n\nA: Use -A i686. i586 is lower than i686, causing many packages to be missing from the installation.\n\nQ: MIC shows in the log: “file /usr/share/whatever conflicts between attempted installs of packageA and packageB”. What does it mean?\n\nA: There are conflicts between some packages in the repository you used, but this is not an issue with MIC. Make sure you are using a proper repository. Try using the repository under the release folder, instead of the snapshot folder.\n\nQ: MIC shows an error: “Command ‘modprobe’ is not available.” What is wrong?\n\nA: In some distributions, when you use sudo, the PATH variable is changed and you lose some important paths. Run export PATH=/sbin:$PATH before running MIC.\n\nQ: MIC shows an error: “Command ‘modprobe’ is not available in Fedora 17.” What is wrong?\n\nA: In Fedora 17, when you use sudo, the PATH variable is changed and you lose some important paths. Run export PATH=/sbin:$PATH before running MIC.\n\nQ: MIC lost some packages which are specified in --includepkgs/--excludepkgs. What happened?\n\nA: If you want to include or exclude some packages in a repository, use the --includepkgs/--excludepkgs option in the proper repository command line. However, you must also list these packages in the %packages section; otherwise, the --includepkgs/--excludepkgs option has no effect.\n\nQ: How does MIC select packages? And how do I set the priority of a repository?\n\nA: In general, MIC selects a higher version if 2 or more are available in all repositories. If the version is the same, a higher release number is preferred.\nIf you assign a priority to a repository, MIC prefers to select packages from a repository with a higher priority, even if a higher version is available in a repository with a lower priority. The default priority for a repository is 99, the range of repository priorities is 1~99, and the larger number has the lower priority.\nTo set the priority:\nrepo --name=base --baseurl=[http://whateverurl](http://whateverurl/) --priority=1\n\n\nKnown Issues\n\nMIC has the following known issues:\n\n\n  \n    ‘zypp’ backend is not supported in Fedora 17\n\n    libsat-solver changed to libsolv in Fedora 17, so the zypp backend cannot work well for some dependency issues. Use ‘yum’ as the backend in the Fedora 17 distribution.\n  \n  \n    Unable to install syslinux bootloader\n\n    In some new Linux distributions, the “syslinux” package in their official software repositories is version 4.04. It causes a segfault, which is a fatal bug, and MIC fails with syslinux installation errors. The solution is to install the patched “syslinux” package in Tizen’s tools repositories, until the officially released one has been fixed.\n  \n  \n    Failed to create btrfs image in OpenSUSE\n\n    When creating a btrfs image in OpenSUSE, it hangs, showing image kernel panic. This issue impacts OpenSUSE distributions, such as 12.1.\n  \n  \n    Failed to create an image when password in the repository URL contains “@”\n\n    MIC cannot support passwords that contain the “@” character. This issue is to be fixed soon. For example:\n    repo --name=Tizen-base --baseurl=https://username:passwd@example.com/arch/packages/ --save  --ssl_verify=no\n    \n  \n\n\nReporting MIC Issues\n\nReport bugs or make feature requests at JIRA:\n\n\n  Click create issue.\n  Select the Development Tools project.\n  Select the MIC component."
					}
					
				
			
		
			
				
					,
					
					"iot-reference-mic-mic-faq": {
						"id": "iot-reference-mic-mic-faq",
						"title": "MIC Frequently Asked Questions",
						"categories": "",
						"url": " iot/reference/mic/mic-faq/",
						"content": "MIC Frequently Asked Questions\n\nQ: When creating an image, MIC shows “Error &lt;creator&gt;: URLGrabber error: http://www.example.com/latest/repos/oss/ia32/packages/repodata/repomd.xml”. What does it mean?\n\nA: Your network can have some issues, or your proxy does not work. Try another proxy and check the network status.\n\nQ: MIC shows “Error &lt;repository&gt;: found 1 resolver problem, abort!” What does it mean?\n\nA: This is not an issue with MIC, but with the repository you used. Make sure the packages in the used repository have proper dependencies. Try using the repository under the release folder, instead of the snapshot folder.\n\nQ: I used -A i586 to create an i586 image, but MIC showed “nothing provided ….”. What is wrong?\n\nA: Use -A i686. i586 is lower than i686, causing many packages to be missing from the installation.\n\nQ: MIC shows in the log: “file /usr/share/whatever conflicts between attempted installs of packageA and packageB”. What does it mean?\n\nA: There are conflicts between some packages in the repository you used, but this is not an issue with MIC. Make sure you are using a proper repository. Try using the repository under the release folder, instead of the snapshot folder.\n\nQ: MIC shows an error: “Command ‘modprobe’ is not available.” What is wrong?\n\nA: In some distributions, when you use sudo, the PATH variable is changed and you lose some important paths. Run export PATH=/sbin:$PATH before running MIC.\n\nQ: MIC shows an error: “Command ‘modprobe’ is not available in Fedora 17.” What is wrong?\n\nA: In Fedora 17, when you use sudo, the PATH variable is changed and you lose some important paths. Run export PATH=/sbin:$PATH before running MIC.\n\nQ: MIC lost some packages which are specified in --includepkgs/--excludepkgs. What happened?\n\nA: If you want to include or exclude some packages in a repository, use the --includepkgs/--excludepkgs option in the proper repository command line. However, you must also list these packages in the %packages section; otherwise, the --includepkgs/--excludepkgs option has no effect.\n\nQ: How does MIC select packages? And how do I set the priority of a repository?\n\nA: In general, MIC selects a higher version if 2 or more are available in all repositories. If the version is the same, a higher release number is preferred.\nIf you assign a priority to a repository, MIC prefers to select packages from a repository with a higher priority, even if a higher version is available in a repository with a lower priority. The default priority for a repository is 99, the range of repository priorities is 1~99, and the larger number has the lower priority.\nTo set the priority:\nrepo --name=base --baseurl=[http://whateverurl](http://whateverurl/) --priority=1\n\n\nKnown Issues\n\nMIC has the following known issues:\n\n\n  \n    ‘zypp’ backend is not supported in Fedora 17\n\n    libsat-solver changed to libsolv in Fedora 17, so the zypp backend cannot work well for some dependency issues. Use ‘yum’ as the backend in the Fedora 17 distribution.\n  \n  \n    Unable to install syslinux bootloader\n\n    In some new Linux distributions, the “syslinux” package in their official software repositories is version 4.04. It causes a segfault, which is a fatal bug, and MIC fails with syslinux installation errors. The solution is to install the patched “syslinux” package in Tizen’s tools repositories, until the officially released one has been fixed.\n  \n  \n    Failed to create btrfs image in OpenSUSE\n\n    When creating a btrfs image in OpenSUSE, it hangs, showing image kernel panic. This issue impacts OpenSUSE distributions, such as 12.1.\n  \n  \n    Failed to create an image when password in the repository URL contains “@”\n\n    MIC cannot support passwords that contain the “@” character. This issue is to be fixed soon. For example:\n    repo --name=Tizen-base --baseurl=https://username:passwd@example.com/arch/packages/ --save  --ssl_verify=no\n    \n  \n\n\nReporting MIC Issues\n\nReport bugs or make feature requests at JIRA:\n\n\n  Click create issue.\n  Select the Development Tools project.\n  Select the MIC component."
					}
					
				
			
		
			
				
					,
					
					"application-reference-mic-mic-overview": {
						"id": "application-reference-mic-mic-overview",
						"title": "MIC Image Creator",
						"categories": "",
						"url": " application/reference/mic/mic-overview/",
						"content": "MIC Image Creator\n\nMIC is an image creator used when creating images for Tizen. With the MIC tool, you can:\n\n\n  Create images of different types for different verticals, such as:\n    \n      Live CD images\n      Live USB images\n      Raw images for KVM\n      Loop images for IVI platforms\n      fs images for chrooting\n    \n  \n  Chroot into an image using MIC’s enhanced chroot command.\n  Convert an image to another image format.\n\n\nThis is a very useful function when handling situations sensitive to image format.\n\nBefore going into further MIC details, make sure you have set up the development environment and learned how to install and upgrade tools.\n\nAfterwards, become familiar with MIC by reading the following instructions:\n\n\n  Customizing Images describes how to modify the kickstart file to customize an image.\n  MIC Reference describes, in more detail, how to use MIC.\n  MIC Frequently Asked Questions describes frequently asked questions and known issues.\n  Reporting MIC Issues describes how to report bugs and feature requests.\n\n\nSource Code\n\nThe source code is tracked in the https://github.com/01org/mic repository.\n\nLicense\n\nCopyright (c) 2012 Intel, Inc.\nThis program is free software; you can redistribute it and/or modify it\nunder the terms of the GNU General Public License as published by the Free\nSoftware Foundation; version 2 of the License.\nThis program is distributed in the hope that it will be useful, but\nWITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\nor FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License\nfor more details.\nYou should have received a copy of the GNU General Public License along\nwith this program; if not, write to the Free Software Foundation, Inc., 59\nTemple Place - Suite 330, Boston, MA 02111-1307, USA."
					}
					
				
			
		
			
				
					,
					
					"platform-reference-mic-mic-overview": {
						"id": "platform-reference-mic-mic-overview",
						"title": "MIC Image Creator",
						"categories": "",
						"url": " platform/reference/mic/mic-overview/",
						"content": "MIC Image Creator\n\nMIC is an image creator used when creating images for Tizen. With the MIC tool, you can:\n\n\n  Create images of different types for different verticals, such as:\n    \n      Live CD images\n      Live USB images\n      Raw images for KVM\n      Loop images for IVI platforms\n      fs images for chrooting\n    \n  \n  Chroot into an image using MIC’s enhanced chroot command.\n  Convert an image to another image format.\n\n\nThis is a very useful function when handling situations sensitive to image format.\n\nBefore going into further MIC details, make sure you have set up the development environment and learned how to install and upgrade tools.\n\nAfterwards, become familiar with MIC by reading the following instructions:\n\n\n  Customizing Images describes how to modify the kickstart file to customize an image.\n  MIC Reference describes, in more detail, how to use MIC.\n  MIC Frequently Asked Questions describes frequently asked questions and known issues.\n  Reporting MIC Issues describes how to report bugs and feature requests.\n\n\nSource Code\n\nThe source code is tracked in the https://github.com/01org/mic repository.\n\nLicense\n\nCopyright (c) 2012 Intel, Inc.\nThis program is free software; you can redistribute it and/or modify it\nunder the terms of the GNU General Public License as published by the Free\nSoftware Foundation; version 2 of the License.\nThis program is distributed in the hope that it will be useful, but\nWITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\nor FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License\nfor more details.\nYou should have received a copy of the GNU General Public License along\nwith this program; if not, write to the Free Software Foundation, Inc., 59\nTemple Place - Suite 330, Boston, MA 02111-1307, USA."
					}
					
				
			
		
			
				
					,
					
					"iot-reference-mic-mic-overview": {
						"id": "iot-reference-mic-mic-overview",
						"title": "MIC Image Creator",
						"categories": "",
						"url": " iot/reference/mic/mic-overview/",
						"content": "MIC Image Creator\n\nMIC is an image creator used when creating images for Tizen. With the MIC tool, you can:\n\n\n  Create images of different types for different verticals, such as:\n    \n      Live CD images\n      Live USB images\n      Raw images for KVM\n      Loop images for IVI platforms\n      fs images for chrooting\n    \n  \n  Chroot into an image using MIC’s enhanced chroot command.\n  Convert an image to another image format.\n\n\nThis is a very useful function when handling situations sensitive to image format.\n\nBefore going into further MIC details, make sure you have set up the development environment and learned how to install and upgrade tools.\n\nAfterwards, become familiar with MIC by reading the following instructions:\n\n\n  Customizing Images describes how to modify the kickstart file to customize an image.\n  MIC Reference describes, in more detail, how to use MIC.\n  MIC Frequently Asked Questions describes frequently asked questions and known issues.\n  Reporting MIC Issues describes how to report bugs and feature requests.\n\n\nSource Code\n\nThe source code is tracked in the https://github.com/01org/mic repository.\n\nLicense\n\nCopyright (c) 2012 Intel, Inc.\nThis program is free software; you can redistribute it and/or modify it\nunder the terms of the GNU General Public License as published by the Free\nSoftware Foundation; version 2 of the License.\nThis program is distributed in the hope that it will be useful, but\nWITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\nor FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License\nfor more details.\nYou should have received a copy of the GNU General Public License along\nwith this program; if not, write to the Free Software Foundation, Inc., 59\nTemple Place - Suite 330, Boston, MA 02111-1307, USA."
					}
					
				
			
		
			
				
					,
					
					"application-reference-mic-mic-reference": {
						"id": "application-reference-mic-mic-reference",
						"title": "MIC Reference",
						"categories": "",
						"url": " application/reference/mic/mic-reference/",
						"content": "MIC Reference\n\nMIC supports the following image formats:\n\n\n  Loop\n    \n      Each loop corresponds to 1 partition.\n      A file system is created inside the image.\n      For a configuration with multiple partitions (specified in the kickstart file), MIC generates multiple loop images.\n      Multiple loop images can be packed into a single archive file.\n    \n  \n  Raw\n    \n      “Raw” format basically means hard disk dumping.\n      It includes a partition table and all the partitions.\n      The image is bootable directly.\n    \n  \n  Livecd and liveusb\n    \n      It is mainly used for an ia32 build.\n      It can be burned to a CD or USB stick, which can be booted into a live system or installation UI.\n    \n  \n  fs\n    \n      “fs” means file-system.\n      MIC can install all the Tizen files to a specified directory, which can be used directly as a chroot environment.\n    \n  \n\n\nCreating an Image\n\nTo create a basic image, use the following command syntax:\n\n$ mic create(cr) SUBCOMMAND &lt;ksfile&gt; [OPTION]\n\n\nIn the command:\n\n\n  \n    SUBCOMMAND specifies the image format:\n\n    fs                 create fs image, which is also a chroot directory\nlivecd             create live CD image, used for CD booting\nliveusb            create live USB image, used for USB booting\nloop               create loop image, including multi-partitions\nraw                create raw image, containing multi-partitions\n    \n  \n  \n    &lt;ksfile&gt; specifies the kickstart file.\n\n    The kickstart file is a simple text file, containing a list of items about, for example, image partition, setup, Bootloader, and packages to be installed. Each item is identified by a key word.\n  \n  \n    OPTION can be used to specify various details:\n\n    -h, --help          Show this help message and exit\n--logfile=LOGFILE   Path of logfile\n-c CONFIG, --config=CONFIG\n                    Specify config file for MIC\n-k CACHEDIR, --cachedir=CACHEDIR\n                    Cache directory to store downloaded files\n-o OUTDIR, --outdir=OUTDIR\n                    Output directory\n-A ARCH, --arch=ARCH\n                    Specify repo architecture\n--release=RID       Generate a release of RID with all necessary files.\n                    When @BUILD_ID@ is contained in kickstart file, it\n                    will be replaced by RID.\n--record-pkgs=RECORD_PKGS\n                    Record the info of installed packages. Multiple values\n                    can be specified which joined by \",\", valid values:\n                    \"name\", \"content\", \"license\", \"vcs\".\n--pkgmgr=PKGMGR     Specify backend package manager\n--local-pkgs-path=LOCAL_PKGS_PATH\n                    Path for local pkgs(rpms) to be installed\n--pack-to=PACK_TO   Pack the images together into the specified archive,\n                    extension supported: .zip, .tar, .tar.gz, .tar.bz2,\n                    etc. by default, .tar will be used\n--copy-kernel       Copy kernel files from image /boot directory to the\n                    image output directory.\n--install-pkgs=INSTALL_PKGS\n                    Specify what type of packages to be installed, valid:\n                    source, debuginfo, debugsource\n    \n\n    Other options include:\n\n    --runtime=RUNTIME_MODE\n                    Sets runtime mode, the default is bootstrap mode, valid\n                    values: \"native\", \"bootstrap\". \"native\" means mic uses\n                    localhost environment to create image, while \"bootstrap\"\n                    means mic uses one tizen chroot environment to create image.\n--compress-image=COMPRESS_IMAGE (for loop &amp; raw)\n                    Sets the disk image compression. Note: The available\n                    values might depend on the used filesystem type.\n--compress-disk-image=COMPRESS_IMAGE\n                    Same with --compress-image\n--shrink (for loop)\n                    Whether to shrink loop images to minimal size\n--generate-bmap (for raw)\n                    Generate the block map file\n--fstab-entry=FSTAB_ENTRY (for raw)\n                    Set fstab entry, 'name' means using device names,\n                    'uuid' means using filesystem uuid\n    \n  \n\n\nFor example, to create a loop image, use the following command:\n\n$ mic cr loop tizen.ks\n\n\nExample of Creating a Loop Image\n\nTo create a loop image:\n\n\n  \n    Prepare the kickstart file.\n\n    To create an image, you need a proper .ks file:\n\n    # filename: tizen-min.ks\nlang en_US.UTF-8\nkeyboard us\ntimezone --utc America/Los_Angeles\n\npart / --size 1824 --ondisk sda --fstype=ext3\n\nrootpw tizen\nbootloader  --timeout=0  --append=\"rootdelay=5\"\n\ndesktop --autologinuser=tizen\nuser --name tizen  --groups audio,video --password 'tizen'\n\nrepo --name=Tizen-base --baseurl=http://download.tizen.org/snapshots/trunk/common/latest/repos/base/ia32/packages/\nrepo --name=Tizen-main --baseurl=http://download.tizen.org/snapshots/trunk/common/latest/repos/main/ia32/packages/\n\n%packages --ignoremissing\n@tizen-bootstrap\n%end\n\n%post\nrm -rf /var/lib/rpm/__db*\nrpm --rebuilddb\n%end\n\n%post --nochroot\n%end\n    \n\n    The above file can be used to create a minimum Tizen image. For other repositories, replace the URL. For example:\n\n    $ repo --name=REPO-NAME --baseurl=https://username:passwd@yourrepo.com/ia32/packages/ --save  --ssl_verify=no\n    \n  \n  \n    Create the loop image with the following command in the terminal:\n\n    $ sudo mic create loop tizen-min.ks\n    \n  \n\n\nExample of Creating an Image with a Local RPM Package\n\nIf you want to install your own RPM into the image, to be able to test your package with the image, using a local package path can be helpful. For example, if your hello.rpm file is under the localpath directory, use the following command:\n\n$ sudo mic create loop test.ks --local-pkgs-path=localpath\n\n\nThe command output states Marked 'hello.rpm' as installed, and the hello.rpm file is installed in the image. Make sure that your RPM is not in the .ks file’s repository and that your RPM version is newer or equal to the repository RPM version.\n\nExample of Creating an Image with a Specific Archive Format\n\nYou can use MIC to archive the image with a specific format, such as .zip, .tar (default), .tar.gz, or .tar.bz2.\n\nTo use a specific archive format:\n\n$ sudo mic create loop test.ks --pack-to=@NAME@.tar.gz\n\n\nChrooting Inside an Image\n\nThe MIC chroot command is a great enhancement over the basic chroot command in the Linux system.\n\nTo chroot inside the image, use the following command syntax:\n\n$ mic chroot(ch) [OPTION] &lt;imgfile&gt;\n\n\nIn the command:\n\n\n  OPTION can be used to specify various details:\n    -h, --help          Show this help message and exit\n-s SAVETO, --saveto=SAVETO\n                    Save the unpacked image to a specified dir\n    \n  \n  &lt;imgfile&gt; specifies the image file.\n\n\nFor example:\n\n$ mic ch loop.img\n$ mic ch tizen.iso\n$ mic ch -s tizenfs tizen.usbimg\n\n\nConverting an Image\n\nTo convert an image to another format, use the following command syntax:\n\nmic convert(cv) [OPTION] &lt;imagefile&gt; &lt;destformat&gt;\n\n\nIn the command:\n\n\n  OPTION can be used to specify various details:\n    -h, --help   Show this help message and exit\n-S, --shell  Launch shell before packaging the converted image\n    \n  \n  &lt;imgfile&gt; specifies the image file.\n  &lt;destformat&gt; specifies the destination format.\n\n\nFor example:\n\n$ mic cv tizen.iso liveusb\n$ mic cv tizen.usbimg livecd\n$ mic cv --shell tizen.iso liveusb\n\n\nSetting a Proxy\n\nYou can set a proxy in various ways:\n\n\n  \n    Proxy variable in bash\n\n    It is common to use a proxy variable in bash. In general, you can set the following environment variables to enable proxy support:\n\n    export http_proxy=http://proxy.com:port\nexport https_proxy=http://proxy.com:port\nexport ftp_proxy=http://proxy.com:port\nexport no_proxy=localhost,127.0.0.0/8,.company.com\n    \n\n    You do not need all the variables, so check which ones you need and only export those. When the repository URL in your .ks file starts with https, MIC uses the https_proxy variable. Be careful when setting the no_proxy variable, because it indicates which domain must be accessed directly. Do not leave any blank spaces in the string.\n\n    MIC needs the sudo privilege. To keep the proxy environment, set /etc/sudoers to add the proxy variables to env_keep:\n\n    Defaults        env_keep += \"http_proxy https_proxy ftp_proxy no_proxy\"\n    \n\n    \n      Note\n\n      Use visudo to modify /etc/sudoers.\n    \n\n    If you do not want to change your /etc/sudoers, you can set the proxy in the mic.conf file, as described below.\n  \n  \n    Proxy setting in the mic.conf file\n\n    The proxy environment variables can disturb other programs, so to enable proxy support only for MIC, set the proxy in the etc/mic/mic.conffile:\n\n    [create]\n; settings for create subcommand\ntmpdir= /var/tmp/mic\ncachedir= /var/tmp/mic/cache\noutdir= .\npkgmgr = zypp\nproxy = http://proxy.yourcompany.com:8080/\nno_proxy = localhost,127.0.0.0/8,.yourcompany.com\n    \n  \n  \n    Proxy setting in the .ks file\n\n    If you need to enable proxy support for a special repository URL only, leaving others at their existing proxy setting:\n\n    $ repo --name=oss --baseurl=http://www.example.com/repos/oss/packages/ --proxy=http://host:port\n    \n  \n\n\nGetting Help\n\nTo get help:\n\n\n  Use the mancommand:\n    $ man mic\n    \n  \n  Use the --help options:\n    $ mic --help\n$ mic create --help\n$ mic help create\n$ mic create loop --help\n$ mic create help loop"
					}
					
				
			
		
			
				
					,
					
					"platform-reference-mic-mic-reference": {
						"id": "platform-reference-mic-mic-reference",
						"title": "MIC Reference",
						"categories": "",
						"url": " platform/reference/mic/mic-reference/",
						"content": "MIC Reference\n\nMIC supports the following image formats:\n\n\n  Loop\n    \n      Each loop corresponds to 1 partition.\n      A file system is created inside the image.\n      For a configuration with multiple partitions (specified in the kickstart file), MIC generates multiple loop images.\n      Multiple loop images can be packed into a single archive file.\n    \n  \n  Raw\n    \n      “Raw” format basically means hard disk dumping.\n      It includes a partition table and all the partitions.\n      The image is bootable directly.\n    \n  \n  Livecd and liveusb\n    \n      It is mainly used for an ia32 build.\n      It can be burned to a CD or USB stick, which can be booted into a live system or installation UI.\n    \n  \n  fs\n    \n      “fs” means file-system.\n      MIC can install all the Tizen files to a specified directory, which can be used directly as a chroot environment.\n    \n  \n\n\nCreating an Image\n\nTo create a basic image, use the following command syntax:\n\n$ mic create(cr) SUBCOMMAND &lt;ksfile&gt; [OPTION]\n\n\nIn the command:\n\n\n  \n    SUBCOMMAND specifies the image format:\n\n    fs                 create fs image, which is also a chroot directory\nlivecd             create live CD image, used for CD booting\nliveusb            create live USB image, used for USB booting\nloop               create loop image, including multi-partitions\nraw                create raw image, containing multi-partitions\n    \n  \n  \n    &lt;ksfile&gt; specifies the kickstart file.\n\n    The kickstart file is a simple text file, containing a list of items about, for example, image partition, setup, Bootloader, and packages to be installed. Each item is identified by a key word.\n  \n  \n    OPTION can be used to specify various details:\n\n    -h, --help          Show this help message and exit\n--logfile=LOGFILE   Path of logfile\n-c CONFIG, --config=CONFIG\n                    Specify config file for MIC\n-k CACHEDIR, --cachedir=CACHEDIR\n                    Cache directory to store downloaded files\n-o OUTDIR, --outdir=OUTDIR\n                    Output directory\n-A ARCH, --arch=ARCH\n                    Specify repo architecture\n--release=RID       Generate a release of RID with all necessary files.\n                    When @BUILD_ID@ is contained in kickstart file, it\n                    will be replaced by RID.\n--record-pkgs=RECORD_PKGS\n                    Record the info of installed packages. Multiple values\n                    can be specified which joined by \",\", valid values:\n                    \"name\", \"content\", \"license\", \"vcs\".\n--pkgmgr=PKGMGR     Specify backend package manager\n--local-pkgs-path=LOCAL_PKGS_PATH\n                    Path for local pkgs(rpms) to be installed\n--pack-to=PACK_TO   Pack the images together into the specified archive,\n                    extension supported: .zip, .tar, .tar.gz, .tar.bz2,\n                    etc. by default, .tar will be used\n--copy-kernel       Copy kernel files from image /boot directory to the\n                    image output directory.\n--install-pkgs=INSTALL_PKGS\n                    Specify what type of packages to be installed, valid:\n                    source, debuginfo, debugsource\n    \n\n    Other options include:\n\n    --runtime=RUNTIME_MODE\n                    Sets runtime mode, the default is bootstrap mode, valid\n                    values: \"native\", \"bootstrap\". \"native\" means mic uses\n                    localhost environment to create image, while \"bootstrap\"\n                    means mic uses one tizen chroot environment to create image.\n--compress-image=COMPRESS_IMAGE (for loop &amp; raw)\n                    Sets the disk image compression. Note: The available\n                    values might depend on the used filesystem type.\n--compress-disk-image=COMPRESS_IMAGE\n                    Same with --compress-image\n--shrink (for loop)\n                    Whether to shrink loop images to minimal size\n--generate-bmap (for raw)\n                    Generate the block map file\n--fstab-entry=FSTAB_ENTRY (for raw)\n                    Set fstab entry, 'name' means using device names,\n                    'uuid' means using filesystem uuid\n    \n  \n\n\nFor example, to create a loop image, use the following command:\n\n$ mic cr loop tizen.ks\n\n\nExample of Creating a Loop Image\n\nTo create a loop image:\n\n\n  \n    Prepare the kickstart file.\n\n    To create an image, you need a proper .ks file:\n\n    # filename: tizen-min.ks\nlang en_US.UTF-8\nkeyboard us\ntimezone --utc America/Los_Angeles\n\npart / --size 1824 --ondisk sda --fstype=ext3\n\nrootpw tizen\nbootloader  --timeout=0  --append=\"rootdelay=5\"\n\ndesktop --autologinuser=tizen\nuser --name tizen  --groups audio,video --password 'tizen'\n\nrepo --name=Tizen-base --baseurl=http://download.tizen.org/snapshots/trunk/common/latest/repos/base/ia32/packages/\nrepo --name=Tizen-main --baseurl=http://download.tizen.org/snapshots/trunk/common/latest/repos/main/ia32/packages/\n\n%packages --ignoremissing\n@tizen-bootstrap\n%end\n\n%post\nrm -rf /var/lib/rpm/__db*\nrpm --rebuilddb\n%end\n\n%post --nochroot\n%end\n    \n\n    The above file can be used to create a minimum Tizen image. For other repositories, replace the URL. For example:\n\n    $ repo --name=REPO-NAME --baseurl=https://username:passwd@yourrepo.com/ia32/packages/ --save  --ssl_verify=no\n    \n  \n  \n    Create the loop image with the following command in the terminal:\n\n    $ sudo mic create loop tizen-min.ks\n    \n  \n\n\nExample of Creating an Image with a Local RPM Package\n\nIf you want to install your own RPM into the image, to be able to test your package with the image, using a local package path can be helpful. For example, if your hello.rpm file is under the localpath directory, use the following command:\n\n$ sudo mic create loop test.ks --local-pkgs-path=localpath\n\n\nThe command output states Marked 'hello.rpm' as installed, and the hello.rpm file is installed in the image. Make sure that your RPM is not in the .ks file’s repository and that your RPM version is newer or equal to the repository RPM version.\n\nExample of Creating an Image with a Specific Archive Format\n\nYou can use MIC to archive the image with a specific format, such as .zip, .tar (default), .tar.gz, or .tar.bz2.\n\nTo use a specific archive format:\n\n$ sudo mic create loop test.ks --pack-to=@NAME@.tar.gz\n\n\nChrooting Inside an Image\n\nThe MIC chroot command is a great enhancement over the basic chroot command in the Linux system.\n\nTo chroot inside the image, use the following command syntax:\n\n$ mic chroot(ch) [OPTION] &lt;imgfile&gt;\n\n\nIn the command:\n\n\n  OPTION can be used to specify various details:\n    -h, --help          Show this help message and exit\n-s SAVETO, --saveto=SAVETO\n                    Save the unpacked image to a specified dir\n    \n  \n  &lt;imgfile&gt; specifies the image file.\n\n\nFor example:\n\n$ mic ch loop.img\n$ mic ch tizen.iso\n$ mic ch -s tizenfs tizen.usbimg\n\n\nConverting an Image\n\nTo convert an image to another format, use the following command syntax:\n\nmic convert(cv) [OPTION] &lt;imagefile&gt; &lt;destformat&gt;\n\n\nIn the command:\n\n\n  OPTION can be used to specify various details:\n    -h, --help   Show this help message and exit\n-S, --shell  Launch shell before packaging the converted image\n    \n  \n  &lt;imgfile&gt; specifies the image file.\n  &lt;destformat&gt; specifies the destination format.\n\n\nFor example:\n\n$ mic cv tizen.iso liveusb\n$ mic cv tizen.usbimg livecd\n$ mic cv --shell tizen.iso liveusb\n\n\nSetting a Proxy\n\nYou can set a proxy in various ways:\n\n\n  \n    Proxy variable in bash\n\n    It is common to use a proxy variable in bash. In general, you can set the following environment variables to enable proxy support:\n\n    export http_proxy=http://proxy.com:port\nexport https_proxy=http://proxy.com:port\nexport ftp_proxy=http://proxy.com:port\nexport no_proxy=localhost,127.0.0.0/8,.company.com\n    \n\n    You do not need all the variables, so check which ones you need and only export those. When the repository URL in your .ks file starts with https, MIC uses the https_proxy variable. Be careful when setting the no_proxy variable, because it indicates which domain must be accessed directly. Do not leave any blank spaces in the string.\n\n    MIC needs the sudo privilege. To keep the proxy environment, set /etc/sudoers to add the proxy variables to env_keep:\n\n    Defaults        env_keep += \"http_proxy https_proxy ftp_proxy no_proxy\"\n    \n\n    \n      Note\n\n      Use visudo to modify /etc/sudoers.\n    \n\n    If you do not want to change your /etc/sudoers, you can set the proxy in the mic.conf file, as described below.\n  \n  \n    Proxy setting in the mic.conf file\n\n    The proxy environment variables can disturb other programs, so to enable proxy support only for MIC, set the proxy in the etc/mic/mic.conffile:\n\n    [create]\n; settings for create subcommand\ntmpdir= /var/tmp/mic\ncachedir= /var/tmp/mic/cache\noutdir= .\npkgmgr = zypp\nproxy = http://proxy.yourcompany.com:8080/\nno_proxy = localhost,127.0.0.0/8,.yourcompany.com\n    \n  \n  \n    Proxy setting in the .ks file\n\n    If you need to enable proxy support for a special repository URL only, leaving others at their existing proxy setting:\n\n    $ repo --name=oss --baseurl=http://www.example.com/repos/oss/packages/ --proxy=http://host:port\n    \n  \n\n\nGetting Help\n\nTo get help:\n\n\n  Use the mancommand:\n    $ man mic\n    \n  \n  Use the --help options:\n    $ mic --help\n$ mic create --help\n$ mic help create\n$ mic create loop --help\n$ mic create help loop"
					}
					
				
			
		
			
				
					,
					
					"iot-reference-mic-mic-reference": {
						"id": "iot-reference-mic-mic-reference",
						"title": "MIC Reference",
						"categories": "",
						"url": " iot/reference/mic/mic-reference/",
						"content": "MIC Reference\n\nMIC supports the following image formats:\n\n\n  Loop\n    \n      Each loop corresponds to 1 partition.\n      A file system is created inside the image.\n      For a configuration with multiple partitions (specified in the kickstart file), MIC generates multiple loop images.\n      Multiple loop images can be packed into a single archive file.\n    \n  \n  Raw\n    \n      “Raw” format basically means hard disk dumping.\n      It includes a partition table and all the partitions.\n      The image is bootable directly.\n    \n  \n  Livecd and liveusb\n    \n      It is mainly used for an ia32 build.\n      It can be burned to a CD or USB stick, which can be booted into a live system or installation UI.\n    \n  \n  fs\n    \n      “fs” means file-system.\n      MIC can install all the Tizen files to a specified directory, which can be used directly as a chroot environment.\n    \n  \n\n\nCreating an Image\n\nTo create a basic image, use the following command syntax:\n\n$ mic create(cr) SUBCOMMAND &lt;ksfile&gt; [OPTION]\n\n\nIn the command:\n\n\n  \n    SUBCOMMAND specifies the image format:\n\n    fs                 create fs image, which is also a chroot directory\nlivecd             create live CD image, used for CD booting\nliveusb            create live USB image, used for USB booting\nloop               create loop image, including multi-partitions\nraw                create raw image, containing multi-partitions\n    \n  \n  \n    &lt;ksfile&gt; specifies the kickstart file.\n\n    The kickstart file is a simple text file, containing a list of items about, for example, image partition, setup, Bootloader, and packages to be installed. Each item is identified by a key word.\n  \n  \n    OPTION can be used to specify various details:\n\n    -h, --help          Show this help message and exit\n--logfile=LOGFILE   Path of logfile\n-c CONFIG, --config=CONFIG\n                    Specify config file for MIC\n-k CACHEDIR, --cachedir=CACHEDIR\n                    Cache directory to store downloaded files\n-o OUTDIR, --outdir=OUTDIR\n                    Output directory\n-A ARCH, --arch=ARCH\n                    Specify repo architecture\n--release=RID       Generate a release of RID with all necessary files.\n                    When @BUILD_ID@ is contained in kickstart file, it\n                    will be replaced by RID.\n--record-pkgs=RECORD_PKGS\n                    Record the info of installed packages. Multiple values\n                    can be specified which joined by \",\", valid values:\n                    \"name\", \"content\", \"license\", \"vcs\".\n--pkgmgr=PKGMGR     Specify backend package manager\n--local-pkgs-path=LOCAL_PKGS_PATH\n                    Path for local pkgs(rpms) to be installed\n--pack-to=PACK_TO   Pack the images together into the specified archive,\n                    extension supported: .zip, .tar, .tar.gz, .tar.bz2,\n                    etc. by default, .tar will be used\n--copy-kernel       Copy kernel files from image /boot directory to the\n                    image output directory.\n--install-pkgs=INSTALL_PKGS\n                    Specify what type of packages to be installed, valid:\n                    source, debuginfo, debugsource\n    \n\n    Other options include:\n\n    --runtime=RUNTIME_MODE\n                    Sets runtime mode, the default is bootstrap mode, valid\n                    values: \"native\", \"bootstrap\". \"native\" means mic uses\n                    localhost environment to create image, while \"bootstrap\"\n                    means mic uses one tizen chroot environment to create image.\n--compress-image=COMPRESS_IMAGE (for loop &amp; raw)\n                    Sets the disk image compression. Note: The available\n                    values might depend on the used filesystem type.\n--compress-disk-image=COMPRESS_IMAGE\n                    Same with --compress-image\n--shrink (for loop)\n                    Whether to shrink loop images to minimal size\n--generate-bmap (for raw)\n                    Generate the block map file\n--fstab-entry=FSTAB_ENTRY (for raw)\n                    Set fstab entry, 'name' means using device names,\n                    'uuid' means using filesystem uuid\n    \n  \n\n\nFor example, to create a loop image, use the following command:\n\n$ mic cr loop tizen.ks\n\n\nExample of Creating a Loop Image\n\nTo create a loop image:\n\n\n  \n    Prepare the kickstart file.\n\n    To create an image, you need a proper .ks file:\n\n    # filename: tizen-min.ks\nlang en_US.UTF-8\nkeyboard us\ntimezone --utc America/Los_Angeles\n\npart / --size 1824 --ondisk sda --fstype=ext3\n\nrootpw tizen\nbootloader  --timeout=0  --append=\"rootdelay=5\"\n\ndesktop --autologinuser=tizen\nuser --name tizen  --groups audio,video --password 'tizen'\n\nrepo --name=Tizen-base --baseurl=http://download.tizen.org/snapshots/trunk/common/latest/repos/base/ia32/packages/\nrepo --name=Tizen-main --baseurl=http://download.tizen.org/snapshots/trunk/common/latest/repos/main/ia32/packages/\n\n%packages --ignoremissing\n@tizen-bootstrap\n%end\n\n%post\nrm -rf /var/lib/rpm/__db*\nrpm --rebuilddb\n%end\n\n%post --nochroot\n%end\n    \n\n    The above file can be used to create a minimum Tizen image. For other repositories, replace the URL. For example:\n\n    $ repo --name=REPO-NAME --baseurl=https://username:passwd@yourrepo.com/ia32/packages/ --save  --ssl_verify=no\n    \n  \n  \n    Create the loop image with the following command in the terminal:\n\n    $ sudo mic create loop tizen-min.ks\n    \n  \n\n\nExample of Creating an Image with a Local RPM Package\n\nIf you want to install your own RPM into the image, to be able to test your package with the image, using a local package path can be helpful. For example, if your hello.rpm file is under the localpath directory, use the following command:\n\n$ sudo mic create loop test.ks --local-pkgs-path=localpath\n\n\nThe command output states Marked 'hello.rpm' as installed, and the hello.rpm file is installed in the image. Make sure that your RPM is not in the .ks file’s repository and that your RPM version is newer or equal to the repository RPM version.\n\nExample of Creating an Image with a Specific Archive Format\n\nYou can use MIC to archive the image with a specific format, such as .zip, .tar (default), .tar.gz, or .tar.bz2.\n\nTo use a specific archive format:\n\n$ sudo mic create loop test.ks --pack-to=@NAME@.tar.gz\n\n\nChrooting Inside an Image\n\nThe MIC chroot command is a great enhancement over the basic chroot command in the Linux system.\n\nTo chroot inside the image, use the following command syntax:\n\n$ mic chroot(ch) [OPTION] &lt;imgfile&gt;\n\n\nIn the command:\n\n\n  OPTION can be used to specify various details:\n    -h, --help          Show this help message and exit\n-s SAVETO, --saveto=SAVETO\n                    Save the unpacked image to a specified dir\n    \n  \n  &lt;imgfile&gt; specifies the image file.\n\n\nFor example:\n\n$ mic ch loop.img\n$ mic ch tizen.iso\n$ mic ch -s tizenfs tizen.usbimg\n\n\nConverting an Image\n\nTo convert an image to another format, use the following command syntax:\n\nmic convert(cv) [OPTION] &lt;imagefile&gt; &lt;destformat&gt;\n\n\nIn the command:\n\n\n  OPTION can be used to specify various details:\n    -h, --help   Show this help message and exit\n-S, --shell  Launch shell before packaging the converted image\n    \n  \n  &lt;imgfile&gt; specifies the image file.\n  &lt;destformat&gt; specifies the destination format.\n\n\nFor example:\n\n$ mic cv tizen.iso liveusb\n$ mic cv tizen.usbimg livecd\n$ mic cv --shell tizen.iso liveusb\n\n\nSetting a Proxy\n\nYou can set a proxy in various ways:\n\n\n  \n    Proxy variable in bash\n\n    It is common to use a proxy variable in bash. In general, you can set the following environment variables to enable proxy support:\n\n    export http_proxy=http://proxy.com:port\nexport https_proxy=http://proxy.com:port\nexport ftp_proxy=http://proxy.com:port\nexport no_proxy=localhost,127.0.0.0/8,.company.com\n    \n\n    You do not need all the variables, so check which ones you need and only export those. When the repository URL in your .ks file starts with https, MIC uses the https_proxy variable. Be careful when setting the no_proxy variable, because it indicates which domain must be accessed directly. Do not leave any blank spaces in the string.\n\n    MIC needs the sudo privilege. To keep the proxy environment, set /etc/sudoers to add the proxy variables to env_keep:\n\n    Defaults        env_keep += \"http_proxy https_proxy ftp_proxy no_proxy\"\n    \n\n    \n      Note\n\n      Use visudo to modify /etc/sudoers.\n    \n\n    If you do not want to change your /etc/sudoers, you can set the proxy in the mic.conf file, as described below.\n  \n  \n    Proxy setting in the mic.conf file\n\n    The proxy environment variables can disturb other programs, so to enable proxy support only for MIC, set the proxy in the etc/mic/mic.conffile:\n\n    [create]\n; settings for create subcommand\ntmpdir= /var/tmp/mic\ncachedir= /var/tmp/mic/cache\noutdir= .\npkgmgr = zypp\nproxy = http://proxy.yourcompany.com:8080/\nno_proxy = localhost,127.0.0.0/8,.yourcompany.com\n    \n  \n  \n    Proxy setting in the .ks file\n\n    If you need to enable proxy support for a special repository URL only, leaving others at their existing proxy setting:\n\n    $ repo --name=oss --baseurl=http://www.example.com/repos/oss/packages/ --proxy=http://host:port\n    \n  \n\n\nGetting Help\n\nTo get help:\n\n\n  Use the mancommand:\n    $ man mic\n    \n  \n  Use the --help options:\n    $ mic --help\n$ mic create --help\n$ mic help create\n$ mic create loop --help\n$ mic create help loop"
					}
					
				
			
		
			
				
					,
					
					"application-porting-multimedia": {
						"id": "application-porting-multimedia",
						"title": "Multimedia",
						"categories": "",
						"url": " application/porting/multimedia/",
						"content": "Multimedia\n\nYou can implement various multimedia features, such as camera, audio, and video.\n\nCamera\n\nThe Multimedia camcorder framework controls the GStreamer camera plugin to capture camera data from the device. The kernel interfaces to control the camera device can be different for different chipsets, so the camera HAL (Hardware Abstraction Layer) used by the camera plugin is provided and it must be implemented specifically for each chipset. Each configuration file contains its own specific hardware-dependent information. The Multimedia camcorder framework reads and parses the information in these configuration files.\n\nFigure: Multimedia camcorder framework\n\n\n\n\n  \n    Camera source plugin for GStreamer\n\n    Gets the camera data (preview or captured image) and sets various camera commands through camera HAL interface\n  \n  \n    Camera HAL\n\n    Common interface to control the camera device on various shipsets and used by the camera source plugin.\n  \n  \n    Configuration files\n\n    There are 3 config files for the Multimedia camcorder framework. They are provided by mmfw- sysconf-xxx:\n    \n      mmfw_camcorder.ini\n      mmfw_camcorder_dev_video_pri.ini\n      mmfw_camcorder_dev_video_sec.ini\n    \n  \n\n\nPorting the OAL Interface\n\nTizen provides a default reference camera source plugin which uses the camera HAL interface.\n\nFor the camera HAL, the mm-hal-interface package provides a header file:\n\n\n  Repository path: platform/core/multimedia/mm-hal-interface\n  File name: tizen-camera.h\n\n\nMajor Camera HAL Functions\n\nThe following list defines the major functions for the camera HAL interface:\n\n\n  \n    Functions for initialization and deinitialization:\n\n    /*Initializes new camera HAL handle */\nint camera_init(void **camera_handle);\n\n/* Deinitializes the camera HAL handle */\nint camera_deinit(void *camera_handle);\n    \n  \n  \n    Functions for opening and closing the camera device:\n\n    /* Opens the camera device */\nint camera_open_device(void *camera_handle, int device_index);\n\n/* Closes the camera device */\nint camera_close_device(void *camera_handle);\n    \n  \n  \n    Functions for getting device information:\n\n    /* Gets the camera device list */\nint camera_get_device_list(void *camera_handle, camera_device_list_t *device_list);\n\n/* Registers a callback function to be called to send a message by the camera HAL */\nint camera_add_message_callback(void *camera_handle, camera_message_cb callback, void *user_data, uint32_t *cb_id);\n\n/* Unregisters a callback function */\nint camera_remove_message_callback(void *camera_handle, uint32_t cb_id);\n    \n  \n  \n    Functions for preview and capture:\n\n    typedef struct camera_format {\n    camera_pixel_format_t stream_format;\n    camera_resolution_t stream_resolution;\n    uint32_t stream_fps;\n    camera_rotation_t stream_rotation;\n    camera_pixel_format_t capture_format;\n    camera_resolution_t capture_resolution;\n    uint32_t capture_quality;\n} camera_format_t;\n\n/* Sets the format of the preview stream */\nint camera_set_preview_stream_format(void *camera_handle, camera_format_t *format);\n\n/* Gets the format of the preview stream  */\nint camera_get_preview_stream_format(void *camera_handle, camera_format_t *format);\n\ntypedef int (*camera_preview_frame_cb)(camera_buffer_t *buffer, camera_metadata_t *meta, void *user_data);\n\n/* Starts the display of preview frames on the scree. */\nint camera_start_preview(void *camera_handle, camera_preview_frame_cb callback, void *user_data);\n\n/* Stops the preview frames */\nint camera_stop_preview(void *camera_handle);\n\n/* Releases the preview buffer; the preview buffer must be released with this function after using it */\nint camera_release_preview_buffer(void *camera_handle, int buffer_index);\n\n/* Starts the camera auto-focusing operation */\nint camera_start_auto_focus(void *camera_handle);\n\n/* Stops the camera auto-focusing operation */\nint camera_stop_auto_focus(void *camera_handle);\n\ntypedef int (*camera_capture_cb)(camera_buffer_t *main, camera_buffer_t *postview, camera_buffer_t *thumbnail, void *user_data);\n\n/* Starts capturing still images */\nint camera_start_capture(void *camera_handle, camera_capture_cb callback, void *user_data);\n\n/* Stops capturing still images */\nint camera_stop_capture(void *camera_handle);\n    \n  \n  \n    Functions for video recording:\n\n    /* Stops capturing still images */\nint camera_set_video_stream_format(void *camera_handle, camera_format_t *format);\n\n/* Gets the video stream format for recording */\nint camera_get_video_stream_format(void *camera_handle, camera_format_t *format);\n\ntypedef int (*camera_video_frame_cb)(camera_buffer_t *buffer, camera_metadata_t *meta, void *user_data);\n\n/* Starts the video frame for recording */\nint camera_start_record(void *camera_handle, camera_video_frame_cb callback, void *user_data);\n\n/* Stops the video frame */\nint camera_stop_record(void *camera_handle);\n\n/* Video buffer must be released with this function after using it */\nint camera_release_video_buffer(void *camera_handle, int buffer_index);\n    \n  \n  \n    Functions for controlling the camera device:\n\n    #define CAMERA_COMMAND_BASE                     ((int64_t)1)\n#define CAMERA_COMMAND_WHITE_BALANCE            ((int64_t)(CAMERA_COMMAND_BASE &lt;&lt; 1))\n#define CAMERA_COMMAND_ISO                      ((int64_t)(CAMERA_COMMAND_BASE &lt;&lt; 2))\n#define CAMERA_COMMAND_CONTRAST                 ((int64_t)(CAMERA_COMMAND_BASE &lt;&lt; 3))\n#define CAMERA_COMMAND_SATURATION               ((int64_t)(CAMERA_COMMAND_BASE &lt;&lt; 4))\n#define CAMERA_COMMAND_HUE                      ((int64_t)(CAMERA_COMMAND_BASE &lt;&lt; 5))\n#define CAMERA_COMMAND_SHARPNESS                ((int64_t)(CAMERA_COMMAND_BASE &lt;&lt; 6))\n#define CAMERA_COMMAND_EFFECT                   ((int64_t)(CAMERA_COMMAND_BASE &lt;&lt; 7))\n#define CAMERA_COMMAND_SCENE_MODE               ((int64_t)(CAMERA_COMMAND_BASE &lt;&lt; 8))\n#define CAMERA_COMMAND_EXPOSURE_MODE            ((int64_t)(CAMERA_COMMAND_BASE &lt;&lt; 9))\n#define CAMERA_COMMAND_EXPOSURE                 ((int64_t)(CAMERA_COMMAND_BASE &lt;&lt; 10))\n#define CAMERA_COMMAND_ROTATION                 ((int64_t)(CAMERA_COMMAND_BASE &lt;&lt; 11))\n#define CAMERA_COMMAND_FLIP                     ((int64_t)(CAMERA_COMMAND_BASE &lt;&lt; 12))\n#define CAMERA_COMMAND_FOCUS_MODE               ((int64_t)(CAMERA_COMMAND_BASE &lt;&lt; 13))\n#define CAMERA_COMMAND_FOCUS_RANGE              ((int64_t)(CAMERA_COMMAND_BASE &lt;&lt; 14))\n#define CAMERA_COMMAND_SHOT_MODE                ((int64_t)(CAMERA_COMMAND_BASE &lt;&lt; 15))\n#define CAMERA_COMMAND_ANTI_SHAKE               ((int64_t)(CAMERA_COMMAND_BASE &lt;&lt; 16))\n#define CAMERA_COMMAND_FOCUS_AREA               ((int64_t)(CAMERA_COMMAND_BASE &lt;&lt; 17))\n#define CAMERA_COMMAND_DIGITAL_ZOOM             ((int64_t)(CAMERA_COMMAND_BASE &lt;&lt; 18))\n#define CAMERA_COMMAND_OPTICAL_ZOOM             ((int64_t)(CAMERA_COMMAND_BASE &lt;&lt; 19))\n#define CAMERA_COMMAND_RECORDING_HINT           ((int64_t)(CAMERA_COMMAND_BASE &lt;&lt; 20))\n#define CAMERA_COMMAND_WDR                      ((int64_t)(CAMERA_COMMAND_BASE &lt;&lt; 21))\n#define CAMERA_COMMAND_SHUTTER_SPEED            ((int64_t)(CAMERA_COMMAND_BASE &lt;&lt; 22))\n#define CAMERA_COMMAND_FLASH_MODE               ((int64_t)(CAMERA_COMMAND_BASE &lt;&lt; 23))\n#define CAMERA_COMMAND_FACE_DETECTION           ((int64_t)(CAMERA_COMMAND_BASE &lt;&lt; 24))\n\n/* Sets various commands and values to control the camera device */\nint camera_set_command(void *camera_handle, int64_t command, void *value);\n\n/* Gets the current value of the command */\nint camera_get_command(void *camera_handle, int64_t command, void *value);\n\ntypedef struct camera_batch_command_control {\n    /* Flag for modified command */\n    int64_t command_set_flag;\n\n    /* Value list */\n    camera_white_balance_t white_balance;\n    int iso;\n    int contrast;\n    int saturation;\n    int hue;\n    int sharpness;\n    camera_effect_t effect;\n    camera_scene_mode_t scene_mode;\n    camera_exposure_mode_t exposure_mode;\n    int exposure;\n    camera_rotation_t rotation;\n    camera_flip_t flip;\n    camera_focus_mode_t focus_mode;\n    camera_focus_range_t focus_range;\n    camera_exposure_mode_t shot_mode;\n    int anti_shake;\n    camera_rectangle_t focus_area;\n    int digital_zoom;\n    int optical_zoom;\n    int recording_hint;\n    int wdr;\n    camera_flash_mode_t flash_mode;\n    camera_face_detection_t face_detection;\n} camera_batch_command_control_t;\n\n/* Sets a batch set of commands */\nint camera_set_batch_command(void *camera_handle, camera_batch_command_control_t *batch_command, int64_t *error_command);\n    \n  \n\n\nConfiguration\n\nTo configure the camera, read the keywords and their values from the configuration files. Recognize the categories by using the keyword list of the MSL camcorder, and save the member structure of the MSL camcorder. Later, these values are used as attribute values or some other operation. The permission of this file is read-only to make sure the configuration files are read once before creating the camcorder. To add comments in the config file, use a semicolon (“;”).\n\nThe following table shows the description of the mmfw_camcorder.ini file.\n\nTable: mmfw_camcorder.ini file\n\n\n  \n    \n      Category\n      Entry\n      Description\n    \n  \n  \n    \n      General\n       \n      General setting or information\n    \n    \n       \n      SyncStateChange\n      API running type. This value must be 1 (TRUE).\n    \n    \n       \n      ModelName\n      Model name of target\n    \n    \n      Video input\n       \n      Setting list related to video input\n    \n    \n       \n      UseConfCtrl\n      Whether to use the configuration file. This value must be 1 (TRUE).\n    \n    \n       \n      ConfCtrlFile0 or 1\n      Name of the setting file to control the camera device\n    \n    \n       \n      VideosrcElement\n      Source plugin which obtains the camera input buffer from the device\n    \n    \n       \n      UseZeroCopyFormat\n      Whether to use the zero copy format\n    \n    \n       \n      DeviceCount\n      Number of camera device\n    \n    \n       \n      SupportMediaPacketPreviewCb\n      Whether the camera API supports media packet preview callback on the target\n    \n    \n      Audio input\n       \n      Setting list related to audio input\n    \n    \n       \n      AudiosrcElement\n      Audio source plugin which obtains audio for the camcorder or voice recorder\n    \n    \n       \n      AudiomodemsrcElement\n      Audio source plugin which obtains audio for call recording\n    \n    \n      Video input\n       \n      Setting list related to video output\n    \n    \n       \n      DisplayDevice\n      Supported output device list and the default value\n    \n    \n       \n      Videosink\n      Supported output surface list and the default value\n    \n    \n       \n      VideosinkElementOverlay\n      Plugin name for the Overlay output surface and the property setting list\n    \n    \n       \n      VideosinkElementEvas\n      Plugin name for the Evas output surface and the property setting list\n    \n    \n       \n      VideosinkElementGL\n      Plugin name for the GL output surface and the property setting list\n    \n    \n       \n      VideosinkElementNULL\n      Plugin name for the NULL surface and the property setting list\n    \n    \n       \n      Video encoder\n      Video encoder list for video recording\n    \n    \n       \n      Audio encoder\n      Audio encoder list for AV recording or voice recording\n    \n    \n      Capture\n       \n      Setting list related to image capture\n    \n    \n       \n      UseEncodebin\n      Whether to use the encodebin to capture the image. Keep this value as 0 (FALSE).\n    \n    \n      Record\n       \n      Setting value list for each recording mode. Keep the values of the example config file.\n    \n    \n      Mux\n       \n      Mux plugin list related with the file container\n    \n  \n\n\nThe following table shows the description of the mmfw_camcorder_dev_video_pri.ini file for the primary camera (usually the rear camera) and the mmfw_camcorder_dev_video_sec.ini file for the secondary camera (usually the front camera).\n\nTable: mmfw_camcorder_dev_video_pri.ini\n\n\n  \n    \n      Category\n      Entry\n      Description\n    \n  \n  \n    \n      Camera\n       \n      Information about the camera\n    \n    \n       \n      InputIndex\n      Camera number to select (primary or secondary)\n    \n    \n       \n      DeviceName\n      Name of the camera module\n    \n    \n       \n      PreviewResolution\n      List of all supported preview resolutions the user can set, as well as the default value for this camera device\n    \n    \n       \n      CaptureResolution\n      List of all supported capture resolutions the user can set, as well as the default value for this camera device\n    \n    \n       \n      VideoResolution\n      List of all supported video resolutions the user can set, as well as the default value for this camera device\n    \n    \n       \n      FPS0 ~ 9\n      List of all supported FPS (Frame Per Second) settings by preview resolution the user can use, as well as the default value for this camera device\n    \n    \n       \n      PictureFormat\n      List of all supported preview formats a user can set, as well as the default value for this camera device\n    \n    \n       \n      RecommendDisplayRotation\n      Default display rotation value for displaying camera input\n    \n    \n       \n      RecommendPreviewFormatCapture\n      Recommended preview format for capturing images\n    \n    \n       \n      RecommendPreviewFormatRecord\n      Recommended preview format for recording\n    \n    \n       \n      RecommendPreviewResolution\n      Recommended preview resolution by ratio of preview resolution\n    \n    \n       \n      FacingDirection\n      Facing direction of camera device\n    \n    \n      Strobe\n       \n      Camera flash settings\n    \n    \n       \n      StrobeMode\n      Supported strobe mode and default value. This is converted to a real value and used in the kernel internally.\n    \n    \n      Effect\n       \n      Effect settings\n    \n    \n       \n      Brightness\n      Supported range of brightness and default value\n    \n    \n       \n      Contrast\n      Supported range of contrast and default value\n    \n    \n       \n      Saturation\n      Supported range of saturation and default value\n    \n    \n       \n      Sharpness\n      Supported range of sharpness and default value\n    \n    \n       \n      Whitebalance\n      Supported white balance list and default value. This is converted to a real value and used in the kernel internally.\n    \n    \n       \n      ColorTone\n      Supported color tone list and default value. This is converted to a real value and used in the kernel internally.\n    \n    \n       \n      WDR\n      Supported Wide Dynamic Range mode list and default value. This is converted to a real value and used in the kernel internally.\n    \n    \n      Photograph\n       \n      Camera shooting settings\n    \n    \n       \n      DigitalZoom\n      Supported range of digital zoom level and default value\n    \n    \n       \n      OpticalZoom\n      Supported range of optical zoom level and default value\n    \n    \n       \n      FocusMode\n      Supported focus mode list and default value. This is converted to a real value and used in the kernel internally.\n    \n    \n       \n      AFType\n      Supported AUTO Focus mode list and default value. This is converted to a real value and used in the kernel internally.\n    \n    \n       \n      AEType\n      Supported AUTO Exposure mode list and default value. This is converted to a real value and used in the kernel internally.\n    \n    \n       \n      ExposureValue\n      Supported range of exposure value and default value\n    \n    \n       \n      ISO\n      Supported ISO list and default value. This is converted to a real value and used in the kernel internally.\n    \n    \n       \n      ProgramMode\n      Supported program mode (scene mode) list and default value. This is converted to a real value and used in the kernel internally.\n    \n    \n       \n      AntiHandshake\n      Supported anti-hand shake mode list and default value. This is converted to a real value and used in the kernel internally.\n    \n    \n      Capture\n       \n      Image capture settings\n    \n    \n       \n      OutputMode\n      Supported capture format list and default value\n    \n    \n       \n      JpegQuality\n      Supported range of JPEG quality and default value\n    \n    \n       \n      MultishotNumber\n      Supported range of multi shot count and default value\n    \n    \n       \n      SensorEncodedCapture\n      Whether the camera device supports encoded capture format (such as JPEG)\n    \n    \n       \n      SupportHDR\n      Supported HDR mode list and default value\n    \n    \n       \n      SupportZSL\n      Whether the camera device supports zero shutter lag capture\n    \n    \n      Detect\n       \n      Detect function settings\n    \n    \n       \n      DetectMode\n      Supported detect mode list and default value\n    \n  \n\n\nReferences\n\n\n  \n    Driver configuration\n\n    Set the kernel .config values for the camera:\n    CONFIG_VIDEO_DEV = y\nCONFIG_VIDEO_SAMSUNG = y\nCONFIG_VIDEO_SAMSUNG_V4L2 = y\nCONFIG_VIDEO_FIMC = y\nCONFIG_VIDEO_FIMC_MMAP_OUTPUT_CACHE = y\nCONFIG_VIDEO_FIMC_MIPI = y\nCONFIG_VIDEO_FIMG2D = y\nCONFIG_VIDEO_JPEG = y\nCONFIG_VIDEO_MFC5X = y\n    \n  \n  \n    Kernel node\n\n    For Camera: /dev/video1\nOther CAMIF interfaces: /dev/video(0-3)\n    \n  \n  \n    GStreamer\n\n    For more information about GStreamer, see http://gstreamer.freedesktop.org/documentation/ and http://gstreamer.freedesktop.org/data/doc/gstreamer/head/pwg/html/index.html.\n  \n  \n    V4L2\n\n    For more information about V4L2, see http://v4l2spec.bytesex.org/spec-single/v4l2.html.\n  \n\n\nRadio\n\nThe radio interface part of the multimedia framework supports APIs to implement the following FM radio features:\n\n\n  Tuning a frequency\n  Getting and setting a frequency\n  Scanning all available frequencies\n  Seeking up and down\n  Getting the frequency signal\n\n\nFigure: Multimedia radio framework\n\n\n\nBecause the interfaces for controlling the radio device differ, Tizen provides the Radio Hardware Abstraction Layer (HAL) to control various radio devices with a common interface. With the common interface, you can control the radio device on various chipsets used by the libmm-radio.\n\nPorting the OAL Interface\n\nThe OAL interface for FM radio is the radio HAL interface.\n\nThe mm-hal-interface package provides the radio HAL header file:\n\n\n  Repository path: platform/core/multimedia/mm-hal-interface\n  File name: tizen-radio.h\n\n\nThe OAL interface for FM radio is the Linux kernel V4L2 interface. The radio module directly uses the V4L2 ioctls to perform various radio hardware configurations.\n\nMajor Radio HAL Functions\n\nThe following list defines the major functions for the radio HAL interface:\n\n\n  \n    Functions for initialization and deinitialization:\n\n    /* Initializes a new radio HAL handle */\nradio_error_t radio_init(void **radio_handle);\n\n/* Deinitializes the radio HAL handle */\nradio_error_t radio_deinit(void *radio_handle);\n    \n  \n  \n    Functions for preparing and unpreparing the radio device:\n\n    /* Prepares the radio device */\nradio_error_t radio_prepare_device(void *radio_handle);\n\n/* Unprepares the radio device */\nradio_error_t radio_unprepare_device(void *radio_handle);\n    \n  \n  \n    Functions for opening and closing the radio device:\n\n    /* Opens the radio device */\nradio_error_t radio_open_device(void *radio_handle);\n\n/* Closes the radio device */\nradio_error_t radio_close_device(void *radio_handle);\n    \n  \n  \n    Functions for starting and stopping the radio device:\n\n    /* Starts the radio device */\nradio_error_t radio_start(void *radio_handle);\n\n/* Stops the radio device */\nradio_error_t radio_stop(void *radio_handle);\n    \n  \n  \n    Functions for setting and getting the frequency:\n\n    /* Gets the radio frequency */\nradio_error_t radio_get_frequency(void *radio_handle, uint32_t *frequency);\n\n/* Sets the radio frequency */\nradio_error_t radio_set_frequency(void *radio_handle, uint32_t frequency);\n    \n  \n  \n    Functions for seeking channels:\n\n    typedef enum radio_seek_direction_type {\n    RADIO_SEEK_DIRECTION_UP, /* Seek upward */\n    RADIO_SEEK_DIRECTION_DOWN /* Seek downward */\n} radio_seek_direction_type_t;\n\n/* Asynchronously seeks (up or down) the effective frequency of the radio */\nradio_error_t radio_seek(void *radio_handle, radio_seek_direction_type_t direction);\n    \n  \n  \n    Functions for  muting and unmuting the radio device:\n\n    /* Mutes the radio */\nradio_error_t radio_mute(void *radio_handle);\n\n/* Unmutes the radio */\nradio_error_t radio_unmute(void *radio_handle);\n    \n  \n  \n    Functions for setting and getting the volume:\n\n    /* Gets the current radio volume */\nradio_error_t radio_get_volume(void *radio_handle, float *volume);\n\n/* Sets the current radio volume */\nradio_error_t radio_set_volume(void *radio_handle, float volume);\n\n/* Sets the current media volume level (system media volume) */\nradio_error_t radio_set_media_volume(void *radio_handle, uint32_t level);\n    \n  \n  \n    Functions for getting the signal strength:\n\n    /* Gets the current signal strength of the radio */\nradio_error_t radio_set_media_volume(void *radio_handle, uint32_t level);\n    \n  \n\n\nReferences\n\n\n  \n    Kernel node\n\n    For Radio: /dev/radio0\n    \n  \n\n\nAudio\n\nThe following figure illustrates the different audio layers.\n\nFigure: Audio layers\n\n\n\n\n  PulseAudio\n    \n      PulseAudio is a sound server accepting sound input from 1 or more sources and redirecting it to 1 or more sinks. It has the following features:\n        \n          Software mixing of multiple audio streams\n          Support for multiple audio sources and sinks\n          An extensible plugin architecture with support for loadable modules\n          Low-latency operation\n          Support for external devices, such as Bluetooth audio and USB audio devices\n        \n      \n      Pulseaudio interacts with AudioHAL interfaces to support various device types.\n    \n  \n  Audio HAL\n    \n      Predefined interfaces for Audio Hardware Abstraction Layer (HAL)\n      Interfaces include the following categories: volume, route, stream, PCM\n    \n  \n  \n    Configuration files\n\n    Configurations for running Pulseaudio and Audio Systems which can be modified without code changes.\n\n    \n      pulseaudio configurations (such as daemon.conf, client.conf, system.pa)\n      stream/device configuration (stream-map.json, device-map.json)\n    \n  \n\n\nPorting the OAL Interface\n\nThe following example defines the major functions for the audio HAL interface:\n\n/* Initializes the audio HAL handle */\naudio_return_t audio_init(void **audio_handle);\n\n/* Deinitializes the audio HAL handle */\naudio_return_t audio_deinit(void *audio_handle);\n\n/* Gets the maximum volume level supported for a particular volume information */\naudio_return_t audio_get_volume_level_max(void *audio_handle, audio_volume_info_t *info, uint32_t *level);\n\n/* Gets the volume level specified for a particular volume information */\naudio_return_t audio_get_volume_level(void *audio_handle, audio_volume_info_t *info, uint32_t *level);\n\n/* Sets the volume level specified for a particular volume information */\naudio_return_t audio_set_volume_level(void *audio_handle, audio_volume_info_t *info, uint32_t level);\n\n/* Gets the volume value specified for a particular volume information and level */\naudio_return_t audio_get_volume_value(void *audio_handle, audio_volume_info_t *info, uint32_t level, double *value);\n\n/* Gets the volume mute specified for a particular volume information */\naudio_return_t audio_get_volume_mute(void *audio_handle, audio_volume_info_t *info, uint32_t *mute);\n\n/* Sets the volume mute specified for a particular volume information */\naudio_return_t audio_set_volume_mute(void *audio_handle, audio_volume_info_t *info, uint32_t mute);\n\n/* Updates the audio routing according to audio route information */\naudio_return_t audio_update_route(void *audio_handle, audio_route_info_t *info);\n\n/* Updates audio routing option according to audio route option */\naudio_return_t audio_update_route_option(void *audio_handle, audio_route_option_t *option);\n\n/* Notifies when a stream is connected and disconnected */\naudio_return_t audio_notify_stream_connection_changed(void *audio_handle, audio_stream_info_t *info, uint32_t is_connected);\n\n/* Opens a PCM device */\naudio_return_t audio_pcm_open(void *audio_handle, void **pcm_handle, uint32_t direction, void *sample_spec, uint32_t period_size, uint32_t periods);\n\n/* Starts a PCM device */\naudio_return_t audio_pcm_start(void *audio_handle, void *pcm_handle);\n\n/* Stops a PCM device */\naudio_return_t audio_pcm_stop(void *audio_handle, void *pcm_handle);\n\n/* Closes a PCM device */\naudio_return_t audio_pcm_close(void *audio_handle, void *pcm_handle);\n\n/* Gets the available number of frames */\naudio_return_t audio_pcm_avail(void *audio_handle, void *pcm_handle, uint32_t *avail);\n\n/* Writes frames to a PCM device */\naudio_return_t audio_pcm_write(void *audio_handle, void *pcm_handle, const void *buffer, uint32_t frames);\n\n/* Reads frames from a PCM device */\naudio_return_t audio_pcm_read(void *audio_handle, void *pcm_handle, void *buffer, uint32_t frames);\n\n/* Gets the poll descriptor for a PCM handle */\naudio_return_t audio_pcm_get_fd(void *audio_handle, void *pcm_handle, int *fd);\n\n/* Recovers the PCM state */\naudio_return_t audio_pcm_recover(void *audio_handle, void *pcm_handle, int revents);\n\n/* Gets the parameters of a PCM device */\naudio_return_t audio_pcm_get_params(void *audio_handle, void *pcm_handle, uint32_t direction, void **sample_spec, uint32_t *period_size, uint32_t *periods);\n\n/* Sets the hardware and software parameters of a PCM device */\naudio_return_t audio_pcm_set_params(void *audio_handle, void *pcm_handle, uint32_t direction, void *sample_spec, uint32_t period_size, uint32_t periods);\n\n\nConfiguration\n\nTo support a variety of devices, PulseAudio and device configuration have to be modified by the vendor. The following table shows the PulseAudio configuration.\n\nTable: PulseAudio configuration\n\n\n  \n    \n      Configuration\n      Description\n    \n  \n  \n    \n      /etc/pulse/daemon.conf\n      Configuration file for the PulseAudio daemon. In this file, the PulseAudio daemon properties, such as priority, log-level, resampling method, and default sample rate, can be modified. In Tizen, the PulseAudio daemon must be running in system mode, not user mode.\n    \n    \n      /etc/pulse/client.conf\n      Configuration file for the PulseAudio clients. It is generally not necessary to modify this file.\n    \n    \n      /etc/pulse/system.pa\n      PulseAudio Sound Server startup script. This startup script is used only if PulseAudio is started in system mode. Initial module loading is triggered by this file, so any vendor-specific modules to be loaded must be added here.\n    \n    \n      /etc/pulse/default.pa\n      PulseAudio Sound Server startup script. This startup script is used only if PulseAudio is started in user mode. Currently Tizen does not support this mode.\n    \n  \n\n\nStream and device configuration:\n\n\n  \n    Stream map: Latency, volume, and streams can be configured in the /etc/pulse/stream-map.json file:\n\n    {\n    \"latencies\":[\n        {\n            \"type\":\"low\",\n            \"fragsize-ms\":25,\n            \"minreq-ms\":-1,\n            \"tlength-ms\":100,\n            \"prebuf-ms\":0,\n            \"maxlength\":-1,\n        },\n        {\n            \"type\":\"high\",\n            \"fragsize-ms\":75,\n            \"minreq-ms\":-1,\n            \"tlength-ms\":400,\n            \"prebuf-ms\":0,\n            \"maxlength\":-1,\n        },\n    ],\n    \"volumes\":[\n        {\n            \"type\":\"media\",\n            \"is-hal-volume\":1,\n        },\n        {\n            \"type\":\"system\",\n            \"is-hal-volume\":0,\n        },\n        {\n            \"type\":\"notification\",\n            \"is-hal-volume\":0,\n        },\n        {\n            \"type\":\"ringtone\",\n            \"is-hal-volume\":0,\n        },\n        {\n            \"type\":\"call\",\n            \"is-hal-volume\":1,\n        },\n    ],\n    \"streams\":[\n        {\n            \"role\":\"media\",\n            \"priority\":3,\n            \"route-type\":\"auto\",\n            \"volume-types\":{\"in\":\"none\",\"out\":\"media\"},\n            \"avail-in-devices\":[\"audio-jack\",\"builtin-mic\"],\n            \"avail-out-devices\":[\"forwarding\",\"audio-jack\",\"bt\",\"builtin-speaker\"],\n            \"avail-frameworks\":[\"player\",\"wav-player\",\"tone-player\",\"audio-io\",\"recorder\"],\n        },\n        {\n            \"role\":\"system\",\n            \"priority\":2,\n            \"route-type\":\"auto\",\n            \"volume-types\":{\"in\":\"none\",\"out\":\"system\"},\n            \"avail-in-devices\":[\"none\"],\n            \"avail-out-devices\":[\"forwarding\",\"audio-jack\",\"bt\",\"builtin-speaker\"],\n            \"avail-frameworks\":[\"player\",\"wav-player\",\"tone-player\",\"audio-io\"],\n        },\n        {\n            \"role\":\"notification\",\n            \"priority\":4,\n            \"route-type\":\"auto-all\",\n            \"volume-types\":{\"in\":\"none\",\"out\":\"notification\"},\n           \"avail-in-devices\":[\"none\"],\n            \"avail-out-devices\":[\"audio-jack\",\"bt\",\"builtin-speaker\"],\n            \"avail-frameworks\":[\"player\",\"wav-player\",\"tone-player\",\"audio-io\"],\n        },\n        {\n            \"role\":\"ringtone-call\",\n            \"priority\":6,\n            \"route-type\":\"auto-all\",\n            \"volume-types\":{\"in\":\"none\",\"out\":\"ringtone\"},\n            \"avail-in-devices\":[\"none\"],\n            \"avail-out-devices\":[\"audio-jack\",\"bt\",\"builtin-speaker\"],\n            \"avail-frameworks\":[\"player\",\"wav-player\",\"tone-player\",\"audio-io\"],\n        },\n        {\n            \"role\":\"call-voice\",\n            \"priority\":6,\n            \"route-type\":\"manual\",\n            \"volume-types\":{\"in\":\"none\",\"out\":\"call\"},\n            \"avail-in-devices\":[\"builtin-mic\",\"audio-jack\",\"bt\"],\n            \"avail-out-devices\":[\"builtin-receiver\",\"builtin-speaker\",\"audio-jack\",\"bt\"],\n            \"avail-frameworks\":[\"sound-manager\"],\n        },\n    ]\n}\n    \n  \n  \n    Device map: Device types and device files can be configured in the /etc/pulse/device-map.json file:\n\n    {\n    \"device-types\":[\n        {\n            \"device-type\":\"builtin-speaker\",\n            \"builtin\":true,\n            \"direction\":[\"out\"],\n            \"avail-condition\":[\"pulse\"],\n            \"playback-devices\":{\"normal\":\"alsa:sprdphone,0\", \"call-voice\":\"alsa:VIRTUALAUDIOW,0\"}\n        },\n        {\n            \"device-type\":\"builtin-mic\",\n            \"builtin\":true,\n            \"direction\":[\"in\"],\n            \"avail-condition\":[\"pulse\"],\n            \"capture-devices\":{\"normal\":\"alsa:sprdphone,0\"}\n        },\n        {\n            \"device-type\":\"audio-jack\",\n            \"builtin\":false,\n            \"direction\":[\"both\",\"out\"],\n            \"avail-condition\":[\"pulse\",\"dbus\"],\n            \"playback-devices\":{\"normal\":\"alsa:sprdphone,0\", \"call-voice\":\"alsa:VIRTUALAUDIOW,0\"},\n            \"capture-devices\":{\"normal\":\"alsa:sprdphone,0\"}\n        },\n        {\n            \"device-type\":\"bt\",\n            \"profile\":\"a2dp\",\n            \"builtin\":false,\n            \"direction\":[\"out\"],\n            \"avail-condition\":[\"pulse\"]\n        },\n        {\n            \"device-type\":\"bt\",\n            \"profile\":\"sco\",\n            \"builtin\":false,\n            \"direction\":[\"both\"],\n            \"avail-condition\":[\"pulse\",\"dbus\"],\n            \"playback-devices\":{\"normal\":\"alsa:sprdphone,0\", \"call-voice\":\"alsa:VIRTUALAUDIOW,0\"},\n            \"capture-devices\":{\"normal\":\"alsa:sprdphone,0\"}\n        },\n        {\n            \"device-type\":\"usb-audio\",\n            \"builtin\":false,\n            \"direction\":[\"both\", \"in\", \"out\"],\n            \"avail-condition\":[\"pulse\"]\n        }\n    ],\n    \"device-files\":\n    {\n        \"playback-devices\":[\n            {\n                \"device-string\":\"alsa:sprdphone,0\",\n                \"role\":\n                {\n                    \"normal\":\"rate=44100\",\n                }\n            },\n            {\n                \"device-string\":\"alsa:VIRTUALAUDIOW,0\",\n                \"role\":\n                {\n                    \"call-voice\":\"rate=16000 channels=1 tsched=0 alternate_rate=16000\",\n                }\n            }\n        ],\n        \"capture-devices\":[\n            {\n                \"device-string\":\"alsa:sprdphone,0\",\n                \"role\":{\"normal\":\"rate=44100\"}\n            }\n        ]\n    }\n}\n    \n  \n\n\nReferences\n\n\n  \n    Driver configuration for the Samsung chipset\n\n    The following list is an example of the kernel .config values to be set for audio when using the Samsung chipset.\n    CONFIG_SOUND=y\nCONFIG_SND=y\nCONFIG_SND_TIMER=y\nCONFIG_SND_HWDEP=y\nCONFIG_SND_JACK=y\nCONFIG_SND_SOC = y\nCONFIG_SND_SOC_SAMSUNG = y\nCONFIG_SND_SAMSUNG_I2S = y\nCONFIG_SND_SOC_SLP_TRATS_MC1N2 = y\nCONFIG_SND_SOC_I2C_AND_SPI = y\nCONFIG_SND_SOC_MC1N2=y\n    \n  \n  \n    PulseAudio\n\n    Version: 5.0\n\n    Website: http://www.freedesktop.org/wiki/Software/PulseAudio\n  \n  \n    ALSA\n\n    Website: http://www.alsa-project.org\n  \n\n\nPlayer\n\nThe multimedia player framework controls the player plugins (demuxer, codecs, and renderer plugins) of the GStreamer to play media content. The kernel interfaces to control codecs can be different for different chipsets, so the corresponding codec plugins must be implemented specifically for each chipset.\n\nFigure: Multimedia player framework\n\n\n\nPorting the OAL Interface\n\nThere is no specific OAL for the multimedia player framework. The OAL interface for the player plugins consists of the gst-omx codec plugins and video/audio renderer plugins. For more information on the gst-omx plugin, see Codec &gt; Porting OAL Interface. For more information about Avsystem for audio, see Audio. For more information on Wayland (UI-framework) for display, see Video.\n\nFigure: Player plugins\n\n\n\nConfiguration\n\n\n  Configuration file:\n    \n      The multimedia player framework uses the mmfw_player.ini configuration file to set various parameters for selecting different codecs and display plugins.\n      The mmfw_player.ini configuration file is provided by the mmfw-sysconf-xxx package.\n      In the final stage of development, the permission for this file needs to be changed to read-only.\n    \n  \n  Configuring the player:\n    \n      File name: mmfw_player.ini\n      1 player.ini file is needed in each board (or model).\n      Codec plugins for the board are located in the /usr/lib/gstreamer-1.0 directory. Changing the codec plugin does not mean modifying this .ini file because the player supports the auto plugin feature.\n    \n  \n  As needed, the following setting values can be used:\n    \n      Exclude keyword element\n      Audio filter\n    \n  \n\n\nReferences\n\n\n  \n    Display driver configuration for the Samsung chipset\n\n    The following list is an example of the kernel .config values to be set for display in the Samsung chipset.\n    CONFIG_DRM = y\nCONFIG_FB = y\nCONFIG_FB_S3C = y\nCONFIG_FB_S3C_LCD_INIT = y\nCONFIG_FIMD_EXT_SUPPORT = y\nCONFIG_FIMD_LITE_SUPPORT = y\n    \n  \n  \n    Kernel node\n    \n      Frame buffers: /dev/fb(0-4)\n      gst-omx version : 1.2.0\n        \n          http://gstreamer.freedesktop.org/src/gst-omx/\n          http://www.freedesktop.org/wiki/GstOpenMAX\n        \n      \n      For all GStreamer documentation, see http://gstreamer.freedesktop.org/documentation/.\n      For developing GStreamer plugins, see http://gstreamer.freedesktop.org/data/doc/gstreamer/head/pwg/html/index.html.\n      For more information about OpenMAX IL components, see http://www.khronos.org/openmax/il/.\n    \n  \n\n\nCodec\n\nThe following figure illustrates the codecs and their relations. It shows 2 types of codec plugins, the Gstreamer and OpenMAX.\n\nFigure: Multimedia codecs\n\n\n\n\n  \n    Gstreamer codec plugin\n\n    \n      The Gstreamer codec plugin can be linked to and easily used in the Gstreamer pipeline, which is used in the multimedia framework.\n      In addition, to link a Gstreamer pipeline, the capability of the codec plugin can be negotiated with the linked element in the pipeline.\n      \n        To get detailed information, such as the capability of an element, use the #gst-inspect-1.0 (element name) command.\n\n        \n      \n    \n  \n  \n    OpenMAX codec plugin\n    \n      Some of the codec vendors provide OpenMAX IL components and not Gstreamer plugins. Tizen provides the gst-omx plugins to use the OpenMAX IL components. The Gstreamer pipeline used in the multimedia framework can control and transfer data to OpenMAX IL component using the gst-omx plugin.\n      To use the OpenMAX component in Gstreamer, the gst-omx (open source) package is provided. By using this package, Gstreamer can recognize and use an OpenMAX component as a Gstreamer element. gst-omx is a Gstreamer plugin that allows communication with OpenMAX IL components. The usage of the gst-omx plugin is the same as other Gstreamer plugins.\n      For more detailed information about this plugin, see http://www.freedesktop.org/wiki/GstOpenMAX. For more information about OpenMAX IL, see http://www.khronos.org/openmax/.\n      The gst-omx plugin refers to a gstomx.conf configuration file. This file is included in the gst-omx package, and installed to the /etc/xdg/gst-omx.conf directory in the target device.\n    \n  \n\n\nPorting the OAL Interface\n\nThe OpenMAX plugin is an industry standard that provides an abstraction layer for computer graphics, video, and sound routines. The interface abstracts the hardware and software architecture in the system. The OpenMAX IL API allows the user to load, control, connect, and unload the individual components. This flexible core architecture allows the Integration Layer to easily implement almost any media use case and mesh with existing graph-based media frameworks. The key focus of the OpenMAX IL API is portability of media components. OpenMAX IL interfaces between the media framework, such as GStreamer, and a set of multimedia components (such as an audio or video codecs). gst-omx is a GStreamer plug-in package that allows communication with OpenMAX IL components. The gst-omx structuring is classified into different object classes based on the functionality. The following figure shows the object structuring of a video decoder plugin in gst-omx.\n\nFigure: gst-omx structuring\n\n\n\nThe GstVideoDecoder base class for video decoders provides encoded data to derived GstOMXVideoDec. Each input frame is provided in turn to the subclass’s handle_frame callback. The GstVideoDecoder base class and derived subclass cooperate in the following manner:\n\n\n  Configuration\n    \n      GstVideoDecoder calls the start() function when the decoder element is activated.\n      GstVideoDecoder calls the set_format() function to inform the subclass of caps describing the input video data.\n    \n  \n  Data processing\n    \n      Each input frame is provided in turn to the subclass’s handle_frames() function.\n      The subclass calls the gst_video_decoder_finish_frame() or gst_video_decoder_drop_frame() function.\n    \n  \n  Shutdown phase\n    \n      The GstVideoDecoder class calls the stop() function.\n    \n  \n\n\nConfiguration\n\nThe gst-omx plugin uses a configuration file, such as gstomx.conf. This file is included in the gst-omx package, and installed in the /etc/xdg/gstomx.conf directory on the target device. The gstomx.conf file needs to be changed according to the OpenMAX component vendor. The following figures lists the values of each item in the lists separated by commas. Each Gstreamer element is separated by a semicolon.\n\nFigure: gstomx.conf elements\n\n\n\nFigure: gstomx.conf example\n\n\n\nEach value needs to be changed according to the OpenMAX component vendor. When you are finished with these settings, the result is a Gstreamer type codec plugin, and you can test the codec the same way.\n\n\n  \n    Using the codec plugin in the player\n\n    Because the player uses auto plugging, it does not need an additional setting.\n\n    \n      If the decoder plugin has an acceptable capability, this plugin can be linked with a player pipeline in order of rank.\n      If the codec name is included in the excluded keyword in the /usr/etc/mmfw_player.ini file (mmfw-sysconf package), it is excluded in the player pipeline.\n    \n  \n  \n    Using the codec plugin in the camcorder\n\n    Because the camcorder clarified its audio, video, and image encoder in the /usr/etc/mmfw_camcorder.ini file (mmfw-sysconf package), you need to change this category value to set your own codec name.\n\n    \n  \n\n\nReferences\n\n\n  \n    gst-omx version: 1.2\n\n    http://gstreamer.freedesktop.org/src/gst-omx/\n\n    http://www.freedesktop.org/wiki/GstOpenMAX\n  \n  \n    For all GStreamer documentation, see http://gstreamer.freedesktop.org/documentation/.\n  \n  \n    For developing GStreamer plug-ins, see http://gstreamer.freedesktop.org/data/doc/gstreamer/head/pwg/html/index.html.\n  \n  \n    For more information about OpenMAX IL components, see http://www.khronos.org/openmax/il/.\n  \n\n\nVideosink\n\nThe videosink renders a video frame buffer from a previous gst element on a local display using Waylandsink (since Tizen 3.0). It is used with a camera or player that requires video output. This element can receive a surface ID of a window from the application through the GstVideoOverlay interface (set_wl_window_wl_surface_id()) and renders the video frame in this window. If no surface ID was provided by the application, the element creates its own internal window and renders into it.\n\nThe following figure shows the video rendering process in the player. The white box is the gstreamer element. GstBuffer is streaming from filesrc to Waylandsink past the video codec. The GstBuffer is TBM or SHM.\n\nFigure: Video rendering process\n\n\n\n\n  Waylandsink requests the rendering of the video frame to the wl_surface of a window, so Waylandsink needs the wl_surface of a Wayland window created by the application. Because the application and Muse are in different process bounds, the application cannot pass the wl_surface pointer to Muse. To solve this problem, Tizen uses the surface ID value.\n  The application sends a wl_surface pointer to the Window Server, which returns the global surface ID to the application, which in turn passes this value to Waylandsink using the GstVideoOverlay interface, set_wl_window_wl_surface_id() (Tizen-specific). Steps 1, 2, and 3 in the figure.\n  Waylandsink creates wl_display to communicate with the Window Server. Normally a Window client uses the wl_display created by the application, but the Tizen Waylandsink creates its own wl_display due to process bounds issues. Step 4. Now Waylandsink can receive events from the server and bind to various interfaces using wl_registry.\n  Waylandsink uses wl_display to create wl_window and a wl_subsurface using the global surface ID passed through the GstVideoOverlay interface. wl_surface is created by the wl_compositor of wl_display. Step 5.\n  The application can use the Waylandsink properties to change video rendering conditions through wl_subsurface. Step 6.\n  The GstBuffer received from the video codec is converted into a wl_buffer, then the wl_surface of wl_window is requested to render the video frame to the Window Server through the attach, damage, and commit process. Steps 7 and 8. The Window Server renders the wl_buffer. Step 9.\n  When the Window Server finishes rendering the video frame, the rendering complete signal is sent to the wl_callback of wl_window, and the wl_buffer release event is sent to the wl_buffer_listener callback function. Steps 10 and 11. Now, Waylandsink can unreference the GstBuffer created by the video codec and return the GstBuffer to the video codec. Sometimes, it is necessary to return a GstBuffer while maintaining the rendered video frame in the window (for gapless playback, or keeping a camera preview). In this case, use FlushBuffer, which is a wl_buffer created after copying TBM from GstBuffer coming from the video codec. Waylandsink returns the GstBuffer to the video codec immediately, and a request to render the FlushBuffer is made to the Window Server.\n\n\nFor more information on Wayland, see https://wayland.freedesktop.org/.  For more information on programming the Wayland client, see Programming Wayland Clients.\n\nPorting the OAL Interface\nThere is no specific OAL for the videosink.\n\nTizen-specific Features Added to Waylandsink\n\nYou can check the original waylandsink behavior easily with Waylandsink’s video rendering test. Simply connect to videotestsrc through gst-launch. If the video test screen does not appear, the Window system must be ported first.\n\ngst-launch-1.0 videotestsrc ! waylandsink\n\nFigure: Video test screen\n\n\n\nWaylandsink Requirements for Tizen\n\nOpen source Waylandsink uses wayland-client, but Waylandsink for Tizen uses libtbm, wayland-tbm-client, and tizen-extension-client to support MMFW’s API requirements and uses Window Server extended functionality.\n\nThe major functions are TBM Video Format, Specific Video Formats, Zero copy, MMVideoBuffer, Tizen Viewport, Flush Buffer, Audio only mode, Handoffs Element signals, preroll-handoff Element signals, Use TBM, Rotate, Flip, Visible, Display Geometry Method, and ROI.\n\nTBM Video Format\n\nOriginal Waylandsink lists various video formats, but Wayland only supports the RGB format. To support various video formats, Waylandsink for Tizen uses the TBM Video Format provided by Wayland for Tizen. The video formats supported by the Window Server are hardware-dependent. The dependency is on the Window Server. When the Gst-pipeline with Waylandsink is created and the caps negotiation begins, the TBM video format provided by the Window Server is passed to Waylandsink. The Window Server can accommodate the video output format of the video codec when the negotiation is completed.\n\nTo use the TBM Video Format, Waylandsink needs to bind tizen_policy_interface, tizen_video_interface, and register listener and get the video formats as a callback.\n\nstatic void handle_tizen_video_format(void *data, struct tizen_video *tizen_video, uint32_t format) {\n    GstWlDisplay *self = data;\n    FUNCTION;\n\n    g_return_if_fail(self != NULL);\n\n    GST_LOG(\"format is %d\", format);\n    g_array_append_val(self-&gt;tbm_formats, format);\n}\n\nstatic const struct tizen_video_listener tizen_video_listener = {\n    handle_tizen_video_format\n};\n\nstatic void global_registry_handler(void *data, struct wl_registry *registry, uint32_t id, const char *interface, uint32_t version) {\n    [...]\n    } else if (g_strcmp0(interface, \"tizen_policy\") == 0) {\n        self-&gt;tizen_policy = wl_registry_bind(registry, id, &amp;tizen_policy_interface, 1);\n    } else if (g_strcmp0(interface, \"tizen_video\") == 0) {\n        self-&gt;tizen_video = wl_registry_bind(registry, id, &amp;tizen_video_interface, version);\n        g_return_if_fail(self-&gt;tizen_video != NULL);\n        tizen_video_add_listener(self-&gt;tizen_video, &amp;tizen_video_listener, self);\n    }\n    [...]\n}\n\n\nSpecific Video Formats (SN12, SN21, ST12, SR32, S420) for Zero copy\n\nThe SN12, SN21, ST12, SR32, and S320 formats are identical to NV12, NV21, NV12MT, BGRA, and I420, but the Multimedia framework uses these specific video formats to indicate that the formats are using a TBM buffer. Tizen provides a TBM buffer to avoid memory copying when transferring the buffer to different processes. Camerasrc or the video codec writes the video data to the TBM buffer, saves it to a pointer to GstBuffer, and sends it to Waylandsink. Waylandsink creates a wl_buffer with tbm_bo and requests rendering from the Window Server. There is no memory copy from Camerasrc or the video codec to the Window Server. This process is called Zero Copy.\n\nMMVideoBuffer\n\nThe Gst Element must use the MMVideoBuffer type when transferring TBM buffer. tbm bo must be stored in bo of MMVideoBufferHandle, and the type must be MM_VIDEO_BUFFER_TYPE_TBM_BO. Waylandsink makes wl_buffer by using the MMVideoBuffer information. If the video frame is not rendered, Waylandsink must make sure that the information in MMVideoBuffer in GstBuffer received from Camerasrc or Video Codec is correct.\n\ntypedef struct {\n    MMVideoBufferType type; /* Buffer type - the handle field that type indicates must be filled, and other handle fields are optional */\n    MMPixelFormatType format; /* Buffer type */\n    int plane_num; /* Number of planes */\n    int width[MM_VIDEO_BUFFER_PLANE_MAX] /* Width of buffer */\n    int height[MM_VIDEO_BUFFER_PLANE_MAX]; /* Height of buffer */\n    int stride_width[MM_VIDEO_BUFFER_PLANE_MAX]; /* Stride width of buffer */\n    int stride_height[MM_VIDEO_BUFFER_PLANE_MAX]; /* Stride height of buffer */\n    int size[MM_VIDEO_BUFFER_PLANE_MAX]; /* Size of planes */\n    void *data[MM_VIDEO_BUFFER_PLANE_MAX]; /* Data pointer(user address) of planes */\n    int handle_num; /* Number of buffer handle */\n    int handle_size[MM_VIDEO_BUFFER_PLANE_MAX]; /* Size of handles */\n    MMVideoBufferHandle handle; /* Handle of buffer */\n    int is_secured; /* Secured buffer flag, such as TrustZone memory; user cannot access it */\n    int flush_request; /* Flush request flag - if this flag is TRUE, sink element makes copy of last buffer, and it returns all buffers from src element. Then, src element can restart without changing pipeline state */\n    MMRectType crop; /* Crop information of buffer */\n} MMVideoBuffer;\n\nMMVideoBuffer can contain video data information of all cases, as shown in the following figure.\n\nFigure: MMVideoBuffer content\n\n\n\nTizen Viewport\n\nTo change the video frame render condition, the original open-source Waylandsink uses wlsurface_set_source(), wl_surface_set_buffer_transform(), wl_subsurface_set_position(), wl_viewport_set_destination(), and wl_surface_set_buffer_transform() functions. For more information on the Wayland API, see https://wayland.freedesktop.org/docs/html/. Waylandsink needs to IPC with wl_surface, wl_subsurface, and wl_viewport.\n\nFigure: Changing video frame render conditions\n\n\n\nFigure: Wayland protocols\n\n\n\nWaylandsink in the Muse Daemon requests rendering conditions on the wl_subsurface of the window created by the application. Therefore, it is difficult to match the geometry sync of the parent (Window) and wl_subsurface, due to the delay caused by the IPC communication between the Window Server and Wayland client. Since wl_viewport_ and wl_set_source_ are surface-based coordination, it is difficult to calculate the coordinates when the buffer is transformed. So Waylandsink for Tizen uses tizen_viewport supported Wayland Server for Tizen. To use tizen_viewport, Waylandsink binds tizen_policy_interface and tizen_video_interface. Now, Waylandsink only needs to IPC tizen_viewport.\n\nFigure: Tizen viewport\n\n\n\n\n  \n    Example 1:\n\n    \n  \n  \n    Example 2:\n\n    \n  \n  \n    Example 3:\n\n    \n  \n  \n    Example 4:\n\n    \n  \n\n\nFlush buffer\n\nSometimes, it is necessary to return GstBuffer while maintaining the video frame rendered in the window. In this case, use FlushBuffer, which is a wl_buffer created after copying TBM from GstBuffer coming from the video codec or Camerasrc. Waylandsink returns the GstBuffer to the video codec or Camerasrc immediately, and a request to render the FlushBuffer is made to the Window Server.\n\n\n  \n    Gapless video playback\n\n    Waylandsink receives the GST_EVENT_CUSTOM_DOWNSTREAM event from the player when it performs gapless video playback. The player creates a FlushBuffer.\n\n    #define GST_APP_EVENT_FLUSH_BUFFER_NAME \"application/flush-buffer\"\n\nstatic gboolean gst_wayland_sink_event(GstBaseSink * bsink, GstEvent * event) {\n    [...]\n    switch (GST_EVENT_TYPE(event)) {\n    case GST_EVENT_CUSTOM_DOWNSTREAM:\n        s = gst_event_get_structure(event);\n        if (s == NULL || !gst_structure_has_name(s, GST_APP_EVENT_FLUSH_BUFFER_NAME))\n            break;\n        gst_wayland_sink_render_flush_buffer(bsink);\n    [...]\n}\n    \n  \n  \n    keep-camera-preview\n\n    The camera sets this property when it needs to maintain the last video frame. Waylandsink copies the last TBM buffer and returns it immediately when the state changes (PAUSED_TO_READY).\n    keep-camera-preview : Last tbm buffer is copied and returned to camerasrc immediately when state change(PAUSED_TO_READY)\n                      flags: readable, writable\n                      Boolean. Default: false\n    \n  \n  \n    flush_request of MMVideoBuffer\n\n    Camerasrc and the video codec can set a flag to request a flushbuffer in the GstBuffer using MMVideoBuffer.flush_request = TRUE.\n  \n\n\nAudio only mode\n\nWaylandsink has a disable-overlay property to support the player’s audio-only mode. If this property is set, the video frame is not rendered. When the player needs to show a video frame, it needs to set this property to false and set wl_surface_id.\n\ndisable-overlay : Stop using overlay by destroying wl_window and wl_display, Use gst_video_overlay_set_wl_window_wl_surface_id before setting FALSE to use overlay\n                              flags: readable, writable\n                              Boolean. Default: false\n\n\ngst_wayland_sink_set_property(GObject * object, guint prop_id, const GValue * value, GParamSpec * pspec) {\n    [...]\n    case PROP_DISABLE_OVERLAY:\n       sink-&gt;disable_overlay = g_value_get_boolean(value);\n       if (sink-&gt;window &amp;&amp; sink-&gt;display) {\n         if (sink-&gt;disable_overlay) {   /* set TRUE */\n           g_clear_object(&amp;sink-&gt;window);\n           g_clear_object(&amp;sink-&gt;display);\n        } else /* set FALSE */\n          gst_wayland_sink_recover_display_window_info(sink);\n       }\n       break;\n    [...]\n}\n\nstatic GstFlowReturn gst_wayland_sink_render(GstBaseSink * bsink, GstBuffer * buffer) {\n    [...]\n    /* check overlay */\n    if (gst_wayland_sink_is_disabled_overlay(sink)) {\n        GST_LOG(\"set disable_overlay, so skip\");\n        goto done; //skip video rendering\n    }\n    [...]\n}\n\nRefer to mm_player_priv.c\n/* Need to set surface_id to enable overlay */\ngst_video_overlay_set_wl_window_wl_surface_id(GST_VIDEO_OVERLAY(player-&gt;pipeline-&gt;videobin[MMPLAYER_V_SINK].gst), *(int*)handle);\n\n\nHandoffs and preroll-handoff element signals\n\nChanging the gst-pipeline of the player is labor-intensive, so Waylandsink provides a fakesink functionality. If this property is set to true, Waylandsink sends a handoff signal to the player.\n\nstatic GstFlowReturn gst_wayland_sink_render(GstBaseSink * bsink, GstBuffer * buffer) {\n    [...]\n    /* fakesink function for media stream callback case */\n    if (sink-&gt;signal_handoffs) {\n        GST_LOG(\"g_signal_emit: hand-off \");\n        g_signal_emit(sink, gst_waylandsink_signals[SIGNAL_HANDOFF], 0, buffer, bsink-&gt;sinkpad);\n        goto done;  /* Skip video rendering */\n    }\n    [...]\n}\n\n\nUse TBM\n\nWaylandsink use 2 types of buffers, shared memory and TBM memory. The default value of the use-tbm property is true and Waylandsink uses TBM memory. If the value is false, Waylandsink for Tizen uses shared memory just like the original open-source Waylandsink.\nuse-tbm  : Use Tizen Buffer Memory instead of Shared memory, Memory is allocated by TBM instead of SHM when enabled\n           flags: readable, writable\n           Boolean. Default: true\n\n\nRotate\n\nWaylandsink can rotate the angle of display output. The default value of the rotate property is 0, “DEGREE_0”.\nrotate   : Rotate angle of display output\n           flags: readable, writable\n           Enum \"GstWaylandSinkRotateAngleType\" Default: 0, \"DEGREE_0\"\n                (0): DEGREE_0         - No rotate\n                (1): DEGREE_90        - Rotate 90 degree\n                (2): DEGREE_180       - Rotate 180 degree\n                (3): DEGREE_270       - Rotate 270 degree\n\n\nThe enumeration values used by the player or camera need to be converted to values used by Wayland.\nstatic gint gst_wl_window_find_rotate_transform(guint rotate_angle) {\n    gint transform = WL_OUTPUT_TRANSFORM_NORMAL;\n    switch (rotate_angle) {\n    case DEGREE_0:\n         transform = WL_OUTPUT_TRANSFORM_NORMAL;\n         break;\n    case DEGREE_90:\n        transform = WL_OUTPUT_TRANSFORM_90;\n        break;\n    case DEGREE_180:\n        transform = WL_OUTPUT_TRANSFORM_180;\n        break;\n    case DEGREE_270:\n        transform = WL_OUTPUT_TRANSFORM_270;\n        break;\n    }\n\n    return transform;\n}\n\ntransform =  gst_wl_window_find_rotate_transform(window-&gt;rotate_angle.value);\ntizen_viewport_set_transform(window-&gt;tizen_area_viewport, transform);\n\n\nFlip\n\nWaylandsink can flip the angle of the display output. The default value of the flip property is 0, “FLIP_NONE”.\n flip  : Flip for display\n         flags: readable, writable\n         Enum \"GstWaylandSinkFlipType\" Default: 0, \"FLIP_NONE\"\n              (0): FLIP_NONE        - Flip NONE\n              (1): FLIP_HORIZONTAL  - Flip HORIZONTAL\n              (2): FLIP_VERTICAL    - Flip VERTICAL\n              (3): FLIP_BOTH        - Flip BOTH\n\n\nWayland has no flip function, so Waylandsink must implement flipping by rotating the video viewport:\nstatic gint gst_wl_window_find_flip_transform(guint flip) {\n    gint transform = WL_OUTPUT_TRANSFORM_NORMAL;\n    FUNCTION;\n\n    GST_DEBUG(\"flip (%d)\", flip);\n    switch (flip) {\n    case FLIP_NONE:\n        transform = WL_OUTPUT_TRANSFORM_NORMAL;\n        break;\n    case FLIP_HORIZONTAL:\n        transform = WL_OUTPUT_TRANSFORM_FLIPPED;\n        break;\n    case FLIP_VERTICAL:\n        transform = WL_OUTPUT_TRANSFORM_FLIPPED_180;\n        break;\n    case FLIP_BOTH:\n        transform = WL_OUTPUT_TRANSFORM_180;\n        break;\n    }\n\n    return transform;\n}\n\ntransform = gst_wl_window_find_flip_transform(window-&gt;flip.value);\ntizen_viewport_set_transform(window-&gt;tizen_video_viewport, transform);\n\n\nVisible\n\nWaylandsink can make the video frame visible or invisible on the display. To make the video frame invisible, attach NULL. To make the video fame visible, Waylandsink needs to keep the last rendered video frame.\n\n/* invisible */\nstatic void gst_wayland_sink_stop_video(GstWaylandSink * sink) {\n    FUNCTION;\n    g_return_if_fail(sink != NULL);\n    gst_wl_window_render(sink-&gt;window, NULL, NULL);\n}\n/* visible */\ngst_wayland_sink_update_last_buffer_geometry(sink);\n\n\nDisplay geometry method and ROI\n\nWhen rendering video, Waylandsink can change the geometry.\n\ndisplay-geometry-method: Geometrical method for display\n           flags: readable, writable\n           Enum \"GstWaylandSinkDisplayGeometryMethodType\" Default: 0, \"LETTER_BOX\"\n                (0): LETTER_BOX       - Letter box\n                (1): ORIGIN_SIZE      - Origin size\n                (2): FULL_SCREEN      - Full-screen\n                (3): CROPPED_FULL_SCREEN - Cropped full-screen\n                (4): ORIGIN_SIZE_OR_LETTER_BOX - Origin size(if screen size is larger than video size(width/height)) or Letter box(if video size(width/height) is larger than screen size)\n                (5): DISP_GEO_METHOD_CUSTOM_ROI - Specially described destination ROI\n\nThese are provided by using tizen_viewport since Tizen 3.0.\n\nenum {\n    DISP_GEO_METHOD_LETTER_BOX = 0,\n    DISP_GEO_METHOD_ORIGIN_SIZE,\n    DISP_GEO_METHOD_FULL_SCREEN,\n    DISP_GEO_METHOD_CROPPED_FULL_SCREEN,\n    DISP_GEO_METHOD_ORIGIN_SIZE_OR_LETTER_BOX,\n    DISP_GEO_METHOD_CUSTOM_ROI,\n    DISP_GEO_METHOD_NUM,\n};\n\nif (tizen_disp_mode &gt; -1) {\n    tizen_destination_mode_set(window-&gt;tizen_video_dest_mode, tizen_disp_mode);\n}\n\n\nROI coordinates can be set only when the value of display-geometry-method is set to 5, and ROI coordinates are obtained from gst_video_overlay_set_render_rectangle() from the player or camera.\nif (window-&gt;disp_geo_method.value == DISP_GEO_METHOD_CUSTOM_ROI) {\n    tizen_viewport_set_destination(window-&gt;tizen_video_viewport, window-&gt;roi.x, window-&gt;roi.y, window-&gt;roi.w, window-&gt;roi.h);\n}\n\n\nThe following examples describe the various available modes:\n\n\n  \n    Letterbox mode\n\n    Fit the video source to the width or height of the window, aligned to the center and keeping the aspect ratio of the original video source.\n\n    \n      \n        Window (width/height) &gt; Video source (width/height)\n\n        \n      \n      \n        Window (width/height) &lt; Video source (width/height)\n\n        \n      \n    \n  \n  \n    Original size mode\n\n    Set the video source size the same as the original video size, aligned to the center and keeping the aspect ratio of the original video source.\n\n    \n      \n        Window size &gt; Video source size\n\n        \n      \n      \n        Window size &lt; Video source size\n\n        \n      \n    \n  \n  \n    Cropped full screen mode\n\n    Fit the video source to the width and height, cropping out the area outside the window, aligned to the center and keeping the aspect ratio of the original video source.\n\n    \n      \n        Window (width/height) &gt; Video source (width/height)\n\n        \n      \n      \n        Window (width/height) &lt; Video source (width/height)\n\n        \n      \n    \n  \n  \n    ROI mode\n\n    The user sets the location and size of where the video is rendered.\n\n    \n      \n        Window size: width(1920), height(1080), ROI size: x(100), y(100), width(800), height(400)"
					}
					
				
			
		
			
				
					,
					
					"platform-porting-multimedia": {
						"id": "platform-porting-multimedia",
						"title": "Multimedia",
						"categories": "",
						"url": " platform/porting/multimedia/",
						"content": "Multimedia\n\nYou can implement various multimedia features, such as camera, audio, and video.\n\nCamera\n\nThe Multimedia camcorder framework controls the GStreamer camera plugin to capture camera data from the device. The kernel interfaces to control the camera device can be different for different chipsets, so the camera HAL (Hardware Abstraction Layer) used by the camera plugin is provided and it must be implemented specifically for each chipset. Each configuration file contains its own specific hardware-dependent information. The Multimedia camcorder framework reads and parses the information in these configuration files.\n\nFigure: Multimedia camcorder framework\n\n\n\n\n  \n    Camera source plugin for GStreamer\n\n    Gets the camera data (preview or captured image) and sets various camera commands through camera HAL interface\n  \n  \n    Camera HAL\n\n    Common interface to control the camera device on various shipsets and used by the camera source plugin.\n  \n  \n    Configuration files\n\n    There are 3 config files for the Multimedia camcorder framework. They are provided by mmfw- sysconf-xxx:\n    \n      mmfw_camcorder.ini\n      mmfw_camcorder_dev_video_pri.ini\n      mmfw_camcorder_dev_video_sec.ini\n    \n  \n\n\nPorting the OAL Interface\n\nTizen provides a default reference camera source plugin which uses the camera HAL interface.\n\nFor the camera HAL, the mm-hal-interface package provides a header file:\n\n\n  Repository path: platform/core/multimedia/mm-hal-interface\n  File name: tizen-camera.h\n\n\nMajor Camera HAL Functions\n\nThe following list defines the major functions for the camera HAL interface:\n\n\n  \n    Functions for initialization and deinitialization:\n\n    /*Initializes new camera HAL handle */\nint camera_init(void **camera_handle);\n\n/* Deinitializes the camera HAL handle */\nint camera_deinit(void *camera_handle);\n    \n  \n  \n    Functions for opening and closing the camera device:\n\n    /* Opens the camera device */\nint camera_open_device(void *camera_handle, int device_index);\n\n/* Closes the camera device */\nint camera_close_device(void *camera_handle);\n    \n  \n  \n    Functions for getting device information:\n\n    /* Gets the camera device list */\nint camera_get_device_list(void *camera_handle, camera_device_list_t *device_list);\n\n/* Registers a callback function to be called to send a message by the camera HAL */\nint camera_add_message_callback(void *camera_handle, camera_message_cb callback, void *user_data, uint32_t *cb_id);\n\n/* Unregisters a callback function */\nint camera_remove_message_callback(void *camera_handle, uint32_t cb_id);\n    \n  \n  \n    Functions for preview and capture:\n\n    typedef struct camera_format {\n    camera_pixel_format_t stream_format;\n    camera_resolution_t stream_resolution;\n    uint32_t stream_fps;\n    camera_rotation_t stream_rotation;\n    camera_pixel_format_t capture_format;\n    camera_resolution_t capture_resolution;\n    uint32_t capture_quality;\n} camera_format_t;\n\n/* Sets the format of the preview stream */\nint camera_set_preview_stream_format(void *camera_handle, camera_format_t *format);\n\n/* Gets the format of the preview stream  */\nint camera_get_preview_stream_format(void *camera_handle, camera_format_t *format);\n\ntypedef int (*camera_preview_frame_cb)(camera_buffer_t *buffer, camera_metadata_t *meta, void *user_data);\n\n/* Starts the display of preview frames on the scree. */\nint camera_start_preview(void *camera_handle, camera_preview_frame_cb callback, void *user_data);\n\n/* Stops the preview frames */\nint camera_stop_preview(void *camera_handle);\n\n/* Releases the preview buffer; the preview buffer must be released with this function after using it */\nint camera_release_preview_buffer(void *camera_handle, int buffer_index);\n\n/* Starts the camera auto-focusing operation */\nint camera_start_auto_focus(void *camera_handle);\n\n/* Stops the camera auto-focusing operation */\nint camera_stop_auto_focus(void *camera_handle);\n\ntypedef int (*camera_capture_cb)(camera_buffer_t *main, camera_buffer_t *postview, camera_buffer_t *thumbnail, void *user_data);\n\n/* Starts capturing still images */\nint camera_start_capture(void *camera_handle, camera_capture_cb callback, void *user_data);\n\n/* Stops capturing still images */\nint camera_stop_capture(void *camera_handle);\n    \n  \n  \n    Functions for video recording:\n\n    /* Stops capturing still images */\nint camera_set_video_stream_format(void *camera_handle, camera_format_t *format);\n\n/* Gets the video stream format for recording */\nint camera_get_video_stream_format(void *camera_handle, camera_format_t *format);\n\ntypedef int (*camera_video_frame_cb)(camera_buffer_t *buffer, camera_metadata_t *meta, void *user_data);\n\n/* Starts the video frame for recording */\nint camera_start_record(void *camera_handle, camera_video_frame_cb callback, void *user_data);\n\n/* Stops the video frame */\nint camera_stop_record(void *camera_handle);\n\n/* Video buffer must be released with this function after using it */\nint camera_release_video_buffer(void *camera_handle, int buffer_index);\n    \n  \n  \n    Functions for controlling the camera device:\n\n    #define CAMERA_COMMAND_BASE                     ((int64_t)1)\n#define CAMERA_COMMAND_WHITE_BALANCE            ((int64_t)(CAMERA_COMMAND_BASE &lt;&lt; 1))\n#define CAMERA_COMMAND_ISO                      ((int64_t)(CAMERA_COMMAND_BASE &lt;&lt; 2))\n#define CAMERA_COMMAND_CONTRAST                 ((int64_t)(CAMERA_COMMAND_BASE &lt;&lt; 3))\n#define CAMERA_COMMAND_SATURATION               ((int64_t)(CAMERA_COMMAND_BASE &lt;&lt; 4))\n#define CAMERA_COMMAND_HUE                      ((int64_t)(CAMERA_COMMAND_BASE &lt;&lt; 5))\n#define CAMERA_COMMAND_SHARPNESS                ((int64_t)(CAMERA_COMMAND_BASE &lt;&lt; 6))\n#define CAMERA_COMMAND_EFFECT                   ((int64_t)(CAMERA_COMMAND_BASE &lt;&lt; 7))\n#define CAMERA_COMMAND_SCENE_MODE               ((int64_t)(CAMERA_COMMAND_BASE &lt;&lt; 8))\n#define CAMERA_COMMAND_EXPOSURE_MODE            ((int64_t)(CAMERA_COMMAND_BASE &lt;&lt; 9))\n#define CAMERA_COMMAND_EXPOSURE                 ((int64_t)(CAMERA_COMMAND_BASE &lt;&lt; 10))\n#define CAMERA_COMMAND_ROTATION                 ((int64_t)(CAMERA_COMMAND_BASE &lt;&lt; 11))\n#define CAMERA_COMMAND_FLIP                     ((int64_t)(CAMERA_COMMAND_BASE &lt;&lt; 12))\n#define CAMERA_COMMAND_FOCUS_MODE               ((int64_t)(CAMERA_COMMAND_BASE &lt;&lt; 13))\n#define CAMERA_COMMAND_FOCUS_RANGE              ((int64_t)(CAMERA_COMMAND_BASE &lt;&lt; 14))\n#define CAMERA_COMMAND_SHOT_MODE                ((int64_t)(CAMERA_COMMAND_BASE &lt;&lt; 15))\n#define CAMERA_COMMAND_ANTI_SHAKE               ((int64_t)(CAMERA_COMMAND_BASE &lt;&lt; 16))\n#define CAMERA_COMMAND_FOCUS_AREA               ((int64_t)(CAMERA_COMMAND_BASE &lt;&lt; 17))\n#define CAMERA_COMMAND_DIGITAL_ZOOM             ((int64_t)(CAMERA_COMMAND_BASE &lt;&lt; 18))\n#define CAMERA_COMMAND_OPTICAL_ZOOM             ((int64_t)(CAMERA_COMMAND_BASE &lt;&lt; 19))\n#define CAMERA_COMMAND_RECORDING_HINT           ((int64_t)(CAMERA_COMMAND_BASE &lt;&lt; 20))\n#define CAMERA_COMMAND_WDR                      ((int64_t)(CAMERA_COMMAND_BASE &lt;&lt; 21))\n#define CAMERA_COMMAND_SHUTTER_SPEED            ((int64_t)(CAMERA_COMMAND_BASE &lt;&lt; 22))\n#define CAMERA_COMMAND_FLASH_MODE               ((int64_t)(CAMERA_COMMAND_BASE &lt;&lt; 23))\n#define CAMERA_COMMAND_FACE_DETECTION           ((int64_t)(CAMERA_COMMAND_BASE &lt;&lt; 24))\n\n/* Sets various commands and values to control the camera device */\nint camera_set_command(void *camera_handle, int64_t command, void *value);\n\n/* Gets the current value of the command */\nint camera_get_command(void *camera_handle, int64_t command, void *value);\n\ntypedef struct camera_batch_command_control {\n    /* Flag for modified command */\n    int64_t command_set_flag;\n\n    /* Value list */\n    camera_white_balance_t white_balance;\n    int iso;\n    int contrast;\n    int saturation;\n    int hue;\n    int sharpness;\n    camera_effect_t effect;\n    camera_scene_mode_t scene_mode;\n    camera_exposure_mode_t exposure_mode;\n    int exposure;\n    camera_rotation_t rotation;\n    camera_flip_t flip;\n    camera_focus_mode_t focus_mode;\n    camera_focus_range_t focus_range;\n    camera_exposure_mode_t shot_mode;\n    int anti_shake;\n    camera_rectangle_t focus_area;\n    int digital_zoom;\n    int optical_zoom;\n    int recording_hint;\n    int wdr;\n    camera_flash_mode_t flash_mode;\n    camera_face_detection_t face_detection;\n} camera_batch_command_control_t;\n\n/* Sets a batch set of commands */\nint camera_set_batch_command(void *camera_handle, camera_batch_command_control_t *batch_command, int64_t *error_command);\n    \n  \n\n\nConfiguration\n\nTo configure the camera, read the keywords and their values from the configuration files. Recognize the categories by using the keyword list of the MSL camcorder, and save the member structure of the MSL camcorder. Later, these values are used as attribute values or some other operation. The permission of this file is read-only to make sure the configuration files are read once before creating the camcorder. To add comments in the config file, use a semicolon (“;”).\n\nThe following table shows the description of the mmfw_camcorder.ini file.\n\nTable: mmfw_camcorder.ini file\n\n\n  \n    \n      Category\n      Entry\n      Description\n    \n  \n  \n    \n      General\n       \n      General setting or information\n    \n    \n       \n      SyncStateChange\n      API running type. This value must be 1 (TRUE).\n    \n    \n       \n      ModelName\n      Model name of target\n    \n    \n      Video input\n       \n      Setting list related to video input\n    \n    \n       \n      UseConfCtrl\n      Whether to use the configuration file. This value must be 1 (TRUE).\n    \n    \n       \n      ConfCtrlFile0 or 1\n      Name of the setting file to control the camera device\n    \n    \n       \n      VideosrcElement\n      Source plugin which obtains the camera input buffer from the device\n    \n    \n       \n      UseZeroCopyFormat\n      Whether to use the zero copy format\n    \n    \n       \n      DeviceCount\n      Number of camera device\n    \n    \n       \n      SupportMediaPacketPreviewCb\n      Whether the camera API supports media packet preview callback on the target\n    \n    \n      Audio input\n       \n      Setting list related to audio input\n    \n    \n       \n      AudiosrcElement\n      Audio source plugin which obtains audio for the camcorder or voice recorder\n    \n    \n       \n      AudiomodemsrcElement\n      Audio source plugin which obtains audio for call recording\n    \n    \n      Video input\n       \n      Setting list related to video output\n    \n    \n       \n      DisplayDevice\n      Supported output device list and the default value\n    \n    \n       \n      Videosink\n      Supported output surface list and the default value\n    \n    \n       \n      VideosinkElementOverlay\n      Plugin name for the Overlay output surface and the property setting list\n    \n    \n       \n      VideosinkElementEvas\n      Plugin name for the Evas output surface and the property setting list\n    \n    \n       \n      VideosinkElementGL\n      Plugin name for the GL output surface and the property setting list\n    \n    \n       \n      VideosinkElementNULL\n      Plugin name for the NULL surface and the property setting list\n    \n    \n       \n      Video encoder\n      Video encoder list for video recording\n    \n    \n       \n      Audio encoder\n      Audio encoder list for AV recording or voice recording\n    \n    \n      Capture\n       \n      Setting list related to image capture\n    \n    \n       \n      UseEncodebin\n      Whether to use the encodebin to capture the image. Keep this value as 0 (FALSE).\n    \n    \n      Record\n       \n      Setting value list for each recording mode. Keep the values of the example config file.\n    \n    \n      Mux\n       \n      Mux plugin list related with the file container\n    \n  \n\n\nThe following table shows the description of the mmfw_camcorder_dev_video_pri.ini file for the primary camera (usually the rear camera) and the mmfw_camcorder_dev_video_sec.ini file for the secondary camera (usually the front camera).\n\nTable: mmfw_camcorder_dev_video_pri.ini\n\n\n  \n    \n      Category\n      Entry\n      Description\n    \n  \n  \n    \n      Camera\n       \n      Information about the camera\n    \n    \n       \n      InputIndex\n      Camera number to select (primary or secondary)\n    \n    \n       \n      DeviceName\n      Name of the camera module\n    \n    \n       \n      PreviewResolution\n      List of all supported preview resolutions the user can set, as well as the default value for this camera device\n    \n    \n       \n      CaptureResolution\n      List of all supported capture resolutions the user can set, as well as the default value for this camera device\n    \n    \n       \n      VideoResolution\n      List of all supported video resolutions the user can set, as well as the default value for this camera device\n    \n    \n       \n      FPS0 ~ 9\n      List of all supported FPS (Frame Per Second) settings by preview resolution the user can use, as well as the default value for this camera device\n    \n    \n       \n      PictureFormat\n      List of all supported preview formats a user can set, as well as the default value for this camera device\n    \n    \n       \n      RecommendDisplayRotation\n      Default display rotation value for displaying camera input\n    \n    \n       \n      RecommendPreviewFormatCapture\n      Recommended preview format for capturing images\n    \n    \n       \n      RecommendPreviewFormatRecord\n      Recommended preview format for recording\n    \n    \n       \n      RecommendPreviewResolution\n      Recommended preview resolution by ratio of preview resolution\n    \n    \n       \n      FacingDirection\n      Facing direction of camera device\n    \n    \n      Strobe\n       \n      Camera flash settings\n    \n    \n       \n      StrobeMode\n      Supported strobe mode and default value. This is converted to a real value and used in the kernel internally.\n    \n    \n      Effect\n       \n      Effect settings\n    \n    \n       \n      Brightness\n      Supported range of brightness and default value\n    \n    \n       \n      Contrast\n      Supported range of contrast and default value\n    \n    \n       \n      Saturation\n      Supported range of saturation and default value\n    \n    \n       \n      Sharpness\n      Supported range of sharpness and default value\n    \n    \n       \n      Whitebalance\n      Supported white balance list and default value. This is converted to a real value and used in the kernel internally.\n    \n    \n       \n      ColorTone\n      Supported color tone list and default value. This is converted to a real value and used in the kernel internally.\n    \n    \n       \n      WDR\n      Supported Wide Dynamic Range mode list and default value. This is converted to a real value and used in the kernel internally.\n    \n    \n      Photograph\n       \n      Camera shooting settings\n    \n    \n       \n      DigitalZoom\n      Supported range of digital zoom level and default value\n    \n    \n       \n      OpticalZoom\n      Supported range of optical zoom level and default value\n    \n    \n       \n      FocusMode\n      Supported focus mode list and default value. This is converted to a real value and used in the kernel internally.\n    \n    \n       \n      AFType\n      Supported AUTO Focus mode list and default value. This is converted to a real value and used in the kernel internally.\n    \n    \n       \n      AEType\n      Supported AUTO Exposure mode list and default value. This is converted to a real value and used in the kernel internally.\n    \n    \n       \n      ExposureValue\n      Supported range of exposure value and default value\n    \n    \n       \n      ISO\n      Supported ISO list and default value. This is converted to a real value and used in the kernel internally.\n    \n    \n       \n      ProgramMode\n      Supported program mode (scene mode) list and default value. This is converted to a real value and used in the kernel internally.\n    \n    \n       \n      AntiHandshake\n      Supported anti-hand shake mode list and default value. This is converted to a real value and used in the kernel internally.\n    \n    \n      Capture\n       \n      Image capture settings\n    \n    \n       \n      OutputMode\n      Supported capture format list and default value\n    \n    \n       \n      JpegQuality\n      Supported range of JPEG quality and default value\n    \n    \n       \n      MultishotNumber\n      Supported range of multi shot count and default value\n    \n    \n       \n      SensorEncodedCapture\n      Whether the camera device supports encoded capture format (such as JPEG)\n    \n    \n       \n      SupportHDR\n      Supported HDR mode list and default value\n    \n    \n       \n      SupportZSL\n      Whether the camera device supports zero shutter lag capture\n    \n    \n      Detect\n       \n      Detect function settings\n    \n    \n       \n      DetectMode\n      Supported detect mode list and default value\n    \n  \n\n\nReferences\n\n\n  \n    Driver configuration\n\n    Set the kernel .config values for the camera:\n    CONFIG_VIDEO_DEV = y\nCONFIG_VIDEO_SAMSUNG = y\nCONFIG_VIDEO_SAMSUNG_V4L2 = y\nCONFIG_VIDEO_FIMC = y\nCONFIG_VIDEO_FIMC_MMAP_OUTPUT_CACHE = y\nCONFIG_VIDEO_FIMC_MIPI = y\nCONFIG_VIDEO_FIMG2D = y\nCONFIG_VIDEO_JPEG = y\nCONFIG_VIDEO_MFC5X = y\n    \n  \n  \n    Kernel node\n\n    For Camera: /dev/video1\nOther CAMIF interfaces: /dev/video(0-3)\n    \n  \n  \n    GStreamer\n\n    For more information about GStreamer, see http://gstreamer.freedesktop.org/documentation/ and http://gstreamer.freedesktop.org/data/doc/gstreamer/head/pwg/html/index.html.\n  \n  \n    V4L2\n\n    For more information about V4L2, see http://v4l2spec.bytesex.org/spec-single/v4l2.html.\n  \n\n\nRadio\n\nThe radio interface part of the multimedia framework supports APIs to implement the following FM radio features:\n\n\n  Tuning a frequency\n  Getting and setting a frequency\n  Scanning all available frequencies\n  Seeking up and down\n  Getting the frequency signal\n\n\nFigure: Multimedia radio framework\n\n\n\nBecause the interfaces for controlling the radio device differ, Tizen provides the Radio Hardware Abstraction Layer (HAL) to control various radio devices with a common interface. With the common interface, you can control the radio device on various chipsets used by the libmm-radio.\n\nPorting the OAL Interface\n\nThe OAL interface for FM radio is the radio HAL interface.\n\nThe mm-hal-interface package provides the radio HAL header file:\n\n\n  Repository path: platform/core/multimedia/mm-hal-interface\n  File name: tizen-radio.h\n\n\nThe OAL interface for FM radio is the Linux kernel V4L2 interface. The radio module directly uses the V4L2 ioctls to perform various radio hardware configurations.\n\nMajor Radio HAL Functions\n\nThe following list defines the major functions for the radio HAL interface:\n\n\n  \n    Functions for initialization and deinitialization:\n\n    /* Initializes a new radio HAL handle */\nradio_error_t radio_init(void **radio_handle);\n\n/* Deinitializes the radio HAL handle */\nradio_error_t radio_deinit(void *radio_handle);\n    \n  \n  \n    Functions for preparing and unpreparing the radio device:\n\n    /* Prepares the radio device */\nradio_error_t radio_prepare_device(void *radio_handle);\n\n/* Unprepares the radio device */\nradio_error_t radio_unprepare_device(void *radio_handle);\n    \n  \n  \n    Functions for opening and closing the radio device:\n\n    /* Opens the radio device */\nradio_error_t radio_open_device(void *radio_handle);\n\n/* Closes the radio device */\nradio_error_t radio_close_device(void *radio_handle);\n    \n  \n  \n    Functions for starting and stopping the radio device:\n\n    /* Starts the radio device */\nradio_error_t radio_start(void *radio_handle);\n\n/* Stops the radio device */\nradio_error_t radio_stop(void *radio_handle);\n    \n  \n  \n    Functions for setting and getting the frequency:\n\n    /* Gets the radio frequency */\nradio_error_t radio_get_frequency(void *radio_handle, uint32_t *frequency);\n\n/* Sets the radio frequency */\nradio_error_t radio_set_frequency(void *radio_handle, uint32_t frequency);\n    \n  \n  \n    Functions for seeking channels:\n\n    typedef enum radio_seek_direction_type {\n    RADIO_SEEK_DIRECTION_UP, /* Seek upward */\n    RADIO_SEEK_DIRECTION_DOWN /* Seek downward */\n} radio_seek_direction_type_t;\n\n/* Asynchronously seeks (up or down) the effective frequency of the radio */\nradio_error_t radio_seek(void *radio_handle, radio_seek_direction_type_t direction);\n    \n  \n  \n    Functions for  muting and unmuting the radio device:\n\n    /* Mutes the radio */\nradio_error_t radio_mute(void *radio_handle);\n\n/* Unmutes the radio */\nradio_error_t radio_unmute(void *radio_handle);\n    \n  \n  \n    Functions for setting and getting the volume:\n\n    /* Gets the current radio volume */\nradio_error_t radio_get_volume(void *radio_handle, float *volume);\n\n/* Sets the current radio volume */\nradio_error_t radio_set_volume(void *radio_handle, float volume);\n\n/* Sets the current media volume level (system media volume) */\nradio_error_t radio_set_media_volume(void *radio_handle, uint32_t level);\n    \n  \n  \n    Functions for getting the signal strength:\n\n    /* Gets the current signal strength of the radio */\nradio_error_t radio_set_media_volume(void *radio_handle, uint32_t level);\n    \n  \n\n\nReferences\n\n\n  \n    Kernel node\n\n    For Radio: /dev/radio0\n    \n  \n\n\nAudio\n\nThe following figure illustrates the different audio layers.\n\nFigure: Audio layers\n\n\n\n\n  PulseAudio\n    \n      PulseAudio is a sound server accepting sound input from 1 or more sources and redirecting it to 1 or more sinks. It has the following features:\n        \n          Software mixing of multiple audio streams\n          Support for multiple audio sources and sinks\n          An extensible plugin architecture with support for loadable modules\n          Low-latency operation\n          Support for external devices, such as Bluetooth audio and USB audio devices\n        \n      \n      Pulseaudio interacts with AudioHAL interfaces to support various device types.\n    \n  \n  Audio HAL\n    \n      Predefined interfaces for Audio Hardware Abstraction Layer (HAL)\n      Interfaces include the following categories: volume, route, stream, PCM\n    \n  \n  \n    Configuration files\n\n    Configurations for running Pulseaudio and Audio Systems which can be modified without code changes.\n\n    \n      pulseaudio configurations (such as daemon.conf, client.conf, system.pa)\n      stream/device configuration (stream-map.json, device-map.json)\n    \n  \n\n\nPorting the OAL Interface\n\nThe following example defines the major functions for the audio HAL interface:\n\n/* Initializes the audio HAL handle */\naudio_return_t audio_init(void **audio_handle);\n\n/* Deinitializes the audio HAL handle */\naudio_return_t audio_deinit(void *audio_handle);\n\n/* Gets the maximum volume level supported for a particular volume information */\naudio_return_t audio_get_volume_level_max(void *audio_handle, audio_volume_info_t *info, uint32_t *level);\n\n/* Gets the volume level specified for a particular volume information */\naudio_return_t audio_get_volume_level(void *audio_handle, audio_volume_info_t *info, uint32_t *level);\n\n/* Sets the volume level specified for a particular volume information */\naudio_return_t audio_set_volume_level(void *audio_handle, audio_volume_info_t *info, uint32_t level);\n\n/* Gets the volume value specified for a particular volume information and level */\naudio_return_t audio_get_volume_value(void *audio_handle, audio_volume_info_t *info, uint32_t level, double *value);\n\n/* Gets the volume mute specified for a particular volume information */\naudio_return_t audio_get_volume_mute(void *audio_handle, audio_volume_info_t *info, uint32_t *mute);\n\n/* Sets the volume mute specified for a particular volume information */\naudio_return_t audio_set_volume_mute(void *audio_handle, audio_volume_info_t *info, uint32_t mute);\n\n/* Updates the audio routing according to audio route information */\naudio_return_t audio_update_route(void *audio_handle, audio_route_info_t *info);\n\n/* Updates audio routing option according to audio route option */\naudio_return_t audio_update_route_option(void *audio_handle, audio_route_option_t *option);\n\n/* Notifies when a stream is connected and disconnected */\naudio_return_t audio_notify_stream_connection_changed(void *audio_handle, audio_stream_info_t *info, uint32_t is_connected);\n\n/* Opens a PCM device */\naudio_return_t audio_pcm_open(void *audio_handle, void **pcm_handle, uint32_t direction, void *sample_spec, uint32_t period_size, uint32_t periods);\n\n/* Starts a PCM device */\naudio_return_t audio_pcm_start(void *audio_handle, void *pcm_handle);\n\n/* Stops a PCM device */\naudio_return_t audio_pcm_stop(void *audio_handle, void *pcm_handle);\n\n/* Closes a PCM device */\naudio_return_t audio_pcm_close(void *audio_handle, void *pcm_handle);\n\n/* Gets the available number of frames */\naudio_return_t audio_pcm_avail(void *audio_handle, void *pcm_handle, uint32_t *avail);\n\n/* Writes frames to a PCM device */\naudio_return_t audio_pcm_write(void *audio_handle, void *pcm_handle, const void *buffer, uint32_t frames);\n\n/* Reads frames from a PCM device */\naudio_return_t audio_pcm_read(void *audio_handle, void *pcm_handle, void *buffer, uint32_t frames);\n\n/* Gets the poll descriptor for a PCM handle */\naudio_return_t audio_pcm_get_fd(void *audio_handle, void *pcm_handle, int *fd);\n\n/* Recovers the PCM state */\naudio_return_t audio_pcm_recover(void *audio_handle, void *pcm_handle, int revents);\n\n/* Gets the parameters of a PCM device */\naudio_return_t audio_pcm_get_params(void *audio_handle, void *pcm_handle, uint32_t direction, void **sample_spec, uint32_t *period_size, uint32_t *periods);\n\n/* Sets the hardware and software parameters of a PCM device */\naudio_return_t audio_pcm_set_params(void *audio_handle, void *pcm_handle, uint32_t direction, void *sample_spec, uint32_t period_size, uint32_t periods);\n\n\nConfiguration\n\nTo support a variety of devices, PulseAudio and device configuration have to be modified by the vendor. The following table shows the PulseAudio configuration.\n\nTable: PulseAudio configuration\n\n\n  \n    \n      Configuration\n      Description\n    \n  \n  \n    \n      /etc/pulse/daemon.conf\n      Configuration file for the PulseAudio daemon. In this file, the PulseAudio daemon properties, such as priority, log-level, resampling method, and default sample rate, can be modified. In Tizen, the PulseAudio daemon must be running in system mode, not user mode.\n    \n    \n      /etc/pulse/client.conf\n      Configuration file for the PulseAudio clients. It is generally not necessary to modify this file.\n    \n    \n      /etc/pulse/system.pa\n      PulseAudio Sound Server startup script. This startup script is used only if PulseAudio is started in system mode. Initial module loading is triggered by this file, so any vendor-specific modules to be loaded must be added here.\n    \n    \n      /etc/pulse/default.pa\n      PulseAudio Sound Server startup script. This startup script is used only if PulseAudio is started in user mode. Currently Tizen does not support this mode.\n    \n  \n\n\nStream and device configuration:\n\n\n  \n    Stream map: Latency, volume, and streams can be configured in the /etc/pulse/stream-map.json file:\n\n    {\n    \"latencies\":[\n        {\n            \"type\":\"low\",\n            \"fragsize-ms\":25,\n            \"minreq-ms\":-1,\n            \"tlength-ms\":100,\n            \"prebuf-ms\":0,\n            \"maxlength\":-1,\n        },\n        {\n            \"type\":\"high\",\n            \"fragsize-ms\":75,\n            \"minreq-ms\":-1,\n            \"tlength-ms\":400,\n            \"prebuf-ms\":0,\n            \"maxlength\":-1,\n        },\n    ],\n    \"volumes\":[\n        {\n            \"type\":\"media\",\n            \"is-hal-volume\":1,\n        },\n        {\n            \"type\":\"system\",\n            \"is-hal-volume\":0,\n        },\n        {\n            \"type\":\"notification\",\n            \"is-hal-volume\":0,\n        },\n        {\n            \"type\":\"ringtone\",\n            \"is-hal-volume\":0,\n        },\n        {\n            \"type\":\"call\",\n            \"is-hal-volume\":1,\n        },\n    ],\n    \"streams\":[\n        {\n            \"role\":\"media\",\n            \"priority\":3,\n            \"route-type\":\"auto\",\n            \"volume-types\":{\"in\":\"none\",\"out\":\"media\"},\n            \"avail-in-devices\":[\"audio-jack\",\"builtin-mic\"],\n            \"avail-out-devices\":[\"forwarding\",\"audio-jack\",\"bt\",\"builtin-speaker\"],\n            \"avail-frameworks\":[\"player\",\"wav-player\",\"tone-player\",\"audio-io\",\"recorder\"],\n        },\n        {\n            \"role\":\"system\",\n            \"priority\":2,\n            \"route-type\":\"auto\",\n            \"volume-types\":{\"in\":\"none\",\"out\":\"system\"},\n            \"avail-in-devices\":[\"none\"],\n            \"avail-out-devices\":[\"forwarding\",\"audio-jack\",\"bt\",\"builtin-speaker\"],\n            \"avail-frameworks\":[\"player\",\"wav-player\",\"tone-player\",\"audio-io\"],\n        },\n        {\n            \"role\":\"notification\",\n            \"priority\":4,\n            \"route-type\":\"auto-all\",\n            \"volume-types\":{\"in\":\"none\",\"out\":\"notification\"},\n           \"avail-in-devices\":[\"none\"],\n            \"avail-out-devices\":[\"audio-jack\",\"bt\",\"builtin-speaker\"],\n            \"avail-frameworks\":[\"player\",\"wav-player\",\"tone-player\",\"audio-io\"],\n        },\n        {\n            \"role\":\"ringtone-call\",\n            \"priority\":6,\n            \"route-type\":\"auto-all\",\n            \"volume-types\":{\"in\":\"none\",\"out\":\"ringtone\"},\n            \"avail-in-devices\":[\"none\"],\n            \"avail-out-devices\":[\"audio-jack\",\"bt\",\"builtin-speaker\"],\n            \"avail-frameworks\":[\"player\",\"wav-player\",\"tone-player\",\"audio-io\"],\n        },\n        {\n            \"role\":\"call-voice\",\n            \"priority\":6,\n            \"route-type\":\"manual\",\n            \"volume-types\":{\"in\":\"none\",\"out\":\"call\"},\n            \"avail-in-devices\":[\"builtin-mic\",\"audio-jack\",\"bt\"],\n            \"avail-out-devices\":[\"builtin-receiver\",\"builtin-speaker\",\"audio-jack\",\"bt\"],\n            \"avail-frameworks\":[\"sound-manager\"],\n        },\n    ]\n}\n    \n  \n  \n    Device map: Device types and device files can be configured in the /etc/pulse/device-map.json file:\n\n    {\n    \"device-types\":[\n        {\n            \"device-type\":\"builtin-speaker\",\n            \"builtin\":true,\n            \"direction\":[\"out\"],\n            \"avail-condition\":[\"pulse\"],\n            \"playback-devices\":{\"normal\":\"alsa:sprdphone,0\", \"call-voice\":\"alsa:VIRTUALAUDIOW,0\"}\n        },\n        {\n            \"device-type\":\"builtin-mic\",\n            \"builtin\":true,\n            \"direction\":[\"in\"],\n            \"avail-condition\":[\"pulse\"],\n            \"capture-devices\":{\"normal\":\"alsa:sprdphone,0\"}\n        },\n        {\n            \"device-type\":\"audio-jack\",\n            \"builtin\":false,\n            \"direction\":[\"both\",\"out\"],\n            \"avail-condition\":[\"pulse\",\"dbus\"],\n            \"playback-devices\":{\"normal\":\"alsa:sprdphone,0\", \"call-voice\":\"alsa:VIRTUALAUDIOW,0\"},\n            \"capture-devices\":{\"normal\":\"alsa:sprdphone,0\"}\n        },\n        {\n            \"device-type\":\"bt\",\n            \"profile\":\"a2dp\",\n            \"builtin\":false,\n            \"direction\":[\"out\"],\n            \"avail-condition\":[\"pulse\"]\n        },\n        {\n            \"device-type\":\"bt\",\n            \"profile\":\"sco\",\n            \"builtin\":false,\n            \"direction\":[\"both\"],\n            \"avail-condition\":[\"pulse\",\"dbus\"],\n            \"playback-devices\":{\"normal\":\"alsa:sprdphone,0\", \"call-voice\":\"alsa:VIRTUALAUDIOW,0\"},\n            \"capture-devices\":{\"normal\":\"alsa:sprdphone,0\"}\n        },\n        {\n            \"device-type\":\"usb-audio\",\n            \"builtin\":false,\n            \"direction\":[\"both\", \"in\", \"out\"],\n            \"avail-condition\":[\"pulse\"]\n        }\n    ],\n    \"device-files\":\n    {\n        \"playback-devices\":[\n            {\n                \"device-string\":\"alsa:sprdphone,0\",\n                \"role\":\n                {\n                    \"normal\":\"rate=44100\",\n                }\n            },\n            {\n                \"device-string\":\"alsa:VIRTUALAUDIOW,0\",\n                \"role\":\n                {\n                    \"call-voice\":\"rate=16000 channels=1 tsched=0 alternate_rate=16000\",\n                }\n            }\n        ],\n        \"capture-devices\":[\n            {\n                \"device-string\":\"alsa:sprdphone,0\",\n                \"role\":{\"normal\":\"rate=44100\"}\n            }\n        ]\n    }\n}\n    \n  \n\n\nReferences\n\n\n  \n    Driver configuration for the Samsung chipset\n\n    The following list is an example of the kernel .config values to be set for audio when using the Samsung chipset.\n    CONFIG_SOUND=y\nCONFIG_SND=y\nCONFIG_SND_TIMER=y\nCONFIG_SND_HWDEP=y\nCONFIG_SND_JACK=y\nCONFIG_SND_SOC = y\nCONFIG_SND_SOC_SAMSUNG = y\nCONFIG_SND_SAMSUNG_I2S = y\nCONFIG_SND_SOC_SLP_TRATS_MC1N2 = y\nCONFIG_SND_SOC_I2C_AND_SPI = y\nCONFIG_SND_SOC_MC1N2=y\n    \n  \n  \n    PulseAudio\n\n    Version: 5.0\n\n    Website: http://www.freedesktop.org/wiki/Software/PulseAudio\n  \n  \n    ALSA\n\n    Website: http://www.alsa-project.org\n  \n\n\nPlayer\n\nThe multimedia player framework controls the player plugins (demuxer, codecs, and renderer plugins) of the GStreamer to play media content. The kernel interfaces to control codecs can be different for different chipsets, so the corresponding codec plugins must be implemented specifically for each chipset.\n\nFigure: Multimedia player framework\n\n\n\nPorting the OAL Interface\n\nThere is no specific OAL for the multimedia player framework. The OAL interface for the player plugins consists of the gst-omx codec plugins and video/audio renderer plugins. For more information on the gst-omx plugin, see Codec &gt; Porting OAL Interface. For more information about Avsystem for audio, see Audio. For more information on Wayland (UI-framework) for display, see Video.\n\nFigure: Player plugins\n\n\n\nConfiguration\n\n\n  Configuration file:\n    \n      The multimedia player framework uses the mmfw_player.ini configuration file to set various parameters for selecting different codecs and display plugins.\n      The mmfw_player.ini configuration file is provided by the mmfw-sysconf-xxx package.\n      In the final stage of development, the permission for this file needs to be changed to read-only.\n    \n  \n  Configuring the player:\n    \n      File name: mmfw_player.ini\n      1 player.ini file is needed in each board (or model).\n      Codec plugins for the board are located in the /usr/lib/gstreamer-1.0 directory. Changing the codec plugin does not mean modifying this .ini file because the player supports the auto plugin feature.\n    \n  \n  As needed, the following setting values can be used:\n    \n      Exclude keyword element\n      Audio filter\n    \n  \n\n\nReferences\n\n\n  \n    Display driver configuration for the Samsung chipset\n\n    The following list is an example of the kernel .config values to be set for display in the Samsung chipset.\n    CONFIG_DRM = y\nCONFIG_FB = y\nCONFIG_FB_S3C = y\nCONFIG_FB_S3C_LCD_INIT = y\nCONFIG_FIMD_EXT_SUPPORT = y\nCONFIG_FIMD_LITE_SUPPORT = y\n    \n  \n  \n    Kernel node\n    \n      Frame buffers: /dev/fb(0-4)\n      gst-omx version : 1.2.0\n        \n          http://gstreamer.freedesktop.org/src/gst-omx/\n          http://www.freedesktop.org/wiki/GstOpenMAX\n        \n      \n      For all GStreamer documentation, see http://gstreamer.freedesktop.org/documentation/.\n      For developing GStreamer plugins, see http://gstreamer.freedesktop.org/data/doc/gstreamer/head/pwg/html/index.html.\n      For more information about OpenMAX IL components, see http://www.khronos.org/openmax/il/.\n    \n  \n\n\nCodec\n\nThe following figure illustrates the codecs and their relations. It shows 2 types of codec plugins, the Gstreamer and OpenMAX.\n\nFigure: Multimedia codecs\n\n\n\n\n  \n    Gstreamer codec plugin\n\n    \n      The Gstreamer codec plugin can be linked to and easily used in the Gstreamer pipeline, which is used in the multimedia framework.\n      In addition, to link a Gstreamer pipeline, the capability of the codec plugin can be negotiated with the linked element in the pipeline.\n      \n        To get detailed information, such as the capability of an element, use the #gst-inspect-1.0 (element name) command.\n\n        \n      \n    \n  \n  \n    OpenMAX codec plugin\n    \n      Some of the codec vendors provide OpenMAX IL components and not Gstreamer plugins. Tizen provides the gst-omx plugins to use the OpenMAX IL components. The Gstreamer pipeline used in the multimedia framework can control and transfer data to OpenMAX IL component using the gst-omx plugin.\n      To use the OpenMAX component in Gstreamer, the gst-omx (open source) package is provided. By using this package, Gstreamer can recognize and use an OpenMAX component as a Gstreamer element. gst-omx is a Gstreamer plugin that allows communication with OpenMAX IL components. The usage of the gst-omx plugin is the same as other Gstreamer plugins.\n      For more detailed information about this plugin, see http://www.freedesktop.org/wiki/GstOpenMAX. For more information about OpenMAX IL, see http://www.khronos.org/openmax/.\n      The gst-omx plugin refers to a gstomx.conf configuration file. This file is included in the gst-omx package, and installed to the /etc/xdg/gst-omx.conf directory in the target device.\n    \n  \n\n\nPorting the OAL Interface\n\nThe OpenMAX plugin is an industry standard that provides an abstraction layer for computer graphics, video, and sound routines. The interface abstracts the hardware and software architecture in the system. The OpenMAX IL API allows the user to load, control, connect, and unload the individual components. This flexible core architecture allows the Integration Layer to easily implement almost any media use case and mesh with existing graph-based media frameworks. The key focus of the OpenMAX IL API is portability of media components. OpenMAX IL interfaces between the media framework, such as GStreamer, and a set of multimedia components (such as an audio or video codecs). gst-omx is a GStreamer plug-in package that allows communication with OpenMAX IL components. The gst-omx structuring is classified into different object classes based on the functionality. The following figure shows the object structuring of a video decoder plugin in gst-omx.\n\nFigure: gst-omx structuring\n\n\n\nThe GstVideoDecoder base class for video decoders provides encoded data to derived GstOMXVideoDec. Each input frame is provided in turn to the subclass’s handle_frame callback. The GstVideoDecoder base class and derived subclass cooperate in the following manner:\n\n\n  Configuration\n    \n      GstVideoDecoder calls the start() function when the decoder element is activated.\n      GstVideoDecoder calls the set_format() function to inform the subclass of caps describing the input video data.\n    \n  \n  Data processing\n    \n      Each input frame is provided in turn to the subclass’s handle_frames() function.\n      The subclass calls the gst_video_decoder_finish_frame() or gst_video_decoder_drop_frame() function.\n    \n  \n  Shutdown phase\n    \n      The GstVideoDecoder class calls the stop() function.\n    \n  \n\n\nConfiguration\n\nThe gst-omx plugin uses a configuration file, such as gstomx.conf. This file is included in the gst-omx package, and installed in the /etc/xdg/gstomx.conf directory on the target device. The gstomx.conf file needs to be changed according to the OpenMAX component vendor. The following figures lists the values of each item in the lists separated by commas. Each Gstreamer element is separated by a semicolon.\n\nFigure: gstomx.conf elements\n\n\n\nFigure: gstomx.conf example\n\n\n\nEach value needs to be changed according to the OpenMAX component vendor. When you are finished with these settings, the result is a Gstreamer type codec plugin, and you can test the codec the same way.\n\n\n  \n    Using the codec plugin in the player\n\n    Because the player uses auto plugging, it does not need an additional setting.\n\n    \n      If the decoder plugin has an acceptable capability, this plugin can be linked with a player pipeline in order of rank.\n      If the codec name is included in the excluded keyword in the /usr/etc/mmfw_player.ini file (mmfw-sysconf package), it is excluded in the player pipeline.\n    \n  \n  \n    Using the codec plugin in the camcorder\n\n    Because the camcorder clarified its audio, video, and image encoder in the /usr/etc/mmfw_camcorder.ini file (mmfw-sysconf package), you need to change this category value to set your own codec name.\n\n    \n  \n\n\nReferences\n\n\n  \n    gst-omx version: 1.2\n\n    http://gstreamer.freedesktop.org/src/gst-omx/\n\n    http://www.freedesktop.org/wiki/GstOpenMAX\n  \n  \n    For all GStreamer documentation, see http://gstreamer.freedesktop.org/documentation/.\n  \n  \n    For developing GStreamer plug-ins, see http://gstreamer.freedesktop.org/data/doc/gstreamer/head/pwg/html/index.html.\n  \n  \n    For more information about OpenMAX IL components, see http://www.khronos.org/openmax/il/.\n  \n\n\nVideosink\n\nThe videosink renders a video frame buffer from a previous gst element on a local display using Waylandsink (since Tizen 3.0). It is used with a camera or player that requires video output. This element can receive a surface ID of a window from the application through the GstVideoOverlay interface (set_wl_window_wl_surface_id()) and renders the video frame in this window. If no surface ID was provided by the application, the element creates its own internal window and renders into it.\n\nThe following figure shows the video rendering process in the player. The white box is the gstreamer element. GstBuffer is streaming from filesrc to Waylandsink past the video codec. The GstBuffer is TBM or SHM.\n\nFigure: Video rendering process\n\n\n\n\n  Waylandsink requests the rendering of the video frame to the wl_surface of a window, so Waylandsink needs the wl_surface of a Wayland window created by the application. Because the application and Muse are in different process bounds, the application cannot pass the wl_surface pointer to Muse. To solve this problem, Tizen uses the surface ID value.\n  The application sends a wl_surface pointer to the Window Server, which returns the global surface ID to the application, which in turn passes this value to Waylandsink using the GstVideoOverlay interface, set_wl_window_wl_surface_id() (Tizen-specific). Steps 1, 2, and 3 in the figure.\n  Waylandsink creates wl_display to communicate with the Window Server. Normally a Window client uses the wl_display created by the application, but the Tizen Waylandsink creates its own wl_display due to process bounds issues. Step 4. Now Waylandsink can receive events from the server and bind to various interfaces using wl_registry.\n  Waylandsink uses wl_display to create wl_window and a wl_subsurface using the global surface ID passed through the GstVideoOverlay interface. wl_surface is created by the wl_compositor of wl_display. Step 5.\n  The application can use the Waylandsink properties to change video rendering conditions through wl_subsurface. Step 6.\n  The GstBuffer received from the video codec is converted into a wl_buffer, then the wl_surface of wl_window is requested to render the video frame to the Window Server through the attach, damage, and commit process. Steps 7 and 8. The Window Server renders the wl_buffer. Step 9.\n  When the Window Server finishes rendering the video frame, the rendering complete signal is sent to the wl_callback of wl_window, and the wl_buffer release event is sent to the wl_buffer_listener callback function. Steps 10 and 11. Now, Waylandsink can unreference the GstBuffer created by the video codec and return the GstBuffer to the video codec. Sometimes, it is necessary to return a GstBuffer while maintaining the rendered video frame in the window (for gapless playback, or keeping a camera preview). In this case, use FlushBuffer, which is a wl_buffer created after copying TBM from GstBuffer coming from the video codec. Waylandsink returns the GstBuffer to the video codec immediately, and a request to render the FlushBuffer is made to the Window Server.\n\n\nFor more information on Wayland, see https://wayland.freedesktop.org/.  For more information on programming the Wayland client, see Programming Wayland Clients.\n\nPorting the OAL Interface\nThere is no specific OAL for the videosink.\n\nTizen-specific Features Added to Waylandsink\n\nYou can check the original waylandsink behavior easily with Waylandsink’s video rendering test. Simply connect to videotestsrc through gst-launch. If the video test screen does not appear, the Window system must be ported first.\n\ngst-launch-1.0 videotestsrc ! waylandsink\n\nFigure: Video test screen\n\n\n\nWaylandsink Requirements for Tizen\n\nOpen source Waylandsink uses wayland-client, but Waylandsink for Tizen uses libtbm, wayland-tbm-client, and tizen-extension-client to support MMFW’s API requirements and uses Window Server extended functionality.\n\nThe major functions are TBM Video Format, Specific Video Formats, Zero copy, MMVideoBuffer, Tizen Viewport, Flush Buffer, Audio only mode, Handoffs Element signals, preroll-handoff Element signals, Use TBM, Rotate, Flip, Visible, Display Geometry Method, and ROI.\n\nTBM Video Format\n\nOriginal Waylandsink lists various video formats, but Wayland only supports the RGB format. To support various video formats, Waylandsink for Tizen uses the TBM Video Format provided by Wayland for Tizen. The video formats supported by the Window Server are hardware-dependent. The dependency is on the Window Server. When the Gst-pipeline with Waylandsink is created and the caps negotiation begins, the TBM video format provided by the Window Server is passed to Waylandsink. The Window Server can accommodate the video output format of the video codec when the negotiation is completed.\n\nTo use the TBM Video Format, Waylandsink needs to bind tizen_policy_interface, tizen_video_interface, and register listener and get the video formats as a callback.\n\nstatic void handle_tizen_video_format(void *data, struct tizen_video *tizen_video, uint32_t format) {\n    GstWlDisplay *self = data;\n    FUNCTION;\n\n    g_return_if_fail(self != NULL);\n\n    GST_LOG(\"format is %d\", format);\n    g_array_append_val(self-&gt;tbm_formats, format);\n}\n\nstatic const struct tizen_video_listener tizen_video_listener = {\n    handle_tizen_video_format\n};\n\nstatic void global_registry_handler(void *data, struct wl_registry *registry, uint32_t id, const char *interface, uint32_t version) {\n    [...]\n    } else if (g_strcmp0(interface, \"tizen_policy\") == 0) {\n        self-&gt;tizen_policy = wl_registry_bind(registry, id, &amp;tizen_policy_interface, 1);\n    } else if (g_strcmp0(interface, \"tizen_video\") == 0) {\n        self-&gt;tizen_video = wl_registry_bind(registry, id, &amp;tizen_video_interface, version);\n        g_return_if_fail(self-&gt;tizen_video != NULL);\n        tizen_video_add_listener(self-&gt;tizen_video, &amp;tizen_video_listener, self);\n    }\n    [...]\n}\n\n\nSpecific Video Formats (SN12, SN21, ST12, SR32, S420) for Zero copy\n\nThe SN12, SN21, ST12, SR32, and S320 formats are identical to NV12, NV21, NV12MT, BGRA, and I420, but the Multimedia framework uses these specific video formats to indicate that the formats are using a TBM buffer. Tizen provides a TBM buffer to avoid memory copying when transferring the buffer to different processes. Camerasrc or the video codec writes the video data to the TBM buffer, saves it to a pointer to GstBuffer, and sends it to Waylandsink. Waylandsink creates a wl_buffer with tbm_bo and requests rendering from the Window Server. There is no memory copy from Camerasrc or the video codec to the Window Server. This process is called Zero Copy.\n\nMMVideoBuffer\n\nThe Gst Element must use the MMVideoBuffer type when transferring TBM buffer. tbm bo must be stored in bo of MMVideoBufferHandle, and the type must be MM_VIDEO_BUFFER_TYPE_TBM_BO. Waylandsink makes wl_buffer by using the MMVideoBuffer information. If the video frame is not rendered, Waylandsink must make sure that the information in MMVideoBuffer in GstBuffer received from Camerasrc or Video Codec is correct.\n\ntypedef struct {\n    MMVideoBufferType type; /* Buffer type - the handle field that type indicates must be filled, and other handle fields are optional */\n    MMPixelFormatType format; /* Buffer type */\n    int plane_num; /* Number of planes */\n    int width[MM_VIDEO_BUFFER_PLANE_MAX] /* Width of buffer */\n    int height[MM_VIDEO_BUFFER_PLANE_MAX]; /* Height of buffer */\n    int stride_width[MM_VIDEO_BUFFER_PLANE_MAX]; /* Stride width of buffer */\n    int stride_height[MM_VIDEO_BUFFER_PLANE_MAX]; /* Stride height of buffer */\n    int size[MM_VIDEO_BUFFER_PLANE_MAX]; /* Size of planes */\n    void *data[MM_VIDEO_BUFFER_PLANE_MAX]; /* Data pointer(user address) of planes */\n    int handle_num; /* Number of buffer handle */\n    int handle_size[MM_VIDEO_BUFFER_PLANE_MAX]; /* Size of handles */\n    MMVideoBufferHandle handle; /* Handle of buffer */\n    int is_secured; /* Secured buffer flag, such as TrustZone memory; user cannot access it */\n    int flush_request; /* Flush request flag - if this flag is TRUE, sink element makes copy of last buffer, and it returns all buffers from src element. Then, src element can restart without changing pipeline state */\n    MMRectType crop; /* Crop information of buffer */\n} MMVideoBuffer;\n\nMMVideoBuffer can contain video data information of all cases, as shown in the following figure.\n\nFigure: MMVideoBuffer content\n\n\n\nTizen Viewport\n\nTo change the video frame render condition, the original open-source Waylandsink uses wlsurface_set_source(), wl_surface_set_buffer_transform(), wl_subsurface_set_position(), wl_viewport_set_destination(), and wl_surface_set_buffer_transform() functions. For more information on the Wayland API, see https://wayland.freedesktop.org/docs/html/. Waylandsink needs to IPC with wl_surface, wl_subsurface, and wl_viewport.\n\nFigure: Changing video frame render conditions\n\n\n\nFigure: Wayland protocols\n\n\n\nWaylandsink in the Muse Daemon requests rendering conditions on the wl_subsurface of the window created by the application. Therefore, it is difficult to match the geometry sync of the parent (Window) and wl_subsurface, due to the delay caused by the IPC communication between the Window Server and Wayland client. Since wl_viewport_ and wl_set_source_ are surface-based coordination, it is difficult to calculate the coordinates when the buffer is transformed. So Waylandsink for Tizen uses tizen_viewport supported Wayland Server for Tizen. To use tizen_viewport, Waylandsink binds tizen_policy_interface and tizen_video_interface. Now, Waylandsink only needs to IPC tizen_viewport.\n\nFigure: Tizen viewport\n\n\n\n\n  \n    Example 1:\n\n    \n  \n  \n    Example 2:\n\n    \n  \n  \n    Example 3:\n\n    \n  \n  \n    Example 4:\n\n    \n  \n\n\nFlush buffer\n\nSometimes, it is necessary to return GstBuffer while maintaining the video frame rendered in the window. In this case, use FlushBuffer, which is a wl_buffer created after copying TBM from GstBuffer coming from the video codec or Camerasrc. Waylandsink returns the GstBuffer to the video codec or Camerasrc immediately, and a request to render the FlushBuffer is made to the Window Server.\n\n\n  \n    Gapless video playback\n\n    Waylandsink receives the GST_EVENT_CUSTOM_DOWNSTREAM event from the player when it performs gapless video playback. The player creates a FlushBuffer.\n\n    #define GST_APP_EVENT_FLUSH_BUFFER_NAME \"application/flush-buffer\"\n\nstatic gboolean gst_wayland_sink_event(GstBaseSink * bsink, GstEvent * event) {\n    [...]\n    switch (GST_EVENT_TYPE(event)) {\n    case GST_EVENT_CUSTOM_DOWNSTREAM:\n        s = gst_event_get_structure(event);\n        if (s == NULL || !gst_structure_has_name(s, GST_APP_EVENT_FLUSH_BUFFER_NAME))\n            break;\n        gst_wayland_sink_render_flush_buffer(bsink);\n    [...]\n}\n    \n  \n  \n    keep-camera-preview\n\n    The camera sets this property when it needs to maintain the last video frame. Waylandsink copies the last TBM buffer and returns it immediately when the state changes (PAUSED_TO_READY).\n    keep-camera-preview : Last tbm buffer is copied and returned to camerasrc immediately when state change(PAUSED_TO_READY)\n                      flags: readable, writable\n                      Boolean. Default: false\n    \n  \n  \n    flush_request of MMVideoBuffer\n\n    Camerasrc and the video codec can set a flag to request a flushbuffer in the GstBuffer using MMVideoBuffer.flush_request = TRUE.\n  \n\n\nAudio only mode\n\nWaylandsink has a disable-overlay property to support the player’s audio-only mode. If this property is set, the video frame is not rendered. When the player needs to show a video frame, it needs to set this property to false and set wl_surface_id.\n\ndisable-overlay : Stop using overlay by destroying wl_window and wl_display, Use gst_video_overlay_set_wl_window_wl_surface_id before setting FALSE to use overlay\n                              flags: readable, writable\n                              Boolean. Default: false\n\n\ngst_wayland_sink_set_property(GObject * object, guint prop_id, const GValue * value, GParamSpec * pspec) {\n    [...]\n    case PROP_DISABLE_OVERLAY:\n       sink-&gt;disable_overlay = g_value_get_boolean(value);\n       if (sink-&gt;window &amp;&amp; sink-&gt;display) {\n         if (sink-&gt;disable_overlay) {   /* set TRUE */\n           g_clear_object(&amp;sink-&gt;window);\n           g_clear_object(&amp;sink-&gt;display);\n        } else /* set FALSE */\n          gst_wayland_sink_recover_display_window_info(sink);\n       }\n       break;\n    [...]\n}\n\nstatic GstFlowReturn gst_wayland_sink_render(GstBaseSink * bsink, GstBuffer * buffer) {\n    [...]\n    /* check overlay */\n    if (gst_wayland_sink_is_disabled_overlay(sink)) {\n        GST_LOG(\"set disable_overlay, so skip\");\n        goto done; //skip video rendering\n    }\n    [...]\n}\n\nRefer to mm_player_priv.c\n/* Need to set surface_id to enable overlay */\ngst_video_overlay_set_wl_window_wl_surface_id(GST_VIDEO_OVERLAY(player-&gt;pipeline-&gt;videobin[MMPLAYER_V_SINK].gst), *(int*)handle);\n\n\nHandoffs and preroll-handoff element signals\n\nChanging the gst-pipeline of the player is labor-intensive, so Waylandsink provides a fakesink functionality. If this property is set to true, Waylandsink sends a handoff signal to the player.\n\nstatic GstFlowReturn gst_wayland_sink_render(GstBaseSink * bsink, GstBuffer * buffer) {\n    [...]\n    /* fakesink function for media stream callback case */\n    if (sink-&gt;signal_handoffs) {\n        GST_LOG(\"g_signal_emit: hand-off \");\n        g_signal_emit(sink, gst_waylandsink_signals[SIGNAL_HANDOFF], 0, buffer, bsink-&gt;sinkpad);\n        goto done;  /* Skip video rendering */\n    }\n    [...]\n}\n\n\nUse TBM\n\nWaylandsink use 2 types of buffers, shared memory and TBM memory. The default value of the use-tbm property is true and Waylandsink uses TBM memory. If the value is false, Waylandsink for Tizen uses shared memory just like the original open-source Waylandsink.\nuse-tbm  : Use Tizen Buffer Memory instead of Shared memory, Memory is allocated by TBM instead of SHM when enabled\n           flags: readable, writable\n           Boolean. Default: true\n\n\nRotate\n\nWaylandsink can rotate the angle of display output. The default value of the rotate property is 0, “DEGREE_0”.\nrotate   : Rotate angle of display output\n           flags: readable, writable\n           Enum \"GstWaylandSinkRotateAngleType\" Default: 0, \"DEGREE_0\"\n                (0): DEGREE_0         - No rotate\n                (1): DEGREE_90        - Rotate 90 degree\n                (2): DEGREE_180       - Rotate 180 degree\n                (3): DEGREE_270       - Rotate 270 degree\n\n\nThe enumeration values used by the player or camera need to be converted to values used by Wayland.\nstatic gint gst_wl_window_find_rotate_transform(guint rotate_angle) {\n    gint transform = WL_OUTPUT_TRANSFORM_NORMAL;\n    switch (rotate_angle) {\n    case DEGREE_0:\n         transform = WL_OUTPUT_TRANSFORM_NORMAL;\n         break;\n    case DEGREE_90:\n        transform = WL_OUTPUT_TRANSFORM_90;\n        break;\n    case DEGREE_180:\n        transform = WL_OUTPUT_TRANSFORM_180;\n        break;\n    case DEGREE_270:\n        transform = WL_OUTPUT_TRANSFORM_270;\n        break;\n    }\n\n    return transform;\n}\n\ntransform =  gst_wl_window_find_rotate_transform(window-&gt;rotate_angle.value);\ntizen_viewport_set_transform(window-&gt;tizen_area_viewport, transform);\n\n\nFlip\n\nWaylandsink can flip the angle of the display output. The default value of the flip property is 0, “FLIP_NONE”.\n flip  : Flip for display\n         flags: readable, writable\n         Enum \"GstWaylandSinkFlipType\" Default: 0, \"FLIP_NONE\"\n              (0): FLIP_NONE        - Flip NONE\n              (1): FLIP_HORIZONTAL  - Flip HORIZONTAL\n              (2): FLIP_VERTICAL    - Flip VERTICAL\n              (3): FLIP_BOTH        - Flip BOTH\n\n\nWayland has no flip function, so Waylandsink must implement flipping by rotating the video viewport:\nstatic gint gst_wl_window_find_flip_transform(guint flip) {\n    gint transform = WL_OUTPUT_TRANSFORM_NORMAL;\n    FUNCTION;\n\n    GST_DEBUG(\"flip (%d)\", flip);\n    switch (flip) {\n    case FLIP_NONE:\n        transform = WL_OUTPUT_TRANSFORM_NORMAL;\n        break;\n    case FLIP_HORIZONTAL:\n        transform = WL_OUTPUT_TRANSFORM_FLIPPED;\n        break;\n    case FLIP_VERTICAL:\n        transform = WL_OUTPUT_TRANSFORM_FLIPPED_180;\n        break;\n    case FLIP_BOTH:\n        transform = WL_OUTPUT_TRANSFORM_180;\n        break;\n    }\n\n    return transform;\n}\n\ntransform = gst_wl_window_find_flip_transform(window-&gt;flip.value);\ntizen_viewport_set_transform(window-&gt;tizen_video_viewport, transform);\n\n\nVisible\n\nWaylandsink can make the video frame visible or invisible on the display. To make the video frame invisible, attach NULL. To make the video fame visible, Waylandsink needs to keep the last rendered video frame.\n\n/* invisible */\nstatic void gst_wayland_sink_stop_video(GstWaylandSink * sink) {\n    FUNCTION;\n    g_return_if_fail(sink != NULL);\n    gst_wl_window_render(sink-&gt;window, NULL, NULL);\n}\n/* visible */\ngst_wayland_sink_update_last_buffer_geometry(sink);\n\n\nDisplay geometry method and ROI\n\nWhen rendering video, Waylandsink can change the geometry.\n\ndisplay-geometry-method: Geometrical method for display\n           flags: readable, writable\n           Enum \"GstWaylandSinkDisplayGeometryMethodType\" Default: 0, \"LETTER_BOX\"\n                (0): LETTER_BOX       - Letter box\n                (1): ORIGIN_SIZE      - Origin size\n                (2): FULL_SCREEN      - Full-screen\n                (3): CROPPED_FULL_SCREEN - Cropped full-screen\n                (4): ORIGIN_SIZE_OR_LETTER_BOX - Origin size(if screen size is larger than video size(width/height)) or Letter box(if video size(width/height) is larger than screen size)\n                (5): DISP_GEO_METHOD_CUSTOM_ROI - Specially described destination ROI\n\nThese are provided by using tizen_viewport since Tizen 3.0.\n\nenum {\n    DISP_GEO_METHOD_LETTER_BOX = 0,\n    DISP_GEO_METHOD_ORIGIN_SIZE,\n    DISP_GEO_METHOD_FULL_SCREEN,\n    DISP_GEO_METHOD_CROPPED_FULL_SCREEN,\n    DISP_GEO_METHOD_ORIGIN_SIZE_OR_LETTER_BOX,\n    DISP_GEO_METHOD_CUSTOM_ROI,\n    DISP_GEO_METHOD_NUM,\n};\n\nif (tizen_disp_mode &gt; -1) {\n    tizen_destination_mode_set(window-&gt;tizen_video_dest_mode, tizen_disp_mode);\n}\n\n\nROI coordinates can be set only when the value of display-geometry-method is set to 5, and ROI coordinates are obtained from gst_video_overlay_set_render_rectangle() from the player or camera.\nif (window-&gt;disp_geo_method.value == DISP_GEO_METHOD_CUSTOM_ROI) {\n    tizen_viewport_set_destination(window-&gt;tizen_video_viewport, window-&gt;roi.x, window-&gt;roi.y, window-&gt;roi.w, window-&gt;roi.h);\n}\n\n\nThe following examples describe the various available modes:\n\n\n  \n    Letterbox mode\n\n    Fit the video source to the width or height of the window, aligned to the center and keeping the aspect ratio of the original video source.\n\n    \n      \n        Window (width/height) &gt; Video source (width/height)\n\n        \n      \n      \n        Window (width/height) &lt; Video source (width/height)\n\n        \n      \n    \n  \n  \n    Original size mode\n\n    Set the video source size the same as the original video size, aligned to the center and keeping the aspect ratio of the original video source.\n\n    \n      \n        Window size &gt; Video source size\n\n        \n      \n      \n        Window size &lt; Video source size\n\n        \n      \n    \n  \n  \n    Cropped full screen mode\n\n    Fit the video source to the width and height, cropping out the area outside the window, aligned to the center and keeping the aspect ratio of the original video source.\n\n    \n      \n        Window (width/height) &gt; Video source (width/height)\n\n        \n      \n      \n        Window (width/height) &lt; Video source (width/height)\n\n        \n      \n    \n  \n  \n    ROI mode\n\n    The user sets the location and size of where the video is rendered.\n\n    \n      \n        Window size: width(1920), height(1080), ROI size: x(100), y(100), width(800), height(400)"
					}
					
				
			
		
			
				
					,
					
					"iot-porting-multimedia": {
						"id": "iot-porting-multimedia",
						"title": "Multimedia",
						"categories": "",
						"url": " iot/porting/multimedia/",
						"content": "Multimedia\n\nYou can implement various multimedia features, such as camera, audio, and video.\n\nCamera\n\nThe Multimedia camcorder framework controls the GStreamer camera plugin to capture camera data from the device. The kernel interfaces to control the camera device can be different for different chipsets, so the camera HAL (Hardware Abstraction Layer) used by the camera plugin is provided and it must be implemented specifically for each chipset. Each configuration file contains its own specific hardware-dependent information. The Multimedia camcorder framework reads and parses the information in these configuration files.\n\nFigure: Multimedia camcorder framework\n\n\n\n\n  \n    Camera source plugin for GStreamer\n\n    Gets the camera data (preview or captured image) and sets various camera commands through camera HAL interface\n  \n  \n    Camera HAL\n\n    Common interface to control the camera device on various shipsets and used by the camera source plugin.\n  \n  \n    Configuration files\n\n    There are 3 config files for the Multimedia camcorder framework. They are provided by mmfw- sysconf-xxx:\n    \n      mmfw_camcorder.ini\n      mmfw_camcorder_dev_video_pri.ini\n      mmfw_camcorder_dev_video_sec.ini\n    \n  \n\n\nPorting the OAL Interface\n\nTizen provides a default reference camera source plugin which uses the camera HAL interface.\n\nFor the camera HAL, the mm-hal-interface package provides a header file:\n\n\n  Repository path: platform/core/multimedia/mm-hal-interface\n  File name: tizen-camera.h\n\n\nMajor Camera HAL Functions\n\nThe following list defines the major functions for the camera HAL interface:\n\n\n  \n    Functions for initialization and deinitialization:\n\n    /*Initializes new camera HAL handle */\nint camera_init(void **camera_handle);\n\n/* Deinitializes the camera HAL handle */\nint camera_deinit(void *camera_handle);\n    \n  \n  \n    Functions for opening and closing the camera device:\n\n    /* Opens the camera device */\nint camera_open_device(void *camera_handle, int device_index);\n\n/* Closes the camera device */\nint camera_close_device(void *camera_handle);\n    \n  \n  \n    Functions for getting device information:\n\n    /* Gets the camera device list */\nint camera_get_device_list(void *camera_handle, camera_device_list_t *device_list);\n\n/* Registers a callback function to be called to send a message by the camera HAL */\nint camera_add_message_callback(void *camera_handle, camera_message_cb callback, void *user_data, uint32_t *cb_id);\n\n/* Unregisters a callback function */\nint camera_remove_message_callback(void *camera_handle, uint32_t cb_id);\n    \n  \n  \n    Functions for preview and capture:\n\n    typedef struct camera_format {\n    camera_pixel_format_t stream_format;\n    camera_resolution_t stream_resolution;\n    uint32_t stream_fps;\n    camera_rotation_t stream_rotation;\n    camera_pixel_format_t capture_format;\n    camera_resolution_t capture_resolution;\n    uint32_t capture_quality;\n} camera_format_t;\n\n/* Sets the format of the preview stream */\nint camera_set_preview_stream_format(void *camera_handle, camera_format_t *format);\n\n/* Gets the format of the preview stream  */\nint camera_get_preview_stream_format(void *camera_handle, camera_format_t *format);\n\ntypedef int (*camera_preview_frame_cb)(camera_buffer_t *buffer, camera_metadata_t *meta, void *user_data);\n\n/* Starts the display of preview frames on the scree. */\nint camera_start_preview(void *camera_handle, camera_preview_frame_cb callback, void *user_data);\n\n/* Stops the preview frames */\nint camera_stop_preview(void *camera_handle);\n\n/* Releases the preview buffer; the preview buffer must be released with this function after using it */\nint camera_release_preview_buffer(void *camera_handle, int buffer_index);\n\n/* Starts the camera auto-focusing operation */\nint camera_start_auto_focus(void *camera_handle);\n\n/* Stops the camera auto-focusing operation */\nint camera_stop_auto_focus(void *camera_handle);\n\ntypedef int (*camera_capture_cb)(camera_buffer_t *main, camera_buffer_t *postview, camera_buffer_t *thumbnail, void *user_data);\n\n/* Starts capturing still images */\nint camera_start_capture(void *camera_handle, camera_capture_cb callback, void *user_data);\n\n/* Stops capturing still images */\nint camera_stop_capture(void *camera_handle);\n    \n  \n  \n    Functions for video recording:\n\n    /* Stops capturing still images */\nint camera_set_video_stream_format(void *camera_handle, camera_format_t *format);\n\n/* Gets the video stream format for recording */\nint camera_get_video_stream_format(void *camera_handle, camera_format_t *format);\n\ntypedef int (*camera_video_frame_cb)(camera_buffer_t *buffer, camera_metadata_t *meta, void *user_data);\n\n/* Starts the video frame for recording */\nint camera_start_record(void *camera_handle, camera_video_frame_cb callback, void *user_data);\n\n/* Stops the video frame */\nint camera_stop_record(void *camera_handle);\n\n/* Video buffer must be released with this function after using it */\nint camera_release_video_buffer(void *camera_handle, int buffer_index);\n    \n  \n  \n    Functions for controlling the camera device:\n\n    #define CAMERA_COMMAND_BASE                     ((int64_t)1)\n#define CAMERA_COMMAND_WHITE_BALANCE            ((int64_t)(CAMERA_COMMAND_BASE &lt;&lt; 1))\n#define CAMERA_COMMAND_ISO                      ((int64_t)(CAMERA_COMMAND_BASE &lt;&lt; 2))\n#define CAMERA_COMMAND_CONTRAST                 ((int64_t)(CAMERA_COMMAND_BASE &lt;&lt; 3))\n#define CAMERA_COMMAND_SATURATION               ((int64_t)(CAMERA_COMMAND_BASE &lt;&lt; 4))\n#define CAMERA_COMMAND_HUE                      ((int64_t)(CAMERA_COMMAND_BASE &lt;&lt; 5))\n#define CAMERA_COMMAND_SHARPNESS                ((int64_t)(CAMERA_COMMAND_BASE &lt;&lt; 6))\n#define CAMERA_COMMAND_EFFECT                   ((int64_t)(CAMERA_COMMAND_BASE &lt;&lt; 7))\n#define CAMERA_COMMAND_SCENE_MODE               ((int64_t)(CAMERA_COMMAND_BASE &lt;&lt; 8))\n#define CAMERA_COMMAND_EXPOSURE_MODE            ((int64_t)(CAMERA_COMMAND_BASE &lt;&lt; 9))\n#define CAMERA_COMMAND_EXPOSURE                 ((int64_t)(CAMERA_COMMAND_BASE &lt;&lt; 10))\n#define CAMERA_COMMAND_ROTATION                 ((int64_t)(CAMERA_COMMAND_BASE &lt;&lt; 11))\n#define CAMERA_COMMAND_FLIP                     ((int64_t)(CAMERA_COMMAND_BASE &lt;&lt; 12))\n#define CAMERA_COMMAND_FOCUS_MODE               ((int64_t)(CAMERA_COMMAND_BASE &lt;&lt; 13))\n#define CAMERA_COMMAND_FOCUS_RANGE              ((int64_t)(CAMERA_COMMAND_BASE &lt;&lt; 14))\n#define CAMERA_COMMAND_SHOT_MODE                ((int64_t)(CAMERA_COMMAND_BASE &lt;&lt; 15))\n#define CAMERA_COMMAND_ANTI_SHAKE               ((int64_t)(CAMERA_COMMAND_BASE &lt;&lt; 16))\n#define CAMERA_COMMAND_FOCUS_AREA               ((int64_t)(CAMERA_COMMAND_BASE &lt;&lt; 17))\n#define CAMERA_COMMAND_DIGITAL_ZOOM             ((int64_t)(CAMERA_COMMAND_BASE &lt;&lt; 18))\n#define CAMERA_COMMAND_OPTICAL_ZOOM             ((int64_t)(CAMERA_COMMAND_BASE &lt;&lt; 19))\n#define CAMERA_COMMAND_RECORDING_HINT           ((int64_t)(CAMERA_COMMAND_BASE &lt;&lt; 20))\n#define CAMERA_COMMAND_WDR                      ((int64_t)(CAMERA_COMMAND_BASE &lt;&lt; 21))\n#define CAMERA_COMMAND_SHUTTER_SPEED            ((int64_t)(CAMERA_COMMAND_BASE &lt;&lt; 22))\n#define CAMERA_COMMAND_FLASH_MODE               ((int64_t)(CAMERA_COMMAND_BASE &lt;&lt; 23))\n#define CAMERA_COMMAND_FACE_DETECTION           ((int64_t)(CAMERA_COMMAND_BASE &lt;&lt; 24))\n\n/* Sets various commands and values to control the camera device */\nint camera_set_command(void *camera_handle, int64_t command, void *value);\n\n/* Gets the current value of the command */\nint camera_get_command(void *camera_handle, int64_t command, void *value);\n\ntypedef struct camera_batch_command_control {\n    /* Flag for modified command */\n    int64_t command_set_flag;\n\n    /* Value list */\n    camera_white_balance_t white_balance;\n    int iso;\n    int contrast;\n    int saturation;\n    int hue;\n    int sharpness;\n    camera_effect_t effect;\n    camera_scene_mode_t scene_mode;\n    camera_exposure_mode_t exposure_mode;\n    int exposure;\n    camera_rotation_t rotation;\n    camera_flip_t flip;\n    camera_focus_mode_t focus_mode;\n    camera_focus_range_t focus_range;\n    camera_exposure_mode_t shot_mode;\n    int anti_shake;\n    camera_rectangle_t focus_area;\n    int digital_zoom;\n    int optical_zoom;\n    int recording_hint;\n    int wdr;\n    camera_flash_mode_t flash_mode;\n    camera_face_detection_t face_detection;\n} camera_batch_command_control_t;\n\n/* Sets a batch set of commands */\nint camera_set_batch_command(void *camera_handle, camera_batch_command_control_t *batch_command, int64_t *error_command);\n    \n  \n\n\nConfiguration\n\nTo configure the camera, read the keywords and their values from the configuration files. Recognize the categories by using the keyword list of the MSL camcorder, and save the member structure of the MSL camcorder. Later, these values are used as attribute values or some other operation. The permission of this file is read-only to make sure the configuration files are read once before creating the camcorder. To add comments in the config file, use a semicolon (“;”).\n\nThe following table shows the description of the mmfw_camcorder.ini file.\n\nTable: mmfw_camcorder.ini file\n\n\n  \n    \n      Category\n      Entry\n      Description\n    \n  \n  \n    \n      General\n       \n      General setting or information\n    \n    \n       \n      SyncStateChange\n      API running type. This value must be 1 (TRUE).\n    \n    \n       \n      ModelName\n      Model name of target\n    \n    \n      Video input\n       \n      Setting list related to video input\n    \n    \n       \n      UseConfCtrl\n      Whether to use the configuration file. This value must be 1 (TRUE).\n    \n    \n       \n      ConfCtrlFile0 or 1\n      Name of the setting file to control the camera device\n    \n    \n       \n      VideosrcElement\n      Source plugin which obtains the camera input buffer from the device\n    \n    \n       \n      UseZeroCopyFormat\n      Whether to use the zero copy format\n    \n    \n       \n      DeviceCount\n      Number of camera device\n    \n    \n       \n      SupportMediaPacketPreviewCb\n      Whether the camera API supports media packet preview callback on the target\n    \n    \n      Audio input\n       \n      Setting list related to audio input\n    \n    \n       \n      AudiosrcElement\n      Audio source plugin which obtains audio for the camcorder or voice recorder\n    \n    \n       \n      AudiomodemsrcElement\n      Audio source plugin which obtains audio for call recording\n    \n    \n      Video input\n       \n      Setting list related to video output\n    \n    \n       \n      DisplayDevice\n      Supported output device list and the default value\n    \n    \n       \n      Videosink\n      Supported output surface list and the default value\n    \n    \n       \n      VideosinkElementOverlay\n      Plugin name for the Overlay output surface and the property setting list\n    \n    \n       \n      VideosinkElementEvas\n      Plugin name for the Evas output surface and the property setting list\n    \n    \n       \n      VideosinkElementGL\n      Plugin name for the GL output surface and the property setting list\n    \n    \n       \n      VideosinkElementNULL\n      Plugin name for the NULL surface and the property setting list\n    \n    \n       \n      Video encoder\n      Video encoder list for video recording\n    \n    \n       \n      Audio encoder\n      Audio encoder list for AV recording or voice recording\n    \n    \n      Capture\n       \n      Setting list related to image capture\n    \n    \n       \n      UseEncodebin\n      Whether to use the encodebin to capture the image. Keep this value as 0 (FALSE).\n    \n    \n      Record\n       \n      Setting value list for each recording mode. Keep the values of the example config file.\n    \n    \n      Mux\n       \n      Mux plugin list related with the file container\n    \n  \n\n\nThe following table shows the description of the mmfw_camcorder_dev_video_pri.ini file for the primary camera (usually the rear camera) and the mmfw_camcorder_dev_video_sec.ini file for the secondary camera (usually the front camera).\n\nTable: mmfw_camcorder_dev_video_pri.ini\n\n\n  \n    \n      Category\n      Entry\n      Description\n    \n  \n  \n    \n      Camera\n       \n      Information about the camera\n    \n    \n       \n      InputIndex\n      Camera number to select (primary or secondary)\n    \n    \n       \n      DeviceName\n      Name of the camera module\n    \n    \n       \n      PreviewResolution\n      List of all supported preview resolutions the user can set, as well as the default value for this camera device\n    \n    \n       \n      CaptureResolution\n      List of all supported capture resolutions the user can set, as well as the default value for this camera device\n    \n    \n       \n      VideoResolution\n      List of all supported video resolutions the user can set, as well as the default value for this camera device\n    \n    \n       \n      FPS0 ~ 9\n      List of all supported FPS (Frame Per Second) settings by preview resolution the user can use, as well as the default value for this camera device\n    \n    \n       \n      PictureFormat\n      List of all supported preview formats a user can set, as well as the default value for this camera device\n    \n    \n       \n      RecommendDisplayRotation\n      Default display rotation value for displaying camera input\n    \n    \n       \n      RecommendPreviewFormatCapture\n      Recommended preview format for capturing images\n    \n    \n       \n      RecommendPreviewFormatRecord\n      Recommended preview format for recording\n    \n    \n       \n      RecommendPreviewResolution\n      Recommended preview resolution by ratio of preview resolution\n    \n    \n       \n      FacingDirection\n      Facing direction of camera device\n    \n    \n      Strobe\n       \n      Camera flash settings\n    \n    \n       \n      StrobeMode\n      Supported strobe mode and default value. This is converted to a real value and used in the kernel internally.\n    \n    \n      Effect\n       \n      Effect settings\n    \n    \n       \n      Brightness\n      Supported range of brightness and default value\n    \n    \n       \n      Contrast\n      Supported range of contrast and default value\n    \n    \n       \n      Saturation\n      Supported range of saturation and default value\n    \n    \n       \n      Sharpness\n      Supported range of sharpness and default value\n    \n    \n       \n      Whitebalance\n      Supported white balance list and default value. This is converted to a real value and used in the kernel internally.\n    \n    \n       \n      ColorTone\n      Supported color tone list and default value. This is converted to a real value and used in the kernel internally.\n    \n    \n       \n      WDR\n      Supported Wide Dynamic Range mode list and default value. This is converted to a real value and used in the kernel internally.\n    \n    \n      Photograph\n       \n      Camera shooting settings\n    \n    \n       \n      DigitalZoom\n      Supported range of digital zoom level and default value\n    \n    \n       \n      OpticalZoom\n      Supported range of optical zoom level and default value\n    \n    \n       \n      FocusMode\n      Supported focus mode list and default value. This is converted to a real value and used in the kernel internally.\n    \n    \n       \n      AFType\n      Supported AUTO Focus mode list and default value. This is converted to a real value and used in the kernel internally.\n    \n    \n       \n      AEType\n      Supported AUTO Exposure mode list and default value. This is converted to a real value and used in the kernel internally.\n    \n    \n       \n      ExposureValue\n      Supported range of exposure value and default value\n    \n    \n       \n      ISO\n      Supported ISO list and default value. This is converted to a real value and used in the kernel internally.\n    \n    \n       \n      ProgramMode\n      Supported program mode (scene mode) list and default value. This is converted to a real value and used in the kernel internally.\n    \n    \n       \n      AntiHandshake\n      Supported anti-hand shake mode list and default value. This is converted to a real value and used in the kernel internally.\n    \n    \n      Capture\n       \n      Image capture settings\n    \n    \n       \n      OutputMode\n      Supported capture format list and default value\n    \n    \n       \n      JpegQuality\n      Supported range of JPEG quality and default value\n    \n    \n       \n      MultishotNumber\n      Supported range of multi shot count and default value\n    \n    \n       \n      SensorEncodedCapture\n      Whether the camera device supports encoded capture format (such as JPEG)\n    \n    \n       \n      SupportHDR\n      Supported HDR mode list and default value\n    \n    \n       \n      SupportZSL\n      Whether the camera device supports zero shutter lag capture\n    \n    \n      Detect\n       \n      Detect function settings\n    \n    \n       \n      DetectMode\n      Supported detect mode list and default value\n    \n  \n\n\nReferences\n\n\n  \n    Driver configuration\n\n    Set the kernel .config values for the camera:\n    CONFIG_VIDEO_DEV = y\nCONFIG_VIDEO_SAMSUNG = y\nCONFIG_VIDEO_SAMSUNG_V4L2 = y\nCONFIG_VIDEO_FIMC = y\nCONFIG_VIDEO_FIMC_MMAP_OUTPUT_CACHE = y\nCONFIG_VIDEO_FIMC_MIPI = y\nCONFIG_VIDEO_FIMG2D = y\nCONFIG_VIDEO_JPEG = y\nCONFIG_VIDEO_MFC5X = y\n    \n  \n  \n    Kernel node\n\n    For Camera: /dev/video1\nOther CAMIF interfaces: /dev/video(0-3)\n    \n  \n  \n    GStreamer\n\n    For more information about GStreamer, see http://gstreamer.freedesktop.org/documentation/ and http://gstreamer.freedesktop.org/data/doc/gstreamer/head/pwg/html/index.html.\n  \n  \n    V4L2\n\n    For more information about V4L2, see http://v4l2spec.bytesex.org/spec-single/v4l2.html.\n  \n\n\nRadio\n\nThe radio interface part of the multimedia framework supports APIs to implement the following FM radio features:\n\n\n  Tuning a frequency\n  Getting and setting a frequency\n  Scanning all available frequencies\n  Seeking up and down\n  Getting the frequency signal\n\n\nFigure: Multimedia radio framework\n\n\n\nBecause the interfaces for controlling the radio device differ, Tizen provides the Radio Hardware Abstraction Layer (HAL) to control various radio devices with a common interface. With the common interface, you can control the radio device on various chipsets used by the libmm-radio.\n\nPorting the OAL Interface\n\nThe OAL interface for FM radio is the radio HAL interface.\n\nThe mm-hal-interface package provides the radio HAL header file:\n\n\n  Repository path: platform/core/multimedia/mm-hal-interface\n  File name: tizen-radio.h\n\n\nThe OAL interface for FM radio is the Linux kernel V4L2 interface. The radio module directly uses the V4L2 ioctls to perform various radio hardware configurations.\n\nMajor Radio HAL Functions\n\nThe following list defines the major functions for the radio HAL interface:\n\n\n  \n    Functions for initialization and deinitialization:\n\n    /* Initializes a new radio HAL handle */\nradio_error_t radio_init(void **radio_handle);\n\n/* Deinitializes the radio HAL handle */\nradio_error_t radio_deinit(void *radio_handle);\n    \n  \n  \n    Functions for preparing and unpreparing the radio device:\n\n    /* Prepares the radio device */\nradio_error_t radio_prepare_device(void *radio_handle);\n\n/* Unprepares the radio device */\nradio_error_t radio_unprepare_device(void *radio_handle);\n    \n  \n  \n    Functions for opening and closing the radio device:\n\n    /* Opens the radio device */\nradio_error_t radio_open_device(void *radio_handle);\n\n/* Closes the radio device */\nradio_error_t radio_close_device(void *radio_handle);\n    \n  \n  \n    Functions for starting and stopping the radio device:\n\n    /* Starts the radio device */\nradio_error_t radio_start(void *radio_handle);\n\n/* Stops the radio device */\nradio_error_t radio_stop(void *radio_handle);\n    \n  \n  \n    Functions for setting and getting the frequency:\n\n    /* Gets the radio frequency */\nradio_error_t radio_get_frequency(void *radio_handle, uint32_t *frequency);\n\n/* Sets the radio frequency */\nradio_error_t radio_set_frequency(void *radio_handle, uint32_t frequency);\n    \n  \n  \n    Functions for seeking channels:\n\n    typedef enum radio_seek_direction_type {\n    RADIO_SEEK_DIRECTION_UP, /* Seek upward */\n    RADIO_SEEK_DIRECTION_DOWN /* Seek downward */\n} radio_seek_direction_type_t;\n\n/* Asynchronously seeks (up or down) the effective frequency of the radio */\nradio_error_t radio_seek(void *radio_handle, radio_seek_direction_type_t direction);\n    \n  \n  \n    Functions for  muting and unmuting the radio device:\n\n    /* Mutes the radio */\nradio_error_t radio_mute(void *radio_handle);\n\n/* Unmutes the radio */\nradio_error_t radio_unmute(void *radio_handle);\n    \n  \n  \n    Functions for setting and getting the volume:\n\n    /* Gets the current radio volume */\nradio_error_t radio_get_volume(void *radio_handle, float *volume);\n\n/* Sets the current radio volume */\nradio_error_t radio_set_volume(void *radio_handle, float volume);\n\n/* Sets the current media volume level (system media volume) */\nradio_error_t radio_set_media_volume(void *radio_handle, uint32_t level);\n    \n  \n  \n    Functions for getting the signal strength:\n\n    /* Gets the current signal strength of the radio */\nradio_error_t radio_set_media_volume(void *radio_handle, uint32_t level);\n    \n  \n\n\nReferences\n\n\n  \n    Kernel node\n\n    For Radio: /dev/radio0\n    \n  \n\n\nAudio\n\nThe following figure illustrates the different audio layers.\n\nFigure: Audio layers\n\n\n\n\n  PulseAudio\n    \n      PulseAudio is a sound server accepting sound input from 1 or more sources and redirecting it to 1 or more sinks. It has the following features:\n        \n          Software mixing of multiple audio streams\n          Support for multiple audio sources and sinks\n          An extensible plugin architecture with support for loadable modules\n          Low-latency operation\n          Support for external devices, such as Bluetooth audio and USB audio devices\n        \n      \n      Pulseaudio interacts with AudioHAL interfaces to support various device types.\n    \n  \n  Audio HAL\n    \n      Predefined interfaces for Audio Hardware Abstraction Layer (HAL)\n      Interfaces include the following categories: volume, route, stream, PCM\n    \n  \n  \n    Configuration files\n\n    Configurations for running Pulseaudio and Audio Systems which can be modified without code changes.\n\n    \n      pulseaudio configurations (such as daemon.conf, client.conf, system.pa)\n      stream/device configuration (stream-map.json, device-map.json)\n    \n  \n\n\nPorting the OAL Interface\n\nThe following example defines the major functions for the audio HAL interface:\n\n/* Initializes the audio HAL handle */\naudio_return_t audio_init(void **audio_handle);\n\n/* Deinitializes the audio HAL handle */\naudio_return_t audio_deinit(void *audio_handle);\n\n/* Gets the maximum volume level supported for a particular volume information */\naudio_return_t audio_get_volume_level_max(void *audio_handle, audio_volume_info_t *info, uint32_t *level);\n\n/* Gets the volume level specified for a particular volume information */\naudio_return_t audio_get_volume_level(void *audio_handle, audio_volume_info_t *info, uint32_t *level);\n\n/* Sets the volume level specified for a particular volume information */\naudio_return_t audio_set_volume_level(void *audio_handle, audio_volume_info_t *info, uint32_t level);\n\n/* Gets the volume value specified for a particular volume information and level */\naudio_return_t audio_get_volume_value(void *audio_handle, audio_volume_info_t *info, uint32_t level, double *value);\n\n/* Gets the volume mute specified for a particular volume information */\naudio_return_t audio_get_volume_mute(void *audio_handle, audio_volume_info_t *info, uint32_t *mute);\n\n/* Sets the volume mute specified for a particular volume information */\naudio_return_t audio_set_volume_mute(void *audio_handle, audio_volume_info_t *info, uint32_t mute);\n\n/* Updates the audio routing according to audio route information */\naudio_return_t audio_update_route(void *audio_handle, audio_route_info_t *info);\n\n/* Updates audio routing option according to audio route option */\naudio_return_t audio_update_route_option(void *audio_handle, audio_route_option_t *option);\n\n/* Notifies when a stream is connected and disconnected */\naudio_return_t audio_notify_stream_connection_changed(void *audio_handle, audio_stream_info_t *info, uint32_t is_connected);\n\n/* Opens a PCM device */\naudio_return_t audio_pcm_open(void *audio_handle, void **pcm_handle, uint32_t direction, void *sample_spec, uint32_t period_size, uint32_t periods);\n\n/* Starts a PCM device */\naudio_return_t audio_pcm_start(void *audio_handle, void *pcm_handle);\n\n/* Stops a PCM device */\naudio_return_t audio_pcm_stop(void *audio_handle, void *pcm_handle);\n\n/* Closes a PCM device */\naudio_return_t audio_pcm_close(void *audio_handle, void *pcm_handle);\n\n/* Gets the available number of frames */\naudio_return_t audio_pcm_avail(void *audio_handle, void *pcm_handle, uint32_t *avail);\n\n/* Writes frames to a PCM device */\naudio_return_t audio_pcm_write(void *audio_handle, void *pcm_handle, const void *buffer, uint32_t frames);\n\n/* Reads frames from a PCM device */\naudio_return_t audio_pcm_read(void *audio_handle, void *pcm_handle, void *buffer, uint32_t frames);\n\n/* Gets the poll descriptor for a PCM handle */\naudio_return_t audio_pcm_get_fd(void *audio_handle, void *pcm_handle, int *fd);\n\n/* Recovers the PCM state */\naudio_return_t audio_pcm_recover(void *audio_handle, void *pcm_handle, int revents);\n\n/* Gets the parameters of a PCM device */\naudio_return_t audio_pcm_get_params(void *audio_handle, void *pcm_handle, uint32_t direction, void **sample_spec, uint32_t *period_size, uint32_t *periods);\n\n/* Sets the hardware and software parameters of a PCM device */\naudio_return_t audio_pcm_set_params(void *audio_handle, void *pcm_handle, uint32_t direction, void *sample_spec, uint32_t period_size, uint32_t periods);\n\n\nConfiguration\n\nTo support a variety of devices, PulseAudio and device configuration have to be modified by the vendor. The following table shows the PulseAudio configuration.\n\nTable: PulseAudio configuration\n\n\n  \n    \n      Configuration\n      Description\n    \n  \n  \n    \n      /etc/pulse/daemon.conf\n      Configuration file for the PulseAudio daemon. In this file, the PulseAudio daemon properties, such as priority, log-level, resampling method, and default sample rate, can be modified. In Tizen, the PulseAudio daemon must be running in system mode, not user mode.\n    \n    \n      /etc/pulse/client.conf\n      Configuration file for the PulseAudio clients. It is generally not necessary to modify this file.\n    \n    \n      /etc/pulse/system.pa\n      PulseAudio Sound Server startup script. This startup script is used only if PulseAudio is started in system mode. Initial module loading is triggered by this file, so any vendor-specific modules to be loaded must be added here.\n    \n    \n      /etc/pulse/default.pa\n      PulseAudio Sound Server startup script. This startup script is used only if PulseAudio is started in user mode. Currently Tizen does not support this mode.\n    \n  \n\n\nStream and device configuration:\n\n\n  \n    Stream map: Latency, volume, and streams can be configured in the /etc/pulse/stream-map.json file:\n\n    {\n    \"latencies\":[\n        {\n            \"type\":\"low\",\n            \"fragsize-ms\":25,\n            \"minreq-ms\":-1,\n            \"tlength-ms\":100,\n            \"prebuf-ms\":0,\n            \"maxlength\":-1,\n        },\n        {\n            \"type\":\"high\",\n            \"fragsize-ms\":75,\n            \"minreq-ms\":-1,\n            \"tlength-ms\":400,\n            \"prebuf-ms\":0,\n            \"maxlength\":-1,\n        },\n    ],\n    \"volumes\":[\n        {\n            \"type\":\"media\",\n            \"is-hal-volume\":1,\n        },\n        {\n            \"type\":\"system\",\n            \"is-hal-volume\":0,\n        },\n        {\n            \"type\":\"notification\",\n            \"is-hal-volume\":0,\n        },\n        {\n            \"type\":\"ringtone\",\n            \"is-hal-volume\":0,\n        },\n        {\n            \"type\":\"call\",\n            \"is-hal-volume\":1,\n        },\n    ],\n    \"streams\":[\n        {\n            \"role\":\"media\",\n            \"priority\":3,\n            \"route-type\":\"auto\",\n            \"volume-types\":{\"in\":\"none\",\"out\":\"media\"},\n            \"avail-in-devices\":[\"audio-jack\",\"builtin-mic\"],\n            \"avail-out-devices\":[\"forwarding\",\"audio-jack\",\"bt\",\"builtin-speaker\"],\n            \"avail-frameworks\":[\"player\",\"wav-player\",\"tone-player\",\"audio-io\",\"recorder\"],\n        },\n        {\n            \"role\":\"system\",\n            \"priority\":2,\n            \"route-type\":\"auto\",\n            \"volume-types\":{\"in\":\"none\",\"out\":\"system\"},\n            \"avail-in-devices\":[\"none\"],\n            \"avail-out-devices\":[\"forwarding\",\"audio-jack\",\"bt\",\"builtin-speaker\"],\n            \"avail-frameworks\":[\"player\",\"wav-player\",\"tone-player\",\"audio-io\"],\n        },\n        {\n            \"role\":\"notification\",\n            \"priority\":4,\n            \"route-type\":\"auto-all\",\n            \"volume-types\":{\"in\":\"none\",\"out\":\"notification\"},\n           \"avail-in-devices\":[\"none\"],\n            \"avail-out-devices\":[\"audio-jack\",\"bt\",\"builtin-speaker\"],\n            \"avail-frameworks\":[\"player\",\"wav-player\",\"tone-player\",\"audio-io\"],\n        },\n        {\n            \"role\":\"ringtone-call\",\n            \"priority\":6,\n            \"route-type\":\"auto-all\",\n            \"volume-types\":{\"in\":\"none\",\"out\":\"ringtone\"},\n            \"avail-in-devices\":[\"none\"],\n            \"avail-out-devices\":[\"audio-jack\",\"bt\",\"builtin-speaker\"],\n            \"avail-frameworks\":[\"player\",\"wav-player\",\"tone-player\",\"audio-io\"],\n        },\n        {\n            \"role\":\"call-voice\",\n            \"priority\":6,\n            \"route-type\":\"manual\",\n            \"volume-types\":{\"in\":\"none\",\"out\":\"call\"},\n            \"avail-in-devices\":[\"builtin-mic\",\"audio-jack\",\"bt\"],\n            \"avail-out-devices\":[\"builtin-receiver\",\"builtin-speaker\",\"audio-jack\",\"bt\"],\n            \"avail-frameworks\":[\"sound-manager\"],\n        },\n    ]\n}\n    \n  \n  \n    Device map: Device types and device files can be configured in the /etc/pulse/device-map.json file:\n\n    {\n    \"device-types\":[\n        {\n            \"device-type\":\"builtin-speaker\",\n            \"builtin\":true,\n            \"direction\":[\"out\"],\n            \"avail-condition\":[\"pulse\"],\n            \"playback-devices\":{\"normal\":\"alsa:sprdphone,0\", \"call-voice\":\"alsa:VIRTUALAUDIOW,0\"}\n        },\n        {\n            \"device-type\":\"builtin-mic\",\n            \"builtin\":true,\n            \"direction\":[\"in\"],\n            \"avail-condition\":[\"pulse\"],\n            \"capture-devices\":{\"normal\":\"alsa:sprdphone,0\"}\n        },\n        {\n            \"device-type\":\"audio-jack\",\n            \"builtin\":false,\n            \"direction\":[\"both\",\"out\"],\n            \"avail-condition\":[\"pulse\",\"dbus\"],\n            \"playback-devices\":{\"normal\":\"alsa:sprdphone,0\", \"call-voice\":\"alsa:VIRTUALAUDIOW,0\"},\n            \"capture-devices\":{\"normal\":\"alsa:sprdphone,0\"}\n        },\n        {\n            \"device-type\":\"bt\",\n            \"profile\":\"a2dp\",\n            \"builtin\":false,\n            \"direction\":[\"out\"],\n            \"avail-condition\":[\"pulse\"]\n        },\n        {\n            \"device-type\":\"bt\",\n            \"profile\":\"sco\",\n            \"builtin\":false,\n            \"direction\":[\"both\"],\n            \"avail-condition\":[\"pulse\",\"dbus\"],\n            \"playback-devices\":{\"normal\":\"alsa:sprdphone,0\", \"call-voice\":\"alsa:VIRTUALAUDIOW,0\"},\n            \"capture-devices\":{\"normal\":\"alsa:sprdphone,0\"}\n        },\n        {\n            \"device-type\":\"usb-audio\",\n            \"builtin\":false,\n            \"direction\":[\"both\", \"in\", \"out\"],\n            \"avail-condition\":[\"pulse\"]\n        }\n    ],\n    \"device-files\":\n    {\n        \"playback-devices\":[\n            {\n                \"device-string\":\"alsa:sprdphone,0\",\n                \"role\":\n                {\n                    \"normal\":\"rate=44100\",\n                }\n            },\n            {\n                \"device-string\":\"alsa:VIRTUALAUDIOW,0\",\n                \"role\":\n                {\n                    \"call-voice\":\"rate=16000 channels=1 tsched=0 alternate_rate=16000\",\n                }\n            }\n        ],\n        \"capture-devices\":[\n            {\n                \"device-string\":\"alsa:sprdphone,0\",\n                \"role\":{\"normal\":\"rate=44100\"}\n            }\n        ]\n    }\n}\n    \n  \n\n\nReferences\n\n\n  \n    Driver configuration for the Samsung chipset\n\n    The following list is an example of the kernel .config values to be set for audio when using the Samsung chipset.\n    CONFIG_SOUND=y\nCONFIG_SND=y\nCONFIG_SND_TIMER=y\nCONFIG_SND_HWDEP=y\nCONFIG_SND_JACK=y\nCONFIG_SND_SOC = y\nCONFIG_SND_SOC_SAMSUNG = y\nCONFIG_SND_SAMSUNG_I2S = y\nCONFIG_SND_SOC_SLP_TRATS_MC1N2 = y\nCONFIG_SND_SOC_I2C_AND_SPI = y\nCONFIG_SND_SOC_MC1N2=y\n    \n  \n  \n    PulseAudio\n\n    Version: 5.0\n\n    Website: http://www.freedesktop.org/wiki/Software/PulseAudio\n  \n  \n    ALSA\n\n    Website: http://www.alsa-project.org\n  \n\n\nPlayer\n\nThe multimedia player framework controls the player plugins (demuxer, codecs, and renderer plugins) of the GStreamer to play media content. The kernel interfaces to control codecs can be different for different chipsets, so the corresponding codec plugins must be implemented specifically for each chipset.\n\nFigure: Multimedia player framework\n\n\n\nPorting the OAL Interface\n\nThere is no specific OAL for the multimedia player framework. The OAL interface for the player plugins consists of the gst-omx codec plugins and video/audio renderer plugins. For more information on the gst-omx plugin, see Codec &gt; Porting OAL Interface. For more information about Avsystem for audio, see Audio. For more information on Wayland (UI-framework) for display, see Video.\n\nFigure: Player plugins\n\n\n\nConfiguration\n\n\n  Configuration file:\n    \n      The multimedia player framework uses the mmfw_player.ini configuration file to set various parameters for selecting different codecs and display plugins.\n      The mmfw_player.ini configuration file is provided by the mmfw-sysconf-xxx package.\n      In the final stage of development, the permission for this file needs to be changed to read-only.\n    \n  \n  Configuring the player:\n    \n      File name: mmfw_player.ini\n      1 player.ini file is needed in each board (or model).\n      Codec plugins for the board are located in the /usr/lib/gstreamer-1.0 directory. Changing the codec plugin does not mean modifying this .ini file because the player supports the auto plugin feature.\n    \n  \n  As needed, the following setting values can be used:\n    \n      Exclude keyword element\n      Audio filter\n    \n  \n\n\nReferences\n\n\n  \n    Display driver configuration for the Samsung chipset\n\n    The following list is an example of the kernel .config values to be set for display in the Samsung chipset.\n    CONFIG_DRM = y\nCONFIG_FB = y\nCONFIG_FB_S3C = y\nCONFIG_FB_S3C_LCD_INIT = y\nCONFIG_FIMD_EXT_SUPPORT = y\nCONFIG_FIMD_LITE_SUPPORT = y\n    \n  \n  \n    Kernel node\n    \n      Frame buffers: /dev/fb(0-4)\n      gst-omx version : 1.2.0\n        \n          http://gstreamer.freedesktop.org/src/gst-omx/\n          http://www.freedesktop.org/wiki/GstOpenMAX\n        \n      \n      For all GStreamer documentation, see http://gstreamer.freedesktop.org/documentation/.\n      For developing GStreamer plugins, see http://gstreamer.freedesktop.org/data/doc/gstreamer/head/pwg/html/index.html.\n      For more information about OpenMAX IL components, see http://www.khronos.org/openmax/il/.\n    \n  \n\n\nCodec\n\nThe following figure illustrates the codecs and their relations. It shows 2 types of codec plugins, the Gstreamer and OpenMAX.\n\nFigure: Multimedia codecs\n\n\n\n\n  \n    Gstreamer codec plugin\n\n    \n      The Gstreamer codec plugin can be linked to and easily used in the Gstreamer pipeline, which is used in the multimedia framework.\n      In addition, to link a Gstreamer pipeline, the capability of the codec plugin can be negotiated with the linked element in the pipeline.\n      \n        To get detailed information, such as the capability of an element, use the #gst-inspect-1.0 (element name) command.\n\n        \n      \n    \n  \n  \n    OpenMAX codec plugin\n    \n      Some of the codec vendors provide OpenMAX IL components and not Gstreamer plugins. Tizen provides the gst-omx plugins to use the OpenMAX IL components. The Gstreamer pipeline used in the multimedia framework can control and transfer data to OpenMAX IL component using the gst-omx plugin.\n      To use the OpenMAX component in Gstreamer, the gst-omx (open source) package is provided. By using this package, Gstreamer can recognize and use an OpenMAX component as a Gstreamer element. gst-omx is a Gstreamer plugin that allows communication with OpenMAX IL components. The usage of the gst-omx plugin is the same as other Gstreamer plugins.\n      For more detailed information about this plugin, see http://www.freedesktop.org/wiki/GstOpenMAX. For more information about OpenMAX IL, see http://www.khronos.org/openmax/.\n      The gst-omx plugin refers to a gstomx.conf configuration file. This file is included in the gst-omx package, and installed to the /etc/xdg/gst-omx.conf directory in the target device.\n    \n  \n\n\nPorting the OAL Interface\n\nThe OpenMAX plugin is an industry standard that provides an abstraction layer for computer graphics, video, and sound routines. The interface abstracts the hardware and software architecture in the system. The OpenMAX IL API allows the user to load, control, connect, and unload the individual components. This flexible core architecture allows the Integration Layer to easily implement almost any media use case and mesh with existing graph-based media frameworks. The key focus of the OpenMAX IL API is portability of media components. OpenMAX IL interfaces between the media framework, such as GStreamer, and a set of multimedia components (such as an audio or video codecs). gst-omx is a GStreamer plug-in package that allows communication with OpenMAX IL components. The gst-omx structuring is classified into different object classes based on the functionality. The following figure shows the object structuring of a video decoder plugin in gst-omx.\n\nFigure: gst-omx structuring\n\n\n\nThe GstVideoDecoder base class for video decoders provides encoded data to derived GstOMXVideoDec. Each input frame is provided in turn to the subclass’s handle_frame callback. The GstVideoDecoder base class and derived subclass cooperate in the following manner:\n\n\n  Configuration\n    \n      GstVideoDecoder calls the start() function when the decoder element is activated.\n      GstVideoDecoder calls the set_format() function to inform the subclass of caps describing the input video data.\n    \n  \n  Data processing\n    \n      Each input frame is provided in turn to the subclass’s handle_frames() function.\n      The subclass calls the gst_video_decoder_finish_frame() or gst_video_decoder_drop_frame() function.\n    \n  \n  Shutdown phase\n    \n      The GstVideoDecoder class calls the stop() function.\n    \n  \n\n\nConfiguration\n\nThe gst-omx plugin uses a configuration file, such as gstomx.conf. This file is included in the gst-omx package, and installed in the /etc/xdg/gstomx.conf directory on the target device. The gstomx.conf file needs to be changed according to the OpenMAX component vendor. The following figures lists the values of each item in the lists separated by commas. Each Gstreamer element is separated by a semicolon.\n\nFigure: gstomx.conf elements\n\n\n\nFigure: gstomx.conf example\n\n\n\nEach value needs to be changed according to the OpenMAX component vendor. When you are finished with these settings, the result is a Gstreamer type codec plugin, and you can test the codec the same way.\n\n\n  \n    Using the codec plugin in the player\n\n    Because the player uses auto plugging, it does not need an additional setting.\n\n    \n      If the decoder plugin has an acceptable capability, this plugin can be linked with a player pipeline in order of rank.\n      If the codec name is included in the excluded keyword in the /usr/etc/mmfw_player.ini file (mmfw-sysconf package), it is excluded in the player pipeline.\n    \n  \n  \n    Using the codec plugin in the camcorder\n\n    Because the camcorder clarified its audio, video, and image encoder in the /usr/etc/mmfw_camcorder.ini file (mmfw-sysconf package), you need to change this category value to set your own codec name.\n\n    \n  \n\n\nReferences\n\n\n  \n    gst-omx version: 1.2\n\n    http://gstreamer.freedesktop.org/src/gst-omx/\n\n    http://www.freedesktop.org/wiki/GstOpenMAX\n  \n  \n    For all GStreamer documentation, see http://gstreamer.freedesktop.org/documentation/.\n  \n  \n    For developing GStreamer plug-ins, see http://gstreamer.freedesktop.org/data/doc/gstreamer/head/pwg/html/index.html.\n  \n  \n    For more information about OpenMAX IL components, see http://www.khronos.org/openmax/il/.\n  \n\n\nVideosink\n\nThe videosink renders a video frame buffer from a previous gst element on a local display using Waylandsink (since Tizen 3.0). It is used with a camera or player that requires video output. This element can receive a surface ID of a window from the application through the GstVideoOverlay interface (set_wl_window_wl_surface_id()) and renders the video frame in this window. If no surface ID was provided by the application, the element creates its own internal window and renders into it.\n\nThe following figure shows the video rendering process in the player. The white box is the gstreamer element. GstBuffer is streaming from filesrc to Waylandsink past the video codec. The GstBuffer is TBM or SHM.\n\nFigure: Video rendering process\n\n\n\n\n  Waylandsink requests the rendering of the video frame to the wl_surface of a window, so Waylandsink needs the wl_surface of a Wayland window created by the application. Because the application and Muse are in different process bounds, the application cannot pass the wl_surface pointer to Muse. To solve this problem, Tizen uses the surface ID value.\n  The application sends a wl_surface pointer to the Window Server, which returns the global surface ID to the application, which in turn passes this value to Waylandsink using the GstVideoOverlay interface, set_wl_window_wl_surface_id() (Tizen-specific). Steps 1, 2, and 3 in the figure.\n  Waylandsink creates wl_display to communicate with the Window Server. Normally a Window client uses the wl_display created by the application, but the Tizen Waylandsink creates its own wl_display due to process bounds issues. Step 4. Now Waylandsink can receive events from the server and bind to various interfaces using wl_registry.\n  Waylandsink uses wl_display to create wl_window and a wl_subsurface using the global surface ID passed through the GstVideoOverlay interface. wl_surface is created by the wl_compositor of wl_display. Step 5.\n  The application can use the Waylandsink properties to change video rendering conditions through wl_subsurface. Step 6.\n  The GstBuffer received from the video codec is converted into a wl_buffer, then the wl_surface of wl_window is requested to render the video frame to the Window Server through the attach, damage, and commit process. Steps 7 and 8. The Window Server renders the wl_buffer. Step 9.\n  When the Window Server finishes rendering the video frame, the rendering complete signal is sent to the wl_callback of wl_window, and the wl_buffer release event is sent to the wl_buffer_listener callback function. Steps 10 and 11. Now, Waylandsink can unreference the GstBuffer created by the video codec and return the GstBuffer to the video codec. Sometimes, it is necessary to return a GstBuffer while maintaining the rendered video frame in the window (for gapless playback, or keeping a camera preview). In this case, use FlushBuffer, which is a wl_buffer created after copying TBM from GstBuffer coming from the video codec. Waylandsink returns the GstBuffer to the video codec immediately, and a request to render the FlushBuffer is made to the Window Server.\n\n\nFor more information on Wayland, see https://wayland.freedesktop.org/.  For more information on programming the Wayland client, see Programming Wayland Clients.\n\nPorting the OAL Interface\nThere is no specific OAL for the videosink.\n\nTizen-specific Features Added to Waylandsink\n\nYou can check the original waylandsink behavior easily with Waylandsink’s video rendering test. Simply connect to videotestsrc through gst-launch. If the video test screen does not appear, the Window system must be ported first.\n\ngst-launch-1.0 videotestsrc ! waylandsink\n\nFigure: Video test screen\n\n\n\nWaylandsink Requirements for Tizen\n\nOpen source Waylandsink uses wayland-client, but Waylandsink for Tizen uses libtbm, wayland-tbm-client, and tizen-extension-client to support MMFW’s API requirements and uses Window Server extended functionality.\n\nThe major functions are TBM Video Format, Specific Video Formats, Zero copy, MMVideoBuffer, Tizen Viewport, Flush Buffer, Audio only mode, Handoffs Element signals, preroll-handoff Element signals, Use TBM, Rotate, Flip, Visible, Display Geometry Method, and ROI.\n\nTBM Video Format\n\nOriginal Waylandsink lists various video formats, but Wayland only supports the RGB format. To support various video formats, Waylandsink for Tizen uses the TBM Video Format provided by Wayland for Tizen. The video formats supported by the Window Server are hardware-dependent. The dependency is on the Window Server. When the Gst-pipeline with Waylandsink is created and the caps negotiation begins, the TBM video format provided by the Window Server is passed to Waylandsink. The Window Server can accommodate the video output format of the video codec when the negotiation is completed.\n\nTo use the TBM Video Format, Waylandsink needs to bind tizen_policy_interface, tizen_video_interface, and register listener and get the video formats as a callback.\n\nstatic void handle_tizen_video_format(void *data, struct tizen_video *tizen_video, uint32_t format) {\n    GstWlDisplay *self = data;\n    FUNCTION;\n\n    g_return_if_fail(self != NULL);\n\n    GST_LOG(\"format is %d\", format);\n    g_array_append_val(self-&gt;tbm_formats, format);\n}\n\nstatic const struct tizen_video_listener tizen_video_listener = {\n    handle_tizen_video_format\n};\n\nstatic void global_registry_handler(void *data, struct wl_registry *registry, uint32_t id, const char *interface, uint32_t version) {\n    [...]\n    } else if (g_strcmp0(interface, \"tizen_policy\") == 0) {\n        self-&gt;tizen_policy = wl_registry_bind(registry, id, &amp;tizen_policy_interface, 1);\n    } else if (g_strcmp0(interface, \"tizen_video\") == 0) {\n        self-&gt;tizen_video = wl_registry_bind(registry, id, &amp;tizen_video_interface, version);\n        g_return_if_fail(self-&gt;tizen_video != NULL);\n        tizen_video_add_listener(self-&gt;tizen_video, &amp;tizen_video_listener, self);\n    }\n    [...]\n}\n\n\nSpecific Video Formats (SN12, SN21, ST12, SR32, S420) for Zero copy\n\nThe SN12, SN21, ST12, SR32, and S320 formats are identical to NV12, NV21, NV12MT, BGRA, and I420, but the Multimedia framework uses these specific video formats to indicate that the formats are using a TBM buffer. Tizen provides a TBM buffer to avoid memory copying when transferring the buffer to different processes. Camerasrc or the video codec writes the video data to the TBM buffer, saves it to a pointer to GstBuffer, and sends it to Waylandsink. Waylandsink creates a wl_buffer with tbm_bo and requests rendering from the Window Server. There is no memory copy from Camerasrc or the video codec to the Window Server. This process is called Zero Copy.\n\nMMVideoBuffer\n\nThe Gst Element must use the MMVideoBuffer type when transferring TBM buffer. tbm bo must be stored in bo of MMVideoBufferHandle, and the type must be MM_VIDEO_BUFFER_TYPE_TBM_BO. Waylandsink makes wl_buffer by using the MMVideoBuffer information. If the video frame is not rendered, Waylandsink must make sure that the information in MMVideoBuffer in GstBuffer received from Camerasrc or Video Codec is correct.\n\ntypedef struct {\n    MMVideoBufferType type; /* Buffer type - the handle field that type indicates must be filled, and other handle fields are optional */\n    MMPixelFormatType format; /* Buffer type */\n    int plane_num; /* Number of planes */\n    int width[MM_VIDEO_BUFFER_PLANE_MAX] /* Width of buffer */\n    int height[MM_VIDEO_BUFFER_PLANE_MAX]; /* Height of buffer */\n    int stride_width[MM_VIDEO_BUFFER_PLANE_MAX]; /* Stride width of buffer */\n    int stride_height[MM_VIDEO_BUFFER_PLANE_MAX]; /* Stride height of buffer */\n    int size[MM_VIDEO_BUFFER_PLANE_MAX]; /* Size of planes */\n    void *data[MM_VIDEO_BUFFER_PLANE_MAX]; /* Data pointer(user address) of planes */\n    int handle_num; /* Number of buffer handle */\n    int handle_size[MM_VIDEO_BUFFER_PLANE_MAX]; /* Size of handles */\n    MMVideoBufferHandle handle; /* Handle of buffer */\n    int is_secured; /* Secured buffer flag, such as TrustZone memory; user cannot access it */\n    int flush_request; /* Flush request flag - if this flag is TRUE, sink element makes copy of last buffer, and it returns all buffers from src element. Then, src element can restart without changing pipeline state */\n    MMRectType crop; /* Crop information of buffer */\n} MMVideoBuffer;\n\nMMVideoBuffer can contain video data information of all cases, as shown in the following figure.\n\nFigure: MMVideoBuffer content\n\n\n\nTizen Viewport\n\nTo change the video frame render condition, the original open-source Waylandsink uses wlsurface_set_source(), wl_surface_set_buffer_transform(), wl_subsurface_set_position(), wl_viewport_set_destination(), and wl_surface_set_buffer_transform() functions. For more information on the Wayland API, see https://wayland.freedesktop.org/docs/html/. Waylandsink needs to IPC with wl_surface, wl_subsurface, and wl_viewport.\n\nFigure: Changing video frame render conditions\n\n\n\nFigure: Wayland protocols\n\n\n\nWaylandsink in the Muse Daemon requests rendering conditions on the wl_subsurface of the window created by the application. Therefore, it is difficult to match the geometry sync of the parent (Window) and wl_subsurface, due to the delay caused by the IPC communication between the Window Server and Wayland client. Since wl_viewport_ and wl_set_source_ are surface-based coordination, it is difficult to calculate the coordinates when the buffer is transformed. So Waylandsink for Tizen uses tizen_viewport supported Wayland Server for Tizen. To use tizen_viewport, Waylandsink binds tizen_policy_interface and tizen_video_interface. Now, Waylandsink only needs to IPC tizen_viewport.\n\nFigure: Tizen viewport\n\n\n\n\n  \n    Example 1:\n\n    \n  \n  \n    Example 2:\n\n    \n  \n  \n    Example 3:\n\n    \n  \n  \n    Example 4:\n\n    \n  \n\n\nFlush buffer\n\nSometimes, it is necessary to return GstBuffer while maintaining the video frame rendered in the window. In this case, use FlushBuffer, which is a wl_buffer created after copying TBM from GstBuffer coming from the video codec or Camerasrc. Waylandsink returns the GstBuffer to the video codec or Camerasrc immediately, and a request to render the FlushBuffer is made to the Window Server.\n\n\n  \n    Gapless video playback\n\n    Waylandsink receives the GST_EVENT_CUSTOM_DOWNSTREAM event from the player when it performs gapless video playback. The player creates a FlushBuffer.\n\n    #define GST_APP_EVENT_FLUSH_BUFFER_NAME \"application/flush-buffer\"\n\nstatic gboolean gst_wayland_sink_event(GstBaseSink * bsink, GstEvent * event) {\n    [...]\n    switch (GST_EVENT_TYPE(event)) {\n    case GST_EVENT_CUSTOM_DOWNSTREAM:\n        s = gst_event_get_structure(event);\n        if (s == NULL || !gst_structure_has_name(s, GST_APP_EVENT_FLUSH_BUFFER_NAME))\n            break;\n        gst_wayland_sink_render_flush_buffer(bsink);\n    [...]\n}\n    \n  \n  \n    keep-camera-preview\n\n    The camera sets this property when it needs to maintain the last video frame. Waylandsink copies the last TBM buffer and returns it immediately when the state changes (PAUSED_TO_READY).\n    keep-camera-preview : Last tbm buffer is copied and returned to camerasrc immediately when state change(PAUSED_TO_READY)\n                      flags: readable, writable\n                      Boolean. Default: false\n    \n  \n  \n    flush_request of MMVideoBuffer\n\n    Camerasrc and the video codec can set a flag to request a flushbuffer in the GstBuffer using MMVideoBuffer.flush_request = TRUE.\n  \n\n\nAudio only mode\n\nWaylandsink has a disable-overlay property to support the player’s audio-only mode. If this property is set, the video frame is not rendered. When the player needs to show a video frame, it needs to set this property to false and set wl_surface_id.\n\ndisable-overlay : Stop using overlay by destroying wl_window and wl_display, Use gst_video_overlay_set_wl_window_wl_surface_id before setting FALSE to use overlay\n                              flags: readable, writable\n                              Boolean. Default: false\n\n\ngst_wayland_sink_set_property(GObject * object, guint prop_id, const GValue * value, GParamSpec * pspec) {\n    [...]\n    case PROP_DISABLE_OVERLAY:\n       sink-&gt;disable_overlay = g_value_get_boolean(value);\n       if (sink-&gt;window &amp;&amp; sink-&gt;display) {\n         if (sink-&gt;disable_overlay) {   /* set TRUE */\n           g_clear_object(&amp;sink-&gt;window);\n           g_clear_object(&amp;sink-&gt;display);\n        } else /* set FALSE */\n          gst_wayland_sink_recover_display_window_info(sink);\n       }\n       break;\n    [...]\n}\n\nstatic GstFlowReturn gst_wayland_sink_render(GstBaseSink * bsink, GstBuffer * buffer) {\n    [...]\n    /* check overlay */\n    if (gst_wayland_sink_is_disabled_overlay(sink)) {\n        GST_LOG(\"set disable_overlay, so skip\");\n        goto done; //skip video rendering\n    }\n    [...]\n}\n\nRefer to mm_player_priv.c\n/* Need to set surface_id to enable overlay */\ngst_video_overlay_set_wl_window_wl_surface_id(GST_VIDEO_OVERLAY(player-&gt;pipeline-&gt;videobin[MMPLAYER_V_SINK].gst), *(int*)handle);\n\n\nHandoffs and preroll-handoff element signals\n\nChanging the gst-pipeline of the player is labor-intensive, so Waylandsink provides a fakesink functionality. If this property is set to true, Waylandsink sends a handoff signal to the player.\n\nstatic GstFlowReturn gst_wayland_sink_render(GstBaseSink * bsink, GstBuffer * buffer) {\n    [...]\n    /* fakesink function for media stream callback case */\n    if (sink-&gt;signal_handoffs) {\n        GST_LOG(\"g_signal_emit: hand-off \");\n        g_signal_emit(sink, gst_waylandsink_signals[SIGNAL_HANDOFF], 0, buffer, bsink-&gt;sinkpad);\n        goto done;  /* Skip video rendering */\n    }\n    [...]\n}\n\n\nUse TBM\n\nWaylandsink use 2 types of buffers, shared memory and TBM memory. The default value of the use-tbm property is true and Waylandsink uses TBM memory. If the value is false, Waylandsink for Tizen uses shared memory just like the original open-source Waylandsink.\nuse-tbm  : Use Tizen Buffer Memory instead of Shared memory, Memory is allocated by TBM instead of SHM when enabled\n           flags: readable, writable\n           Boolean. Default: true\n\n\nRotate\n\nWaylandsink can rotate the angle of display output. The default value of the rotate property is 0, “DEGREE_0”.\nrotate   : Rotate angle of display output\n           flags: readable, writable\n           Enum \"GstWaylandSinkRotateAngleType\" Default: 0, \"DEGREE_0\"\n                (0): DEGREE_0         - No rotate\n                (1): DEGREE_90        - Rotate 90 degree\n                (2): DEGREE_180       - Rotate 180 degree\n                (3): DEGREE_270       - Rotate 270 degree\n\n\nThe enumeration values used by the player or camera need to be converted to values used by Wayland.\nstatic gint gst_wl_window_find_rotate_transform(guint rotate_angle) {\n    gint transform = WL_OUTPUT_TRANSFORM_NORMAL;\n    switch (rotate_angle) {\n    case DEGREE_0:\n         transform = WL_OUTPUT_TRANSFORM_NORMAL;\n         break;\n    case DEGREE_90:\n        transform = WL_OUTPUT_TRANSFORM_90;\n        break;\n    case DEGREE_180:\n        transform = WL_OUTPUT_TRANSFORM_180;\n        break;\n    case DEGREE_270:\n        transform = WL_OUTPUT_TRANSFORM_270;\n        break;\n    }\n\n    return transform;\n}\n\ntransform =  gst_wl_window_find_rotate_transform(window-&gt;rotate_angle.value);\ntizen_viewport_set_transform(window-&gt;tizen_area_viewport, transform);\n\n\nFlip\n\nWaylandsink can flip the angle of the display output. The default value of the flip property is 0, “FLIP_NONE”.\n flip  : Flip for display\n         flags: readable, writable\n         Enum \"GstWaylandSinkFlipType\" Default: 0, \"FLIP_NONE\"\n              (0): FLIP_NONE        - Flip NONE\n              (1): FLIP_HORIZONTAL  - Flip HORIZONTAL\n              (2): FLIP_VERTICAL    - Flip VERTICAL\n              (3): FLIP_BOTH        - Flip BOTH\n\n\nWayland has no flip function, so Waylandsink must implement flipping by rotating the video viewport:\nstatic gint gst_wl_window_find_flip_transform(guint flip) {\n    gint transform = WL_OUTPUT_TRANSFORM_NORMAL;\n    FUNCTION;\n\n    GST_DEBUG(\"flip (%d)\", flip);\n    switch (flip) {\n    case FLIP_NONE:\n        transform = WL_OUTPUT_TRANSFORM_NORMAL;\n        break;\n    case FLIP_HORIZONTAL:\n        transform = WL_OUTPUT_TRANSFORM_FLIPPED;\n        break;\n    case FLIP_VERTICAL:\n        transform = WL_OUTPUT_TRANSFORM_FLIPPED_180;\n        break;\n    case FLIP_BOTH:\n        transform = WL_OUTPUT_TRANSFORM_180;\n        break;\n    }\n\n    return transform;\n}\n\ntransform = gst_wl_window_find_flip_transform(window-&gt;flip.value);\ntizen_viewport_set_transform(window-&gt;tizen_video_viewport, transform);\n\n\nVisible\n\nWaylandsink can make the video frame visible or invisible on the display. To make the video frame invisible, attach NULL. To make the video fame visible, Waylandsink needs to keep the last rendered video frame.\n\n/* invisible */\nstatic void gst_wayland_sink_stop_video(GstWaylandSink * sink) {\n    FUNCTION;\n    g_return_if_fail(sink != NULL);\n    gst_wl_window_render(sink-&gt;window, NULL, NULL);\n}\n/* visible */\ngst_wayland_sink_update_last_buffer_geometry(sink);\n\n\nDisplay geometry method and ROI\n\nWhen rendering video, Waylandsink can change the geometry.\n\ndisplay-geometry-method: Geometrical method for display\n           flags: readable, writable\n           Enum \"GstWaylandSinkDisplayGeometryMethodType\" Default: 0, \"LETTER_BOX\"\n                (0): LETTER_BOX       - Letter box\n                (1): ORIGIN_SIZE      - Origin size\n                (2): FULL_SCREEN      - Full-screen\n                (3): CROPPED_FULL_SCREEN - Cropped full-screen\n                (4): ORIGIN_SIZE_OR_LETTER_BOX - Origin size(if screen size is larger than video size(width/height)) or Letter box(if video size(width/height) is larger than screen size)\n                (5): DISP_GEO_METHOD_CUSTOM_ROI - Specially described destination ROI\n\nThese are provided by using tizen_viewport since Tizen 3.0.\n\nenum {\n    DISP_GEO_METHOD_LETTER_BOX = 0,\n    DISP_GEO_METHOD_ORIGIN_SIZE,\n    DISP_GEO_METHOD_FULL_SCREEN,\n    DISP_GEO_METHOD_CROPPED_FULL_SCREEN,\n    DISP_GEO_METHOD_ORIGIN_SIZE_OR_LETTER_BOX,\n    DISP_GEO_METHOD_CUSTOM_ROI,\n    DISP_GEO_METHOD_NUM,\n};\n\nif (tizen_disp_mode &gt; -1) {\n    tizen_destination_mode_set(window-&gt;tizen_video_dest_mode, tizen_disp_mode);\n}\n\n\nROI coordinates can be set only when the value of display-geometry-method is set to 5, and ROI coordinates are obtained from gst_video_overlay_set_render_rectangle() from the player or camera.\nif (window-&gt;disp_geo_method.value == DISP_GEO_METHOD_CUSTOM_ROI) {\n    tizen_viewport_set_destination(window-&gt;tizen_video_viewport, window-&gt;roi.x, window-&gt;roi.y, window-&gt;roi.w, window-&gt;roi.h);\n}\n\n\nThe following examples describe the various available modes:\n\n\n  \n    Letterbox mode\n\n    Fit the video source to the width or height of the window, aligned to the center and keeping the aspect ratio of the original video source.\n\n    \n      \n        Window (width/height) &gt; Video source (width/height)\n\n        \n      \n      \n        Window (width/height) &lt; Video source (width/height)\n\n        \n      \n    \n  \n  \n    Original size mode\n\n    Set the video source size the same as the original video size, aligned to the center and keeping the aspect ratio of the original video source.\n\n    \n      \n        Window size &gt; Video source size\n\n        \n      \n      \n        Window size &lt; Video source size\n\n        \n      \n    \n  \n  \n    Cropped full screen mode\n\n    Fit the video source to the width and height, cropping out the area outside the window, aligned to the center and keeping the aspect ratio of the original video source.\n\n    \n      \n        Window (width/height) &gt; Video source (width/height)\n\n        \n      \n      \n        Window (width/height) &lt; Video source (width/height)\n\n        \n      \n    \n  \n  \n    ROI mode\n\n    The user sets the location and size of where the video is rendered.\n\n    \n      \n        Window size: width(1920), height(1080), ROI size: x(100), y(100), width(800), height(400)"
					}
					
				
			
		
			
				
					,
					
					"application-porting-overview": {
						"id": "application-porting-overview",
						"title": "Overview",
						"categories": "",
						"url": " application/porting/overview/",
						"content": "Overview\n\nTizen is an open-source software stack created for a wide array of devices with different form factors. The primary purposes of Tizen are to create an open software platform available for carriers, OEMs, and developers to make their innovative ideas a reality and to introduce a successful, real-world product that improves the mobile experience for users.\n\nIt is also important that is no central point of failure, where 1 industry player can restrict or control the innovations of any other. The result is a full, production-quality consumer product with source code open for customization and porting.\n\nThe intent of the porting guides is to provide information and instructions to boot Tizen on new hardware and create products based on the Tizen OS. The Tizen porting guides take you through the porting process by elaborating the Tizen architecture, the necessary tools, and the development environment setup, as well as creating a Tizen image and demonstrating the modifications needed across various functional areas.\n\nTizen Architecture\n\nThe following figure illustrates the Tizen architecture for smart phone and tablet devices.\n\nFigure: Tizen architecture\n\n\n\nFor more information on the Tizen framework layer, see the Tizen Application Types.\n\nCore Layer\n\nThe core layer consists of various subsystems:\n\n\n  \n    Application framework\n\n    The Application framework provides application management, including launching other applications using the package name, URI, or MIME type. It also launches predefined services, such as the system dialer application. The Application framework also notifies applications of common events, such as low memory events, low battery, changes in screen orientation, and push notifications.\n  \n  \n    Base\n\n    Base contains GNU/Linux-based essential system libraries that provide key features, such as database support, internationalization, and XML parsing.\n  \n  \n    Connectivity\n\n    Connectivity consists of all network and connectivity related functionalities, such as 3G, Wi-Fi, Bluetooth, HTTP, and NFC (Near Field Communication). Data network is based on ConnMan (Connection manager), which provides 3G and Wi-Fi based network connection management.\n  \n  \n    Graphics and UI\n\n    Graphics and UI consist of the system graphic and UI stacks, which include EFL (Enlightenment Foundation Libraries), window management system (x11 for Tizen 2.x / Wayland for Tizen 3.0), input methods, and OpenGL® ES APIs.\n\n    EFL, the heart of the graphics component, is a suite of libraries. EFL is used to create rich graphics with ease, for all UI resolutions. The libraries build UIs in layers, allowing for 3D transformations and more. EFL includes the Evas canvas API library and the elementary widget library.\n\n    WebKit-based graphics are provided as well, capable of running within a full browser UI or a dedicated Web runtime environment (without a browser window), all based on Tizen’s own HTML5 canvas WebKitEFL implementation. Additionally, WebGL™ is supported and Web-based frameworks for UI, such as jQuery Mobile, are also offered, which help with porting existing jQuery code.\n  \n  \n    Location\n\n    Location provides location-based services (LBS), including position information, geocoding, satellite information, and GPS status. It delivers location information from various positioning sources, such as GPS, WPS (Wi-Fi Positioning System), Cell ID, and sensors.\n  \n  \n    Messaging\n\n    Messaging consists of Message and Email. The Message supports SMS, MMS, and cell broadcast messages. Email supports protocols, such as SMTP, IMAP, and POP3.\n  \n  \n    Multimedia\n\n    Multimedia is based on GStreamer. It provides support for media, including video, audio, imaging, and VoIP. It also provides media content management for managing media file metadata information.\n  \n  \n    PIM (Personal Information Management)\n\n    PIM enables managing user data on the device, including managing calendar, contacts, tasks, and retrieving data about the device context (such as device position and cable status).\n  \n  \n    Security\n\n    Security is responsible for security deployment across the system. It consists of the platform security enablers, such as access control, certificate management, and secure application distribution.\n\n    For more information, see Security/Tizen 3.0 security porting guide and All 3.X security pages.\n  \n  \n    System\n\n    System consists of service (process), device, and resource management features, including:\n    \n      Interfaces for accessing devices, such as sensors, display, or vibrator\n      Power management, such as LCD display backlight dimming/off and application processor sleep\n      Monitoring devices and handling events, such as USB, MMC, charger, and earjack events\n      Resource management, such as CPU quota control and low memory management\n      Service management, such as watchdog management and capability control\n    \n  \n  \n    Telephony\n\n    Telephony consists of cellular functionalities communicating with the modem:\n    \n      Provides call services (single call and multiparty call).\n      Provides call-related and non-call-related supplementary services (call waiting, barring, and forwarding and USSD).\n      Supports GSM, UMTS, LTE, and CDMA network services.\n      Provides packet services and network status information.\n      Provides SMS-related services.\n      Provides SIM card functionalities (SIM phonebook, SIM EF files, SIM Application Toolkit support)\n    \n  \n  \n    Web\n\n    Web provides a complete implementation of the Tizen Web API optimized for low-power devices. It includes WebKit, which is a layout engine designed to allow Web browsers to render Web pages. It also provides Web runtime for Web applications."
					}
					
				
			
		
			
				
					,
					
					"platform-porting-overview": {
						"id": "platform-porting-overview",
						"title": "Overview",
						"categories": "",
						"url": " platform/porting/overview/",
						"content": "Overview\n\nTizen is an open-source software stack created for a wide array of devices with different form factors. The primary purposes of Tizen are to create an open software platform available for carriers, OEMs, and developers to make their innovative ideas a reality and to introduce a successful, real-world product that improves the mobile experience for users.\n\nIt is also important that is no central point of failure, where 1 industry player can restrict or control the innovations of any other. The result is a full, production-quality consumer product with source code open for customization and porting.\n\nThe intent of the porting guides is to provide information and instructions to boot Tizen on new hardware and create products based on the Tizen OS. The Tizen porting guides take you through the porting process by elaborating the Tizen architecture, the necessary tools, and the development environment setup, as well as creating a Tizen image and demonstrating the modifications needed across various functional areas.\n\nTizen Architecture\n\nThe following figure illustrates the Tizen architecture for smart phone and tablet devices.\n\nFigure: Tizen architecture\n\n\n\nFor more information on the Tizen framework layer, see the Tizen Application Types.\n\nCore Layer\n\nThe core layer consists of various subsystems:\n\n\n  \n    Application framework\n\n    The Application framework provides application management, including launching other applications using the package name, URI, or MIME type. It also launches predefined services, such as the system dialer application. The Application framework also notifies applications of common events, such as low memory events, low battery, changes in screen orientation, and push notifications.\n  \n  \n    Base\n\n    Base contains GNU/Linux-based essential system libraries that provide key features, such as database support, internationalization, and XML parsing.\n  \n  \n    Connectivity\n\n    Connectivity consists of all network and connectivity related functionalities, such as 3G, Wi-Fi, Bluetooth, HTTP, and NFC (Near Field Communication). Data network is based on ConnMan (Connection manager), which provides 3G and Wi-Fi based network connection management.\n  \n  \n    Graphics and UI\n\n    Graphics and UI consist of the system graphic and UI stacks, which include EFL (Enlightenment Foundation Libraries), window management system (x11 for Tizen 2.x / Wayland for Tizen 3.0), input methods, and OpenGL® ES APIs.\n\n    EFL, the heart of the graphics component, is a suite of libraries. EFL is used to create rich graphics with ease, for all UI resolutions. The libraries build UIs in layers, allowing for 3D transformations and more. EFL includes the Evas canvas API library and the elementary widget library.\n\n    WebKit-based graphics are provided as well, capable of running within a full browser UI or a dedicated Web runtime environment (without a browser window), all based on Tizen’s own HTML5 canvas WebKitEFL implementation. Additionally, WebGL™ is supported and Web-based frameworks for UI, such as jQuery Mobile, are also offered, which help with porting existing jQuery code.\n  \n  \n    Location\n\n    Location provides location-based services (LBS), including position information, geocoding, satellite information, and GPS status. It delivers location information from various positioning sources, such as GPS, WPS (Wi-Fi Positioning System), Cell ID, and sensors.\n  \n  \n    Messaging\n\n    Messaging consists of Message and Email. The Message supports SMS, MMS, and cell broadcast messages. Email supports protocols, such as SMTP, IMAP, and POP3.\n  \n  \n    Multimedia\n\n    Multimedia is based on GStreamer. It provides support for media, including video, audio, imaging, and VoIP. It also provides media content management for managing media file metadata information.\n  \n  \n    PIM (Personal Information Management)\n\n    PIM enables managing user data on the device, including managing calendar, contacts, tasks, and retrieving data about the device context (such as device position and cable status).\n  \n  \n    Security\n\n    Security is responsible for security deployment across the system. It consists of the platform security enablers, such as access control, certificate management, and secure application distribution.\n\n    For more information, see Security/Tizen 3.0 security porting guide and All 3.X security pages.\n  \n  \n    System\n\n    System consists of service (process), device, and resource management features, including:\n    \n      Interfaces for accessing devices, such as sensors, display, or vibrator\n      Power management, such as LCD display backlight dimming/off and application processor sleep\n      Monitoring devices and handling events, such as USB, MMC, charger, and earjack events\n      Resource management, such as CPU quota control and low memory management\n      Service management, such as watchdog management and capability control\n    \n  \n  \n    Telephony\n\n    Telephony consists of cellular functionalities communicating with the modem:\n    \n      Provides call services (single call and multiparty call).\n      Provides call-related and non-call-related supplementary services (call waiting, barring, and forwarding and USSD).\n      Supports GSM, UMTS, LTE, and CDMA network services.\n      Provides packet services and network status information.\n      Provides SMS-related services.\n      Provides SIM card functionalities (SIM phonebook, SIM EF files, SIM Application Toolkit support)\n    \n  \n  \n    Web\n\n    Web provides a complete implementation of the Tizen Web API optimized for low-power devices. It includes WebKit, which is a layout engine designed to allow Web browsers to render Web pages. It also provides Web runtime for Web applications."
					}
					
				
			
		
			
				
					,
					
					"iot-porting-overview": {
						"id": "iot-porting-overview",
						"title": "Overview",
						"categories": "",
						"url": " iot/porting/overview/",
						"content": "Overview\n\nTizen is an open-source software stack created for a wide array of devices with different form factors. The primary purposes of Tizen are to create an open software platform available for carriers, OEMs, and developers to make their innovative ideas a reality and to introduce a successful, real-world product that improves the mobile experience for users.\n\nIt is also important that is no central point of failure, where 1 industry player can restrict or control the innovations of any other. The result is a full, production-quality consumer product with source code open for customization and porting.\n\nThe intent of the porting guides is to provide information and instructions to boot Tizen on new hardware and create products based on the Tizen OS. The Tizen porting guides take you through the porting process by elaborating the Tizen architecture, the necessary tools, and the development environment setup, as well as creating a Tizen image and demonstrating the modifications needed across various functional areas.\n\nTizen Architecture\n\nThe following figure illustrates the Tizen architecture for smart phone and tablet devices.\n\nFigure: Tizen architecture\n\n\n\nFor more information on the Tizen framework layer, see the Tizen Application Types.\n\nCore Layer\n\nThe core layer consists of various subsystems:\n\n\n  \n    Application framework\n\n    The Application framework provides application management, including launching other applications using the package name, URI, or MIME type. It also launches predefined services, such as the system dialer application. The Application framework also notifies applications of common events, such as low memory events, low battery, changes in screen orientation, and push notifications.\n  \n  \n    Base\n\n    Base contains GNU/Linux-based essential system libraries that provide key features, such as database support, internationalization, and XML parsing.\n  \n  \n    Connectivity\n\n    Connectivity consists of all network and connectivity related functionalities, such as 3G, Wi-Fi, Bluetooth, HTTP, and NFC (Near Field Communication). Data network is based on ConnMan (Connection manager), which provides 3G and Wi-Fi based network connection management.\n  \n  \n    Graphics and UI\n\n    Graphics and UI consist of the system graphic and UI stacks, which include EFL (Enlightenment Foundation Libraries), window management system (x11 for Tizen 2.x / Wayland for Tizen 3.0), input methods, and OpenGL® ES APIs.\n\n    EFL, the heart of the graphics component, is a suite of libraries. EFL is used to create rich graphics with ease, for all UI resolutions. The libraries build UIs in layers, allowing for 3D transformations and more. EFL includes the Evas canvas API library and the elementary widget library.\n\n    WebKit-based graphics are provided as well, capable of running within a full browser UI or a dedicated Web runtime environment (without a browser window), all based on Tizen’s own HTML5 canvas WebKitEFL implementation. Additionally, WebGL™ is supported and Web-based frameworks for UI, such as jQuery Mobile, are also offered, which help with porting existing jQuery code.\n  \n  \n    Location\n\n    Location provides location-based services (LBS), including position information, geocoding, satellite information, and GPS status. It delivers location information from various positioning sources, such as GPS, WPS (Wi-Fi Positioning System), Cell ID, and sensors.\n  \n  \n    Messaging\n\n    Messaging consists of Message and Email. The Message supports SMS, MMS, and cell broadcast messages. Email supports protocols, such as SMTP, IMAP, and POP3.\n  \n  \n    Multimedia\n\n    Multimedia is based on GStreamer. It provides support for media, including video, audio, imaging, and VoIP. It also provides media content management for managing media file metadata information.\n  \n  \n    PIM (Personal Information Management)\n\n    PIM enables managing user data on the device, including managing calendar, contacts, tasks, and retrieving data about the device context (such as device position and cable status).\n  \n  \n    Security\n\n    Security is responsible for security deployment across the system. It consists of the platform security enablers, such as access control, certificate management, and secure application distribution.\n\n    For more information, see Security/Tizen 3.0 security porting guide and All 3.X security pages.\n  \n  \n    System\n\n    System consists of service (process), device, and resource management features, including:\n    \n      Interfaces for accessing devices, such as sensors, display, or vibrator\n      Power management, such as LCD display backlight dimming/off and application processor sleep\n      Monitoring devices and handling events, such as USB, MMC, charger, and earjack events\n      Resource management, such as CPU quota control and low memory management\n      Service management, such as watchdog management and capability control\n    \n  \n  \n    Telephony\n\n    Telephony consists of cellular functionalities communicating with the modem:\n    \n      Provides call services (single call and multiparty call).\n      Provides call-related and non-call-related supplementary services (call waiting, barring, and forwarding and USSD).\n      Supports GSM, UMTS, LTE, and CDMA network services.\n      Provides packet services and network status information.\n      Provides SMS-related services.\n      Provides SIM card functionalities (SIM phonebook, SIM EF files, SIM Application Toolkit support)\n    \n  \n  \n    Web\n\n    Web provides a complete implementation of the Tizen Web API optimized for low-power devices. It includes WebKit, which is a layout engine designed to allow Web browsers to render Web pages. It also provides Web runtime for Web applications."
					}
					
				
			
		
			
				
					,
					
					"tizenstudio-setup-overview": {
						"id": "tizenstudio-setup-overview",
						"title": "Overview",
						"categories": "",
						"url": " tizenstudio/setup/overview/",
						"content": "Overview\n\nTizen Studio 3.2 is now launched!\n\n  Download\n\n\n\n\n\nTizen Studio is an official integrated development environment (IDE) for developing Tizen apps. This environment is built over Eclipse, it presents a unified environment where you can write, edit, debug, build, and publish your app. \nTizen Studio runs on Windows®, Ubuntu, and MacOSX. For more information on the latest release, see the Download page.\nTizen Studio primarily consists of:\n\n    set of fast and feature-rich emulators for devices based on Tizen, for example: Smartphone, TV emulator, Smart watch and much more\n    extensive tool chains to capture performance, usability, version compatibility\n    code templates, samples to help you get started \n    components to support new platforms\n    system applications and drivers\n    utilities for compiling applications to Tizen RT (Tizen RTOS kernel variant)\n\nVisit the following pages to explore more about Tizen Studio: \n\n\n\n  \n    \n    Download\n    \n  \n\n  \n    \n        Native Tools\n    \n  \n \n   \n    \n    Web Tools\n    \n  \n\n  \n    \n        Configurable - IoT SDK\n    \n  \n\n  \n    \n        Extension SDK\n    \n  \n\n  \n    \n        Tizen RT IDE"
					}
					
				
			
		
			
				
					,
					
					"tizenstudio-rt-ide-overview": {
						"id": "tizenstudio-rt-ide-overview",
						"title": "TizenRT",
						"categories": "",
						"url": " tizenstudio/rt-ide/overview/",
						"content": "TizenRT\n\nTizen platform is commercialized on smart TVs, smartphones, wearable devices (Gear S, Gear Fit), and smart home appliances. However, low-end and low-cost IoT devices, such as home appliances without display and wearable bands with a small LCD, have received less attention. The objective of TizenRT is to extend the Tizen platform device coverage to these kind of low-end devices.\n\nTizenRT is an RTOS-based lightweight platform. The following are the hardware and environmental requirements:\n\n\n  \n    Hardware targets:\n\n    Cortex-M/R processors with MPU, less than 2 MB RAM, and less than 16 MB Flash.\n  \n  \n    Development environment:\n    \n      TizenRT Studio for SmartThings:\n  TizenRT Studio version 2.0 (or later) is used as an IDE for developing IoT applications with st_things framework and ARTIK 053(s).\n    \n  \n\n\nFor more information on TizenRT, please refer to TizenRT GitHub"
					}
					
				
			
		
			
				
					,
					
					"tizenstudio-extension-sdk-overview": {
						"id": "tizenstudio-extension-sdk-overview",
						"title": "Extension SDK",
						"categories": "",
						"url": " tizenstudio/extension-sdk/overview/",
						"content": "Extension SDK\n\nThis page explains about using Extension SDK to extend the feature set of Tizen Studio. The Extension SDK maximizes on the capabilities, and functionalities of the Tizen Studio. Extension SDK helps you enrich the Tizen Studio capabilities by integrating one or more new functionalities or modifying the behaviour of existing functionalities.\nWith Extension SDK, you can also create your own extensions that work with additional built-in platform functions, communicate with existing 3rd-Party SDKs and APIs. These Extension SDK magnify the power of the Tizen applications and games.\n\nThe following are some of the ways in which you can extend your Tizen Studio:\n\nIn-App Purchase\n\nIn-app purchase allows you to sell the digital content to customers inside your application. With In-app purchase service, \nyou can make your customers to make an in-app purchase in order to access special content or features in an app such as power-ups, restricted levels, virtual money, special characters, boosts, etc. In-app purchase is offered as a consumable, non-consumable, or subscription.\n\nYou can implement in-app purchase in your application by using the Tizen application control mechanism. In-app purchase service provides the functionality to process payments for items offered in your application through the Tizen Store. In-app purchase uses the same payment service as is used for application purchases, so your customers experience a consistent and secured purchase flow. In-app purchase can be implemented in both Tizen native and Web applications.\n\nTo use in-app purchase, you can use your Tizen Store Seller Office account to register items to the Tizen Store Seller Office.\n\nTo get started, read the following guide:\n\n\n  In-app Purchase Programming Guide\n\n\nInMobi Tizen Ad SDK\n\nThe InMobi Tizen Ad SDK allows you to monetize your Tizen application with a wide range of advertisement formats. You can deliver all kinds of adS (banner ads to full-screen native interstitial ads) for a better user experience.\n\nYou can use InMobi Tizen Ads in Tizen Web applications, native applications, and Unity games.\n\n\n  Tizen Web application: Tizen Web applications use the Tizen Web Framework to interact with the Web subsystems. The application is built using Web languages, such as HTML5, CSS, and JavaScript.\n  Tizen native application: Tizen native application uses EFL (Enlightenment Foundation Libraries) for the application UI. The application is developed using C and it can access advanced device-specific features.\n  Unity game on Tizen: To use Tizen Ads in your Unity game, you need the Unity SDK version 5.2.2 or above for privilege addition support. The games are developed using C#.\n\n\nTo get started with the InMobi Tizen Ad SDK, see the following guide:\n\n\n  InMobi Tizen Ad SDK Programming Guide\n\n\nVMAX Tizen Ad SDK\n\nVMAX™ is the one-stop solution that gives you complete control over your app monetization. It is a publisher-centric mediation SSP platform which sources ads from various sources and optimizes to maximize yield rate and fill rate.\n\nVMAX provides support for Ads in Tizen Native, Unity and Web applications.\n\n\n  Native SDK: It is for the Application developers who want to build Tizen Native App, utilizing EFL (Enlightenment Foundation Libraries) for the UI. Among the other SDK’s available, Native SDK allows building Native feature-rich app and also allows to use Ad SDK for to display in app ads.\n  Unity SDK: Game developers can utilize this Ad SDK to monetize various in-game ad placements and they can make .\n  Webapp SDK: Web application developers can use this SDK for applications developed using web technologies such as (HTML, CSS &amp; Javascript), you can monetize your web app with VMAX Tizen SDK.\n\n\nTo get started with the VMAX Ad SDK, read the following guide:\n\n\n  VMAX Tizen SDK Integration Guide"
					}
					
				
			
		
			
				
					,
					
					"tizenstudio-setup-quick-start-guide": {
						"id": "tizenstudio-setup-quick-start-guide",
						"title": "Hardware Accelerated Execution Manager",
						"categories": "",
						"url": " tizenstudio/setup/quick_start_guide/",
						"content": "How to Develop Tizen Web Applications?\n\nIntroduction\nWeb applications involve the standards for building and rendering web pages such as HTML, CSS, and JavaScript. The following figure illustrates the basic structure of a Tizen Web application:\n\n\n\nHow to create Tizen Web project?\n\n\n\n\n\n\n\nHow to implement Tizen Web applications?\n\nFollowing are the four implementation stages for a digital watch application:\n\n\n\nHow to add user interface layout to a digital watch?\n\nFollowing are the steps to add user interface layout to a digital watch:\n\n\n\n\n\n\n\nHow to add watch functionality to a digital watch?\n\nFollowing are the steps to implement the functionality of the digital watch using JavaScript and standard APIs:\n\n\n\n\n\n\n\n\n\n\n\n\n\nHow to add battery UI layout to a digital watch?\n\nFollowing are the steps to implement the user interface layout for the battery, and add a background image to the digital watch using HTML and CSS:\n\n\n\n\n\n\n\n\n\nHow to add battery functionality to a digital watch?\n\nFollowing are the steps to implement the functionality of the battery indicator using JavaScript and the Tizen Device API:"
					}
					
				
			
		
			
				
					,
					
					"tizenstudio-setup-quick-start-guide-tizen-app-ts": {
						"id": "tizenstudio-setup-quick-start-guide-tizen-app-ts",
						"title": "Hardware Accelerated Execution Manager",
						"categories": "",
						"url": " tizenstudio/setup/quick_start_guide_tizen_app_ts/",
						"content": "Develop Wearable Web Applications using Template\n\nIntroduction\nWearable Web applications are apps that help you monitor health, show time, play games, and much more. These applications are developed using various Web-native languages, such as HTML5, Cascading Style Sheets (CSS), and JavaScript.\n\nThis page explains how to develop a Wearable Web application in Tizen Studio using Template.\n\nSystem Requirements\n\n\n\nDownload Tizen Studio\nYou can download and install Tizen Studio using the IDE installer or the CLI installer. For more information, see https://developer.tizen.org/tizen-studio/download\n\nTizen Studio UI\n\n\n\nCreate Project\n\n\n\n\n\n\n\nGenerate Author Certificate\n\n\n\n\n\n\n\nRunning Application on Emulator\n\n\n\n\n\n\n\nRunning Applications on Target Device"
					}
					
				
			
		
			
				
					,
					
					"application-porting-recovery": {
						"id": "application-porting-recovery",
						"title": "System Recovery",
						"categories": "",
						"url": " application/porting/recovery/",
						"content": "System Recovery\n\nTizen 4.0 comes with 3 different root filesystems, each designed for a different purpose.\n\nTable: Root filesystems\n\n\n  \n    \n      Label\n      Purpose\n    \n  \n  \n    \n      rootfs\n      Main root filesystem\n    \n    \n      ramdisk\n      Regular boot ramdisk\n    \n    \n      ramdisk-recovery\n      System recovery ramdisk\n    \n  \n\n\nThis topic describes operation and customization options of the system\nrecovery ramdisk.\n\nThe following steps describe the boot process:\n\n\n  \n    The boot process starts with a bootloader (u-boot or s-boot) loading\nappropriate kernel and ramdisk images dedicated for the system\nrecovery process (methods for controlling bootloader actions are beyond the\nscope of this document). With both images loaded into RAM, the kernel\ninitialization begins. When the initialization is complete, the kernel passes\ncontrol to the init process, such as /sbin/init (PID#1).\n  \n  \n    In the case of the recovery ramdisk, /sbin/init is a symlink to\n/usr/libexec/initrd-recovery/init (a shell script that comes\nfrom the initrd-recovery package). The script mounts several kernel\nfilesystems and the inform partition (if it exists), and parses the\nkernel command line options (/proc/cmdline) to find the bootmode\nparameter. If the parameter is present, one of the /sbin/*-init scripts is\nstarted. If the boot mode is set to recovery,\n/usr/libexec/system-recovery/recovery-init is started.\n  \n  \n    The recovery-init script mounts the real root filesystem under\nthe /system directory, and other filesystems (such as /opt and\n/opt/usr) below the /system directory. The script starts a shell on the serial console and launches the\nsystem-recovery program.\n  \n  \n    The system-recovery program can work as either an interactive GUI or\na non-interactive dispatcher, executing 1 (non-interactive) or\nmore (interactive) actions. The actions are configured in the\n/usr/share/system-recovery/system-recovery.cfg file.\n  \n\n\nConfiguration File\n\nThe configuration file allows you to customize 2 aspects of\nthe system-recovery operation: GUI and actions. The following sections take a closer look\nat the actions.\n\nThe configuration file is parsed using libconfig. For a detailed description of the\ngrammar, see the libconfig documentation.\n\naction_handlers\n\naction_handlers is a dictionary, in which shell commands (action\nhandlers) are assigned names (actions). The names are used later in\nthe configuration to refer to commands. The dictionary can be edited\nand actions can be added or removed. The names must be unique.\n\naction_handlers = {\n    reboot = \"reboot -f\";\n    factory-reset = \"touch -f /opt/.factoryreset\";\n    safeboot = \"touch -f /opt/etc/.safeboot\";\n}\n\n\nmenus\n\nActions (names) are used in the menus dictionary, which\ncomprises all pages of the menu system presented by\nsystem-recovery. The main entry is the one the program displays\nat startup. The rest must be linked in a tree-like structure.\n\nEach menu entry consists of the following fields:\n\n\n  pos_x and pox_y: Position on a screen\n  style: Reference to the menu_styles dictionary\n  actions: Array of actions available in this menu\n  item_default: Action to highlight when opening the menu\n\n\nThe system-recovery program can handle an action in 2 ways: it can run an action handler\nor switch to another screen. There is a reserved screen name BACK, which\nmeans switching to the previous screen (for more information, see screen_back in the screens\ndictionary).\n\nmenus = {\n    main = {\n        pos_x = 0;\n        pos_y = 100;\n        style = \"common\";\n        actions = ({\n            label = \"Reboot system now\";\n            screen_switch_to = \"reboot\";\n        },{\n            label = \"Safe mode\";\n            screen_switch_to = \"safe\";\n        },{\n            label = \"Phone reinitialisation\";\n            screen_switch_to = \"factory\";\n        });\n    };\n    reboot = {\n        pos_x = 0;\n        pos_y = 480;\n        style = \"common\";\n        item_default = 1;\n        actions = ({\n            label = \"Yes\";\n            action_handler = \"reboot\";\n            exit_after_action = 0;\n        },{\n            label = \"No\";\n            screen_switch_to = \"BACK\";\n        });\n    };\n    safe = {\n        pos_x = 0;\n        pos_y = 480;\n        style = \"common\";\n        item_default = 1;\n        actions = ({\n            label = \"Yes\";\n            action_handler = \"safeboot\";\n            exit_after_action = 1;\n        },{\n            label = \"No\";\n            screen_switch_to = \"BACK\";\n        });\n    };\n    factory = {\n        pos_x = 0;\n        pos_y = 480;\n        style = \"common\";\n        item_default = 1;\n        actions = ({\n            label = \"Yes\";\n            screen_switch_to = \"factory-run\";\n            action_handler = \"factory-reset\";\n            exit_after_action = 1;\n        },{\n            label = \"No\";\n            screen_switch_to = \"BACK\";\n        });\n    };\n};\n\n\n\n  Note\n\n  The system-recovery.cfg.m4.in source file provides the confirm_action m4 macro to define a Yes/No style action array:\n  \n    Yes executes an action.\n    No switches to a previous screen.\n  \n\n  Use this macro when adding an action to the config file in the repository.\n\n  For example:\n  actions = confirm_action('safeboot', 1);\n  \n  Expands to:\n  actions = ({\n    label = \"Yes\";\n    action_handler = \"safeboot\";\n    exit_after_action = 1;\n},{\n    label = \"No\";\n    screen_switch_to = \"BACK\";\n});\n  \n\n  The first argument of the macro is an action, and the second is the value to assign to the exit_after_action element.\n\n\nscreens\n\nEach action can either execute an action handler (a shell command) or switch to a screen. The screens are configured in\ntheir dictionary as follows:\n\nscreens = {\n    main = {\n        style = \"common\";\n        menu = \"main\";\n        description = \"main\";\n        rulers = \"main\";\n        images = (\"background_default\", \"menu_title\");\n        screen_back = \"CURRENT\";\n    };\n    reboot = {\n        style = \"common\";\n        menu = \"reboot\";\n        description = \"reboot\"\n        rulers = \"confirm\";\n        images = (\"background_default\", \"menu_title\");\n        screen_back = \"main\";\n    };\n    safe = {\n        style = \"common\";\n        menu = \"safe\";\n        description = \"safe\";\n        rulers = \"confirm\";\n        images = (\"background_default\", \"menu_title\");\n        screen_back = \"main\";\n    };\n    factory = {\n        style = \"common\";\n        menu = \"factory\";\n        description = \"factory\";\n        rulers = \"confirm\";\n        images = (\"background_default\", \"menu_title\");\n        screen_back = \"main\";\n    };\n    factory-run = {\n        style = \"common\";\n        description = \"factory-run\";\n        rulers = \"confirm\";\n        images = (\"background_default\", \"menu_title\");\n        animations = (\"working\");\n        screen_back = \"main\";\n        allow_force_reboot = 1;\n    };\n};\n\n\nThe above entries contain 2 parameter groups:\n\n\n  The first group is responsible for the look of a screen:\n    \n      style: Element of the screen_styles dictionary\n      rulers: Element of the rulers dictionary\n      images: List of elements of the images dictionary\n      animations: Element of the animations dictionary\n    \n\n    These parameters are not described in detail in this document.\n  \n  The second group comprises parameters that describe logic:\n    \n      menu: Menu to display (an element of the menus dictionary)\n      description: Description text and screen title to display (an element of the descriptions dictionary)\n      screen_back: Screen to switch to when switching BACK\n      allow_force_reboot: Reboot after executing an action\n    \n  \n\n\ndescriptions\n\nThe elements of the descriptions dictionary hold screen titles and\nbrief descriptions for screen entries:\n\n\n  title: Short (one line) title displayed at the top of a screen\n  description: Brief explanation of actions available on the screen\n\n\ndescriptions = {\n    main = {\n        pos_x = 15;\n        pos_y = 480;\n        style = \"common\";\n        title = \"Controls:\";\n        text = \"Volume Up/Down to move menu cursor\\n\"\n            \"Power button to select\";\n    };\n\n    reboot = {\n        pos_x = 15;\n        pos_y = 100;\n        title = \"The phone will be restarted.\";\n        text = \"Continue?\";\n        style = \"common\";\n    };\n\n    safe = {\n        pos_x = 15;\n        pos_y = 100;\n        title = \"Safe mode:\",\n        text = \"The phone will be started in safe mode.\\n\"\n            \"Home screen will be changed to default\\n\"\n            \"setting and just allow a user to use\\n\"\n            \"only preloaded applications.\\n\"\n            \"Continue?\";\n        style = \"common\";\n    };\n\n    factory = {\n        pos_x = 15;\n        pos_y = 100;\n        title = \"Factory reset (except SD-card)\";\n        text = \"This will erase all data from your\\n\"\n            \"phone's internal storage, including\\n\"\n            \"settings of downloaded and preloaded\\n\"\n            \"applications and system configuration.\\n\"\n            \"Continue?\";\n        style = \"common\";\n    };\n\n    factory-run = {\n        pos_x = 15;\n        pos_y = 100;\n        style = \"common\";\n        title = \"Restoring settings to factory default.\";\n        text = \"Please wait. Do not turn off.\\n\"\n            \"(Hold power button for 3 seconds\\n\"\n            \"to reboot the device. Not recommended.)\";\n    }\n};\n\n\nNon-interactive Operation\n\nIf the system-recovery program is compiled without GUI support, only 2 parameters\nin the configuration file control how the program behaves:\n\n\n  action_handlers: List of shell commands\n  headless_action: Action to execute by default\n\n\nBefore system-recovery reads the headless_action parameter, it looks\nfor the action to execute in 2 other places:\n\n\n  tizen.recovery kernel command line option (such as tizen.recovery=factory-reset)\n  /opt/.recovery.action\n\n\nheadless_action = \"factory-reset\";\n\n\nAdding New Actions\n\nTo add a new action:\n\n\n  Define an action handler in the action_handlers dictionary:\n    action_handlers = {\n    factory-reset-minimal = \"/usr/bin/factory-reset-minimal.sh\"\n};\n    \n  \n  Take the factory entry from the menus dictionary and adapt it:\n    menus = {\n    factory-minimal = {\n        pos_x = 0;\n        pos_y = 480;\n        style = \"common\";\n        item_default = 1;\n        actions = ({\n            label = \"Yes\";\n            screen_switch_to = \"factory-run-minimal\";\n            action_handler = \"factory-reset-minimal\";\n            exit_after_action = 1;\n        },{\n            label = \"No\";\n            screen_switch_to = \"BACK\";\n        });\n    };\n};\n    \n  \n  Add 2 new entries in the screens dictionary:\n    screens = {\n    factory-minimal = {\n        style = \"common\";\n        menu = \"factory-minimal\";\n        description = \"factory-minimal\";\n        rulers = \"confirm\";\n        images = (\"background_default\", \"menu_title\");\n        screen_back = \"main\";\n    };\n    factory-run-minimal = {\n        style = \"common\";\n        description = \"factory-run-minimal\";\n        rulers = \"confirm\";\n        images = (\"background_default\", \"menu_title\");\n        animations = (\"working\");\n        screen_back = \"main\";\n        allow_force_reboot = 1;\n    };\n};\n    \n  \n  Add 2 new entries in the descriptions dictionary:\n    descriptions = {\n    factory-minimal = {\n        pos_x = 15;\n        pos_y = 100;\n        title = \"Factory reset (except SD-card)\";\n        text = \"This will erase SOME data from your\\n\"\n            \"phone's internal storage, including\\n\"\n            \"settings of downloaded and preloaded\\n\"\n            \"applications and system configuration.\\n\"\n            \"Continue?\";\n        style = \"common\";\n    };\n    factory-run-minimal = {\n        pos_x = 15;\n        pos_y = 100;\n        style = \"common\";\n        title = \"Restoring SOME settings to factory default.\";\n        text = \"Please wait. Do not turn off.\\n\"\n            \"(Hold power button for 3 seconds\\n\"\n            \"to reboot the device. Not recommended.)\";\n    };\n};\n    \n  \n  Add an action to the main menu that switches to the factory-minimal screen:\n    main = {\n    pos_x = 0;\n    pos_y = 100;\n    style = \"common\";\n    actions = ({\n        label = \"Reboot system now\";\n        screen_switch_to = \"reboot\";\n    },{\n        label = \"Safe mode\";\n        screen_switch_to = \"safe\";\n    },{\n        label = \"Phone reinitialisation\";\n        screen_switch_to = \"factory\";\n    },{\n        label = \"Minimal phone reinitialisation\";\n        screen_switch_to = \"factory-minimal\";\n    });\n};\n    \n  \n\n\nLook-and-feel Options\n\nThe following example shows the remaining parts of the configuration file, containing options that control the look-and-feel of the system recovery menus:\n\ncolors = {\n    background = \"#000000ff\";\n    title = \"#1bc7ccff\";\n    ruler = \"#1bc7ccff\";\n    white = \"#ffffffff\";\n};\n\nruler_styles = {\n    common = {\n        c_ruler = \"ruler\";\n    };\n};\n\nmenu_styles = {\n    common = {\n        item_height = 80;\n        item_spacing = 8;\n        text_pos_x = 15;\n        c_bg_selected = \"title\";\n        c_bg_unselected = \"background\";\n        c_text_selected = \"white\";\n        c_text_unselected = \"white\";\n    };\n};\n\nscreen_styles = {\n    common = {\n        c_background = \"background\";\n    };\n};\n\ndescription_styles = {\n    common = {\n        c_title = \"title\";\n        c_text = \"white\";\n    };\n};\n\nrulers = {\n    main = (\n    {\n        pos_x = 0;\n        pos_y = 80;\n        height = 2;\n        style = \"common\";\n    }, {\n        pos_x = 0;\n        pos_y = 420;\n        height = 2;\n        style = \"common\";\n    });\n\n    confirm = (\n    {\n        pos_x = 0;\n        pos_y = 80;\n        height = 2;\n        style = \"common\";\n    });\n};\n\nimages = {\n    background_default = {\n        fname = \"/usr/share/system-recovery/res/images/warning.png\";\n        c_bg = \"background\"; // reference to colors\n        align_hor = \"center\";\n        align_ver = \"bottom\";\n        offset_x = 0;\n        offset_y = 0;\n        img_type = \"alpha\"; // alt: \"no-alpha\";\n    };\n    menu_title = {\n        fname = \"/usr/share/system-recovery/res/images/menu-title.png\";\n        c_bg = \"title\";\n        align_hor = \"center\";\n        align_ver = \"top\";\n        offset_x = 0;\n        offset_y = 20;\n        img_type = \"no-alpha\"; // alt: \"no-alpha\";\n    };\n};\n\nanimations = {\n    working = {\n        fname = \"/usr/share/system-recovery/res/images/tizen-anim.png\";\n        c_bg = \"background\";\n        align_hor = \"center\";\n        align_ver = \"middle\";\n        offset_x = 0;\n        offset_y = 0;\n        frames_num = 0;\n        current_frame = 0;\n        img_type = \"no-alpha\"; // alt: \"no-alpha\";\n    };\n};\n\n\nAdding New Files to the ramdisk-recovery Partition\n\nThe ramdisk-recovery partition is created along with the rootfs\npartition (methods for creating images are beyond the scope of this\ndocument):\n\n\n  Files to be added to the ramdisk-recovery partition must\nbe available in Tizen RPM packages.\n  Files are added to the partition by the mkinitrd-recovery.sh script, which is started\nautomatically as a part of the %posttrans RPM script of the initrd-recovery package.\n\n\nTo install a selected file in the recovery\nimage, its RPM needs to be installed before initrd-recovery is run. The\neasiest way to make sure this happens is to list the package as a\ndependency in the initrd-recovery.spec file.\n\nThe mkinitrd-recovery.sh script copies or moves files from the\nrootfs partition to the initrd-recovery partition according to\ndirections provided in configuration files stored in the\n/usr/share/initrd-recovery/initrd.list.d directory. These files\nmust be packaged in the RPM packages together with the\nfiles to be put on the initrd-recovery partition. The configuration files are\ninterpreted as shell scripts and can be used to set the following\nvariables:\n\n\n  DIRECTORIES: Create directories.\n  DIR_SYMLINKS: Create symbolic links to directories.\n  LIBONLYS: Copy only the libraries required by the listed executable files.\n  MVWITHLIBS: Move the listed executable files and copy the required libraries.\n  SYMLINKS: Create symbolic links.\n  VERBATIMS: Copy the listed files. List non-executable files here.\n  WITHLIBS: Copy the listed executable files and the required libraries.\n\n\nThe SYMLINKS and DIR_SYMLINKS variables contain pairs of filenames separated with\ncolons.\n\nThe following section contains examples of the above variables:\n\nDIRECTORIES=\"\n/var/tmp\n/usr/lib/odbc\n\"\n\n# LinkFileName:Target\nDIR_SYMLINKS=\"\n/lib:usr/lib\n/opt:system/opt\n\"\n\nLIBONLYS=\"\n/bin/bash\n/bin/kill\n\"\n\nMVWITHLIBS=\"\n/usr/libexec/initrd-recovery/minireboot\n/usr/libexec/system-recovery/system-recovery.gui\n\"\n\nWITHLIBS=\"\n/usr/bin/sync\n/usr/bin/touch\n\"\n\nVERBATIMS=\"\n/usr/share/system-recovery/res/images/font.png\n/usr/share/system-recovery/res/images/menu-title.png\n/usr/share/system-recovery/system-recovery.cfg\n\"\n\n# LinkFileName:Target\nSYMLINKS=\"\n/sbin/recovery-init:/usr/libexec/system-recovery/recovery-init\n/usr/lib/bufmgr/libtbm_default.so:libtbm_sprd.so\n\"\n\n\nThe following real-world example comes from the initrd-recovery\npackage. Following this configuration, mkinitrd-recovery.sh copies\nsome basic tools to the initrd-recovery partition, moves init and\nminireboot, and creates some symlinks:\n\nMVWITHLIBS=\"\n/usr/libexec/initrd-recovery/init\n/usr/libexec/initrd-recovery/minireboot\n\"\n\nWITHLIBS=\"\n/usr/bin/bash\n/usr/bin/cat\n/usr/bin/mkdir\n/usr/bin/mount\n/usr/bin/sleep\n/usr/bin/sync\n/usr/bin/umount\n/usr/sbin/blkid\n\"\n\n# LinkFileName:Target\nSYMLINKS=\"\n/bin/sh:bash\n/sbin/init:/usr/libexec/initrd-recovery/init\n/sbin/minireboot:/usr/libexec/initrd-recovery/minireboot\n/sbin/reboot:/usr/libexec/initrd-recovery/minireboot\n\""
					}
					
				
			
		
			
				
					,
					
					"platform-porting-recovery": {
						"id": "platform-porting-recovery",
						"title": "System Recovery",
						"categories": "",
						"url": " platform/porting/recovery/",
						"content": "System Recovery\n\nTizen 4.0 comes with 3 different root filesystems, each designed for a different purpose.\n\nTable: Root filesystems\n\n\n  \n    \n      Label\n      Purpose\n    \n  \n  \n    \n      rootfs\n      Main root filesystem\n    \n    \n      ramdisk\n      Regular boot ramdisk\n    \n    \n      ramdisk-recovery\n      System recovery ramdisk\n    \n  \n\n\nThis topic describes operation and customization options of the system\nrecovery ramdisk.\n\nThe following steps describe the boot process:\n\n\n  \n    The boot process starts with a bootloader (u-boot or s-boot) loading\nappropriate kernel and ramdisk images dedicated for the system\nrecovery process (methods for controlling bootloader actions are beyond the\nscope of this document). With both images loaded into RAM, the kernel\ninitialization begins. When the initialization is complete, the kernel passes\ncontrol to the init process, such as /sbin/init (PID#1).\n  \n  \n    In the case of the recovery ramdisk, /sbin/init is a symlink to\n/usr/libexec/initrd-recovery/init (a shell script that comes\nfrom the initrd-recovery package). The script mounts several kernel\nfilesystems and the inform partition (if it exists), and parses the\nkernel command line options (/proc/cmdline) to find the bootmode\nparameter. If the parameter is present, one of the /sbin/*-init scripts is\nstarted. If the boot mode is set to recovery,\n/usr/libexec/system-recovery/recovery-init is started.\n  \n  \n    The recovery-init script mounts the real root filesystem under\nthe /system directory, and other filesystems (such as /opt and\n/opt/usr) below the /system directory. The script starts a shell on the serial console and launches the\nsystem-recovery program.\n  \n  \n    The system-recovery program can work as either an interactive GUI or\na non-interactive dispatcher, executing 1 (non-interactive) or\nmore (interactive) actions. The actions are configured in the\n/usr/share/system-recovery/system-recovery.cfg file.\n  \n\n\nConfiguration File\n\nThe configuration file allows you to customize 2 aspects of\nthe system-recovery operation: GUI and actions. The following sections take a closer look\nat the actions.\n\nThe configuration file is parsed using libconfig. For a detailed description of the\ngrammar, see the libconfig documentation.\n\naction_handlers\n\naction_handlers is a dictionary, in which shell commands (action\nhandlers) are assigned names (actions). The names are used later in\nthe configuration to refer to commands. The dictionary can be edited\nand actions can be added or removed. The names must be unique.\n\naction_handlers = {\n    reboot = \"reboot -f\";\n    factory-reset = \"touch -f /opt/.factoryreset\";\n    safeboot = \"touch -f /opt/etc/.safeboot\";\n}\n\n\nmenus\n\nActions (names) are used in the menus dictionary, which\ncomprises all pages of the menu system presented by\nsystem-recovery. The main entry is the one the program displays\nat startup. The rest must be linked in a tree-like structure.\n\nEach menu entry consists of the following fields:\n\n\n  pos_x and pox_y: Position on a screen\n  style: Reference to the menu_styles dictionary\n  actions: Array of actions available in this menu\n  item_default: Action to highlight when opening the menu\n\n\nThe system-recovery program can handle an action in 2 ways: it can run an action handler\nor switch to another screen. There is a reserved screen name BACK, which\nmeans switching to the previous screen (for more information, see screen_back in the screens\ndictionary).\n\nmenus = {\n    main = {\n        pos_x = 0;\n        pos_y = 100;\n        style = \"common\";\n        actions = ({\n            label = \"Reboot system now\";\n            screen_switch_to = \"reboot\";\n        },{\n            label = \"Safe mode\";\n            screen_switch_to = \"safe\";\n        },{\n            label = \"Phone reinitialisation\";\n            screen_switch_to = \"factory\";\n        });\n    };\n    reboot = {\n        pos_x = 0;\n        pos_y = 480;\n        style = \"common\";\n        item_default = 1;\n        actions = ({\n            label = \"Yes\";\n            action_handler = \"reboot\";\n            exit_after_action = 0;\n        },{\n            label = \"No\";\n            screen_switch_to = \"BACK\";\n        });\n    };\n    safe = {\n        pos_x = 0;\n        pos_y = 480;\n        style = \"common\";\n        item_default = 1;\n        actions = ({\n            label = \"Yes\";\n            action_handler = \"safeboot\";\n            exit_after_action = 1;\n        },{\n            label = \"No\";\n            screen_switch_to = \"BACK\";\n        });\n    };\n    factory = {\n        pos_x = 0;\n        pos_y = 480;\n        style = \"common\";\n        item_default = 1;\n        actions = ({\n            label = \"Yes\";\n            screen_switch_to = \"factory-run\";\n            action_handler = \"factory-reset\";\n            exit_after_action = 1;\n        },{\n            label = \"No\";\n            screen_switch_to = \"BACK\";\n        });\n    };\n};\n\n\n\n  Note\n\n  The system-recovery.cfg.m4.in source file provides the confirm_action m4 macro to define a Yes/No style action array:\n  \n    Yes executes an action.\n    No switches to a previous screen.\n  \n\n  Use this macro when adding an action to the config file in the repository.\n\n  For example:\n  actions = confirm_action('safeboot', 1);\n  \n  Expands to:\n  actions = ({\n    label = \"Yes\";\n    action_handler = \"safeboot\";\n    exit_after_action = 1;\n},{\n    label = \"No\";\n    screen_switch_to = \"BACK\";\n});\n  \n\n  The first argument of the macro is an action, and the second is the value to assign to the exit_after_action element.\n\n\nscreens\n\nEach action can either execute an action handler (a shell command) or switch to a screen. The screens are configured in\ntheir dictionary as follows:\n\nscreens = {\n    main = {\n        style = \"common\";\n        menu = \"main\";\n        description = \"main\";\n        rulers = \"main\";\n        images = (\"background_default\", \"menu_title\");\n        screen_back = \"CURRENT\";\n    };\n    reboot = {\n        style = \"common\";\n        menu = \"reboot\";\n        description = \"reboot\"\n        rulers = \"confirm\";\n        images = (\"background_default\", \"menu_title\");\n        screen_back = \"main\";\n    };\n    safe = {\n        style = \"common\";\n        menu = \"safe\";\n        description = \"safe\";\n        rulers = \"confirm\";\n        images = (\"background_default\", \"menu_title\");\n        screen_back = \"main\";\n    };\n    factory = {\n        style = \"common\";\n        menu = \"factory\";\n        description = \"factory\";\n        rulers = \"confirm\";\n        images = (\"background_default\", \"menu_title\");\n        screen_back = \"main\";\n    };\n    factory-run = {\n        style = \"common\";\n        description = \"factory-run\";\n        rulers = \"confirm\";\n        images = (\"background_default\", \"menu_title\");\n        animations = (\"working\");\n        screen_back = \"main\";\n        allow_force_reboot = 1;\n    };\n};\n\n\nThe above entries contain 2 parameter groups:\n\n\n  The first group is responsible for the look of a screen:\n    \n      style: Element of the screen_styles dictionary\n      rulers: Element of the rulers dictionary\n      images: List of elements of the images dictionary\n      animations: Element of the animations dictionary\n    \n\n    These parameters are not described in detail in this document.\n  \n  The second group comprises parameters that describe logic:\n    \n      menu: Menu to display (an element of the menus dictionary)\n      description: Description text and screen title to display (an element of the descriptions dictionary)\n      screen_back: Screen to switch to when switching BACK\n      allow_force_reboot: Reboot after executing an action\n    \n  \n\n\ndescriptions\n\nThe elements of the descriptions dictionary hold screen titles and\nbrief descriptions for screen entries:\n\n\n  title: Short (one line) title displayed at the top of a screen\n  description: Brief explanation of actions available on the screen\n\n\ndescriptions = {\n    main = {\n        pos_x = 15;\n        pos_y = 480;\n        style = \"common\";\n        title = \"Controls:\";\n        text = \"Volume Up/Down to move menu cursor\\n\"\n            \"Power button to select\";\n    };\n\n    reboot = {\n        pos_x = 15;\n        pos_y = 100;\n        title = \"The phone will be restarted.\";\n        text = \"Continue?\";\n        style = \"common\";\n    };\n\n    safe = {\n        pos_x = 15;\n        pos_y = 100;\n        title = \"Safe mode:\",\n        text = \"The phone will be started in safe mode.\\n\"\n            \"Home screen will be changed to default\\n\"\n            \"setting and just allow a user to use\\n\"\n            \"only preloaded applications.\\n\"\n            \"Continue?\";\n        style = \"common\";\n    };\n\n    factory = {\n        pos_x = 15;\n        pos_y = 100;\n        title = \"Factory reset (except SD-card)\";\n        text = \"This will erase all data from your\\n\"\n            \"phone's internal storage, including\\n\"\n            \"settings of downloaded and preloaded\\n\"\n            \"applications and system configuration.\\n\"\n            \"Continue?\";\n        style = \"common\";\n    };\n\n    factory-run = {\n        pos_x = 15;\n        pos_y = 100;\n        style = \"common\";\n        title = \"Restoring settings to factory default.\";\n        text = \"Please wait. Do not turn off.\\n\"\n            \"(Hold power button for 3 seconds\\n\"\n            \"to reboot the device. Not recommended.)\";\n    }\n};\n\n\nNon-interactive Operation\n\nIf the system-recovery program is compiled without GUI support, only 2 parameters\nin the configuration file control how the program behaves:\n\n\n  action_handlers: List of shell commands\n  headless_action: Action to execute by default\n\n\nBefore system-recovery reads the headless_action parameter, it looks\nfor the action to execute in 2 other places:\n\n\n  tizen.recovery kernel command line option (such as tizen.recovery=factory-reset)\n  /opt/.recovery.action\n\n\nheadless_action = \"factory-reset\";\n\n\nAdding New Actions\n\nTo add a new action:\n\n\n  Define an action handler in the action_handlers dictionary:\n    action_handlers = {\n    factory-reset-minimal = \"/usr/bin/factory-reset-minimal.sh\"\n};\n    \n  \n  Take the factory entry from the menus dictionary and adapt it:\n    menus = {\n    factory-minimal = {\n        pos_x = 0;\n        pos_y = 480;\n        style = \"common\";\n        item_default = 1;\n        actions = ({\n            label = \"Yes\";\n            screen_switch_to = \"factory-run-minimal\";\n            action_handler = \"factory-reset-minimal\";\n            exit_after_action = 1;\n        },{\n            label = \"No\";\n            screen_switch_to = \"BACK\";\n        });\n    };\n};\n    \n  \n  Add 2 new entries in the screens dictionary:\n    screens = {\n    factory-minimal = {\n        style = \"common\";\n        menu = \"factory-minimal\";\n        description = \"factory-minimal\";\n        rulers = \"confirm\";\n        images = (\"background_default\", \"menu_title\");\n        screen_back = \"main\";\n    };\n    factory-run-minimal = {\n        style = \"common\";\n        description = \"factory-run-minimal\";\n        rulers = \"confirm\";\n        images = (\"background_default\", \"menu_title\");\n        animations = (\"working\");\n        screen_back = \"main\";\n        allow_force_reboot = 1;\n    };\n};\n    \n  \n  Add 2 new entries in the descriptions dictionary:\n    descriptions = {\n    factory-minimal = {\n        pos_x = 15;\n        pos_y = 100;\n        title = \"Factory reset (except SD-card)\";\n        text = \"This will erase SOME data from your\\n\"\n            \"phone's internal storage, including\\n\"\n            \"settings of downloaded and preloaded\\n\"\n            \"applications and system configuration.\\n\"\n            \"Continue?\";\n        style = \"common\";\n    };\n    factory-run-minimal = {\n        pos_x = 15;\n        pos_y = 100;\n        style = \"common\";\n        title = \"Restoring SOME settings to factory default.\";\n        text = \"Please wait. Do not turn off.\\n\"\n            \"(Hold power button for 3 seconds\\n\"\n            \"to reboot the device. Not recommended.)\";\n    };\n};\n    \n  \n  Add an action to the main menu that switches to the factory-minimal screen:\n    main = {\n    pos_x = 0;\n    pos_y = 100;\n    style = \"common\";\n    actions = ({\n        label = \"Reboot system now\";\n        screen_switch_to = \"reboot\";\n    },{\n        label = \"Safe mode\";\n        screen_switch_to = \"safe\";\n    },{\n        label = \"Phone reinitialisation\";\n        screen_switch_to = \"factory\";\n    },{\n        label = \"Minimal phone reinitialisation\";\n        screen_switch_to = \"factory-minimal\";\n    });\n};\n    \n  \n\n\nLook-and-feel Options\n\nThe following example shows the remaining parts of the configuration file, containing options that control the look-and-feel of the system recovery menus:\n\ncolors = {\n    background = \"#000000ff\";\n    title = \"#1bc7ccff\";\n    ruler = \"#1bc7ccff\";\n    white = \"#ffffffff\";\n};\n\nruler_styles = {\n    common = {\n        c_ruler = \"ruler\";\n    };\n};\n\nmenu_styles = {\n    common = {\n        item_height = 80;\n        item_spacing = 8;\n        text_pos_x = 15;\n        c_bg_selected = \"title\";\n        c_bg_unselected = \"background\";\n        c_text_selected = \"white\";\n        c_text_unselected = \"white\";\n    };\n};\n\nscreen_styles = {\n    common = {\n        c_background = \"background\";\n    };\n};\n\ndescription_styles = {\n    common = {\n        c_title = \"title\";\n        c_text = \"white\";\n    };\n};\n\nrulers = {\n    main = (\n    {\n        pos_x = 0;\n        pos_y = 80;\n        height = 2;\n        style = \"common\";\n    }, {\n        pos_x = 0;\n        pos_y = 420;\n        height = 2;\n        style = \"common\";\n    });\n\n    confirm = (\n    {\n        pos_x = 0;\n        pos_y = 80;\n        height = 2;\n        style = \"common\";\n    });\n};\n\nimages = {\n    background_default = {\n        fname = \"/usr/share/system-recovery/res/images/warning.png\";\n        c_bg = \"background\"; // reference to colors\n        align_hor = \"center\";\n        align_ver = \"bottom\";\n        offset_x = 0;\n        offset_y = 0;\n        img_type = \"alpha\"; // alt: \"no-alpha\";\n    };\n    menu_title = {\n        fname = \"/usr/share/system-recovery/res/images/menu-title.png\";\n        c_bg = \"title\";\n        align_hor = \"center\";\n        align_ver = \"top\";\n        offset_x = 0;\n        offset_y = 20;\n        img_type = \"no-alpha\"; // alt: \"no-alpha\";\n    };\n};\n\nanimations = {\n    working = {\n        fname = \"/usr/share/system-recovery/res/images/tizen-anim.png\";\n        c_bg = \"background\";\n        align_hor = \"center\";\n        align_ver = \"middle\";\n        offset_x = 0;\n        offset_y = 0;\n        frames_num = 0;\n        current_frame = 0;\n        img_type = \"no-alpha\"; // alt: \"no-alpha\";\n    };\n};\n\n\nAdding New Files to the ramdisk-recovery Partition\n\nThe ramdisk-recovery partition is created along with the rootfs\npartition (methods for creating images are beyond the scope of this\ndocument):\n\n\n  Files to be added to the ramdisk-recovery partition must\nbe available in Tizen RPM packages.\n  Files are added to the partition by the mkinitrd-recovery.sh script, which is started\nautomatically as a part of the %posttrans RPM script of the initrd-recovery package.\n\n\nTo install a selected file in the recovery\nimage, its RPM needs to be installed before initrd-recovery is run. The\neasiest way to make sure this happens is to list the package as a\ndependency in the initrd-recovery.spec file.\n\nThe mkinitrd-recovery.sh script copies or moves files from the\nrootfs partition to the initrd-recovery partition according to\ndirections provided in configuration files stored in the\n/usr/share/initrd-recovery/initrd.list.d directory. These files\nmust be packaged in the RPM packages together with the\nfiles to be put on the initrd-recovery partition. The configuration files are\ninterpreted as shell scripts and can be used to set the following\nvariables:\n\n\n  DIRECTORIES: Create directories.\n  DIR_SYMLINKS: Create symbolic links to directories.\n  LIBONLYS: Copy only the libraries required by the listed executable files.\n  MVWITHLIBS: Move the listed executable files and copy the required libraries.\n  SYMLINKS: Create symbolic links.\n  VERBATIMS: Copy the listed files. List non-executable files here.\n  WITHLIBS: Copy the listed executable files and the required libraries.\n\n\nThe SYMLINKS and DIR_SYMLINKS variables contain pairs of filenames separated with\ncolons.\n\nThe following section contains examples of the above variables:\n\nDIRECTORIES=\"\n/var/tmp\n/usr/lib/odbc\n\"\n\n# LinkFileName:Target\nDIR_SYMLINKS=\"\n/lib:usr/lib\n/opt:system/opt\n\"\n\nLIBONLYS=\"\n/bin/bash\n/bin/kill\n\"\n\nMVWITHLIBS=\"\n/usr/libexec/initrd-recovery/minireboot\n/usr/libexec/system-recovery/system-recovery.gui\n\"\n\nWITHLIBS=\"\n/usr/bin/sync\n/usr/bin/touch\n\"\n\nVERBATIMS=\"\n/usr/share/system-recovery/res/images/font.png\n/usr/share/system-recovery/res/images/menu-title.png\n/usr/share/system-recovery/system-recovery.cfg\n\"\n\n# LinkFileName:Target\nSYMLINKS=\"\n/sbin/recovery-init:/usr/libexec/system-recovery/recovery-init\n/usr/lib/bufmgr/libtbm_default.so:libtbm_sprd.so\n\"\n\n\nThe following real-world example comes from the initrd-recovery\npackage. Following this configuration, mkinitrd-recovery.sh copies\nsome basic tools to the initrd-recovery partition, moves init and\nminireboot, and creates some symlinks:\n\nMVWITHLIBS=\"\n/usr/libexec/initrd-recovery/init\n/usr/libexec/initrd-recovery/minireboot\n\"\n\nWITHLIBS=\"\n/usr/bin/bash\n/usr/bin/cat\n/usr/bin/mkdir\n/usr/bin/mount\n/usr/bin/sleep\n/usr/bin/sync\n/usr/bin/umount\n/usr/sbin/blkid\n\"\n\n# LinkFileName:Target\nSYMLINKS=\"\n/bin/sh:bash\n/sbin/init:/usr/libexec/initrd-recovery/init\n/sbin/minireboot:/usr/libexec/initrd-recovery/minireboot\n/sbin/reboot:/usr/libexec/initrd-recovery/minireboot\n\""
					}
					
				
			
		
			
				
					,
					
					"iot-porting-recovery": {
						"id": "iot-porting-recovery",
						"title": "System Recovery",
						"categories": "",
						"url": " iot/porting/recovery/",
						"content": "System Recovery\n\nTizen 4.0 comes with 3 different root filesystems, each designed for a different purpose.\n\nTable: Root filesystems\n\n\n  \n    \n      Label\n      Purpose\n    \n  \n  \n    \n      rootfs\n      Main root filesystem\n    \n    \n      ramdisk\n      Regular boot ramdisk\n    \n    \n      ramdisk-recovery\n      System recovery ramdisk\n    \n  \n\n\nThis topic describes operation and customization options of the system\nrecovery ramdisk.\n\nThe following steps describe the boot process:\n\n\n  \n    The boot process starts with a bootloader (u-boot or s-boot) loading\nappropriate kernel and ramdisk images dedicated for the system\nrecovery process (methods for controlling bootloader actions are beyond the\nscope of this document). With both images loaded into RAM, the kernel\ninitialization begins. When the initialization is complete, the kernel passes\ncontrol to the init process, such as /sbin/init (PID#1).\n  \n  \n    In the case of the recovery ramdisk, /sbin/init is a symlink to\n/usr/libexec/initrd-recovery/init (a shell script that comes\nfrom the initrd-recovery package). The script mounts several kernel\nfilesystems and the inform partition (if it exists), and parses the\nkernel command line options (/proc/cmdline) to find the bootmode\nparameter. If the parameter is present, one of the /sbin/*-init scripts is\nstarted. If the boot mode is set to recovery,\n/usr/libexec/system-recovery/recovery-init is started.\n  \n  \n    The recovery-init script mounts the real root filesystem under\nthe /system directory, and other filesystems (such as /opt and\n/opt/usr) below the /system directory. The script starts a shell on the serial console and launches the\nsystem-recovery program.\n  \n  \n    The system-recovery program can work as either an interactive GUI or\na non-interactive dispatcher, executing 1 (non-interactive) or\nmore (interactive) actions. The actions are configured in the\n/usr/share/system-recovery/system-recovery.cfg file.\n  \n\n\nConfiguration File\n\nThe configuration file allows you to customize 2 aspects of\nthe system-recovery operation: GUI and actions. The following sections take a closer look\nat the actions.\n\nThe configuration file is parsed using libconfig. For a detailed description of the\ngrammar, see the libconfig documentation.\n\naction_handlers\n\naction_handlers is a dictionary, in which shell commands (action\nhandlers) are assigned names (actions). The names are used later in\nthe configuration to refer to commands. The dictionary can be edited\nand actions can be added or removed. The names must be unique.\n\naction_handlers = {\n    reboot = \"reboot -f\";\n    factory-reset = \"touch -f /opt/.factoryreset\";\n    safeboot = \"touch -f /opt/etc/.safeboot\";\n}\n\n\nmenus\n\nActions (names) are used in the menus dictionary, which\ncomprises all pages of the menu system presented by\nsystem-recovery. The main entry is the one the program displays\nat startup. The rest must be linked in a tree-like structure.\n\nEach menu entry consists of the following fields:\n\n\n  pos_x and pox_y: Position on a screen\n  style: Reference to the menu_styles dictionary\n  actions: Array of actions available in this menu\n  item_default: Action to highlight when opening the menu\n\n\nThe system-recovery program can handle an action in 2 ways: it can run an action handler\nor switch to another screen. There is a reserved screen name BACK, which\nmeans switching to the previous screen (for more information, see screen_back in the screens\ndictionary).\n\nmenus = {\n    main = {\n        pos_x = 0;\n        pos_y = 100;\n        style = \"common\";\n        actions = ({\n            label = \"Reboot system now\";\n            screen_switch_to = \"reboot\";\n        },{\n            label = \"Safe mode\";\n            screen_switch_to = \"safe\";\n        },{\n            label = \"Phone reinitialisation\";\n            screen_switch_to = \"factory\";\n        });\n    };\n    reboot = {\n        pos_x = 0;\n        pos_y = 480;\n        style = \"common\";\n        item_default = 1;\n        actions = ({\n            label = \"Yes\";\n            action_handler = \"reboot\";\n            exit_after_action = 0;\n        },{\n            label = \"No\";\n            screen_switch_to = \"BACK\";\n        });\n    };\n    safe = {\n        pos_x = 0;\n        pos_y = 480;\n        style = \"common\";\n        item_default = 1;\n        actions = ({\n            label = \"Yes\";\n            action_handler = \"safeboot\";\n            exit_after_action = 1;\n        },{\n            label = \"No\";\n            screen_switch_to = \"BACK\";\n        });\n    };\n    factory = {\n        pos_x = 0;\n        pos_y = 480;\n        style = \"common\";\n        item_default = 1;\n        actions = ({\n            label = \"Yes\";\n            screen_switch_to = \"factory-run\";\n            action_handler = \"factory-reset\";\n            exit_after_action = 1;\n        },{\n            label = \"No\";\n            screen_switch_to = \"BACK\";\n        });\n    };\n};\n\n\n\n  Note\n\n  The system-recovery.cfg.m4.in source file provides the confirm_action m4 macro to define a Yes/No style action array:\n  \n    Yes executes an action.\n    No switches to a previous screen.\n  \n\n  Use this macro when adding an action to the config file in the repository.\n\n  For example:\n  actions = confirm_action('safeboot', 1);\n  \n  Expands to:\n  actions = ({\n    label = \"Yes\";\n    action_handler = \"safeboot\";\n    exit_after_action = 1;\n},{\n    label = \"No\";\n    screen_switch_to = \"BACK\";\n});\n  \n\n  The first argument of the macro is an action, and the second is the value to assign to the exit_after_action element.\n\n\nscreens\n\nEach action can either execute an action handler (a shell command) or switch to a screen. The screens are configured in\ntheir dictionary as follows:\n\nscreens = {\n    main = {\n        style = \"common\";\n        menu = \"main\";\n        description = \"main\";\n        rulers = \"main\";\n        images = (\"background_default\", \"menu_title\");\n        screen_back = \"CURRENT\";\n    };\n    reboot = {\n        style = \"common\";\n        menu = \"reboot\";\n        description = \"reboot\"\n        rulers = \"confirm\";\n        images = (\"background_default\", \"menu_title\");\n        screen_back = \"main\";\n    };\n    safe = {\n        style = \"common\";\n        menu = \"safe\";\n        description = \"safe\";\n        rulers = \"confirm\";\n        images = (\"background_default\", \"menu_title\");\n        screen_back = \"main\";\n    };\n    factory = {\n        style = \"common\";\n        menu = \"factory\";\n        description = \"factory\";\n        rulers = \"confirm\";\n        images = (\"background_default\", \"menu_title\");\n        screen_back = \"main\";\n    };\n    factory-run = {\n        style = \"common\";\n        description = \"factory-run\";\n        rulers = \"confirm\";\n        images = (\"background_default\", \"menu_title\");\n        animations = (\"working\");\n        screen_back = \"main\";\n        allow_force_reboot = 1;\n    };\n};\n\n\nThe above entries contain 2 parameter groups:\n\n\n  The first group is responsible for the look of a screen:\n    \n      style: Element of the screen_styles dictionary\n      rulers: Element of the rulers dictionary\n      images: List of elements of the images dictionary\n      animations: Element of the animations dictionary\n    \n\n    These parameters are not described in detail in this document.\n  \n  The second group comprises parameters that describe logic:\n    \n      menu: Menu to display (an element of the menus dictionary)\n      description: Description text and screen title to display (an element of the descriptions dictionary)\n      screen_back: Screen to switch to when switching BACK\n      allow_force_reboot: Reboot after executing an action\n    \n  \n\n\ndescriptions\n\nThe elements of the descriptions dictionary hold screen titles and\nbrief descriptions for screen entries:\n\n\n  title: Short (one line) title displayed at the top of a screen\n  description: Brief explanation of actions available on the screen\n\n\ndescriptions = {\n    main = {\n        pos_x = 15;\n        pos_y = 480;\n        style = \"common\";\n        title = \"Controls:\";\n        text = \"Volume Up/Down to move menu cursor\\n\"\n            \"Power button to select\";\n    };\n\n    reboot = {\n        pos_x = 15;\n        pos_y = 100;\n        title = \"The phone will be restarted.\";\n        text = \"Continue?\";\n        style = \"common\";\n    };\n\n    safe = {\n        pos_x = 15;\n        pos_y = 100;\n        title = \"Safe mode:\",\n        text = \"The phone will be started in safe mode.\\n\"\n            \"Home screen will be changed to default\\n\"\n            \"setting and just allow a user to use\\n\"\n            \"only preloaded applications.\\n\"\n            \"Continue?\";\n        style = \"common\";\n    };\n\n    factory = {\n        pos_x = 15;\n        pos_y = 100;\n        title = \"Factory reset (except SD-card)\";\n        text = \"This will erase all data from your\\n\"\n            \"phone's internal storage, including\\n\"\n            \"settings of downloaded and preloaded\\n\"\n            \"applications and system configuration.\\n\"\n            \"Continue?\";\n        style = \"common\";\n    };\n\n    factory-run = {\n        pos_x = 15;\n        pos_y = 100;\n        style = \"common\";\n        title = \"Restoring settings to factory default.\";\n        text = \"Please wait. Do not turn off.\\n\"\n            \"(Hold power button for 3 seconds\\n\"\n            \"to reboot the device. Not recommended.)\";\n    }\n};\n\n\nNon-interactive Operation\n\nIf the system-recovery program is compiled without GUI support, only 2 parameters\nin the configuration file control how the program behaves:\n\n\n  action_handlers: List of shell commands\n  headless_action: Action to execute by default\n\n\nBefore system-recovery reads the headless_action parameter, it looks\nfor the action to execute in 2 other places:\n\n\n  tizen.recovery kernel command line option (such as tizen.recovery=factory-reset)\n  /opt/.recovery.action\n\n\nheadless_action = \"factory-reset\";\n\n\nAdding New Actions\n\nTo add a new action:\n\n\n  Define an action handler in the action_handlers dictionary:\n    action_handlers = {\n    factory-reset-minimal = \"/usr/bin/factory-reset-minimal.sh\"\n};\n    \n  \n  Take the factory entry from the menus dictionary and adapt it:\n    menus = {\n    factory-minimal = {\n        pos_x = 0;\n        pos_y = 480;\n        style = \"common\";\n        item_default = 1;\n        actions = ({\n            label = \"Yes\";\n            screen_switch_to = \"factory-run-minimal\";\n            action_handler = \"factory-reset-minimal\";\n            exit_after_action = 1;\n        },{\n            label = \"No\";\n            screen_switch_to = \"BACK\";\n        });\n    };\n};\n    \n  \n  Add 2 new entries in the screens dictionary:\n    screens = {\n    factory-minimal = {\n        style = \"common\";\n        menu = \"factory-minimal\";\n        description = \"factory-minimal\";\n        rulers = \"confirm\";\n        images = (\"background_default\", \"menu_title\");\n        screen_back = \"main\";\n    };\n    factory-run-minimal = {\n        style = \"common\";\n        description = \"factory-run-minimal\";\n        rulers = \"confirm\";\n        images = (\"background_default\", \"menu_title\");\n        animations = (\"working\");\n        screen_back = \"main\";\n        allow_force_reboot = 1;\n    };\n};\n    \n  \n  Add 2 new entries in the descriptions dictionary:\n    descriptions = {\n    factory-minimal = {\n        pos_x = 15;\n        pos_y = 100;\n        title = \"Factory reset (except SD-card)\";\n        text = \"This will erase SOME data from your\\n\"\n            \"phone's internal storage, including\\n\"\n            \"settings of downloaded and preloaded\\n\"\n            \"applications and system configuration.\\n\"\n            \"Continue?\";\n        style = \"common\";\n    };\n    factory-run-minimal = {\n        pos_x = 15;\n        pos_y = 100;\n        style = \"common\";\n        title = \"Restoring SOME settings to factory default.\";\n        text = \"Please wait. Do not turn off.\\n\"\n            \"(Hold power button for 3 seconds\\n\"\n            \"to reboot the device. Not recommended.)\";\n    };\n};\n    \n  \n  Add an action to the main menu that switches to the factory-minimal screen:\n    main = {\n    pos_x = 0;\n    pos_y = 100;\n    style = \"common\";\n    actions = ({\n        label = \"Reboot system now\";\n        screen_switch_to = \"reboot\";\n    },{\n        label = \"Safe mode\";\n        screen_switch_to = \"safe\";\n    },{\n        label = \"Phone reinitialisation\";\n        screen_switch_to = \"factory\";\n    },{\n        label = \"Minimal phone reinitialisation\";\n        screen_switch_to = \"factory-minimal\";\n    });\n};\n    \n  \n\n\nLook-and-feel Options\n\nThe following example shows the remaining parts of the configuration file, containing options that control the look-and-feel of the system recovery menus:\n\ncolors = {\n    background = \"#000000ff\";\n    title = \"#1bc7ccff\";\n    ruler = \"#1bc7ccff\";\n    white = \"#ffffffff\";\n};\n\nruler_styles = {\n    common = {\n        c_ruler = \"ruler\";\n    };\n};\n\nmenu_styles = {\n    common = {\n        item_height = 80;\n        item_spacing = 8;\n        text_pos_x = 15;\n        c_bg_selected = \"title\";\n        c_bg_unselected = \"background\";\n        c_text_selected = \"white\";\n        c_text_unselected = \"white\";\n    };\n};\n\nscreen_styles = {\n    common = {\n        c_background = \"background\";\n    };\n};\n\ndescription_styles = {\n    common = {\n        c_title = \"title\";\n        c_text = \"white\";\n    };\n};\n\nrulers = {\n    main = (\n    {\n        pos_x = 0;\n        pos_y = 80;\n        height = 2;\n        style = \"common\";\n    }, {\n        pos_x = 0;\n        pos_y = 420;\n        height = 2;\n        style = \"common\";\n    });\n\n    confirm = (\n    {\n        pos_x = 0;\n        pos_y = 80;\n        height = 2;\n        style = \"common\";\n    });\n};\n\nimages = {\n    background_default = {\n        fname = \"/usr/share/system-recovery/res/images/warning.png\";\n        c_bg = \"background\"; // reference to colors\n        align_hor = \"center\";\n        align_ver = \"bottom\";\n        offset_x = 0;\n        offset_y = 0;\n        img_type = \"alpha\"; // alt: \"no-alpha\";\n    };\n    menu_title = {\n        fname = \"/usr/share/system-recovery/res/images/menu-title.png\";\n        c_bg = \"title\";\n        align_hor = \"center\";\n        align_ver = \"top\";\n        offset_x = 0;\n        offset_y = 20;\n        img_type = \"no-alpha\"; // alt: \"no-alpha\";\n    };\n};\n\nanimations = {\n    working = {\n        fname = \"/usr/share/system-recovery/res/images/tizen-anim.png\";\n        c_bg = \"background\";\n        align_hor = \"center\";\n        align_ver = \"middle\";\n        offset_x = 0;\n        offset_y = 0;\n        frames_num = 0;\n        current_frame = 0;\n        img_type = \"no-alpha\"; // alt: \"no-alpha\";\n    };\n};\n\n\nAdding New Files to the ramdisk-recovery Partition\n\nThe ramdisk-recovery partition is created along with the rootfs\npartition (methods for creating images are beyond the scope of this\ndocument):\n\n\n  Files to be added to the ramdisk-recovery partition must\nbe available in Tizen RPM packages.\n  Files are added to the partition by the mkinitrd-recovery.sh script, which is started\nautomatically as a part of the %posttrans RPM script of the initrd-recovery package.\n\n\nTo install a selected file in the recovery\nimage, its RPM needs to be installed before initrd-recovery is run. The\neasiest way to make sure this happens is to list the package as a\ndependency in the initrd-recovery.spec file.\n\nThe mkinitrd-recovery.sh script copies or moves files from the\nrootfs partition to the initrd-recovery partition according to\ndirections provided in configuration files stored in the\n/usr/share/initrd-recovery/initrd.list.d directory. These files\nmust be packaged in the RPM packages together with the\nfiles to be put on the initrd-recovery partition. The configuration files are\ninterpreted as shell scripts and can be used to set the following\nvariables:\n\n\n  DIRECTORIES: Create directories.\n  DIR_SYMLINKS: Create symbolic links to directories.\n  LIBONLYS: Copy only the libraries required by the listed executable files.\n  MVWITHLIBS: Move the listed executable files and copy the required libraries.\n  SYMLINKS: Create symbolic links.\n  VERBATIMS: Copy the listed files. List non-executable files here.\n  WITHLIBS: Copy the listed executable files and the required libraries.\n\n\nThe SYMLINKS and DIR_SYMLINKS variables contain pairs of filenames separated with\ncolons.\n\nThe following section contains examples of the above variables:\n\nDIRECTORIES=\"\n/var/tmp\n/usr/lib/odbc\n\"\n\n# LinkFileName:Target\nDIR_SYMLINKS=\"\n/lib:usr/lib\n/opt:system/opt\n\"\n\nLIBONLYS=\"\n/bin/bash\n/bin/kill\n\"\n\nMVWITHLIBS=\"\n/usr/libexec/initrd-recovery/minireboot\n/usr/libexec/system-recovery/system-recovery.gui\n\"\n\nWITHLIBS=\"\n/usr/bin/sync\n/usr/bin/touch\n\"\n\nVERBATIMS=\"\n/usr/share/system-recovery/res/images/font.png\n/usr/share/system-recovery/res/images/menu-title.png\n/usr/share/system-recovery/system-recovery.cfg\n\"\n\n# LinkFileName:Target\nSYMLINKS=\"\n/sbin/recovery-init:/usr/libexec/system-recovery/recovery-init\n/usr/lib/bufmgr/libtbm_default.so:libtbm_sprd.so\n\"\n\n\nThe following real-world example comes from the initrd-recovery\npackage. Following this configuration, mkinitrd-recovery.sh copies\nsome basic tools to the initrd-recovery partition, moves init and\nminireboot, and creates some symlinks:\n\nMVWITHLIBS=\"\n/usr/libexec/initrd-recovery/init\n/usr/libexec/initrd-recovery/minireboot\n\"\n\nWITHLIBS=\"\n/usr/bin/bash\n/usr/bin/cat\n/usr/bin/mkdir\n/usr/bin/mount\n/usr/bin/sleep\n/usr/bin/sync\n/usr/bin/umount\n/usr/sbin/blkid\n\"\n\n# LinkFileName:Target\nSYMLINKS=\"\n/bin/sh:bash\n/sbin/init:/usr/libexec/initrd-recovery/init\n/sbin/minireboot:/usr/libexec/initrd-recovery/minireboot\n/sbin/reboot:/usr/libexec/initrd-recovery/minireboot\n\""
					}
					
				
			
		
			
				
					,
					
					"search-html": {
						"id": "search-html",
						"title": "Search",
						"categories": "",
						"url": " search.html",
						"content": "Loading results for \"\""
					}
					
				
			
		
			
				
					,
					
					"application-developing-setting-up": {
						"id": "application-developing-setting-up",
						"title": "Setting up the Development Environment",
						"categories": "",
						"url": " application/developing/setting-up/",
						"content": "# Setting up the Development Environment\n\nThis topic provides information on how to set up a development environment.\n\n> **Note**\n>\n> If you encounter problems while obtaining the repo tool, see [Development Tips](tips.md).\n\n## Setting Up Gerrit Access\n\nYou can set up access to [Tizen Gerrit](http://review.tizen.org/gerrit/) through the following steps:\n\n1. Register a user account to gain access to tizen.org.\n2. Configure Secure Shell (SSH) for Gerrit access.\n3. Configure Git for Gerrit access.\n\n### Registering a User Account\n\nTo register a user account to gain access to tizen.org:\n\n1. Open the [Register page](https://www.tizen.org/user/register).\n\n2. Fill in the mandatory fields and other necessary information, and click **Register**.\n\n   Gerrit sends a verification email to the email address you have provided.\n\n3. Follow the instructions in the verification email to verify the email address, change the password, and gain access to tizen.org.\n   > **Note**\n   >\n   >  If an error message is shown when you click the link in the verification email, copy the link to the address bar of the browser manually.\n\nAt this point, the prerequisites for accessing Gerrit are ready. Move on to the next section to enable Gerrit access.\n\n### Configuring SSH for Gerrit Access\n\nTo configure SSH for Gerrit access:\n\n1. Generate RSA keys:\n\n   ```\n   $ ssh-keygen [-t rsa] [-C \"\"]\n   ```\n\n   > **Note**\n   >\n   > `[-t rsa]` and `[-C \"\"]` are both optional arguments for the `ssh-keygen` command.\n   >\n   > If invoked without specifying key type, `ssh-keygen` generates an RSA key for use in SSH protocol 2 connections, thus making `[-t rsa]`, which specifies the key type, optional.\n   >\n   > For an RSA key, if invoked without adding any comment, `ssh-keygen` initializes the comment as \"@\" when the key is generated, thus making `[-C \"\"]` optional. In spite of this, adding this argument is recommended because a rephrased comment can make it easier to identify the keys.\n\n   Based on the on-screen prompts, specify the file in which to save the key, and the passphrase.\n\n   ```\n   Enter file in which to save the key (/home//.ssh/id_rsa):\n   Enter passphrase (empty for no passphrase):\n   Enter same passphrase again:\n   ```\n\n   If you press ENTER directly for the file, the default value `/home//.ssh/id_rsa` is used. If you press ENTER directly for the passphrase, no passphrase is used.\n\n   At this point, the SSH keys are successfully generated.\n\n2. Create an SSH configuration file, `~/.ssh/config`, and add 1 of the following, as appropriate:\n\n   - Ubuntu, openSUSE, CentOS, or Debian:\n\n     ```\n     Host tizen review.tizen.org\n     Hostname review.tizen.org\n     IdentityFile ~/.ssh/id_rsa\n     User \n     Port 29418\n     # Add the line below when using proxy, otherwise, skip it\n     # ProxyCommand nc -X5 -x : %h %p\n     ```\n\n   - Fedora:\n\n     ```\n     Host tizen review.tizen.org\n     Hostname review.tizen.org\n     IdentityFile ~/.ssh/id_rsaUser \n     Port 29418\n     # Add the line below when using proxy, otherwise, skip it\n     # ProxyCommand nc --proxy-type socks4 --proxy : %h %p\n     ```\n\n   > **Note**\n   >\n   > - Both \"tizen\" and \"review.tizen.org\" are aliases of the hostname. \"tizen\" is configured for simplicity of commands when initializing Git repositories and cloning specific Tizen projects, and \"review.tizen.org\" is configured to work with the `manifest.xml` and `_remote.xml` files when synchronizing the entire Tizen source.\n   >\n   > - The `~/.ssh/config` file must not be written in by other users. Make sure to remove the write permission by executing `chmod o-w ~/.ssh/config`. For more information on `ssh_config`, see `man ssh_config`.\n\n3. Copy the full text in `~/.ssh/id_rsa.pub`, including all of the following:\n\n   - `ssh-rsa` lead\n   - SSH public key\n   - Email address tail\n\n4. Log in to [Tizen Gerrit](http://review.tizen.org/gerrit/) and upload the key:\n\n   1. In the Gerrit Web page, click the user name on the top right corner (with an inverted triangle on the right), and select **Settings**.\n   2. Click **SSH Public Keys** in the left panel, paste the text copied earlier into the **Add SSH Public Key** box, and click **Add**.\n\n5. Verify the SSH connection:\n\n   ```\n   $ ssh tizen\n   ```\n\n   The following message indicates that SSH connection has been established successfully:\n\n   ```\n   **** Welcome to Gerrit Code Review ****\n   ```\n\n### Configuring Git for Gerrit Access\n\nGit must know the user's name and email address to determine the author of each commit. If the user name or email address is not set up in a way that Git can find it, the user can encounter some odd warnings.\n\nThis configuration operation requires developer access. In addition, it is recommended to match the email address with the one registered in contact information, which helps Git identify the user.\n\nTo configure Git for Gerrit access:\n\n1. Set the user name by executing the following command:\n   ```\n   $ git config --global user.name \n   ```\n2. Set the email address by executing the following command:\n   ```\n   $ git config --global user.email \"\"\n   ```\n\n> **Note**\n>\n> Using the `GIT_AUTHOR_NAME` and `GIT_AUTHOR_EMAIL` environment variables is an alternative solution. These variables override all configuration settings once set.\n\n## Setting Up the GBS Configuration\n\nYou can set up the GBS configuration through editing the `.gbs.conf` file.\n\n### Setting Up the Default GBS Configuration File\n\nThe default GBS configuration file is located in `~/.gbs.conf`:\n\n```\n[general]\nprofile = profile.3.0-mobile_target-TM1\n\n\n#########################################################\n################## Profile Section ##################\n#########################################################\n\n############# 5.0-unified #############\n[profile.unified_standard]\nbuildconf=./scm/meta/build-config/unified/standard_build.conf\nrepos = repo.base_standard,repo.base_standard_debug,repo.unified_standard,repo.unified_standard_debug\n\n[profile.unified_emulator]\nbuildconf=./scm/meta/build-config/unified/emulator_build.conf\nrepos = repo.base_standard,repo.base_standard_debug,repo.unified_emulator,repo.unified_emulator_debug\n\n############# 4.0-unified #############\n[profile.4.0-unified_standard]\nbuildconf=./scm/meta/build-config/4.0/unified/standard_build.conf\nrepos = repo.4.0-base_arm,repo.4.0-base_arm_debug,repo.4.0-base_arm64,repo.4.0-base_arm64_debug,repo.4.0-base_ia32,repo.4.0-base_ia32_debug,repo.4.0-base_x86_64,repo.4.0-base_x86_64_debug,repo.4.0-unified_standard,repo.4.0-unified_standard_debug\n\n[profile.4.0-unified_emulator]\nbuildconf=./scm/meta/build-config/4.0/unified/emulator_build.conf\nrepos = repo.4.0-base_ia32,repo.4.0-base_ia32_debug,repo.4.0-base_x86_64,repo.4.0-base_x86_64_debug,repo.4.0-unified_emulator,repo.4.0-unified_emulator_debug\n\n############# 3.0-common #############\n[profile.3.0-common_x86_64-wayland]\nbuildconf=./scm/meta/build-config/3.0/common/x86_64-wayland_build.conf\nrepos = repo.3.0-base_x86_64,repo.3.0-base_x86_64_debug,repo.3.0-common_x86_64-wayland,repo.3.0-common_x86_64-wayland_debug\n\n[profile.3.0-common_ia32-wayland]\nbuildconf=./scm/meta/build-config/3.0/common/ia32-wayland_build.conf\nrepos = repo.3.0-base_ia32,repo.3.0-base_ia32_debug,repo.3.0-common_ia32-wayland,repo.3.0-common_ia32-wayland_debug\n\n[profile.3.0-common_emulator32-wayland]\nbuildconf=./scm/meta/build-config/3.0/common/emulator32-wayland_build.conf\nrepos = repo.3.0-base_emulator32,repo.3.0-base_emulator32_debug,repo.3.0-common_emulator32-wayland,repo.3.0-common_emulator32-wayland_debug\n\n[profile.3.0-common_arm64-wayland]\nbuildconf=./scm/meta/build-config/3.0/common/arm64-wayland_build.conf\nrepos = repo.3.0-base_arm64,repo.3.0-base_arm64_debug,repo.3.0-common_arm64-wayland,repo.3.0-common_arm64-wayland_debug\n\n[profile.3.0-common_arm-wayland]\nbuildconf=./scm/meta/build-config/3.0/common/arm-wayland_build.conf\nrepos = repo.3.0-base_arm,repo.3.0-base_arm_debug,repo.3.0-common_arm-wayland,repo.3.0-common_arm-wayland_debug\n\n############# 3.0-mobile #############\n[profile.3.0-mobile_target-TM1]\nbuildconf=./scm/meta/build-config/3.0/mobile/target-TM1_build.conf\nrepos = repo.3.0-base_arm,repo.3.0-base_arm_debug,repo.3.0-mobile_target-TM1,repo.3.0-mobile_target-TM1_debug\n\n[profile.3.0-mobile_emulator32-wayland]\nbuildconf=./scm/meta/build-config/3.0/mobile/emulator32-wayland_build.conf\nrepos = repo.3.0-base_emulator32,repo.3.0-base_emulator32_debug,repo.3.0-mobile_emulator32-wayland,repo.3.0-mobile_emulator32-wayland_debug\n\n[profile.3.0-mobile_arm-wayland]\nbuildconf=./scm/meta/build-config/3.0/mobile/arm-wayland_build.conf\nrepos = repo.3.0-base_arm,repo.3.0-base_arm_debug,repo.3.0-mobile_arm-wayland,repo.3.0-mobile_arm-wayland_debug\n\n############# 3.0-tv #############\n[profile.3.0-tv_emulator64-wayland]\nbuildconf=./scm/meta/build-config/3.0/tv/emulator64-wayland_build.conf\nrepos = repo.3.0-base_emulator64,repo.3.0-base_emulator64_debug,repo.3.0-tv_emulator64-wayland,repo.3.0-tv_emulator64-wayland_debug\n\n[profile.3.0-tv_emulator32-wayland]\nbuildconf=./scm/meta/build-config/3.0/tv/emulator32-wayland_build.conf\nrepos = repo.3.0-base_emulator32,repo.3.0-base_emulator32_debug,repo.3.0-tv_emulator32-wayland,repo.3.0-tv_emulator32-wayland_debug\n\n[profile.3.0-tv_arm-wayland]\nbuildconf=./scm/meta/build-config/3.0/tv/arm-wayland_build.conf\nrepos = repo.3.0-base_arm,repo.3.0-base_arm_debug,repo.3.0-tv_arm-wayland,repo.3.0-tv_arm-wayland_debug\n\n############# 3.0-wearable #############\n[profile.3.0-wearable_target-circle]\nbuildconf=./scm/meta/build-config/3.0/wearable/target-circle_build.conf\nrepos = repo.3.0-base_arm,repo.3.0-base_arm_debug,repo.3.0-wearable_target-circle,repo.3.0-wearable_target-circle_debug\n\n[profile.3.0-wearable_emulator32-wayland]\nbuildconf=./scm/meta/build-config/3.0/wearable/emulator32-wayland_build.conf\nrepos = repo.3.0-base_emulator32,repo.3.0-base_emulator32_debug,repo.3.0-wearable_emulator32-wayland,repo.3.0-wearable_emulator32-wayland_debug\n\n[profile.3.0-wearable_emulator-circle]\nbuildconf=./scm/meta/build-config/3.0/wearable/emulator-circle_build.conf\nrepos = repo.3.0-base_emulator32,repo.3.0-base_emulator32_debug,repo.3.0-wearable_emulator-circle,repo.3.0-wearable_emulator-circle_debug\n\n############# 3.0-ivi #############\n[profile.3.0-ivi_emulator]\nbuildconf=./scm/meta/build-config/3.0/ivi/emulator_build.conf\nrepos = repo.3.0-base_emulator32,repo.3.0-base_emulator32_debug,repo.3.0-ivi_emulator,repo.3.0-ivi_emulator_debug\n\n[profile.3.0-ivi_arm]\nbuildconf=./scm/meta/build-config/3.0/ivi/arm_build.conf\nrepos = repo.3.0-base_arm,repo.3.0-base_arm_debug,repo.3.0-ivi_arm,repo.3.0-ivi_arm_debug\n\n\n\n#########################################################\n################## Repo Section##################\n#########################################################\n\n############# base #############\n[repo.base_standard]\nurl = http://download.tizen.org/releases/daily/tizen/base/latest/repos/standard/packages/\n[repo.base_standard_debug]\nurl = http://download.tizen.org/releases/daily/tizen/base/latest/repos/standard/debug/\n\n############# 4.0-base #############\n[repo.4.0-base_x86_64]\nurl = http://download.tizen.org/releases/daily/tizen/4.0-base/latest/repos/x86_64/packages/\n[repo.4.0-base_x86_64_debug]\nurl = http://download.tizen.org/releases/daily/tizen/4.0-base/latest/repos/x86_64/debug/\n\n[repo.4.0-base_ia32]\nurl = http://download.tizen.org/releases/daily/tizen/4.0-base/latest/repos/ia32/packages/\n[repo.4.0-base_ia32_debug]\nurl = http://download.tizen.org/releases/daily/tizen/4.0-base/latest/repos/ia32/debug/\n\n[repo.4.0-base_emulator64]\nurl = http://download.tizen.org/releases/daily/tizen/4.0-base/latest/repos/emulator64/packages/\n[repo.4.0-base_emulator64_debug]\nurl = http://download.tizen.org/releases/daily/tizen/4.0-base/latest/repos/emulator64/debug/\n\n[repo.4.0-base_emulator32]\nurl = http://download.tizen.org/releases/daily/tizen/4.0-base/latest/repos/emulator32/packages/\n[repo.4.0-base_emulator32_debug]\nurl = http://download.tizen.org/releases/daily/tizen/4.0-base/latest/repos/emulator32/debug/\n\n[repo.4.0-base_arm64]\nurl = http://download.tizen.org/releases/daily/4.0-base/latest/repos/arm64/packages/\n[repo.4.0-base_arm64_debug]\nurl = http://download.tizen.org/releases/daily/tizen/4.0-base/latest/repos/arm64/debug/\n\n[repo.4.0-base_arm]\nurl = http://download.tizen.org/releases/daily/tizen/4.0-base/latest/repos/arm/packages/\n[repo.4.0-base_arm_debug]\nurl = http://download.tizen.org/releases/daily/tizen/4.0-base/latest/repos/arm/debug/\n\n############# 3.0-base #############\n[repo.3.0-base_x86_64]\nurl = http://download.tizen.org/releases/daily/tizen/3.0-base/latest/repos/x86_64/packages/\n[repo.3.0-base_x86_64_debug]\nurl = http://download.tizen.org/releases/daily/tizen/3.0-base/latest/repos/x86_64/debug/\n\n[repo.3.0-base_ia32]\nurl = http://download.tizen.org/releases/daily/tizen/3.0-base/latest/repos/ia32/packages/\n[repo.3.0-base_ia32_debug]\nurl = http://download.tizen.org/releases/daily/tizen/3.0-base/latest/repos/ia32/debug/\n\n[repo.3.0-base_emulator64]\nurl = http://download.tizen.org/releases/daily/tizen/3.0-base/latest/repos/emulator64/packages/\n[repo.3.0-base_emulator64_debug]\nurl = http://download.tizen.org/releases/daily/tizen/3.0-base/latest/repos/emulator64/debug/\n\n[repo.3.0-base_emulator32]\nurl = http://download.tizen.org/releases/daily/tizen/3.0-base/latest/repos/emulator32/packages/\n[repo.3.0-base_emulator32_debug]\nurl = http://download.tizen.org/releases/daily/tizen/3.0-base/latest/repos/emulator32/debug/\n\n[repo.3.0-base_arm64]\nurl = http://download.tizen.org/releases/daily/tizen/3.0-base/latest/repos/arm64/packages/\n[repo.3.0-base_arm64_debug]\nurl = http://download.tizen.org/releases/daily/tizen/3.0-base/latest/repos/arm64/debug/\n\n[repo.3.0-base_arm]\nurl = http://download.tizen.org/releases/daily/tizen/3.0-base/latest/repos/arm/packages/\n[repo.3.0-base_arm_debug]\nurl = http://download.tizen.org/releases/daily/tizen/3.0-base/latest/repos/arm/debug/\n\n############# 5.0-unified #############\n[repo.unified_standard]\nurl = http://download.tizen.org/releases/daily/tizen/unified/latest/repos/standard/packages/\n[repo.unified_standard_debug]\nurl = http://download.tizen.org/releases/daily/tizen/unified/latest/repos/standard/debug/\n\n[repo.unified_emulator]\nurl = http://download.tizen.org/releases/daily/tizen/unified/latest/repos/emulator/packages/\n[repo.unified_emulator_debug]\nurl = http://download.tizen.org/releases/daily/tizen/unified/latest/repos/emulator/debug/\n\n############# 4.0-unified #############\n[repo.4.0-unified_standard]\nurl = http://download.tizen.org/releases/daily/tizen/4.0-unified/latest/repos/standard/packages/\n[repo.4.0-unified_standard_debug]\nurl = http://download.tizen.org/releases/daily/tizen/4.0-unified/latest/repos/standard/debug/\n\n[repo.4.0-unified_emulator]\nurl = http://download.tizen.org/releases/daily/tizen/4.0-unified/latest/repos/emulator/packages/\n[repo.4.0-unified_emulator_debug]\nurl = http://download.tizen.org/releases/daily/tizen/4.0-unified/latest/repos/emulator/debug/\n\n############# 3.0-common #############\n[repo.3.0-common_x86_64-wayland]\nurl = http://download.tizen.org/releases/daily/tizen/3.0-common/latest/repos/x86_64-wayland/packages/\n[repo.3.0-common_x86_64-wayland_debug]\nurl = http://download.tizen.org/releases/daily/tizen/3.0-common/latest/repos/x86_64-wayland/debug/\n\n[repo.3.0-common_ia32-wayland]\nurl = http://download.tizen.org/releases/daily/tizen/3.0-common/latest/repos/ia32-wayland/packages/\n[repo.3.0-common_ia32-wayland_debug]\nurl = http://download.tizen.org/releases/daily/tizen/3.0-common/latest/repos/ia32-wayland/debug/\n\n[repo.3.0-common_emulator32-wayland]\nurl = http://download.tizen.org/releases/daily/tizen/3.0-common/latest/repos/emulator32-wayland/packages/\n[repo.3.0-common_emulator32-wayland_debug]\nurl = http://download.tizen.org/releases/daily/tizen/3.0-common/latest/repos/emulator32-wayland/debug/\n\n[repo.3.0-common_arm64-wayland]\nurl = http://download.tizen.org/releases/daily/tizen/3.0-common/latest/repos/arm64-wayland/packages/\n[repo.3.0-common_arm64-wayland_debug]\nurl = http://download.tizen.org/releases/daily/tizen/3.0-common/latest/repos/arm64-wayland/debug/\n\n[repo.3.0-common_arm-wayland]\nurl = http://download.tizen.org/releases/daily/tizen/3.0-common/latest/repos/arm-wayland/packages/\n[repo.3.0-common_arm-wayland_debug]\nurl = http://download.tizen.org/releases/daily/tizen/3.0-common/latest/repos/arm-wayland/debug/\n\n############# 3.0-mobile #############\n[repo.3.0-mobile_target-TM1]\nurl = http://download.tizen.org/releases/daily/tizen/3.0-mobile/latest/repos/target-TM1/packages/\n[repo.3.0-mobile_target-TM1_debug]\nurl = http://download.tizen.org/releases/daily/tizen/3.0-mobile/latest/repos/target-TM1/debug/\n\n[repo.3.0-mobile_emulator32-wayland]\nurl = http://download.tizen.org/releases/daily/tizen/3.0-mobile/latest/repos/emulator32-wayland/packages/\n[repo.3.0-mobile_emulator32-wayland_debug]\nurl = http://download.tizen.org/releases/daily/tizen/3.0-mobile/latest/repos/emulator32-wayland/debug/\n\n[repo.3.0-mobile_arm-wayland]\nurl = http://download.tizen.org/releases/daily/tizen/3.0-mobile/latest/repos/arm-wayland/packages/\n[repo.3.0-mobile_arm-wayland_debug]\nurl = http://download.tizen.org/releases/daily/tizen/3.0-mobile/latest/repos/arm-wayland/debug/\n\n############# 3.0-tv #############\n[repo.3.0-tv_emulator64-wayland]\nurl = http://download.tizen.org/releases/daily/tizen/3.0-tv/latest/repos/emulator64-wayland/packages/\n[repo.3.0-tv_emulator64-wayland_debug]\nurl = http://download.tizen.org/releases/daily/tizen/3.0-tv/latest/repos/emulator64-wayland/debug/\n\n[repo.3.0-tv_emulator32-wayland]\nurl = http://download.tizen.org/releases/daily/tizen/3.0-tv/latest/repos/emulator32-wayland/packages/\n[repo.3.0-tv_emulator32-wayland_debug]\nurl = http://download.tizen.org/releases/daily/tizen/3.0-tv/latest/repos/emulator32-wayland/debug/\n\n[repo.3.0-tv_arm-wayland]\nurl = http://download.tizen.org/releases/daily/tizen/3.0-tv/latest/repos/arm-wayland/packages/\n[repo.3.0-tv_arm-wayland_debug]\nurl = http://download.tizen.org/releases/daily/tizen/3.0-tv/latest/repos/arm-wayland/debug/\n\n############# 3.0-wearable #############\n[repo.3.0-wearable_target-circle]\nurl = http://download.tizen.org/releases/daily/tizen/3.0-wearable/latest/repos/target-circle/packages/\n[repo.3.0-wearable_target-circle_debug]\nurl = http://download.tizen.org/releases/daily/tizen/3.0-wearable/latest/repos/target-circle/debug/\n\n[repo.3.0-wearable_emulator32-wayland]\nurl = http://download.tizen.org/releases/daily/tizen/3.0-wearable/latest/repos/emulator32-wayland/packages/\n[repo.3.0-wearable_emulator32-wayland_debug]\nurl = http://download.tizen.org/releases/daily/tizen/3.0-wearable/latest/repos/emulator32-wayland/debug/\n\n[repo.3.0-wearable_emulator-circle]\nurl = http://download.tizen.org/releases/daily/tizen/3.0-wearable/latest/repos/emulator-circle/packages/\n[repo.3.0-wearable_emulator-circle_debug]\nurl = http://download.tizen.org/releases/daily/tizen/3.0-wearable/latest/repos/emulator-circle/debug/\n\n############# 3.0-ivi #############\n[repo.3.0-ivi_emulator]\nurl = http://download.tizen.org/releases/daily/tizen/3.0-ivi/latest/repos/emulator/packages/\n[repo.3.0-ivi_emulator_debug]\nurl = http://download.tizen.org/releases/daily/tizen/3.0-ivi/latest/repos/emulator/debug/\n\n[repo.3.0-ivi_arm]\nurl = http://download.tizen.org/releases/daily/tizen/3.0-ivi/latest/repos/arm/packages/\n[repo.3.0-ivi_arm_debug]\nurl = http://download.tizen.org/releases/daily/tizen/3.0-ivi/latest/repos/arm/debug/\n```\n\n> **Note**\n>\n> The file contains the GBS configuration for all profiles and repositories in Tizen version 3.0, Tizen version 4.0 and Tizen version 5.0. In the near future in new GBS versions, the above default configuration file (`~/.gbs.conf`) is automatically installed when GBS is installed.\n\n> **Note**\n>\n> If \"scm/meta/build-config\" git is not cloned in your working directory, every line which starts with \"buildconf=./scm/meta/build-config\" should be removed.\n\nThe default profile used in GBS is specified in the `[general]` section:\n\n```\n[general]\nprofile = profile.unified_standard\n```\n\n> **Note**\n>\n> The default GBS build parameters, based on the above block, are as follows:\n> - Tizen version: 5.0\n> - Profile: unified\n> - Repository: standard\n\n### Setting Up a Specific Profile in the `.gbs.conf` File\n\nTo build using a non-default Tizen version, profile, or repository, select 1 of the profiles specified in the `.gbs.conf` file and set that profile in the `[general]` section, using the following format:\n\n```\n[general]\nprofile = profile.\"$Version\"\"$Profile\"_\"$Repository\"\n```\n\n- If the Tizen version is 3.0, `$Version` equals \"3.0-\".\n- If the Tizen version is 4.0, `$Version` equals \"4.0-\".\n- If the Tizen version is 5.0, `$Version` equals \"\".\n\nOther examples:\n\n- Tizen 5.0 Unified / emulator repository\n\n  ```\n  [general]\n  profile = profile.unified_emulator\n  ```\n\n- Tizen 4.0 Unified / emulator repository\n\n  ```\n  [general]\n  profile = profile.4.0-unified_emulator\n  ```\n\n- Tizen 3.0 Common / arm64-wayland repository\n  ```\n  [general]\n  profile = profile.3.0-common_arm64-wayland\n  ```\n\n- Tizen 3.0 Common / emulator32-wayland repository\n  ```\n  [general]\n  profile = profile.3.0-common_emulator32-wayland\n  ```\n\n- Tizen 3.0 Mobile / target-TM1 repository\n  ```\n  [general]\n  profile = profile.3.0-mobile_target-TM1\n  ```\n\n- Tizen 3.0 TV / arm-wayland repository\n  ```\n  [general]\n  profile = profile.3.0-tv_arm-wayland\n  ```\n\n- Tizen 3.0 Wearable / target-circle repository\n  ```\n  [general]\n  profile = profile.3.0-wearable_target-circle\n  ```\n\n- Tizen 3.0 IVI / emulator repository\n  ```\n  [general]\n  profile = profile.3.0-ivi_emulator\n  ```\n\nEach `profile` entry in the `.gbs.conf` file specifies multiple `repo` entries, and each `repo` entry specifies a URL where RPM files used in the GBS build are located.\n\n> **Note**\n>\n> The `latest` directory in the remote repository URLs is a symbolic link in the remote server, which is always linked to the latest new directory and can be changed any time, so make sure to use the latest repo with a specific date to guarantee usability. An example is shown below:\n> ```\n> url = http://download.tizen.org/releases/daily/tizen/unified/latest/repos/standard/packages/\n> ```\n> This URL is symbolically linked to the latest snapshot number in \"[http://download.tizen.org/releases/daily/tizen/unified/](http://download.tizen.org/releases/daily/tizen/unified/)\". To guarantee usability, use a specific date:\n> ```\n> url = http://download.tizen.org/releases/daily/tizen/unified/tizen-unified_20170627.1/repos/standard/packages/\n> ```\n\nFor more information on `.gbs.conf`, see [GBS Configuration](../reference/gbs/gbs.conf.md).\n\n## Setting Up the Repo Tool\n\nRepo is a repository management tool built on top of Git.  Multiple Git repositories can be downloaded with a single repo command.\n\nTo install and set up the repo tool:\n\n1. Create a `~/bin/` subdirectory, include it in `PATH`, and switch to it:\n\n   ```\n   $ mkdir ~/bin/\n   $ PATH=~/bin:$PATH\n   ```\n\n2. Download the repo script:\n\n   ```\n   $ curl http://commondatastorage.googleapis.com/git-repo-downloads/repo > ~/bin/repo\n   ```\n\n   > **Note**\n   >\n   > If you encounter problems while obtaining the repo tool, see [Development Tips](tips.md).\n\n3. Change the attributes of the repo script to make it executable:\n\n   ```\n   $ sudo chmod a+x ~/bin/repo\n   ```\n\n## Working through a Network Proxy\n\nYou can set up your development environment to work through a network proxy.\n\n> **Note**\n>\n> A network proxy is particularly useful if you also track other Git repositories for which you do not already have a dedicated `ProxyCommand` in your `~/.ssh/config`, or which use \"git://\" or \"http://\".\n\n### Configuring a Proxy\n\nTo configure a proxy through the Linux shell prompt:\n\n1. Open the `.bashrc` file and set the `http_proxy`, `ftp_proxy`, `https_proxy`, and `no_proxy` environment variables:\n   ```\n    export http_proxy=:\n    export ftp_proxy=$http_proxy\n    export https_proxy=:\n    export no_proxy=\n   ```\n\n2. Open `/etc/sudoers` and preserve the environment variables by adding the following content:\n\n    ```\n    Defaults env_keep=\"http_proxy ftp_proxy https_proxy no_proxy\"\n    ```\n\n   > **Note**\n   >\n   > Replace \"=\" with \"+=\" if other `env_keep` settings already exist in `/etc/sudoers`.\n\n\n### Configuring Git Access through the Proxy\n\nTo allow Git access through the proxy:\n\n1. Create a script named `git-proxy` in the `/usr/local/bin` directory by using a text editor.\n\n   The following example uses VIM:\n\n   ```\n   $ sudo vim /usr/local/bin/git-proxy\n   ```\n\n2. Add the following lines into the file and save it:\n\n   ```\n   #!/bin/bash\n\n   PROXY=\n   PORT=\n\n   case $1 in\n   # list Git servers here that you do not want to use\n   # the proxy with, separated by a pipe character '|' as below:\n\n   review.tizen.org)\n   METHOD=\"-X connect\"\n   ;;\n   *)\n   METHOD=\"-X 5 -x ${PROXY}:${PORT}\"\n   #The line above is applicable to Ubuntu and openSUSE\n   #For Fedora, use the variation below since it only supports socks v4\n   #METHOD=\"-X 4 -x ${PROXY}:${PORT}\"\n   ;;\n   esac\n\n   nc $METHOD $*\n   ```\n\n3. Change the attributes of the `git-proxy` script to make it executable:\n\n   ```\n   $ sudo chmod +x /usr/local/bin/git-proxy\n   ```\n\n4. Set the `GIT_PROXY_COMMAND` and `GIT_PROXY_IGNORE` environment variables by adding the following lines into the `.bashrc` file:\n\n   ```\n   export GIT_PROXY_COMMAND=/usr/local/bin/git-proxy\n   export GIT_PROXY_IGNORE=\n   ```\n\n5. Apply the changes:\n\n   ```\n   $ source ~/.bashrc\n   ```"
					}
					
				
			
		
			
				
					,
					
					"platform-developing-setting-up": {
						"id": "platform-developing-setting-up",
						"title": "Setting up the Development Environment",
						"categories": "",
						"url": " platform/developing/setting-up/",
						"content": "# Setting up the Development Environment\n\nThis topic provides information on how to set up a development environment.\n\n> **Note**\n>\n> If you encounter problems while obtaining the repo tool, see [Development Tips](tips.md).\n\n## Setting Up Gerrit Access\n\nYou can set up access to [Tizen Gerrit](http://review.tizen.org/gerrit/) through the following steps:\n\n1. Register a user account to gain access to tizen.org.\n2. Configure Secure Shell (SSH) for Gerrit access.\n3. Configure Git for Gerrit access.\n\n### Registering a User Account\n\nTo register a user account to gain access to tizen.org:\n\n1. Open the [Register page](https://www.tizen.org/user/register).\n\n2. Fill in the mandatory fields and other necessary information, and click **Register**.\n\n   Gerrit sends a verification email to the email address you have provided.\n\n3. Follow the instructions in the verification email to verify the email address, change the password, and gain access to tizen.org.\n   > **Note**\n   >\n   >  If an error message is shown when you click the link in the verification email, copy the link to the address bar of the browser manually.\n\nAt this point, the prerequisites for accessing Gerrit are ready. Move on to the next section to enable Gerrit access.\n\n### Configuring SSH for Gerrit Access\n\nTo configure SSH for Gerrit access:\n\n1. Generate RSA keys:\n\n   ```\n   $ ssh-keygen [-t rsa] [-C \"\"]\n   ```\n\n   > **Note**\n   >\n   > `[-t rsa]` and `[-C \"\"]` are both optional arguments for the `ssh-keygen` command.\n   >\n   > If invoked without specifying key type, `ssh-keygen` generates an RSA key for use in SSH protocol 2 connections, thus making `[-t rsa]`, which specifies the key type, optional.\n   >\n   > For an RSA key, if invoked without adding any comment, `ssh-keygen` initializes the comment as \"@\" when the key is generated, thus making `[-C \"\"]` optional. In spite of this, adding this argument is recommended because a rephrased comment can make it easier to identify the keys.\n\n   Based on the on-screen prompts, specify the file in which to save the key, and the passphrase.\n\n   ```\n   Enter file in which to save the key (/home//.ssh/id_rsa):\n   Enter passphrase (empty for no passphrase):\n   Enter same passphrase again:\n   ```\n\n   If you press ENTER directly for the file, the default value `/home//.ssh/id_rsa` is used. If you press ENTER directly for the passphrase, no passphrase is used.\n\n   At this point, the SSH keys are successfully generated.\n\n2. Create an SSH configuration file, `~/.ssh/config`, and add 1 of the following, as appropriate:\n\n   - Ubuntu, openSUSE, CentOS, or Debian:\n\n     ```\n     Host tizen review.tizen.org\n     Hostname review.tizen.org\n     IdentityFile ~/.ssh/id_rsa\n     User \n     Port 29418\n     # Add the line below when using proxy, otherwise, skip it\n     # ProxyCommand nc -X5 -x : %h %p\n     ```\n\n   - Fedora:\n\n     ```\n     Host tizen review.tizen.org\n     Hostname review.tizen.org\n     IdentityFile ~/.ssh/id_rsaUser \n     Port 29418\n     # Add the line below when using proxy, otherwise, skip it\n     # ProxyCommand nc --proxy-type socks4 --proxy : %h %p\n     ```\n\n   > **Note**\n   >\n   > - Both \"tizen\" and \"review.tizen.org\" are aliases of the hostname. \"tizen\" is configured for simplicity of commands when initializing Git repositories and cloning specific Tizen projects, and \"review.tizen.org\" is configured to work with the `manifest.xml` and `_remote.xml` files when synchronizing the entire Tizen source.\n   >\n   > - The `~/.ssh/config` file must not be written in by other users. Make sure to remove the write permission by executing `chmod o-w ~/.ssh/config`. For more information on `ssh_config`, see `man ssh_config`.\n\n3. Copy the full text in `~/.ssh/id_rsa.pub`, including all of the following:\n\n   - `ssh-rsa` lead\n   - SSH public key\n   - Email address tail\n\n4. Log in to [Tizen Gerrit](http://review.tizen.org/gerrit/) and upload the key:\n\n   1. In the Gerrit Web page, click the user name on the top right corner (with an inverted triangle on the right), and select **Settings**.\n   2. Click **SSH Public Keys** in the left panel, paste the text copied earlier into the **Add SSH Public Key** box, and click **Add**.\n\n5. Verify the SSH connection:\n\n   ```\n   $ ssh tizen\n   ```\n\n   The following message indicates that SSH connection has been established successfully:\n\n   ```\n   **** Welcome to Gerrit Code Review ****\n   ```\n\n### Configuring Git for Gerrit Access\n\nGit must know the user's name and email address to determine the author of each commit. If the user name or email address is not set up in a way that Git can find it, the user can encounter some odd warnings.\n\nThis configuration operation requires developer access. In addition, it is recommended to match the email address with the one registered in contact information, which helps Git identify the user.\n\nTo configure Git for Gerrit access:\n\n1. Set the user name by executing the following command:\n   ```\n   $ git config --global user.name \n   ```\n2. Set the email address by executing the following command:\n   ```\n   $ git config --global user.email \"\"\n   ```\n\n> **Note**\n>\n> Using the `GIT_AUTHOR_NAME` and `GIT_AUTHOR_EMAIL` environment variables is an alternative solution. These variables override all configuration settings once set.\n\n## Setting Up the GBS Configuration\n\nYou can set up the GBS configuration through editing the `.gbs.conf` file.\n\n### Setting Up the Default GBS Configuration File\n\nThe default GBS configuration file is located in `~/.gbs.conf`:\n\n```\n[general]\nprofile = profile.3.0-mobile_target-TM1\n\n\n#########################################################\n################## Profile Section ##################\n#########################################################\n\n############# 5.0-unified #############\n[profile.unified_standard]\nbuildconf=./scm/meta/build-config/unified/standard_build.conf\nrepos = repo.base_standard,repo.base_standard_debug,repo.unified_standard,repo.unified_standard_debug\n\n[profile.unified_emulator]\nbuildconf=./scm/meta/build-config/unified/emulator_build.conf\nrepos = repo.base_standard,repo.base_standard_debug,repo.unified_emulator,repo.unified_emulator_debug\n\n############# 4.0-unified #############\n[profile.4.0-unified_standard]\nbuildconf=./scm/meta/build-config/4.0/unified/standard_build.conf\nrepos = repo.4.0-base_arm,repo.4.0-base_arm_debug,repo.4.0-base_arm64,repo.4.0-base_arm64_debug,repo.4.0-base_ia32,repo.4.0-base_ia32_debug,repo.4.0-base_x86_64,repo.4.0-base_x86_64_debug,repo.4.0-unified_standard,repo.4.0-unified_standard_debug\n\n[profile.4.0-unified_emulator]\nbuildconf=./scm/meta/build-config/4.0/unified/emulator_build.conf\nrepos = repo.4.0-base_ia32,repo.4.0-base_ia32_debug,repo.4.0-base_x86_64,repo.4.0-base_x86_64_debug,repo.4.0-unified_emulator,repo.4.0-unified_emulator_debug\n\n############# 3.0-common #############\n[profile.3.0-common_x86_64-wayland]\nbuildconf=./scm/meta/build-config/3.0/common/x86_64-wayland_build.conf\nrepos = repo.3.0-base_x86_64,repo.3.0-base_x86_64_debug,repo.3.0-common_x86_64-wayland,repo.3.0-common_x86_64-wayland_debug\n\n[profile.3.0-common_ia32-wayland]\nbuildconf=./scm/meta/build-config/3.0/common/ia32-wayland_build.conf\nrepos = repo.3.0-base_ia32,repo.3.0-base_ia32_debug,repo.3.0-common_ia32-wayland,repo.3.0-common_ia32-wayland_debug\n\n[profile.3.0-common_emulator32-wayland]\nbuildconf=./scm/meta/build-config/3.0/common/emulator32-wayland_build.conf\nrepos = repo.3.0-base_emulator32,repo.3.0-base_emulator32_debug,repo.3.0-common_emulator32-wayland,repo.3.0-common_emulator32-wayland_debug\n\n[profile.3.0-common_arm64-wayland]\nbuildconf=./scm/meta/build-config/3.0/common/arm64-wayland_build.conf\nrepos = repo.3.0-base_arm64,repo.3.0-base_arm64_debug,repo.3.0-common_arm64-wayland,repo.3.0-common_arm64-wayland_debug\n\n[profile.3.0-common_arm-wayland]\nbuildconf=./scm/meta/build-config/3.0/common/arm-wayland_build.conf\nrepos = repo.3.0-base_arm,repo.3.0-base_arm_debug,repo.3.0-common_arm-wayland,repo.3.0-common_arm-wayland_debug\n\n############# 3.0-mobile #############\n[profile.3.0-mobile_target-TM1]\nbuildconf=./scm/meta/build-config/3.0/mobile/target-TM1_build.conf\nrepos = repo.3.0-base_arm,repo.3.0-base_arm_debug,repo.3.0-mobile_target-TM1,repo.3.0-mobile_target-TM1_debug\n\n[profile.3.0-mobile_emulator32-wayland]\nbuildconf=./scm/meta/build-config/3.0/mobile/emulator32-wayland_build.conf\nrepos = repo.3.0-base_emulator32,repo.3.0-base_emulator32_debug,repo.3.0-mobile_emulator32-wayland,repo.3.0-mobile_emulator32-wayland_debug\n\n[profile.3.0-mobile_arm-wayland]\nbuildconf=./scm/meta/build-config/3.0/mobile/arm-wayland_build.conf\nrepos = repo.3.0-base_arm,repo.3.0-base_arm_debug,repo.3.0-mobile_arm-wayland,repo.3.0-mobile_arm-wayland_debug\n\n############# 3.0-tv #############\n[profile.3.0-tv_emulator64-wayland]\nbuildconf=./scm/meta/build-config/3.0/tv/emulator64-wayland_build.conf\nrepos = repo.3.0-base_emulator64,repo.3.0-base_emulator64_debug,repo.3.0-tv_emulator64-wayland,repo.3.0-tv_emulator64-wayland_debug\n\n[profile.3.0-tv_emulator32-wayland]\nbuildconf=./scm/meta/build-config/3.0/tv/emulator32-wayland_build.conf\nrepos = repo.3.0-base_emulator32,repo.3.0-base_emulator32_debug,repo.3.0-tv_emulator32-wayland,repo.3.0-tv_emulator32-wayland_debug\n\n[profile.3.0-tv_arm-wayland]\nbuildconf=./scm/meta/build-config/3.0/tv/arm-wayland_build.conf\nrepos = repo.3.0-base_arm,repo.3.0-base_arm_debug,repo.3.0-tv_arm-wayland,repo.3.0-tv_arm-wayland_debug\n\n############# 3.0-wearable #############\n[profile.3.0-wearable_target-circle]\nbuildconf=./scm/meta/build-config/3.0/wearable/target-circle_build.conf\nrepos = repo.3.0-base_arm,repo.3.0-base_arm_debug,repo.3.0-wearable_target-circle,repo.3.0-wearable_target-circle_debug\n\n[profile.3.0-wearable_emulator32-wayland]\nbuildconf=./scm/meta/build-config/3.0/wearable/emulator32-wayland_build.conf\nrepos = repo.3.0-base_emulator32,repo.3.0-base_emulator32_debug,repo.3.0-wearable_emulator32-wayland,repo.3.0-wearable_emulator32-wayland_debug\n\n[profile.3.0-wearable_emulator-circle]\nbuildconf=./scm/meta/build-config/3.0/wearable/emulator-circle_build.conf\nrepos = repo.3.0-base_emulator32,repo.3.0-base_emulator32_debug,repo.3.0-wearable_emulator-circle,repo.3.0-wearable_emulator-circle_debug\n\n############# 3.0-ivi #############\n[profile.3.0-ivi_emulator]\nbuildconf=./scm/meta/build-config/3.0/ivi/emulator_build.conf\nrepos = repo.3.0-base_emulator32,repo.3.0-base_emulator32_debug,repo.3.0-ivi_emulator,repo.3.0-ivi_emulator_debug\n\n[profile.3.0-ivi_arm]\nbuildconf=./scm/meta/build-config/3.0/ivi/arm_build.conf\nrepos = repo.3.0-base_arm,repo.3.0-base_arm_debug,repo.3.0-ivi_arm,repo.3.0-ivi_arm_debug\n\n\n\n#########################################################\n################## Repo Section##################\n#########################################################\n\n############# base #############\n[repo.base_standard]\nurl = http://download.tizen.org/releases/daily/tizen/base/latest/repos/standard/packages/\n[repo.base_standard_debug]\nurl = http://download.tizen.org/releases/daily/tizen/base/latest/repos/standard/debug/\n\n############# 4.0-base #############\n[repo.4.0-base_x86_64]\nurl = http://download.tizen.org/releases/daily/tizen/4.0-base/latest/repos/x86_64/packages/\n[repo.4.0-base_x86_64_debug]\nurl = http://download.tizen.org/releases/daily/tizen/4.0-base/latest/repos/x86_64/debug/\n\n[repo.4.0-base_ia32]\nurl = http://download.tizen.org/releases/daily/tizen/4.0-base/latest/repos/ia32/packages/\n[repo.4.0-base_ia32_debug]\nurl = http://download.tizen.org/releases/daily/tizen/4.0-base/latest/repos/ia32/debug/\n\n[repo.4.0-base_emulator64]\nurl = http://download.tizen.org/releases/daily/tizen/4.0-base/latest/repos/emulator64/packages/\n[repo.4.0-base_emulator64_debug]\nurl = http://download.tizen.org/releases/daily/tizen/4.0-base/latest/repos/emulator64/debug/\n\n[repo.4.0-base_emulator32]\nurl = http://download.tizen.org/releases/daily/tizen/4.0-base/latest/repos/emulator32/packages/\n[repo.4.0-base_emulator32_debug]\nurl = http://download.tizen.org/releases/daily/tizen/4.0-base/latest/repos/emulator32/debug/\n\n[repo.4.0-base_arm64]\nurl = http://download.tizen.org/releases/daily/4.0-base/latest/repos/arm64/packages/\n[repo.4.0-base_arm64_debug]\nurl = http://download.tizen.org/releases/daily/tizen/4.0-base/latest/repos/arm64/debug/\n\n[repo.4.0-base_arm]\nurl = http://download.tizen.org/releases/daily/tizen/4.0-base/latest/repos/arm/packages/\n[repo.4.0-base_arm_debug]\nurl = http://download.tizen.org/releases/daily/tizen/4.0-base/latest/repos/arm/debug/\n\n############# 3.0-base #############\n[repo.3.0-base_x86_64]\nurl = http://download.tizen.org/releases/daily/tizen/3.0-base/latest/repos/x86_64/packages/\n[repo.3.0-base_x86_64_debug]\nurl = http://download.tizen.org/releases/daily/tizen/3.0-base/latest/repos/x86_64/debug/\n\n[repo.3.0-base_ia32]\nurl = http://download.tizen.org/releases/daily/tizen/3.0-base/latest/repos/ia32/packages/\n[repo.3.0-base_ia32_debug]\nurl = http://download.tizen.org/releases/daily/tizen/3.0-base/latest/repos/ia32/debug/\n\n[repo.3.0-base_emulator64]\nurl = http://download.tizen.org/releases/daily/tizen/3.0-base/latest/repos/emulator64/packages/\n[repo.3.0-base_emulator64_debug]\nurl = http://download.tizen.org/releases/daily/tizen/3.0-base/latest/repos/emulator64/debug/\n\n[repo.3.0-base_emulator32]\nurl = http://download.tizen.org/releases/daily/tizen/3.0-base/latest/repos/emulator32/packages/\n[repo.3.0-base_emulator32_debug]\nurl = http://download.tizen.org/releases/daily/tizen/3.0-base/latest/repos/emulator32/debug/\n\n[repo.3.0-base_arm64]\nurl = http://download.tizen.org/releases/daily/tizen/3.0-base/latest/repos/arm64/packages/\n[repo.3.0-base_arm64_debug]\nurl = http://download.tizen.org/releases/daily/tizen/3.0-base/latest/repos/arm64/debug/\n\n[repo.3.0-base_arm]\nurl = http://download.tizen.org/releases/daily/tizen/3.0-base/latest/repos/arm/packages/\n[repo.3.0-base_arm_debug]\nurl = http://download.tizen.org/releases/daily/tizen/3.0-base/latest/repos/arm/debug/\n\n############# 5.0-unified #############\n[repo.unified_standard]\nurl = http://download.tizen.org/releases/daily/tizen/unified/latest/repos/standard/packages/\n[repo.unified_standard_debug]\nurl = http://download.tizen.org/releases/daily/tizen/unified/latest/repos/standard/debug/\n\n[repo.unified_emulator]\nurl = http://download.tizen.org/releases/daily/tizen/unified/latest/repos/emulator/packages/\n[repo.unified_emulator_debug]\nurl = http://download.tizen.org/releases/daily/tizen/unified/latest/repos/emulator/debug/\n\n############# 4.0-unified #############\n[repo.4.0-unified_standard]\nurl = http://download.tizen.org/releases/daily/tizen/4.0-unified/latest/repos/standard/packages/\n[repo.4.0-unified_standard_debug]\nurl = http://download.tizen.org/releases/daily/tizen/4.0-unified/latest/repos/standard/debug/\n\n[repo.4.0-unified_emulator]\nurl = http://download.tizen.org/releases/daily/tizen/4.0-unified/latest/repos/emulator/packages/\n[repo.4.0-unified_emulator_debug]\nurl = http://download.tizen.org/releases/daily/tizen/4.0-unified/latest/repos/emulator/debug/\n\n############# 3.0-common #############\n[repo.3.0-common_x86_64-wayland]\nurl = http://download.tizen.org/releases/daily/tizen/3.0-common/latest/repos/x86_64-wayland/packages/\n[repo.3.0-common_x86_64-wayland_debug]\nurl = http://download.tizen.org/releases/daily/tizen/3.0-common/latest/repos/x86_64-wayland/debug/\n\n[repo.3.0-common_ia32-wayland]\nurl = http://download.tizen.org/releases/daily/tizen/3.0-common/latest/repos/ia32-wayland/packages/\n[repo.3.0-common_ia32-wayland_debug]\nurl = http://download.tizen.org/releases/daily/tizen/3.0-common/latest/repos/ia32-wayland/debug/\n\n[repo.3.0-common_emulator32-wayland]\nurl = http://download.tizen.org/releases/daily/tizen/3.0-common/latest/repos/emulator32-wayland/packages/\n[repo.3.0-common_emulator32-wayland_debug]\nurl = http://download.tizen.org/releases/daily/tizen/3.0-common/latest/repos/emulator32-wayland/debug/\n\n[repo.3.0-common_arm64-wayland]\nurl = http://download.tizen.org/releases/daily/tizen/3.0-common/latest/repos/arm64-wayland/packages/\n[repo.3.0-common_arm64-wayland_debug]\nurl = http://download.tizen.org/releases/daily/tizen/3.0-common/latest/repos/arm64-wayland/debug/\n\n[repo.3.0-common_arm-wayland]\nurl = http://download.tizen.org/releases/daily/tizen/3.0-common/latest/repos/arm-wayland/packages/\n[repo.3.0-common_arm-wayland_debug]\nurl = http://download.tizen.org/releases/daily/tizen/3.0-common/latest/repos/arm-wayland/debug/\n\n############# 3.0-mobile #############\n[repo.3.0-mobile_target-TM1]\nurl = http://download.tizen.org/releases/daily/tizen/3.0-mobile/latest/repos/target-TM1/packages/\n[repo.3.0-mobile_target-TM1_debug]\nurl = http://download.tizen.org/releases/daily/tizen/3.0-mobile/latest/repos/target-TM1/debug/\n\n[repo.3.0-mobile_emulator32-wayland]\nurl = http://download.tizen.org/releases/daily/tizen/3.0-mobile/latest/repos/emulator32-wayland/packages/\n[repo.3.0-mobile_emulator32-wayland_debug]\nurl = http://download.tizen.org/releases/daily/tizen/3.0-mobile/latest/repos/emulator32-wayland/debug/\n\n[repo.3.0-mobile_arm-wayland]\nurl = http://download.tizen.org/releases/daily/tizen/3.0-mobile/latest/repos/arm-wayland/packages/\n[repo.3.0-mobile_arm-wayland_debug]\nurl = http://download.tizen.org/releases/daily/tizen/3.0-mobile/latest/repos/arm-wayland/debug/\n\n############# 3.0-tv #############\n[repo.3.0-tv_emulator64-wayland]\nurl = http://download.tizen.org/releases/daily/tizen/3.0-tv/latest/repos/emulator64-wayland/packages/\n[repo.3.0-tv_emulator64-wayland_debug]\nurl = http://download.tizen.org/releases/daily/tizen/3.0-tv/latest/repos/emulator64-wayland/debug/\n\n[repo.3.0-tv_emulator32-wayland]\nurl = http://download.tizen.org/releases/daily/tizen/3.0-tv/latest/repos/emulator32-wayland/packages/\n[repo.3.0-tv_emulator32-wayland_debug]\nurl = http://download.tizen.org/releases/daily/tizen/3.0-tv/latest/repos/emulator32-wayland/debug/\n\n[repo.3.0-tv_arm-wayland]\nurl = http://download.tizen.org/releases/daily/tizen/3.0-tv/latest/repos/arm-wayland/packages/\n[repo.3.0-tv_arm-wayland_debug]\nurl = http://download.tizen.org/releases/daily/tizen/3.0-tv/latest/repos/arm-wayland/debug/\n\n############# 3.0-wearable #############\n[repo.3.0-wearable_target-circle]\nurl = http://download.tizen.org/releases/daily/tizen/3.0-wearable/latest/repos/target-circle/packages/\n[repo.3.0-wearable_target-circle_debug]\nurl = http://download.tizen.org/releases/daily/tizen/3.0-wearable/latest/repos/target-circle/debug/\n\n[repo.3.0-wearable_emulator32-wayland]\nurl = http://download.tizen.org/releases/daily/tizen/3.0-wearable/latest/repos/emulator32-wayland/packages/\n[repo.3.0-wearable_emulator32-wayland_debug]\nurl = http://download.tizen.org/releases/daily/tizen/3.0-wearable/latest/repos/emulator32-wayland/debug/\n\n[repo.3.0-wearable_emulator-circle]\nurl = http://download.tizen.org/releases/daily/tizen/3.0-wearable/latest/repos/emulator-circle/packages/\n[repo.3.0-wearable_emulator-circle_debug]\nurl = http://download.tizen.org/releases/daily/tizen/3.0-wearable/latest/repos/emulator-circle/debug/\n\n############# 3.0-ivi #############\n[repo.3.0-ivi_emulator]\nurl = http://download.tizen.org/releases/daily/tizen/3.0-ivi/latest/repos/emulator/packages/\n[repo.3.0-ivi_emulator_debug]\nurl = http://download.tizen.org/releases/daily/tizen/3.0-ivi/latest/repos/emulator/debug/\n\n[repo.3.0-ivi_arm]\nurl = http://download.tizen.org/releases/daily/tizen/3.0-ivi/latest/repos/arm/packages/\n[repo.3.0-ivi_arm_debug]\nurl = http://download.tizen.org/releases/daily/tizen/3.0-ivi/latest/repos/arm/debug/\n```\n\n> **Note**\n>\n> The file contains the GBS configuration for all profiles and repositories in Tizen version 3.0, Tizen version 4.0 and Tizen version 5.0. In the near future in new GBS versions, the above default configuration file (`~/.gbs.conf`) is automatically installed when GBS is installed.\n\n> **Note**\n>\n> If \"scm/meta/build-config\" git is not cloned in your working directory, every line which starts with \"buildconf=./scm/meta/build-config\" should be removed.\n\nThe default profile used in GBS is specified in the `[general]` section:\n\n```\n[general]\nprofile = profile.unified_standard\n```\n\n> **Note**\n>\n> The default GBS build parameters, based on the above block, are as follows:\n> - Tizen version: 5.0\n> - Profile: unified\n> - Repository: standard\n\n### Setting Up a Specific Profile in the `.gbs.conf` File\n\nTo build using a non-default Tizen version, profile, or repository, select 1 of the profiles specified in the `.gbs.conf` file and set that profile in the `[general]` section, using the following format:\n\n```\n[general]\nprofile = profile.\"$Version\"\"$Profile\"_\"$Repository\"\n```\n\n- If the Tizen version is 3.0, `$Version` equals \"3.0-\".\n- If the Tizen version is 4.0, `$Version` equals \"4.0-\".\n- If the Tizen version is 5.0, `$Version` equals \"\".\n\nOther examples:\n\n- Tizen 5.0 Unified / emulator repository\n\n  ```\n  [general]\n  profile = profile.unified_emulator\n  ```\n\n- Tizen 4.0 Unified / emulator repository\n\n  ```\n  [general]\n  profile = profile.4.0-unified_emulator\n  ```\n\n- Tizen 3.0 Common / arm64-wayland repository\n  ```\n  [general]\n  profile = profile.3.0-common_arm64-wayland\n  ```\n\n- Tizen 3.0 Common / emulator32-wayland repository\n  ```\n  [general]\n  profile = profile.3.0-common_emulator32-wayland\n  ```\n\n- Tizen 3.0 Mobile / target-TM1 repository\n  ```\n  [general]\n  profile = profile.3.0-mobile_target-TM1\n  ```\n\n- Tizen 3.0 TV / arm-wayland repository\n  ```\n  [general]\n  profile = profile.3.0-tv_arm-wayland\n  ```\n\n- Tizen 3.0 Wearable / target-circle repository\n  ```\n  [general]\n  profile = profile.3.0-wearable_target-circle\n  ```\n\n- Tizen 3.0 IVI / emulator repository\n  ```\n  [general]\n  profile = profile.3.0-ivi_emulator\n  ```\n\nEach `profile` entry in the `.gbs.conf` file specifies multiple `repo` entries, and each `repo` entry specifies a URL where RPM files used in the GBS build are located.\n\n> **Note**\n>\n> The `latest` directory in the remote repository URLs is a symbolic link in the remote server, which is always linked to the latest new directory and can be changed any time, so make sure to use the latest repo with a specific date to guarantee usability. An example is shown below:\n> ```\n> url = http://download.tizen.org/releases/daily/tizen/unified/latest/repos/standard/packages/\n> ```\n> This URL is symbolically linked to the latest snapshot number in \"[http://download.tizen.org/releases/daily/tizen/unified/](http://download.tizen.org/releases/daily/tizen/unified/)\". To guarantee usability, use a specific date:\n> ```\n> url = http://download.tizen.org/releases/daily/tizen/unified/tizen-unified_20170627.1/repos/standard/packages/\n> ```\n\nFor more information on `.gbs.conf`, see [GBS Configuration](../reference/gbs/gbs.conf.md).\n\n## Setting Up the Repo Tool\n\nRepo is a repository management tool built on top of Git.  Multiple Git repositories can be downloaded with a single repo command.\n\nTo install and set up the repo tool:\n\n1. Create a `~/bin/` subdirectory, include it in `PATH`, and switch to it:\n\n   ```\n   $ mkdir ~/bin/\n   $ PATH=~/bin:$PATH\n   ```\n\n2. Download the repo script:\n\n   ```\n   $ curl http://commondatastorage.googleapis.com/git-repo-downloads/repo > ~/bin/repo\n   ```\n\n   > **Note**\n   >\n   > If you encounter problems while obtaining the repo tool, see [Development Tips](tips.md).\n\n3. Change the attributes of the repo script to make it executable:\n\n   ```\n   $ sudo chmod a+x ~/bin/repo\n   ```\n\n## Working through a Network Proxy\n\nYou can set up your development environment to work through a network proxy.\n\n> **Note**\n>\n> A network proxy is particularly useful if you also track other Git repositories for which you do not already have a dedicated `ProxyCommand` in your `~/.ssh/config`, or which use \"git://\" or \"http://\".\n\n### Configuring a Proxy\n\nTo configure a proxy through the Linux shell prompt:\n\n1. Open the `.bashrc` file and set the `http_proxy`, `ftp_proxy`, `https_proxy`, and `no_proxy` environment variables:\n   ```\n    export http_proxy=:\n    export ftp_proxy=$http_proxy\n    export https_proxy=:\n    export no_proxy=\n   ```\n\n2. Open `/etc/sudoers` and preserve the environment variables by adding the following content:\n\n    ```\n    Defaults env_keep=\"http_proxy ftp_proxy https_proxy no_proxy\"\n    ```\n\n   > **Note**\n   >\n   > Replace \"=\" with \"+=\" if other `env_keep` settings already exist in `/etc/sudoers`.\n\n\n### Configuring Git Access through the Proxy\n\nTo allow Git access through the proxy:\n\n1. Create a script named `git-proxy` in the `/usr/local/bin` directory by using a text editor.\n\n   The following example uses VIM:\n\n   ```\n   $ sudo vim /usr/local/bin/git-proxy\n   ```\n\n2. Add the following lines into the file and save it:\n\n   ```\n   #!/bin/bash\n\n   PROXY=\n   PORT=\n\n   case $1 in\n   # list Git servers here that you do not want to use\n   # the proxy with, separated by a pipe character '|' as below:\n\n   review.tizen.org)\n   METHOD=\"-X connect\"\n   ;;\n   *)\n   METHOD=\"-X 5 -x ${PROXY}:${PORT}\"\n   #The line above is applicable to Ubuntu and openSUSE\n   #For Fedora, use the variation below since it only supports socks v4\n   #METHOD=\"-X 4 -x ${PROXY}:${PORT}\"\n   ;;\n   esac\n\n   nc $METHOD $*\n   ```\n\n3. Change the attributes of the `git-proxy` script to make it executable:\n\n   ```\n   $ sudo chmod +x /usr/local/bin/git-proxy\n   ```\n\n4. Set the `GIT_PROXY_COMMAND` and `GIT_PROXY_IGNORE` environment variables by adding the following lines into the `.bashrc` file:\n\n   ```\n   export GIT_PROXY_COMMAND=/usr/local/bin/git-proxy\n   export GIT_PROXY_IGNORE=\n   ```\n\n5. Apply the changes:\n\n   ```\n   $ source ~/.bashrc\n   ```"
					}
					
				
			
		
			
				
					,
					
					"iot-developing-setting-up": {
						"id": "iot-developing-setting-up",
						"title": "Setting up the Development Environment",
						"categories": "",
						"url": " iot/developing/setting-up/",
						"content": "# Setting up the Development Environment\n\nThis topic provides information on how to set up a development environment.\n\n> **Note**\n>\n> If you encounter problems while obtaining the repo tool, see [Development Tips](tips.md).\n\n## Setting Up Gerrit Access\n\nYou can set up access to [Tizen Gerrit](http://review.tizen.org/gerrit/) through the following steps:\n\n1. Register a user account to gain access to tizen.org.\n2. Configure Secure Shell (SSH) for Gerrit access.\n3. Configure Git for Gerrit access.\n\n### Registering a User Account\n\nTo register a user account to gain access to tizen.org:\n\n1. Open the [Register page](https://www.tizen.org/user/register).\n\n2. Fill in the mandatory fields and other necessary information, and click **Register**.\n\n   Gerrit sends a verification email to the email address you have provided.\n\n3. Follow the instructions in the verification email to verify the email address, change the password, and gain access to tizen.org.\n   > **Note**\n   >\n   >  If an error message is shown when you click the link in the verification email, copy the link to the address bar of the browser manually.\n\nAt this point, the prerequisites for accessing Gerrit are ready. Move on to the next section to enable Gerrit access.\n\n### Configuring SSH for Gerrit Access\n\nTo configure SSH for Gerrit access:\n\n1. Generate RSA keys:\n\n   ```\n   $ ssh-keygen [-t rsa] [-C \"\"]\n   ```\n\n   > **Note**\n   >\n   > `[-t rsa]` and `[-C \"\"]` are both optional arguments for the `ssh-keygen` command.\n   >\n   > If invoked without specifying key type, `ssh-keygen` generates an RSA key for use in SSH protocol 2 connections, thus making `[-t rsa]`, which specifies the key type, optional.\n   >\n   > For an RSA key, if invoked without adding any comment, `ssh-keygen` initializes the comment as \"@\" when the key is generated, thus making `[-C \"\"]` optional. In spite of this, adding this argument is recommended because a rephrased comment can make it easier to identify the keys.\n\n   Based on the on-screen prompts, specify the file in which to save the key, and the passphrase.\n\n   ```\n   Enter file in which to save the key (/home//.ssh/id_rsa):\n   Enter passphrase (empty for no passphrase):\n   Enter same passphrase again:\n   ```\n\n   If you press ENTER directly for the file, the default value `/home//.ssh/id_rsa` is used. If you press ENTER directly for the passphrase, no passphrase is used.\n\n   At this point, the SSH keys are successfully generated.\n\n2. Create an SSH configuration file, `~/.ssh/config`, and add 1 of the following, as appropriate:\n\n   - Ubuntu, openSUSE, CentOS, or Debian:\n\n     ```\n     Host tizen review.tizen.org\n     Hostname review.tizen.org\n     IdentityFile ~/.ssh/id_rsa\n     User \n     Port 29418\n     # Add the line below when using proxy, otherwise, skip it\n     # ProxyCommand nc -X5 -x : %h %p\n     ```\n\n   - Fedora:\n\n     ```\n     Host tizen review.tizen.org\n     Hostname review.tizen.org\n     IdentityFile ~/.ssh/id_rsaUser \n     Port 29418\n     # Add the line below when using proxy, otherwise, skip it\n     # ProxyCommand nc --proxy-type socks4 --proxy : %h %p\n     ```\n\n   > **Note**\n   >\n   > - Both \"tizen\" and \"review.tizen.org\" are aliases of the hostname. \"tizen\" is configured for simplicity of commands when initializing Git repositories and cloning specific Tizen projects, and \"review.tizen.org\" is configured to work with the `manifest.xml` and `_remote.xml` files when synchronizing the entire Tizen source.\n   >\n   > - The `~/.ssh/config` file must not be written in by other users. Make sure to remove the write permission by executing `chmod o-w ~/.ssh/config`. For more information on `ssh_config`, see `man ssh_config`.\n\n3. Copy the full text in `~/.ssh/id_rsa.pub`, including all of the following:\n\n   - `ssh-rsa` lead\n   - SSH public key\n   - Email address tail\n\n4. Log in to [Tizen Gerrit](http://review.tizen.org/gerrit/) and upload the key:\n\n   1. In the Gerrit Web page, click the user name on the top right corner (with an inverted triangle on the right), and select **Settings**.\n   2. Click **SSH Public Keys** in the left panel, paste the text copied earlier into the **Add SSH Public Key** box, and click **Add**.\n\n5. Verify the SSH connection:\n\n   ```\n   $ ssh tizen\n   ```\n\n   The following message indicates that SSH connection has been established successfully:\n\n   ```\n   **** Welcome to Gerrit Code Review ****\n   ```\n\n### Configuring Git for Gerrit Access\n\nGit must know the user's name and email address to determine the author of each commit. If the user name or email address is not set up in a way that Git can find it, the user can encounter some odd warnings.\n\nThis configuration operation requires developer access. In addition, it is recommended to match the email address with the one registered in contact information, which helps Git identify the user.\n\nTo configure Git for Gerrit access:\n\n1. Set the user name by executing the following command:\n   ```\n   $ git config --global user.name \n   ```\n2. Set the email address by executing the following command:\n   ```\n   $ git config --global user.email \"\"\n   ```\n\n> **Note**\n>\n> Using the `GIT_AUTHOR_NAME` and `GIT_AUTHOR_EMAIL` environment variables is an alternative solution. These variables override all configuration settings once set.\n\n## Setting Up the GBS Configuration\n\nYou can set up the GBS configuration through editing the `.gbs.conf` file.\n\n### Setting Up the Default GBS Configuration File\n\nThe default GBS configuration file is located in `~/.gbs.conf`:\n\n```\n[general]\nprofile = profile.3.0-mobile_target-TM1\n\n\n#########################################################\n################## Profile Section ##################\n#########################################################\n\n############# 5.0-unified #############\n[profile.unified_standard]\nbuildconf=./scm/meta/build-config/unified/standard_build.conf\nrepos = repo.base_standard,repo.base_standard_debug,repo.unified_standard,repo.unified_standard_debug\n\n[profile.unified_emulator]\nbuildconf=./scm/meta/build-config/unified/emulator_build.conf\nrepos = repo.base_standard,repo.base_standard_debug,repo.unified_emulator,repo.unified_emulator_debug\n\n############# 4.0-unified #############\n[profile.4.0-unified_standard]\nbuildconf=./scm/meta/build-config/4.0/unified/standard_build.conf\nrepos = repo.4.0-base_arm,repo.4.0-base_arm_debug,repo.4.0-base_arm64,repo.4.0-base_arm64_debug,repo.4.0-base_ia32,repo.4.0-base_ia32_debug,repo.4.0-base_x86_64,repo.4.0-base_x86_64_debug,repo.4.0-unified_standard,repo.4.0-unified_standard_debug\n\n[profile.4.0-unified_emulator]\nbuildconf=./scm/meta/build-config/4.0/unified/emulator_build.conf\nrepos = repo.4.0-base_ia32,repo.4.0-base_ia32_debug,repo.4.0-base_x86_64,repo.4.0-base_x86_64_debug,repo.4.0-unified_emulator,repo.4.0-unified_emulator_debug\n\n############# 3.0-common #############\n[profile.3.0-common_x86_64-wayland]\nbuildconf=./scm/meta/build-config/3.0/common/x86_64-wayland_build.conf\nrepos = repo.3.0-base_x86_64,repo.3.0-base_x86_64_debug,repo.3.0-common_x86_64-wayland,repo.3.0-common_x86_64-wayland_debug\n\n[profile.3.0-common_ia32-wayland]\nbuildconf=./scm/meta/build-config/3.0/common/ia32-wayland_build.conf\nrepos = repo.3.0-base_ia32,repo.3.0-base_ia32_debug,repo.3.0-common_ia32-wayland,repo.3.0-common_ia32-wayland_debug\n\n[profile.3.0-common_emulator32-wayland]\nbuildconf=./scm/meta/build-config/3.0/common/emulator32-wayland_build.conf\nrepos = repo.3.0-base_emulator32,repo.3.0-base_emulator32_debug,repo.3.0-common_emulator32-wayland,repo.3.0-common_emulator32-wayland_debug\n\n[profile.3.0-common_arm64-wayland]\nbuildconf=./scm/meta/build-config/3.0/common/arm64-wayland_build.conf\nrepos = repo.3.0-base_arm64,repo.3.0-base_arm64_debug,repo.3.0-common_arm64-wayland,repo.3.0-common_arm64-wayland_debug\n\n[profile.3.0-common_arm-wayland]\nbuildconf=./scm/meta/build-config/3.0/common/arm-wayland_build.conf\nrepos = repo.3.0-base_arm,repo.3.0-base_arm_debug,repo.3.0-common_arm-wayland,repo.3.0-common_arm-wayland_debug\n\n############# 3.0-mobile #############\n[profile.3.0-mobile_target-TM1]\nbuildconf=./scm/meta/build-config/3.0/mobile/target-TM1_build.conf\nrepos = repo.3.0-base_arm,repo.3.0-base_arm_debug,repo.3.0-mobile_target-TM1,repo.3.0-mobile_target-TM1_debug\n\n[profile.3.0-mobile_emulator32-wayland]\nbuildconf=./scm/meta/build-config/3.0/mobile/emulator32-wayland_build.conf\nrepos = repo.3.0-base_emulator32,repo.3.0-base_emulator32_debug,repo.3.0-mobile_emulator32-wayland,repo.3.0-mobile_emulator32-wayland_debug\n\n[profile.3.0-mobile_arm-wayland]\nbuildconf=./scm/meta/build-config/3.0/mobile/arm-wayland_build.conf\nrepos = repo.3.0-base_arm,repo.3.0-base_arm_debug,repo.3.0-mobile_arm-wayland,repo.3.0-mobile_arm-wayland_debug\n\n############# 3.0-tv #############\n[profile.3.0-tv_emulator64-wayland]\nbuildconf=./scm/meta/build-config/3.0/tv/emulator64-wayland_build.conf\nrepos = repo.3.0-base_emulator64,repo.3.0-base_emulator64_debug,repo.3.0-tv_emulator64-wayland,repo.3.0-tv_emulator64-wayland_debug\n\n[profile.3.0-tv_emulator32-wayland]\nbuildconf=./scm/meta/build-config/3.0/tv/emulator32-wayland_build.conf\nrepos = repo.3.0-base_emulator32,repo.3.0-base_emulator32_debug,repo.3.0-tv_emulator32-wayland,repo.3.0-tv_emulator32-wayland_debug\n\n[profile.3.0-tv_arm-wayland]\nbuildconf=./scm/meta/build-config/3.0/tv/arm-wayland_build.conf\nrepos = repo.3.0-base_arm,repo.3.0-base_arm_debug,repo.3.0-tv_arm-wayland,repo.3.0-tv_arm-wayland_debug\n\n############# 3.0-wearable #############\n[profile.3.0-wearable_target-circle]\nbuildconf=./scm/meta/build-config/3.0/wearable/target-circle_build.conf\nrepos = repo.3.0-base_arm,repo.3.0-base_arm_debug,repo.3.0-wearable_target-circle,repo.3.0-wearable_target-circle_debug\n\n[profile.3.0-wearable_emulator32-wayland]\nbuildconf=./scm/meta/build-config/3.0/wearable/emulator32-wayland_build.conf\nrepos = repo.3.0-base_emulator32,repo.3.0-base_emulator32_debug,repo.3.0-wearable_emulator32-wayland,repo.3.0-wearable_emulator32-wayland_debug\n\n[profile.3.0-wearable_emulator-circle]\nbuildconf=./scm/meta/build-config/3.0/wearable/emulator-circle_build.conf\nrepos = repo.3.0-base_emulator32,repo.3.0-base_emulator32_debug,repo.3.0-wearable_emulator-circle,repo.3.0-wearable_emulator-circle_debug\n\n############# 3.0-ivi #############\n[profile.3.0-ivi_emulator]\nbuildconf=./scm/meta/build-config/3.0/ivi/emulator_build.conf\nrepos = repo.3.0-base_emulator32,repo.3.0-base_emulator32_debug,repo.3.0-ivi_emulator,repo.3.0-ivi_emulator_debug\n\n[profile.3.0-ivi_arm]\nbuildconf=./scm/meta/build-config/3.0/ivi/arm_build.conf\nrepos = repo.3.0-base_arm,repo.3.0-base_arm_debug,repo.3.0-ivi_arm,repo.3.0-ivi_arm_debug\n\n\n\n#########################################################\n################## Repo Section##################\n#########################################################\n\n############# base #############\n[repo.base_standard]\nurl = http://download.tizen.org/releases/daily/tizen/base/latest/repos/standard/packages/\n[repo.base_standard_debug]\nurl = http://download.tizen.org/releases/daily/tizen/base/latest/repos/standard/debug/\n\n############# 4.0-base #############\n[repo.4.0-base_x86_64]\nurl = http://download.tizen.org/releases/daily/tizen/4.0-base/latest/repos/x86_64/packages/\n[repo.4.0-base_x86_64_debug]\nurl = http://download.tizen.org/releases/daily/tizen/4.0-base/latest/repos/x86_64/debug/\n\n[repo.4.0-base_ia32]\nurl = http://download.tizen.org/releases/daily/tizen/4.0-base/latest/repos/ia32/packages/\n[repo.4.0-base_ia32_debug]\nurl = http://download.tizen.org/releases/daily/tizen/4.0-base/latest/repos/ia32/debug/\n\n[repo.4.0-base_emulator64]\nurl = http://download.tizen.org/releases/daily/tizen/4.0-base/latest/repos/emulator64/packages/\n[repo.4.0-base_emulator64_debug]\nurl = http://download.tizen.org/releases/daily/tizen/4.0-base/latest/repos/emulator64/debug/\n\n[repo.4.0-base_emulator32]\nurl = http://download.tizen.org/releases/daily/tizen/4.0-base/latest/repos/emulator32/packages/\n[repo.4.0-base_emulator32_debug]\nurl = http://download.tizen.org/releases/daily/tizen/4.0-base/latest/repos/emulator32/debug/\n\n[repo.4.0-base_arm64]\nurl = http://download.tizen.org/releases/daily/4.0-base/latest/repos/arm64/packages/\n[repo.4.0-base_arm64_debug]\nurl = http://download.tizen.org/releases/daily/tizen/4.0-base/latest/repos/arm64/debug/\n\n[repo.4.0-base_arm]\nurl = http://download.tizen.org/releases/daily/tizen/4.0-base/latest/repos/arm/packages/\n[repo.4.0-base_arm_debug]\nurl = http://download.tizen.org/releases/daily/tizen/4.0-base/latest/repos/arm/debug/\n\n############# 3.0-base #############\n[repo.3.0-base_x86_64]\nurl = http://download.tizen.org/releases/daily/tizen/3.0-base/latest/repos/x86_64/packages/\n[repo.3.0-base_x86_64_debug]\nurl = http://download.tizen.org/releases/daily/tizen/3.0-base/latest/repos/x86_64/debug/\n\n[repo.3.0-base_ia32]\nurl = http://download.tizen.org/releases/daily/tizen/3.0-base/latest/repos/ia32/packages/\n[repo.3.0-base_ia32_debug]\nurl = http://download.tizen.org/releases/daily/tizen/3.0-base/latest/repos/ia32/debug/\n\n[repo.3.0-base_emulator64]\nurl = http://download.tizen.org/releases/daily/tizen/3.0-base/latest/repos/emulator64/packages/\n[repo.3.0-base_emulator64_debug]\nurl = http://download.tizen.org/releases/daily/tizen/3.0-base/latest/repos/emulator64/debug/\n\n[repo.3.0-base_emulator32]\nurl = http://download.tizen.org/releases/daily/tizen/3.0-base/latest/repos/emulator32/packages/\n[repo.3.0-base_emulator32_debug]\nurl = http://download.tizen.org/releases/daily/tizen/3.0-base/latest/repos/emulator32/debug/\n\n[repo.3.0-base_arm64]\nurl = http://download.tizen.org/releases/daily/tizen/3.0-base/latest/repos/arm64/packages/\n[repo.3.0-base_arm64_debug]\nurl = http://download.tizen.org/releases/daily/tizen/3.0-base/latest/repos/arm64/debug/\n\n[repo.3.0-base_arm]\nurl = http://download.tizen.org/releases/daily/tizen/3.0-base/latest/repos/arm/packages/\n[repo.3.0-base_arm_debug]\nurl = http://download.tizen.org/releases/daily/tizen/3.0-base/latest/repos/arm/debug/\n\n############# 5.0-unified #############\n[repo.unified_standard]\nurl = http://download.tizen.org/releases/daily/tizen/unified/latest/repos/standard/packages/\n[repo.unified_standard_debug]\nurl = http://download.tizen.org/releases/daily/tizen/unified/latest/repos/standard/debug/\n\n[repo.unified_emulator]\nurl = http://download.tizen.org/releases/daily/tizen/unified/latest/repos/emulator/packages/\n[repo.unified_emulator_debug]\nurl = http://download.tizen.org/releases/daily/tizen/unified/latest/repos/emulator/debug/\n\n############# 4.0-unified #############\n[repo.4.0-unified_standard]\nurl = http://download.tizen.org/releases/daily/tizen/4.0-unified/latest/repos/standard/packages/\n[repo.4.0-unified_standard_debug]\nurl = http://download.tizen.org/releases/daily/tizen/4.0-unified/latest/repos/standard/debug/\n\n[repo.4.0-unified_emulator]\nurl = http://download.tizen.org/releases/daily/tizen/4.0-unified/latest/repos/emulator/packages/\n[repo.4.0-unified_emulator_debug]\nurl = http://download.tizen.org/releases/daily/tizen/4.0-unified/latest/repos/emulator/debug/\n\n############# 3.0-common #############\n[repo.3.0-common_x86_64-wayland]\nurl = http://download.tizen.org/releases/daily/tizen/3.0-common/latest/repos/x86_64-wayland/packages/\n[repo.3.0-common_x86_64-wayland_debug]\nurl = http://download.tizen.org/releases/daily/tizen/3.0-common/latest/repos/x86_64-wayland/debug/\n\n[repo.3.0-common_ia32-wayland]\nurl = http://download.tizen.org/releases/daily/tizen/3.0-common/latest/repos/ia32-wayland/packages/\n[repo.3.0-common_ia32-wayland_debug]\nurl = http://download.tizen.org/releases/daily/tizen/3.0-common/latest/repos/ia32-wayland/debug/\n\n[repo.3.0-common_emulator32-wayland]\nurl = http://download.tizen.org/releases/daily/tizen/3.0-common/latest/repos/emulator32-wayland/packages/\n[repo.3.0-common_emulator32-wayland_debug]\nurl = http://download.tizen.org/releases/daily/tizen/3.0-common/latest/repos/emulator32-wayland/debug/\n\n[repo.3.0-common_arm64-wayland]\nurl = http://download.tizen.org/releases/daily/tizen/3.0-common/latest/repos/arm64-wayland/packages/\n[repo.3.0-common_arm64-wayland_debug]\nurl = http://download.tizen.org/releases/daily/tizen/3.0-common/latest/repos/arm64-wayland/debug/\n\n[repo.3.0-common_arm-wayland]\nurl = http://download.tizen.org/releases/daily/tizen/3.0-common/latest/repos/arm-wayland/packages/\n[repo.3.0-common_arm-wayland_debug]\nurl = http://download.tizen.org/releases/daily/tizen/3.0-common/latest/repos/arm-wayland/debug/\n\n############# 3.0-mobile #############\n[repo.3.0-mobile_target-TM1]\nurl = http://download.tizen.org/releases/daily/tizen/3.0-mobile/latest/repos/target-TM1/packages/\n[repo.3.0-mobile_target-TM1_debug]\nurl = http://download.tizen.org/releases/daily/tizen/3.0-mobile/latest/repos/target-TM1/debug/\n\n[repo.3.0-mobile_emulator32-wayland]\nurl = http://download.tizen.org/releases/daily/tizen/3.0-mobile/latest/repos/emulator32-wayland/packages/\n[repo.3.0-mobile_emulator32-wayland_debug]\nurl = http://download.tizen.org/releases/daily/tizen/3.0-mobile/latest/repos/emulator32-wayland/debug/\n\n[repo.3.0-mobile_arm-wayland]\nurl = http://download.tizen.org/releases/daily/tizen/3.0-mobile/latest/repos/arm-wayland/packages/\n[repo.3.0-mobile_arm-wayland_debug]\nurl = http://download.tizen.org/releases/daily/tizen/3.0-mobile/latest/repos/arm-wayland/debug/\n\n############# 3.0-tv #############\n[repo.3.0-tv_emulator64-wayland]\nurl = http://download.tizen.org/releases/daily/tizen/3.0-tv/latest/repos/emulator64-wayland/packages/\n[repo.3.0-tv_emulator64-wayland_debug]\nurl = http://download.tizen.org/releases/daily/tizen/3.0-tv/latest/repos/emulator64-wayland/debug/\n\n[repo.3.0-tv_emulator32-wayland]\nurl = http://download.tizen.org/releases/daily/tizen/3.0-tv/latest/repos/emulator32-wayland/packages/\n[repo.3.0-tv_emulator32-wayland_debug]\nurl = http://download.tizen.org/releases/daily/tizen/3.0-tv/latest/repos/emulator32-wayland/debug/\n\n[repo.3.0-tv_arm-wayland]\nurl = http://download.tizen.org/releases/daily/tizen/3.0-tv/latest/repos/arm-wayland/packages/\n[repo.3.0-tv_arm-wayland_debug]\nurl = http://download.tizen.org/releases/daily/tizen/3.0-tv/latest/repos/arm-wayland/debug/\n\n############# 3.0-wearable #############\n[repo.3.0-wearable_target-circle]\nurl = http://download.tizen.org/releases/daily/tizen/3.0-wearable/latest/repos/target-circle/packages/\n[repo.3.0-wearable_target-circle_debug]\nurl = http://download.tizen.org/releases/daily/tizen/3.0-wearable/latest/repos/target-circle/debug/\n\n[repo.3.0-wearable_emulator32-wayland]\nurl = http://download.tizen.org/releases/daily/tizen/3.0-wearable/latest/repos/emulator32-wayland/packages/\n[repo.3.0-wearable_emulator32-wayland_debug]\nurl = http://download.tizen.org/releases/daily/tizen/3.0-wearable/latest/repos/emulator32-wayland/debug/\n\n[repo.3.0-wearable_emulator-circle]\nurl = http://download.tizen.org/releases/daily/tizen/3.0-wearable/latest/repos/emulator-circle/packages/\n[repo.3.0-wearable_emulator-circle_debug]\nurl = http://download.tizen.org/releases/daily/tizen/3.0-wearable/latest/repos/emulator-circle/debug/\n\n############# 3.0-ivi #############\n[repo.3.0-ivi_emulator]\nurl = http://download.tizen.org/releases/daily/tizen/3.0-ivi/latest/repos/emulator/packages/\n[repo.3.0-ivi_emulator_debug]\nurl = http://download.tizen.org/releases/daily/tizen/3.0-ivi/latest/repos/emulator/debug/\n\n[repo.3.0-ivi_arm]\nurl = http://download.tizen.org/releases/daily/tizen/3.0-ivi/latest/repos/arm/packages/\n[repo.3.0-ivi_arm_debug]\nurl = http://download.tizen.org/releases/daily/tizen/3.0-ivi/latest/repos/arm/debug/\n```\n\n> **Note**\n>\n> The file contains the GBS configuration for all profiles and repositories in Tizen version 3.0, Tizen version 4.0 and Tizen version 5.0. In the near future in new GBS versions, the above default configuration file (`~/.gbs.conf`) is automatically installed when GBS is installed.\n\n> **Note**\n>\n> If \"scm/meta/build-config\" git is not cloned in your working directory, every line which starts with \"buildconf=./scm/meta/build-config\" should be removed.\n\nThe default profile used in GBS is specified in the `[general]` section:\n\n```\n[general]\nprofile = profile.unified_standard\n```\n\n> **Note**\n>\n> The default GBS build parameters, based on the above block, are as follows:\n> - Tizen version: 5.0\n> - Profile: unified\n> - Repository: standard\n\n### Setting Up a Specific Profile in the `.gbs.conf` File\n\nTo build using a non-default Tizen version, profile, or repository, select 1 of the profiles specified in the `.gbs.conf` file and set that profile in the `[general]` section, using the following format:\n\n```\n[general]\nprofile = profile.\"$Version\"\"$Profile\"_\"$Repository\"\n```\n\n- If the Tizen version is 3.0, `$Version` equals \"3.0-\".\n- If the Tizen version is 4.0, `$Version` equals \"4.0-\".\n- If the Tizen version is 5.0, `$Version` equals \"\".\n\nOther examples:\n\n- Tizen 5.0 Unified / emulator repository\n\n  ```\n  [general]\n  profile = profile.unified_emulator\n  ```\n\n- Tizen 4.0 Unified / emulator repository\n\n  ```\n  [general]\n  profile = profile.4.0-unified_emulator\n  ```\n\n- Tizen 3.0 Common / arm64-wayland repository\n  ```\n  [general]\n  profile = profile.3.0-common_arm64-wayland\n  ```\n\n- Tizen 3.0 Common / emulator32-wayland repository\n  ```\n  [general]\n  profile = profile.3.0-common_emulator32-wayland\n  ```\n\n- Tizen 3.0 Mobile / target-TM1 repository\n  ```\n  [general]\n  profile = profile.3.0-mobile_target-TM1\n  ```\n\n- Tizen 3.0 TV / arm-wayland repository\n  ```\n  [general]\n  profile = profile.3.0-tv_arm-wayland\n  ```\n\n- Tizen 3.0 Wearable / target-circle repository\n  ```\n  [general]\n  profile = profile.3.0-wearable_target-circle\n  ```\n\n- Tizen 3.0 IVI / emulator repository\n  ```\n  [general]\n  profile = profile.3.0-ivi_emulator\n  ```\n\nEach `profile` entry in the `.gbs.conf` file specifies multiple `repo` entries, and each `repo` entry specifies a URL where RPM files used in the GBS build are located.\n\n> **Note**\n>\n> The `latest` directory in the remote repository URLs is a symbolic link in the remote server, which is always linked to the latest new directory and can be changed any time, so make sure to use the latest repo with a specific date to guarantee usability. An example is shown below:\n> ```\n> url = http://download.tizen.org/releases/daily/tizen/unified/latest/repos/standard/packages/\n> ```\n> This URL is symbolically linked to the latest snapshot number in \"[http://download.tizen.org/releases/daily/tizen/unified/](http://download.tizen.org/releases/daily/tizen/unified/)\". To guarantee usability, use a specific date:\n> ```\n> url = http://download.tizen.org/releases/daily/tizen/unified/tizen-unified_20170627.1/repos/standard/packages/\n> ```\n\nFor more information on `.gbs.conf`, see [GBS Configuration](../reference/gbs/gbs.conf.md).\n\n## Setting Up the Repo Tool\n\nRepo is a repository management tool built on top of Git.  Multiple Git repositories can be downloaded with a single repo command.\n\nTo install and set up the repo tool:\n\n1. Create a `~/bin/` subdirectory, include it in `PATH`, and switch to it:\n\n   ```\n   $ mkdir ~/bin/\n   $ PATH=~/bin:$PATH\n   ```\n\n2. Download the repo script:\n\n   ```\n   $ curl http://commondatastorage.googleapis.com/git-repo-downloads/repo > ~/bin/repo\n   ```\n\n   > **Note**\n   >\n   > If you encounter problems while obtaining the repo tool, see [Development Tips](tips.md).\n\n3. Change the attributes of the repo script to make it executable:\n\n   ```\n   $ sudo chmod a+x ~/bin/repo\n   ```\n\n## Working through a Network Proxy\n\nYou can set up your development environment to work through a network proxy.\n\n> **Note**\n>\n> A network proxy is particularly useful if you also track other Git repositories for which you do not already have a dedicated `ProxyCommand` in your `~/.ssh/config`, or which use \"git://\" or \"http://\".\n\n### Configuring a Proxy\n\nTo configure a proxy through the Linux shell prompt:\n\n1. Open the `.bashrc` file and set the `http_proxy`, `ftp_proxy`, `https_proxy`, and `no_proxy` environment variables:\n   ```\n    export http_proxy=:\n    export ftp_proxy=$http_proxy\n    export https_proxy=:\n    export no_proxy=\n   ```\n\n2. Open `/etc/sudoers` and preserve the environment variables by adding the following content:\n\n    ```\n    Defaults env_keep=\"http_proxy ftp_proxy https_proxy no_proxy\"\n    ```\n\n   > **Note**\n   >\n   > Replace \"=\" with \"+=\" if other `env_keep` settings already exist in `/etc/sudoers`.\n\n\n### Configuring Git Access through the Proxy\n\nTo allow Git access through the proxy:\n\n1. Create a script named `git-proxy` in the `/usr/local/bin` directory by using a text editor.\n\n   The following example uses VIM:\n\n   ```\n   $ sudo vim /usr/local/bin/git-proxy\n   ```\n\n2. Add the following lines into the file and save it:\n\n   ```\n   #!/bin/bash\n\n   PROXY=\n   PORT=\n\n   case $1 in\n   # list Git servers here that you do not want to use\n   # the proxy with, separated by a pipe character '|' as below:\n\n   review.tizen.org)\n   METHOD=\"-X connect\"\n   ;;\n   *)\n   METHOD=\"-X 5 -x ${PROXY}:${PORT}\"\n   #The line above is applicable to Ubuntu and openSUSE\n   #For Fedora, use the variation below since it only supports socks v4\n   #METHOD=\"-X 4 -x ${PROXY}:${PORT}\"\n   ;;\n   esac\n\n   nc $METHOD $*\n   ```\n\n3. Change the attributes of the `git-proxy` script to make it executable:\n\n   ```\n   $ sudo chmod +x /usr/local/bin/git-proxy\n   ```\n\n4. Set the `GIT_PROXY_COMMAND` and `GIT_PROXY_IGNORE` environment variables by adding the following lines into the `.bashrc` file:\n\n   ```\n   export GIT_PROXY_COMMAND=/usr/local/bin/git-proxy\n   export GIT_PROXY_IGNORE=\n   ```\n\n5. Apply the changes:\n\n   ```\n   $ source ~/.bashrc\n   ```"
					}
					
				
			
		
			
				
					,
					
					"design-tv-styles": {
						"id": "design-tv-styles",
						"title": "Styles",
						"categories": "",
						"url": " design/tv/styles/",
						"content": "# Styles\n\nTizen TV applications use various styles to improve the clarity and usability of the information on the screen:\n\n-   [Background color](#background-color)\n-   [Theme](#theme)\n-   [Color swatch](#color-swatch)\n-   [Font style](#font-style)\n\n## Background Color\n\nThe Tizen TV uses a dark color (RGB 0,0,0) as a fullscreen background. The color has some transparency (opacity 95%), to allow the user to see the current screen image through the dark color.\n\n![Background color](media/st_01_bg_color.png)\n*Background color for fullscreen.*\n\n## Theme\n\nThe UI components have 2 themes available: dark and light.\n\nEach theme is used based on the background color. Since the background color is usually dark, the dark theme is mainly used. However, if the background is light, the light theme is applied.\n\n| ![dark theme](media/st_02_theme_dark_normal_re-300x83.png) | ![light theme](media/st_03_theme_light_normal-300x83.png) |\n|:---:|:---:|\n| *Dark theme* | *Light theme* |\n\n## Color Swatch\n\nThe Tizen TV uses clear and distinct colors to allow various item states (such as normal, focused, selected, and disabled) to be easily recognized.\n\n| No. | Color | RGB / Opacity | Swatch | Components |\n|:---:|:---:|:---:|:---:|:---:|\n| 1 | Black | 0,0,0 / 95% |  | Background dim |\n| 2 | White | 0, 0, 0 / 100% |  | Normal text |\n| 3 | Grey | 220, 220, 220 / 100% |  | Popup |\n| 4 | Blue | 0, 129, 198 / 100% |  | Selected color |\n\n## Font Style\n\nDifferent font styles are used to help the user easily recognize different states or importance levels of items. To ensure clear visibility, the style is determined based on the color background.\n\n![font styles](media/st_04_font_style_states_re-850x511.png)\n*Different font styles for different states.*"
					}
					
				
			
		
			
				
					,
					
					"design-introduction-styles": {
						"id": "design-introduction-styles",
						"title": "Styles",
						"categories": "",
						"url": " design/introduction/styles/",
						"content": "# Styles\n\n##### Contents\n\n-   [Animations](styles/animations.md)\n-   [Colors](styles/colors.md)\n-   [Device Compatibility](styles/device-compatibility.md)\n-   [Iconography](styles/iconography.md)\n-   [Terminology](styles/terminology.md)\n-   [Typography](styles/typography.md)"
					}
					
				
			
		
			
				
					,
					
					"design-mobile-styles": {
						"id": "design-mobile-styles",
						"title": "Design Principles",
						"categories": "",
						"url": " design/mobile/styles/",
						"content": "# Styles\n\n## Theme Colors\n\nThe Tizen offers a single background gradient called \"Midday\" as the default Home screen background since Tizen SDK 2.4. It captures colors and natural gradients of the sky.\n\n![Midday, the new theme color for the Tizen mobile.](design/mobile/media/2.4_a.png)\n*Midday, the new theme color for the Tizen mobile since Tizen SDK 2.4.*\n\n## Color Swatch\n\nFor basic action buttons, such as 'Go' and 'Stop', Tizen 2.4 uses clear and distinct colors for focus and emphasis. Transparency may be applied to text colors to add subtle nuances.\n\n\n| No.            | Color          | HSB code       | Swatch         | Component      |\n|----------------|----------------|----------------|----------------|----------------|\n| 1              | White          | \\#FFFFFF       | ![Swatch White](design/mobilemedia/swatch_white.png) | Primary text / Primary color|\n| 2              | Gray           | \\#666666       |  ![Swatch Gray](design/mobilemedia/swatch_gray.png)     | Secondary text |\n| 3              | Black          | \\#000000       | ![Swatch Black](design/mobilemedia/swatch_black.png)        | Primary text / Primary color |\n| 4              | Green          | \\#2AB842       | ![Swatch Green](design/mobilemedia/swatch_green.png)     | Start          |\n| 5              | Red            | \\#E12222       | ![Swatch Red](design/mobilemedia/swatch_red.png)        | Stop           |\n| 6              | Yellow         | \\#FFB400       | ![Swatch Yellow](design/mobilemedia/swatch_yellow.png)       | Snooze, Favorite(star) |\n\n\n## Font Styles\n\nDifferent text colors may be used depending on the level of text information and background colors. The following are examples of the primary and secondary text colors in the Tizen Mobile SDK 2.4.\n\n\n\n*White text against a dark background (theme color)*\n\n\n\n*Colored text against a white background*\n\n\n\n*Black primary text against a white background*\n\n\n\n*Gray secondary text against a light blue background*\n\nThe following examples show how different text colors appear on the call log screen. White primary text displays well over the header area (dark theme color). Primary text in black and secondary text in gray also look fine over the lightly colored list area.\n\nOnce again, the text colors should be decided based on the color of the background. Black or gray text usually fails to stand out against darker backgrounds, resulting in decreased visibility.\n\n | |  |\n|:--:|:--:|\n| *Do* | *Don't* |\n\nText with vivid colors, such as red, yellow, blue, and green is not recommended. Such color choice may cause the usability of your design to suffer, because they may impose excessive stress to a user's vision and distract them.\n\n### List Principles\n\nTizen mobile devices use multilayered page structure, with the main theme background (gradient) in the bottom layer position. By separating the layers based on their roles, sophisticated effects may be applied on the pages with a minimal set of rules to follow.\n\nThe list view is one example that can help you understand how superimposed layers with gradient and text items appear against the background. Semi-transparent stripes of gradient on top of the main background create subtle dividers for each list item, above which list item text layer is placed.\n\n \n\n*Multilayered screen structurecreated by layers of different opacities over the background gradient.*\n\nDifferent opacity levels on a list create an interesting gradient. On the item list layer, the opacity level of the first list item is 100 percent, and it decreases by 4 percent for each item after it until the twentieth item. After the twentieth item, the opacity level begins to increase by 4 percent until it reaches 100 percent again.\n\n\n\n*Scrolling a list*"
					}
					
				
			
		
			
				
					,
					
					"application-porting-system": {
						"id": "application-porting-system",
						"title": "System",
						"categories": "",
						"url": " application/porting/system/",
						"content": "# System\n\nYou can implement various features related to the System framework and the file system.\n\n## Partition and File System\n\nThe following description is an example of the Tizen partition layout. Product vendors can modify the sequence or partition layout for their devices, as needed.\n\n1. The `boot` partition includes the kernel image, boot-loader image, and modem image. It can also contain device driver modules.\n1. The `rootfs` partition is mounted on the root directory. It contains the fundamental frameworks for Tizen and some general utilities for Linux.\n1. The `system-data` partition is mounted on the `/opt` directory. It contains the platform database and platform configurations.\n1. The `user` partition can be mounted on the `/opt/usr` directory separately. It contains user-installed applications.\n1. External storages are mounted on `/opt/media`.\n1. The partition image files (`rootfs.img`, `system-data.img`, and `user.img`) can be zipped for downloading, such as `.tar.gz`.\n\nThe `/etc/fstab` directory must be modified or the `systemd` mount units must be added based on the partition layout. Consequently, the `fstab` file or system mount unit files for specific devices must be added to the `system-plugin` Git repository. The following example shows an `fstab` file:\n\n```\n/dev/root         /               ext4    defaults,noatime 0      1\nLABEL=system-data /opt            ext4    defaults,noatime 0      2\nLABEL=user        /opt/usr        ext4    defaults,noatime 0      3\n```\n\n### Supported File Systems\n\nTizen supports the Extended 4 (Ext 4) file system as the default file system.\n\nTo enable support for other file systems, such as JFS, XFS, BTRFS, and Reiserfs, the Tizen kernel must be modified and compiled. The following configuration options must be enabled in the kernel configuration file:\n\n- `CONFIG_EXT4_FS=y`\n- `CONFIG_EXT4_FS_XATTR=y`\n- `CONFIG_EXT4_USE_FOR_EXT23=y`\n- `CONFIG_EXT4_FS_SECURITY=y`\n\n### File System Hierarchy\n\nThe Tizen directory hierarchy intends to follow the File System Hierarchy Standard (FHS) as much as possible, for compatibility with the Linux world. However, Tizen uses the `/opt` directory for Tizen-specific purposes: place all RW data in the `/opt` directory.\n\n**Figure: File system hierarchy**\n\n![File system hierarchy](media/467px-fsh.png)\n\nDirectory macros for accessing the Tizen-specific directories are provided in the Tizen platform configuration metafile. The following table lists some example macros.\n\n**Table: Example directory macros**\n\n| Directory macro | Real path    |\n| ---------------- | ------------ |\n| `TZ_SYS_DATA`    | `/opt/data`  |\n| `TZ_SYS_SHARE`   | `/opt/share` |\n| `TZ_SYS_VAR`     | `/opt/var`   |\n\n## System Framework\n\nThe System framework module abstracts low-level system functions and manages the Tizen system:\n\n- `systemd` requirements for system and service management\n    - Linux Kernel >= 3.4 , Linux Kernel >= 3.8 for Smack support\n    - `CONFIG_CGROUPS`, `CONFIG_TIMERFD`, `CONFIG_SIGNALFD`, `CONFIG_EPOLL`, ...\n\n- Basic resource requirements (such as CPU, memory) usage management\n  - Linux Kernel >= 3.10 for `VMPRESSURE`, Linux Kernel >= 3.8 for `MEMCG SWAP`\n  - `CONFIG_CGROUPS`, `CONFIG_CGROUP_SCHED`, `CONFIG_MEMCG`, `CONFIG_MEMCG_SWAP`, ...\n- `deviced` requirements for device and power management\n    - Device HAL layer porting\n\n- dlog requirements\n\n  Select a backend for the target environment and enable the appropriate kernel feature:\n    - Additional KMSG patch for multiple Kmsg backend\n    - Android&trade; logger driver for Android log backend\n    - Userspace logger daemon\n\nUsing the Linux kernel 3.10 or above is recommended.\n\n**Figure: System framework**\n\n![System framework](media/800px-systemfw.png)\n\n### systemd\n\n`systemd` (ver.219) is a system and service manager for the Tizen system. It provides functionalities, such as parallelized service execution, socket and dbus activation for starting services and daemons, on-demand daemon start-up, service process management using Linux `cgroup`, automount point support, and service snapshot and restore.\n\nThe `systemd` core manages all units, such as service, socket, and mount. It stores all log data. When you add a new service daemon, you need to provide the proper system units and unit dependencies.\n\nTo use `systemd`, you must enable the `cgroup` and `autofs` options in the [Linux](https://wiki.tizen.org/Linux) kernel configuration. It also depends on dbus and some libraries.\n\n### resourced\n\n`resourced` is a daemon that manages system resources, such as memory and CPU.\n\nTo use most of the `resourced` functionalities, you must enable the following `cgroup` kernel features:\n\n  - `CONFIG_CGROUPS`: Base feature\n  - `CONFIG_CGROUP_SCHED`: Controls the CPU share of applications\n  - `CONFIG_MEMCG`: Selects the victim in low-memory situations\n  - `CONFIG_FREEZER`: Freezes background (and idle) applications\n  - `CONFIG_MEMCG_SWAP`, `CONFIG_MEMCG_SWAP_ENABLED`: Adds swap management features to memory resource controller. Depends on `CONFIG_MEMCG` and `CONFIG_SWAP`.\n  - `CONFIG_ZRAM`: Creates memory-backed compressed block devices /dev/zramX (X = 0, 1, …). Depends on `CONFIG_ZSMALLOC`.\n  - `CONFIG_ZRAM_LZ4_COMPRESS`: Enables support for an alternative compression algorithm. By default, ZRAM uses Lempel–Ziv–Oberhumer (LZO).\n  - `CONFIG_ZSWAP`: Compresses data in memory before moving them to a storage device.\n  - `CRYPTO_DEFLATE`, `CRYPTO_ZLIB`, `CRYPTO_LZO`, `CRYPTO_LZ4`, `CRYPTO_LZ4HC`: Compression algorithms available as part of kernel cyrpto API.\n\n> **Note**\n>\n> To use the `resourced` freezer feature, you must install the freezer plugin by enabling `CONFIG_FREEZER`.\n\n### deviced\n\n`deviced` is a daemon that handles device events, such as the battery level and plug-and-play device status, and provides interfaces to manage devices, such as power, display, and external storages. If your BSP does not provide the Linux kernel-standard interface, these functionalities can require a HAL layer:\n\n- Managing the LCD backlight state (on/off/dim)\n- Managing the CPU sleep state and handling requests to lock the CPU from sleeping\n- Monitoring external devices, such as USB cable, earjack, and charger\n- Monitoring the battery level\n- Managing external storages, such as SD card and USB storages\n- Controlling the vibrator\n- Setting the USB configuration for connecting to a host computer\n- Powering off the LED, IR, and other features\n- Using the device HAL to handle devices and get events\n\n### dlog\n\nTizen provides 3 logging system backends:\n\n- Multiple `kmsg` backend\n\n  Requires a kernel patch. For more information, see https://lwn.net/Articles/677047/.\n\n- Android-logger backend\n\n  Utilizes the Android logger driver.\n\n- User logger backend\n\n  No requirement (you do not have to enable anything from dlog)\n\n### Porting the Smart Development Bridge (SDB)\n\nSDB is a device management tool used for remote shell command, file transfer, controlling device log out, and USB debugging.\n\n- To use SDB, you must install a kernel driver.\n\n    For example:\n    - [Gadget Driver for SLP based on Android](https://review.tizen.org/git/?p=profile/mobile/platform/kernel/linux-3.10-sc7730.git;a=blob;f=drivers/usb/gadget/slp.c;h=c0d935f5362cc5ae03807d3533fe84df88e8c354;hb=refs/heads/accepted/tizen_mobile)\n    - [Gadget Driver for Samsung SDB (based on Android ADB)](https://review.tizen.org/git/?p=profile/mobile/platform/kernel/linux-3.10-sc7730.git;a=blob;f=drivers/usb/gadget/f_sdb.c;h=7f334ba01139d6bcbe7668bd84582e078d563638;hb=refs/heads/accepted/tizen_mobile)\n\n- To recognize the target as a Tizen device, the SDB interface on the target device must have the following information in the USB interface descriptor:\n    ```\n    Class: 0xff\n    SubClass: 0x20\n    Protocol: 0x02\n    ```\n- When using multi-configuration, SDB must be located in the first configuration on the target multi-configuration system. The SDB client of the host PC (Linux PC) selects the first configuration.\n\n- To recognize the USB cable connection, you must port the External Connector Class (`extcon`) to the kernel. If `extcon` cannot be ported, you can enable SDB using the following shell command:\n    ```\n    /usr/bin/direct_set_debug.sh --sdb-set\n    ```\n\n### Porting the Device HAL Interface\n\nThe device HAL is applied for the hardware-independent platform. The device HAL consists of libraries corresponding to hardware, such as display, external connector, battery, LED, and IR. The HAL is used by `deviced` (device daemon) to control hardware, and manages the events of device state changes. `deviced` opens the implemented libraries and uses the APIs to control the devices.\n\nOEM developers must implement the API defined in the header files of the `libdevice-node` package and compile their libraries (`.so` file) for their devices.\n\nThe following code snippet shows the device HAL structure:\n\n```cpp\n#define MAKE_TAG_CONSTANT(A,B,C,D) (((A) = 0 && val > 0) {\n        *src = POWER_SOURCE_AC;\n\n        return 0;\n    }\n\n    ret = sys_get_int(BATTERY_ROOT_PATH\"/\"POWER_SOURCE_USB\"/online\", &val);\n    if (ret >= 0 && val > 0) {\n        *src = POWER_SOURCE_USB;\n\n        return 0;\n    }\n\n    ret = sys_get_int(BATTERY_ROOT_PATH\"/\"POWER_SOURCE_WIRELESS\"/online\", &val);\n    if (ret >= 0 && val > 0) {\n        *src = POWER_SOURCE_WIRELESS;\n\n        return 0;\n    }\n\n    *src = POWER_SOURCE_NONE;\n\n    return 0;\n}\n\nstatic int\nbattery_get_current_state(BatteryUpdated updated_cb, void *data) {\n    int fd;\n    struct battery_info info;\n    char status[32];\n    char health[32];\n    char *power_source;\n\n    if (!updated_cb)\n        return -EINVAL;\n\n    info.name = BATTERY_HARDWARE_DEVICE_ID;\n\n\n    fd = open(BATTERY_ROOT_PATH\"/battery/status\", O_RDONLY);\n    read(fd, status, sizeof(status));\n    close(fd);\n    info.status = status;\n\n    fd = open(BATTERY_ROOT_PATH\"/battery/health\", O_RDONLY);\n    read(fd, health, sizeof(health));\n    close(fd);\n    info.health = health;\n\n    ....\n\n    get_power_source(&power_source);\n    info.power_source = power_source;\n\n    updated_cb(&info, data);\n\n    return 0;\n}\n\nstatic int\nbattery_open(struct hw_info *info, const char *id, struct hw_common **common) {\n    struct battery_device *battery_dev;\n    battery_dev = calloc(1, sizeof(struct battery_device));\n\n    battery_dev->common.info = info;\n    battery_dev->register_changed_event = battery_register_changed_event;\n    battery_dev->unregister_changed_event = battery_unregister_changed_event;\n    battery_dev->get_current_state = battery_get_current_state;\n\n    *common = (struct hw_common *)battery_dev;\n\n    return 0;\n}\n\nstatic int\nbattery_close(struct hw_common *common) {\n    free(common);\n\n    return 0;\n}\n\nHARDWARE_MODULE_STRUCTURE = {\n    .magic = HARDWARE_INFO_TAG,\n    .hal_version = HARDWARE_INFO_VERSION,\n    .device_version = BATTERY_HARDWARE_DEVICE_VERSION,\n    .id = BATTERY_HARDWARE_DEVICE_ID,\n    .name = \"battery\",\n    .open = battery_open,\n    .close = battery_close,\n};\n```\n\n#### Display HAL\n\nThe display HAL provides functions for controlling the display brightness. The HAL interface is defined in the `hw/display.h` header file of the `libdevice-node` library, and the `pkg-config` `device-node` must be used to use the HAL interface.\n\nThe following code snippet shows the display HAL interface:\n\n```cpp\n/*\n   Device ID\n*/\n#define DISPLAY_HARDWARE_DEVICE_ID \"display\"\n\n/*\n   Device version\n*/\n#define DISPLAY_HARDWARE_DEVICE_VERSION MAKE_VERSION(0,2)\n\nstruct display_device {\n    struct hw_common common;\n\n    /* Control display brightness */\n    int (*get_max_brightness)(int *brightness);\n    int (*get_brightness)(int *brightness);\n    int (*set_brightness)(int brightness);\n};\n```\n\nThe following table lists the display HAL functions.\n\n**Table: Display HAL functions**\n\n| Function prototype                       | Description                              | Mandatory |\n| ---------------------------------------- | ---------------------------------------- | --------- |\n| `int (*get_max_brightness)(int *brightness)` | Returns the maximum brightness value the display driver supports. | Yes |\n| `int (*get_brightness)(int *brightness)` | Returns the current brightness value. | Yes |\n| `int (*set_brightness)(int brightness)`  | Sets the brightness value.  | Yes |\n\nThe following code snippet shows an example of the display HAL:\n\n```cpp\n#ifndef BACKLIGHT_PATH\n#define BACKLIGHT_PATH \"/sys/class/backlight/panel\"\n#endif\n\nstatic int\ndisplay_get_max_brightness(int *val) {\n    static int max = -1;\n    char buf[BUF_MAX];\n    int fd;\n    if (max  max)\n        brightness = max;\n    snprintf(buf, sizeof(buf), \"%d\", brightness);\n    fd = open(BACKLIGHT_PATH\"/brightness\", O_WRONLY);\n    write(fd, buf, strlen(buf));\n    close(fd);\n\n    return 0;\n}\n\nstatic int\ndisplay_open(struct hw_info *info,\n        const char *id, struct hw_common **common) {\n    struct display_device *display_dev;\n\n    if (!info || !common)\n        return -EINVAL;\n\n    display_dev = calloc(1, sizeof(struct display_device));\n    if (!display_dev)\n        return -ENOMEM;\n\n    display_dev->common.info = info;\n    display_dev->get_max_brightness = display_get_max_brightness;\n    display_dev->get_brightness = display_get_brightness;\n    display_dev->set_brightness = display_set_brightness;\n\n    *common = (struct hw_common *)display_dev;\n\n    return 0;\n}\n\nstatic int\ndisplay_close(struct hw_common *common) {\n    if (!common)\n        return -EINVAL;\n\n    free(common);\n\n    return 0;\n}\n\nHARDWARE_MODULE_STRUCTURE = {\n    .magic = HARDWARE_INFO_TAG,\n    .hal_version = HARDWARE_INFO_VERSION,\n    .device_version = DISPLAY_HARDWARE_DEVICE_VERSION,\n    .id = DISPLAY_HARDWARE_DEVICE_ID,\n    .name = \"Display\",\n    .open = display_open,\n    .close = display_close,\n};\n```\n\n#### External Connector HAL\n\nThe external connector HAL provides functions for getting the external connector device status. The HAL interface is defined in the `hw/external_connection.h` header file of the `libdevice-node` library, and the `pkg-config` `device-node` needs to be used to use the HAL interface.\n\nThe following code snippet shows the interface of the external connector HAL:\n\n```cpp\n/*\n   Device ID\n*/\n#define EXTERNAL_CONNECTION_HARDWARE_DEVICE_ID \"external_connection\"\n\n#define EXTERNAL_CONNECTION_USB \"USB\"\n#define EXTERNAL_CONNECTION_USB_HOST \"USB-HOST\"\n#define EXTERNAL_CONNECTION_TA \"TA\"\n#define EXTERNAL_CONNECTION_HDMI \"HDMI\"\n#define EXTERNAL_CONNECTION_DOCK \"Dock\"\n#define EXTERNAL_CONNECTION_MIC \"Microphone\"\n#define EXTERNAL_CONNECTION_HEADPHONE \"Headphone\"\n\n/*\n   Device version\n*/\n#define EXTERNAL_CONNECTION_HARDWARE_DEVICE_VERSION MAKE_VERSION(0,1)\n\nstruct connection_info {\n    char *name;\n    char *state;\n    int flags;\n};\n\ntypedef void (*ConnectionUpdated)(struct connection_info *info, void *data);\n\nstruct external_connection_device {\n    struct hw_common common;\n\n    /* Register external_connection event */\n    int (*register_changed_event)(ConnectionUpdated updated_cb, void *data);\n    void (*unregister_changed_event)(ConnectionUpdated updated_cb);\n\n    /* Get current states */\n    int (*get_current_state)(ConnectionUpdated updated_cb, void *data);\n};\n```\n\nThe following table lists the external connector HAL functions.\n\n**Table: External connector HAL functions**\n\n| Function prototype                       | Description                              | Mandatory |\n| ---------------------------------------- | ---------------------------------------- | --------- |\n| `int (*register_changed_event)(ConnectionUpdated updated_cb, void *data);` | Adds a callback function which is called when the external connector status changes. | Yes |\n| `void (*unregister_changed_event)(ConnectionUpdated updated_cb);` | Removes the callback function added for the external connector status event. | Yes |\n| `int (*get_current_state)(ConnectionUpdated updated_cb, void *data);` | Calls the function specified in the first parameter. The external connector information is delivered to the function parameter. | Yes |\n\nThe following code snippet shows an example of the external connector HAL:\n\n```cpp\n#define SWITCH_ROOT_PATH \"/sys/devices/virtual/switch\"\n\nstatic struct switch_device {\n    char *type;\n    char *name;\n    int state;\n} switch_devices[] = {\n    {EXTERNAL_CONNECTION_USB, \"usb_cable\", 0},\n    {EXTERNAL_CONNECTION_DOCK, \"dock\", 0},\n    {EXTERNAL_CONNECTION_HEADPHONE, \"earjack\", 0},\n};\n\nstatic int\nread_switch_state(char *path) {\n    char node[128], val[8];\n    FILE *fp;\n\n    snprintf(node, sizeof(node), \"%s/%s/state\", SWITCH_ROOT_PATH, path);\n    fp = fopen(node, \"r\");\n    fgets(val, sizeof(val), fp));\n    fclose(fp);\n\n    return atoi(val);\n}\n\nstatic int\nexternal_connection_get_current_state(ConnectionUpdated updated_cb, void *data) {\n    int ret, i;\n    struct connection_info info;\n    char buf[8];\n\n    for (i = 0; i type == LED_TYPE_BLINK) {\n        printf(\"camera back led does not support LED_TYPE_BLINK mode\");\n\n        return -ENOTSUP;\n    }\n\n    if (max color >> 24) & 0xFF;\n    brt = brt / 255.f * max;\n\n    snprintf(buf, sizeof(buf), \"%d\", brt);\n    fd = open(CAMERA_BACK_PATH\"/brightness\", O_WRONLY);\n    write(fd, buf, strlen(buf));\n    close(fd);\n\n    return 0;\n}\n\nstruct led_device camera_back_dev = {\n    .set_state = camera_back_set_state,\n};\n\nstruct led_device_list {\n    const char *id;\n    struct led_device *operations;\n    struct led_device *dev;\n} led_list[] = {\n    {LED_ID_CAMERA_BACK, &camera_back_dev, NULL},\n    {LED_ID_CAMERA_FRONT, NULL, NULL},\n    {LED_ID_NOTIFICATION, NULL, NULL},\n    {LED_ID_TOUCH_KEY, NULL, NULL},\n};\n\nstatic int\nled_open(struct hw_info *info, const char *id, struct hw_common **common) {\n    int i, list_len, id_len;\n\n    list_len = ARRAY_SIZE(led_list);\n    id_len = strlen(id) + 1;\n    for (i = 0; i = list_len)\n        return -EINVAL;\n    led_list[i].dev = calloc(1, sizeof(struct led_device));\n\n    led_list[i].dev->common.info = info;\n    led_list[i].dev->set_state\n        = led_list[i].operations->set_state;\n\nout:\n    *common = (struct hw_common *)led_list[i].dev;\n\n    return 0;\n}\n\nstatic int\nled_close(struct hw_common *common) {\n    free(common);\n\n    return 0;\n}\n\nHARDWARE_MODULE_STRUCTURE = {\n    .magic = HARDWARE_INFO_TAG,\n    .hal_version = HARDWARE_INFO_VERSION,\n    .device_version = LED_HARDWARE_DEVICE_VERSION,\n    .id = LED_HARDWARE_DEVICE_ID,\n    .name = \"Default LED\",\n    .open = led_open,\n    .close = led_close,\n};\n```\n\n#### IR HAL\n\nThe IR HAL provides functions for controlling IR transmission. The HAL interface is defined in the `hw/ir.h` header file of the `libdevice-node` library, and the `pkg-config` `device-node` must be used to use the HAL interface.\n\nThe following code snippet shows the interface of the IR HAL:\n\n```cpp\n/*\n   Device ID\n*/\n#define IR_HARDWARE_DEVICE_ID \"ir\"\n\n/*\n   Device version\n*/\n#define IR_HARDWARE_DEVICE_VERSION MAKE_VERSION(0,1)\n\nstruct ir_device {\n    struct hw_common common;\n\n    /* Control the IR state */\n    int (*is_available)(bool *available);\n    int (*transmit)(int *frequency_pattern, int size);\n};\n```\n\nThe following table lists the IR HAL functions.\n\n**Table: IR HAL functions**\n\n| Function prototype                       | Description                              | Mandatory |\n| ---------------------------------------- | ---------------------------------------- | --------- |\n| `int (*is_available)(bool *available);`  | Returns whether the target device supports IR transmission. | Yes |\n| `int (*transmit)(int *frequency_pattern, int size);` | Transmits IR with frequency pattern and its size. | Yes |\n\nThe following code snippet shows an example of the IR HAL:\n\n```cpp\n#define IRLED_CONTROL_PATH \"/sys/class/ir/ir_send\"\n\nstatic int\nir_is_available(bool *available) {\n    *available = true;\n\n    return 0;\n}\n\nstatic int\nir_transmit(int *frequency_pattern, int size) {\n    int i, ret;\n\n    for (i = 0; i common.info = info;\n    ir_dev->is_available = ir_is_available;\n    ir_dev->transmit = ir_transmit;\n\n    *common = (struct hw_common *)ir_dev;\n\n    return 0;\n}\n\nstatic int\nir_close(struct hw_common *common) {\n    free(common);\n\n    return 0;\n}\n\nHARDWARE_MODULE_STRUCTURE = {\n    .magic = HARDWARE_INFO_TAG,\n    .hal_version = HARDWARE_INFO_VERSION,\n    .device_version = IR_HARDWARE_DEVICE_VERSION,\n    .id = IR_HARDWARE_DEVICE_ID,\n    .name = \"ir\",\n    .open = ir_open,\n    .close = ir_close,\n};\n```\n\n#### Touchscreen HAL\n\nThe touchscreen HAL provides functions for switching the touchscreen on and off. The HAL interface is defined in the `hw/touchscreenf.h` header file of the `libdevice-node` library, and the `pkg-config` `device-node` must be used to use the HAL interface.\n\nThe following code snippet shows the interface of the touchscreen HAL:\n\n```cpp\n/*\n   Device ID\n*/\n#define TOUCHSCREEN_HARDWARE_DEVICE_ID \"touchscreen\"\n\n/*\n   Device version\n*/\n#define TOUCHSCREEN_HARDWARE_DEVICE_VERSION MAKE_VERSION(0,1)\n\nenum touchscreen_state {\n    TOUCHSCREEN_OFF, /* Disable touchscreen */\n    TOUCHSCREEN_ON, /* Enable touchscreen */\n};\n\nstruct touchscreen_device {\n    struct hw_common common;\n\n    /* Control touchscreen state */\n    int (*get_state)(enum touchscreen_state *state);\n    int (*set_state)(enum touchscreen_state state);\n};\n```\n\nThe following table lists the touchscreen HAL functions.\n\n**Table: Touchscreen HAL functions**\n\n| Function prototype                       | Description                              | Mandatory |\n| ---------------------------------------- | ---------------------------------------- | --------- |\n| `int (*get_state)(enum touchscreen_state *state);` | Returns whether the touchscreen is enabled. | Yes |\n| `int (*set_state)(enum touchscreen_state state);` | Enables and disables the touchscreen. | Yes |\n\nThe following code snippet shows an example of the touchscreen HAL:\n\n```cpp\n#define TURNON_TOUCHSCREEN 1\n#define TURNOFF_TOUCHSCREEN 0\n#define TOUCHSCREEN_PATH \"/sys/class/input/touchscreen/enable\"\n\nstatic int\ntouchscreen_get_state(enum touchscreen_state *state) {\n    int val;\n    int fd;\n    char buf[BUF_MAX];\n\n    fd = open(TOUCHSCREEN_PATH, O_RDONLY);\n    read(fd, buf, sizeof(buf));\n    close(fd);\n    val = atoi(buf);\n\n    switch (val) {\n    case TURNOFF_TOUCHSCREEN:\n        *state = TOUCHSCREEN_OFF;\n        break;\n    case TURNON_TOUCHSCREEN:\n        *state = TOUCHSCREEN_ON;\n        break;\n    default:\n        return -EINVAL;\n    }\n\n    return 0;\n}\n\nstatic int\ntouchscreen_set_state(enum touchscreen_state state) {\n    int val;\n    char buf[BUF_MAX];\n\n    switch (state) {\n    case TOUCHSCREEN_OFF:\n        val = TURNOFF_TOUCHSCREEN;\n        break;\n    case TOUCHSCREEN_ON:\n        val = TURNON_TOUCHSCREEN;\n        break;\n    default:\n        return -EINVAL;\n    }\n\n    snprintf(buf, sizeof(buf), \"%d\", val);\n    fd = open(TOUCHSCREEN_PATH, O_WRONLY);\n    write(fd, buf, strlen(buf));\n    close(fd);\n\n    return ret;\n}\n\nstatic int\ntouchscreen_open(struct hw_info *info, const char *id, struct hw_common **common) {\n    struct touchscreen_device *touchscreen_dev;\n\n    touchscreen_dev = calloc(1, sizeof(struct touchscreen_device));\n\n    touchscreen_dev->common.info = info;\n    touchscreen_dev->get_state = touchscreen_get_state;\n    touchscreen_dev->set_state = touchscreen_set_state;\n\n    *common = (struct hw_common *)touchscreen_dev;\n\n    return 0;\n}\n\nstatic int\ntouchscreen_close(struct hw_common *common) {\n    free(common);\n\n    return 0;\n}\n\nHARDWARE_MODULE_STRUCTURE = {\n    .magic = HARDWARE_INFO_TAG,\n    .hal_version = HARDWARE_INFO_VERSION,\n    .device_version = TOUCHSCREEN_HARDWARE_DEVICE_VERSION,\n    .id = TOUCHSCREEN_HARDWARE_DEVICE_ID,\n    .name = \"touchscreen\",\n    .open = touchscreen_open,\n    .close = touchscreen_close,\n};\n```\n\n## Sensor Framework\n\nSensor devices are used widely in mobile devices to enhance the user experience. Most modern mobile operating systems have a framework which manages hardware and virtual sensors on the platform and provides convenient APIs to the application.\n\nSensors can be classified into hardware and virtual sensors. Tizen supports individual HALs for the following sensors:\n\n- Hardware sensors\n  - Accelerometer\n  - Geomagnetic sensor\n  - Gyroscope\n  - Light sensor\n  - Proximity sensor\n  - Pressure sensor\n  - Ultraviolet sensor\n  - Temperature sensor\n  - Humidity sensor\n  - HRM (Heart Rate Monitor)\n  - HRM LED green sensor\n  - HRM LED IR sensor\n  - HRM LED red sensor\n  - Uncalibrated geomagnetic sensor\n  - Uncalibrated gyroscope sensor\n  - Human pedometer\n  - Human sleep monitor\n  - Human sleep detector\n  - Human stress monitor\n- Virtual sensors\n  - Orientation sensor\n  - Gravity sensor\n  - Linear acceleration sensor\n  - Rotation vector sensor\n  - Gyroscope rotation vector sensor\n  - Geomagnetic rotation vector sensor\n\nThe sensor framework provides a sensor server for managing sensor HALs and a medium through which client applications are connected to the sensor handler to exchange data.\n\n**Figure: Sensor framework architecture**\n\n![Sensor framework architecture](media/678px-tizen-3-sensorfw.png)\n\nThe sensor HALs retrieve data from sensor hardware and enable client applications to use the data for specific requirements.\n\nThe Sensor framework consists of the following components:\n\n- Sensor client library\n\n  Any application that wants to access the sensor server and communicate with it must use the sensor API library. Using the Sensor API, the application can control sensors and receive sensor events from the sensor server. By using the sensor API, any application or middleware framework can have the sensor client library executing within its own process context.\n\n- Sensor server\n\n  The sensor server is a daemon which communicates uniquely to multiple sensors (through drivers) in the system and dispatches sensor data or events back to the application. The sensor server is responsible for initializing the sensors during boot, driver configuration, sensor data fetching and delivery, and managing all sensors and clients on the platform.\n\n- Sensor HAL (Hardware Abstraction Layer)\n\n  The sensor HAL, which is interfaced to the sensor server, is responsible for interacting with the sensor drivers. The HAL processes data from the sensor drivers and communicates it to the server. Hardware sensors must support the HAL. The sensor HAL is implemented as a shared library. The `sensor_loader` finds the `hal.so` library in the `/usr/lib/sensor/` directory, and loads it at boot time.\n\n### Porting the HAL Interface\n\nYou can port individual sensors or a sensorhub.\n\n#### Sensor\n\nTo port new hardware sensors, the HAL library-inherited `sensor_device` interface must be implemented. The HAL header files can be found at `git:sensord/src/hal`.\n\nThe Tizen HAL sensor types are also defined in the `sensor_hal_types.h` header file under the names `SENSOR_DEVICE_...`.\n\n**Figure: Sensor HAL**\n\n![Sensor HAL](media/tizen-3-sensor-fw-hal.png)\n\nThe following code snippet shows the interface of the sensor HAL in the `sensor_hal.h` header file:\n\n```cpp\n/*\n   Create devices\n*/\ntypedef void *sensor_device_t;\ntypedef int (*create_t)(sensor_device_t **devices);\n\n/*\n   Sensor device interface\n   1 device must be abstracted from 1 device event node\n*/\nclass sensor_device {\npublic:\n    virtual ~sensor_device() {}\n\n    uint32_t get_hal_version(void) {\n        return SENSOR_HAL_VERSION(1, 0);\n    }\n\n    virtual int get_poll_fd(void) = 0;\n    virtual int get_sensors(const sensor_info_t **sensors) = 0;\n\n    virtual bool enable(uint32_t id) = 0;\n    virtual bool disable(uint32_t id) = 0;\n\n    virtual int read_fd(uint32_t **ids) = 0;\n    virtual int get_data(uint32_t id, sensor_data_t **data, int *length) = 0;\n\n    virtual bool set_interval(uint32_t id, unsigned long val) {\n        return true;\n    }\n    virtual bool set_batch_latency(uint32_t id, unsigned long val) {\n        return true;\n    }\n    virtual bool set_attribute_int(uint32_t id, int32_t attribute, int32_t value) {\n        return true;\n    }\n    virtual bool set_attribute_str(uint32_t id, int32_t attribute, char *value, int value_len) {\n        return true;\n    }\n    virtual bool flush(uint32_t id) {\n        return true;\n    }\n};\n```\n\nThe following table describes the functions of the `sensor_device` interface.\n\n**Table: sensor_device interface functions**\n\n| Prototype                                | Description                              | Return value      |\n| ---------------------------------------- | ---------------------------------------- | ----------------- |\n| `uint32_t get_hal_version(void)`         | Returns the HAL version.                 | Version           |\n| `int get_poll_fd(void)`                  | Returns the file description to poll events. | `fd`              |\n| `int get_sensors(const sensor_info_t **sensors)` | Returns the list of supported sensors. See the `sensor_info_t` in the `sensor_hal_types.h` header file. | Size              |\n| `bool enable(uint32_t id)`               | Enables the sensor.                      | `true` on success |\n| `bool disable(uint32_t id)`              | Disables the sensor.                     | `true` on success |\n| `int read_fd(uint32_t **ids)`            | Returns the sensor device IDs. The sensor framework calls this function when an event is detected from the `poll-fd`. | Size              |\n| `int get_data(uint32_t id, sensor_data_t **data, int *length)` | Updates the `sensor_data_t` object (data) with details about the sensor, such as accuracy, timestamp, and values. Note that the `sensor_data_t` object must be created using the `malloc()` function. | 0 on success      |\n| `bool set_interval(uint32_t id, unsigned long val)` | Sets the interval.                       | `true` on success |\n| `bool set_batch_latency(uint32_t id, unsigned long val)` | Sets the batch latency.                   | `true` on success |\n| `bool set_attribute_int(uint32_t id, int32_t attribute, int32_t value)` | Sets the `int` value to the attribute.   | `true` on success |\n| `bool set_attribute_str(uint32_t id, int32_t attribute, char *value, int value_len)` | Sets the `string` value to the attribute.      | `true` on success |\n| `bool flush(uint32_t id)`                | Flushes the sensor events.               | `true` on success |\n| `int (create_t *)(sensor_device_t **devices)` | Returns the `sensor_device` list. To create the sensor module in `sensord`, you must implement this interface. | Size              |\n\nThe following code snippet shows the interface of the sensor HAL types in the `sensor_hal_type.h` header file:\n\n```cpp\n/*\n   Sensor Types\n   These types are used to control the sensors\n\n   - base unit\n     acceleration values : meter per second^2 (m/s^2)\n     magnetic values     : micro-Tesla (uT)\n     orientation values  : degrees\n     gyroscope values    : degree/s\n     temperature values  : degrees centigrade\n     proximity values    : distance\n     light values        : lux\n     pressure values     : hectopascal (hPa)\n     humidity            : relative humidity (%)\n*/\ntypedef enum {\n    SENSOR_DEVICE_UNKNOWN = -2,\n    SENSOR_DEVICE_ALL = -1,\n    SENSOR_DEVICE_ACCELEROMETER,\n    SENSOR_DEVICE_GRAVITY,\n    SENSOR_DEVICE_LINEAR_\n    SENSOR_DEVICE_GEOMAGNETIC,\n    SENSOR_DEVICE_ROTATION_VECTOR,\n    SENSOR_DEVICE_ORIENTATION,\n    SENSOR_DEVICE_GYROSCOPE,\n    SENSOR_DEVICE_LIGHT,\n    SENSOR_DEVICE_PROXIMITY,\n    SENSOR_DEVICE_PRESSURE,\n    SENSOR_DEVICE_ULTRAVIOLET,\n    SENSOR_DEVICE_TEMPERATURE,\n    SENSOR_DEVICE_HUMIDITY,\n    SENSOR_DEVICE_HRM,\n    SENSOR_DEVICE_HRM_LED_GREEN,\n    SENSOR_DEVICE_HRM_LED_IR,\n    SENSOR_DEVICE_HRM_LED_RED,\n    SENSOR_DEVICE_GYROSCOPE_UNCAL,\n    SENSOR_DEVICE_GEOMAGNETIC_UNCAL,\n    SENSOR_DEVICE_GYROSCOPE_RV,\n    SENSOR_DEVICE_GEOMAGNETIC_RV,\n\n    SENSOR_DEVICE_HUMAN_PEDOMETER = 0x300,\n    SENSOR_DEVICE_HUMAN_SLEEP_MONITOR,\n    SENSOR_DEVICE_HUMAN_SLEEP_DETECTOR,\n    SENSOR_DEVICE_HUMAN_STRESS_MONITOR,\n\n    SENSOR_DEVICE_EXERCISE_WALKING = 0x400,\n    SENSOR_DEVICE_EXERCISE_RUNNING,\n    SENSOR_DEVICE_EXERCISE_HIKING,\n    SENSOR_DEVICE_EXERCISE_CYCLING,\n    SENSOR_DEVICE_EXERCISE_ELLIPTICAL,\n    SENSOR_DEVICE_EXERCISE_INDOOR_CYCLING,\n    SENSOR_DEVICE_EXERCISE_ROWING,\n    SENSOR_DEVICE_EXERCISE_STEPPER,\n\n    SENSOR_DEVICE_FUSION = 0x900,\n    SENSOR_DEVICE_AUTO_ROTATION,\n    SENSOR_DEVICE_AUTO_BRIGHTNESS,\n\n    SENSOR_DEVICE_GESTURE_MOVEMENT = 0x1200,\n    SENSOR_DEVICE_GESTURE_WRIST_UP,\n    SENSOR_DEVICE_GESTURE_WRIST_\n    SENSOR_DEVICE_GESTURE_MOVEMENT_STATE,\n\n    SENSOR_DEVICE_ACTIVITY_TRACKER = 0x1A00,\n    SENSOR_DEVICE_ACTIVITY_LEVEL_MONITOR,\n} sensor_device_type;\n```\n\nThe following code snippet shows the interface of the sensor HAL information in the `sensor_hal_type.h` header file:\n\n```cpp\n/*\n   A platform sensor handler is generated based on this handle\n   This ID can be assigned by HAL developer, so it must be unique in 1 sensor_device.\n*/\ntypedef struct sensor_info_t {\n    uint32_t\n    const char *name;\n    sensor_device_type type;\n    unsigned int event_type; /* for Internal API */\n    const char *model_name;\n    const char *vendor;\n    float min_range;\n    float max_range;\n    float resolution;\n    int min_interval;\n    int max_batch_count;\n    bool wakeup_supported;\n} sensor_info_t;\n\nenum sensor_accuracy_t {\n    SENSOR_ACCURACY_UNDEFINED = -1,\n    SENSOR_ACCURACY_BAD = 0,\n    SENSOR_ACCURACY_NORMAL = 1,\n    SENSOR_ACCURACY_GOOD = 2,\n    SENSOR_ACCURACY_VERYGOOD = 3\n};\n\n#define SENSOR_DATA_VALUE_SIZE 16\n\n/* sensor_data_t */\ntypedef struct sensor_data_t {\n    int accuracy;\n    unsigned long long timestamp;\n    int value_count;\n    float values[SENSOR_DATA_VALUE_SIZE];\n} sensor_data_t;\n\n#define SENSOR_PEDOMETER_DATA_DIFFS_SIZE\t20\n\ntypedef struct {\n    int accuracy;\n    unsigned long long timestamp;\n    int value_count; /* value_count == 8 */\n    float values[SENSOR_DATA_VALUE_SIZE];\n    /* values = {step count, walk step count, run step count,\n\t         moving distance, calorie burned, last speed,\n\t         last stepping frequency (steps per sec),\n\t         last step status (walking, running, ...)} */\n    /* Additional data attributes (not in sensor_data_t)*/\n    int diffs_count;\n    struct differences {\n        int timestamp;\n        int steps;\n        int walk_steps;\n        int run_steps;\n        int walk_up_steps;\n        int walk_down_steps;\n        int run_up_steps;\n        int run_down_steps;\n        float distance;\n        float calories;\n        float speed;\n    } diffs[SENSOR_PEDOMETER_DATA_DIFFS_SIZE];\n} sensor_pedometer_data_t;\n\n#define CONVERT_TYPE_ATTR(type, index) ((type) \n#include \n#include \n\n#include \"accel/accel_device.h\"\n\nstatic std::vector devs;\n\ntemplate\nvoid\ncreate_sensor(const char *name) {\n    sensor_device *instance = NULL;\n    try {\n        instance = new _sensor;\n    } catch (std::exception &e) {\n        ERR(\"Failed to create %s sensor device, exception: %s\", name, e.what());\n\n        return;\n    } catch (int err) {\n        _ERRNO(err, _E, \"Failed to create %s sensor device\", name);\n\n        return;\n    }\n\n    devs.push_back(instance);\n}\n\nextern \"C\" int create(sensor_device_t **devices) {\n#ifdef ENABLE_ACCEL\n    create_sensor(\"Accelerometer\");\n#endif\n\n    *devices = &devs[0];\n\n    return devs.size();\n}\n```\n\n```cpp\n/* In accel_device.h */\n#ifndef _ACCEL_DEVICE_H_\n#define _ACCEL_DEVICE_H_\n\n#include \n#include \n#include \n#include \n\nclass accel_device : public sensor_device {\npublic:\n    accel_device();\n    virtual ~accel_device();\n\n    int get_poll_fd(void);\n    int get_sensors(const sensor_info_t **sensors);\n\n    bool enable(uint32_t id);\n    bool disable(uint32_t id);\n\n    bool set_interval(uint32_t id, unsigned long val);\n\n    int read_fd(uint32_t **ids);\n    int get_data(uint32_t id, sensor_data_t **data, int *length);\n\nprivate:\n    int m_node_handle;\n    int m_x;\n    int m_y;\n    int m_z;\n    unsigned long m_polling_interval;\n    unsigned long long m_fired_time;\n    bool m_sensorhub_controlled;\n\n    int m_method;\n    std::string m_data_node;\n    std::string m_enable_node;\n    std::string m_interval_node;\n\n    std::function update_value;\n\n    std::vector event_ids;\n\n    bool update_value_input_event(void);\n    bool update_value_iio(void);\n\n    void raw_to_base(sensor_data_t *data);\n};\n#endif /* _ACCEL_DEVICE_H_ */\n```\n\n```cpp\n/* In accel_device.cpp */\n#include \n#include \n#include \n#include \n\n#include \n#include \n#include \n\n#include \n#include \n#include \n\n#include \"accel_device.h\"\n\n#define MODEL_NAME \"K2HH\"\n#define VENDOR \"ST Microelectronics\"\n#define RESOLUTION 16\n#define RAW_DATA_UNIT 0.122\n#define MIN_INTERVAL 1\n#define MAX_BATCH_COUNT 0\n\n#define SENSOR_NAME \"SENSOR_ACCELEROMETER\"\n#define SENSOR_TYPE_ACCEL\t\t\"ACCEL\"\n\n#define INPUT_NAME\t\"accelerometer_sensor\"\n#define ACCEL_SENSORHUB_POLL_NODE_NAME \"accel_poll_delay\"\n\n#define GRAVITY 9.80665\n#define G_TO_MG 1000\n#define RAW_DATA_TO_G_UNIT(X) (((float)(X))/((float)G_TO_MG))\n#define RAW_DATA_TO_METRE_PER_SECOND_SQUARED_UNIT(X) (GRAVITY * (RAW_DATA_TO_G_UNIT(X)))\n\n#define MIN_RANGE(RES) (-((1 update_value_input_event();\n        };\n    } else {\n        if (!info.buffer_length_node_path.empty())\n            util::set_node_value(info.buffer_length_node_path, 480);\n\n        if (!info.buffer_enable_node_path.empty())\n            util::set_node_value(info.buffer_enable_node_path, 1);\n\n        update_value = [=]() {\n            return this->update_value_iio();\n        };\n    }\n\n    _I(\"accel_device is created!\");\n}\n\naccel_device::~accel_device() {\n    close(m_node_handle);\n    m_node_handle = -1;\n\n    _I(\"accel_device is destroyed!\");\n}\n\nint\naccel_device::get_poll_fd(void) {\n    return m_node_handle;\n}\n\nint\naccel_device::get_sensors(const sensor_info_t **sensors) {\n    *sensors = &sensor_info;\n\n    return 1;\n}\n\nbool\naccel_device::enable(uint32_t id) {\n    util::set_enable_node(m_enable_node, m_sensorhub_controlled, true, SENSORHUB_ACCELEROMETER_ENABLE_BIT);\n    set_interval(id, m_polling_interval);\n\n    m_fired_time = 0;\n    _I(\"Enable accelerometer sensor\");\n\n    return true;\n}\n\nbool\naccel_device::disable(uint32_t id) {\n    util::set_enable_node(m_enable_node, m_sensorhub_controlled, false, SENSORHUB_ACCELEROMETER_ENABLE_BIT);\n\n    _I(\"Disable accelerometer sensor\");\n\n    return true;\n}\n\nbool\naccel_device::set_interval(uint32_t id, unsigned long val) {\n    unsigned long long polling_interval_ns;\n\n    polling_interval_ns = ((unsigned long long)(val) * 1000llu * 1000llu);\n\n    if (!util::set_node_value(m_interval_node, polling_interval_ns)) {\n        _E(\"Failed to set polling resource: %s\", m_interval_node.c_str());\n\n        return false;\n    }\n\n    _I(\"Interval is changed from %dms to %dms\", m_polling_interval, val);\n    m_polling_interval = val;\n\n    return true;\n}\n\nbool\naccel_device::update_value_input_event(void) {\n    int accel_raw[3] = {0,};\n    bool x,y,z;\n    int read_input_cnt = 0;\n    const int INPUT_MAX_BEFORE_SYN = 10;\n    unsigned long long fired_time = 0;\n    bool syn = false;\n\n    x = y = z = false;\n\n    struct input_event accel_input;\n    _D(\"accel event detection!\");\n\n    while ((syn == false) && (read_input_cnt accuracy = SENSOR_ACCURACY_GOOD;\n    sensor_data->timestamp = m_fired_time;\n    sensor_data->value_count = 3;\n    sensor_data->values[0] = m_x;\n    sensor_data->values[1] = m_y;\n    sensor_data->values[2] = m_z;\n\n    raw_to_base(sensor_data);\n\n    *data = sensor_data;\n    *length = sizeof(sensor_data_t);\n\n    return 0;\n}\n\nvoid\naccel_device::raw_to_base(sensor_data_t *data) {\n    data->values[0] = RAW_DATA_TO_METRE_PER_SECOND_SQUARED_UNIT(data->values[0] * RAW_DATA_UNIT);\n    data->values[1] = RAW_DATA_TO_METRE_PER_SECOND_SQUARED_UNIT(data->values[1] * RAW_DATA_UNIT);\n    data->values[2] = RAW_DATA_TO_METRE_PER_SECOND_SQUARED_UNIT(data->values[2] * RAW_DATA_UNIT);\n}\n```\n\n#### Sensorhub\n\nThe sensorhub HAL supports multiple sensors logically from 1 physical device file. If many sensors are supported by a single device file, the sensorhub HAL can be configured so that it can operate each sensor as a logically-separate device.\n\nThe sensor HAL interface is provided to manufacturers and vendors through the `sensor_hal.h` and `sensor_hal_types.h` header files. It uses just 1 thread for polling sensor events from multiple device files.\n\n**Figure: Sensorhub HAL**\n\n![Sensorhub HAL](media/656px-tizen-3-sensorhub2.png)\n\nThe sensorhub HAL can be developed by using the `sensor_device` interface. An example of a sensorhub HAL can be found in the `sensor-hal-tm1/src/sensorhub` Git.\n\nIDs can be assigned by the vendor or manufacturer for the sensorhub sensors by using the following `sensor_info_t` interface:\n\n```cpp\ntypedef struct sensor_info_t {\n    uint32_t id;\n    const char *name;\n    sensor_device_type type;\n    unsigned int event_type; /* For Internal API */\n    const char *model_name;\n    const char *vendor;\n    float min_range;\n    float max_range;\n    float resolution;\n    int min_interval;\n    int max_batch_count;\n    bool wakeup_supported;\n} sensor_info_t;\n```\n\nThe following code snippet shows an example of a sensorhub HAL implementation:\n\n```cpp\n#include \n#include \n\n#include \"sensorhub.h\"\n#include \"sensorhub_controller.h\"\n#include \"sensorhub_manager.h\"\n#include \"system_state.h\"\n\nsensorhub_device::sensorhub_device() {\n    controller = &sensorhub_controller::get_instance();\n    if (!controller) {\n        ERR(\"Failed to allocated memory\");\n        throw;\n    }\n\n    manager = &sensorhub_manager::get_instance();\n    if (!manager) {\n        ERR(\"Failed to allocated memory\");\n        throw;\n    }\n    manager->set_controller(controller);\n    system_state_handler::get_instance().set_controller(controller);\n\n    INFO(\"sensorhub_device is created!\");\n}\n\nsensorhub_device::~sensorhub_device() {\n    INFO(\"sensorhub_device is destroyed!\");\n}\n\nint\nsensorhub_device::get_poll_fd(void) {\n    return controller->get_poll_fd();\n}\n\nint\nsensorhub_device::get_sensors(const sensor_info_t **sensors) {\n    int size;\n    size = manager->get_sensors(sensors);\n\n    return size;\n}\n\nbool\nsensorhub_device::enable(uint32_t id) {\n    system_state_handler::get_instance().initialize();\n\n    controller->enable();\n    sensorhub_sensor *sensor = manager->get_sensor(id);\n\n    if (!sensor) {\n        ERR(\"Failed to enable sensor(0x%x)\", id);\n\n        return false;\n    }\n\n    return sensor->enable();\n}\n\nbool\nsensorhub_device::disable(uint32_t id) {\n    system_state_handler::get_instance().finalize();\n\n    controller->disable();\n    sensorhub_sensor *sensor = manager->get_sensor(id);\n\n    if (!sensor) {\n        ERR(\"Failed to disable sensor(0x%x)\", id);\n\n        return false;\n    }\n\n    return sensor->disable();\n}\n\nbool\nsensorhub_device::set_interval(uint32_t id, unsigned long val) {\n    sensorhub_sensor *sensor = manager->get_sensor(id);\n\n    if (!sensor) {\n        ERR(\"Failed to set interval to sensor(0x%x)\", id);\n\n        return false;\n    }\n\n    return sensor->set_interval(val);\n}\n\nbool\nsensorhub_device::set_batch_latency(uint32_t id, unsigned long val) {\n    sensorhub_sensor *sensor = manager->get_sensor(id);\n\n    if (!sensor) {\n        ERR(\"Failed to set batch latency to sensor(0x%x)\", id);\n\n        return false;\n    }\n\n    return sensor->set_batch_latency(val);\n}\n\nbool\nsensorhub_device::set_attribute_int(uint32_t id, int32_t attribute, int32_t value) {\n    int ret;\n\n    sensorhub_sensor *sensor = manager->get_sensor(id);\n\n    if (!sensor) {\n        ERR(\"Failed to set attribute to sensor(0x%x)\", id);\n\n        return false;\n    }\n\n    ret = sensor->set_attribute_int(attribute, value);\n\n    if ((ret get_sensor(id);\n\n    if (!sensor) {\n        ERR(\"Failed to set attribute to sensor(0x%x)\", id);\n\n        return false;\n    }\n\n    ret = sensor->set_attribute_str(attribute, value, value_len);\n\n    if ((ret read_fd(data))\n        return 0;\n\n    /* Step 2 */\n    const char *hub_data = data.values;\n    int data_len = data.value_count;\n\n    /* Step 3 */\n    event_ids.clear();\n\n    while (data_len > 0) {\n        DBG(\"Remaining data length: %d\", data_len);\n        int parsed = parse(hub_data, data_len);\n        if (parsed get_sensor(id);\n    if (!sensor) {\n        ERR(\"Failed to get data from sensor(0x%x)\", id);\n\n        return -1;\n    }\n\n    remains = sensor->get_data(data, length);\n\n    return remains;\n}\n\nbool\nsensorhub_device::flush(uint32_t id) {\n    return false;\n}\n\nint\nsensorhub_device::parse(const char *hub_data, int data_len) {\n    return parse_data(hub_data, data_len);\n}\n\nint\nsensorhub_device::parse_data(const char *hub_data, int data_len) {\n    const char *cursor = hub_data;\n    int32_t libtype = 0;\n\n    sensorhub_sensor *sensor = manager->get_sensor(libtype);\n    if (!sensor) {\n        ERR(\"Unknown Sensorhub lib type: %d\", libtype);\n\n        return -1;\n    }\n\n    event_ids.push_back(sensor->get_id());\n\n    return sensor->parse(cursor, data_len);\n}\n\nint\nsensorhub_device::parse_debug(const char *hub_data, int data_len) {\n    return 0;\n}\n```\n\n```cpp\n#include \n#include \n#include \n#include \n#include \n#include \n#include \n#include \n\n#include \n#include \n#include \"sensorhub_controller.h\"\n\nsensorhub_controller::sensorhub_controller()\n: m_enabled(false)\n, m_poll_node(-1)\n, m_data_node(-1) {}\n\nsensorhub_controller::~sensorhub_controller() {}\n\nsensorhub_controller& sensorhub_controller::get_instance(void) {\n    static sensorhub_controller instance;\n\n    return instance;\n}\n\nint\nsensorhub_controller::get_poll_fd(void) {\n    /* Returns the sensorhub fd */\n\n    return -1;\n}\n\nbool\nsensorhub_controller::enable(void) {\n    m_enabled = true;\n    INFO(\"Enable Sensorhub\");\n\n    return true;\n}\n\nbool\nsensorhub_controller::disable(void) {\n    m_enabled = false;\n    INFO(\"Disable Sensorhub\");\n\n    return true;\n}\n\nint\nsensorhub_controller::open_input_node(const char* input_node) {\n    /* Implements the specific sensorhub logic */\n\n    return -1;\n}\n\nbool\nsensorhub_controller::read_fd(sensorhub_data_t &data) {\n    /* Implements the specific sensorhub logic */\n\n    return false;\n}\n\nint\nsensorhub_controller::read_sensorhub_data(void) {\n    /* Implements the specific sensorhub logic */\n\n    return -1;\n}\n\nint\nsensorhub_controller::read_large_sensorhub_data(void) {\n    /* Implements the specific sensorhub logic */\n\n    return -1;\n}\n\nint\nsensorhub_controller::send_sensorhub_data(const char *data, int data_len) {\n    /* Implements the specific sensorhub logic */\n\n    return -1;\n}\n\nint\nsensorhub_controller::print_sensorhub_data(const char* name, const char *data, int length) {\n    /* Implements the specific sensorhub logic */\n\n    return 0;\n}\n```\n\n### References\n\nThe reference kernel configuration for sensors varies depending on vendor types. However, there is a standard kernel subsystem for sensors: the Industrial I/O (IIO) subsystem. IIO is intended to provide support for devices that are, in some sense, analog to digital or digital to analog.\nFor more information, see [https://wiki.analog.com/software/linux/docs/iio/iio](https://wiki.analog.com/software/linux/docs/iio/iio).\n\nThe following table lists some example kernel configurations.\n\n**Table: Example kernel configurations**\n\n| Sensor component   | Kernel configuration    | Device nodes                             |\n| ------------------ | ----------------------- | ---------------------------------------- |\n| Accelerometer      | `CONFIG_INPUT_KR3DH`    | `/dev/input/event0/`, `/dev/input/event1/`, `/dev/input/event2/`, `/dev/input/event3/`, `/dev/input/event4/`, `/dev/input/event5/` |\n| Proximity          | `CONFIG_INPUT_GP2A`     |                                          |\n| Light sensor       | `CONFIG_INPUT_GP2A`     |                                          |\n| Electronic compass | `CONFIG_SENSORS_AK8975` |                                          |\n\n### Project Git Repositories\n\nThe following table lists the available project Git repositories.\n\n**Table: Git repositories**\n\n| Project               | Repository                               | Description                              |\n| --------------------- | ---------------------------------------- | ---------------------------------------- |\n| `capi-system-sensor`  | `platform/core/api/sensor`               | Tizen sensor C-API                       |\n| `sensord`             | `platform/core/system/sensord`           | Sensor daemon and libraries for managing sensors and clients |\n| `sensor-hal-tm1`      | `platform/adaptation/tm1/sensor-hal-tm1` | Sensor HAL for the TM1 device                |\n| `sensor-hal-tm2`      | `platform/adaptation/tm2/sensor-hal-tm2` | Sensor HAL for the TM2 device                |\n| `sensor-hal-tw1`      | `platform/adaptation/tw1/sensor-hal-tw1` | Sensor HAL for the TW1 device                |\n| `sensor-hal-emulator` | `platform/adaptation/emulator/sensor-hal-emulator` | Sensor HAL for the emulator                  |\n\n### Testing and Verifying Sensors\n\nThe `sensor-test package`, in the `sensord` Git repository, provides `sensorctl`, a command-line tool for testing sensors. After installing `sensor-test package`, you can test sensors using the following commands:\n\n```\n$ sensorctl test accelerometer\n$ sensorctl test gyroscope\n$ sensorctl test accelerometer 100 /* enable accelerometer with interval 100 ms */\n$ sensorctl test accelerometer 100 1000 /* enable accelerometer with interval 100 ms and 1s batch latency */\n$ sensorctl test accelerometer 100 1000 0 /* enable accelerometer with interval 100 ms, 1s batch latency and always on option */\n$ sensorctl info accelerometer /* retrieve accelerometer sensor information */\n```\n\n## Crash Framework\n\n### crash-manager\n\ncrash-manager is a tool used to create crash reports when an application gets crashed.\ncrash-manager is not usually invoked manually, but automatically by the kernel when the crash occurs. crash-manager generates the crash report and attaches the kernel-provided core, if requested. crash-worker package provides the `99-crash-manager.conf` file, which configures kernel parameters for crash-manager to get invoked automatically on crash. For more information, see [`99-crash-manager.conf`](#99-crash-managerconf).\n\ncrash-manager consists of the following options:\n\nOption                | Description\n----------------------|------------------------------------------------------\n-p  --pid=PID         | Specifies the process ID (PID) of the dumped process.\n-u  --uid=UID         | Specifies the real user identifier (UID) of the dumped process.\n-g  --gid=GID         | Specifies the real group identifier (GID) of the dumped process.\n-i  --tid=TID         | Specifies the thread identifier (TID) of the thread that triggered core dump. For more information, see [core(5)](http://man7.org/linux/man-pages/man5/core.5.html).\n-s  --signal=SIG      | Specifies the signal number causing dump.\n-t  --time=TIME       | Specifies the time of dump in seconds since the epoch.\n-l  --live            | Gets the core dump of the running process.\n-k  --kill-after-dump | Kills after dump (only with --live option).\n-r  --print           | Prints the report path to standard output (stdout).\n-h  --help            | Prints the help message.\n\nIn addition to handling crashes, crash-manager can create reports from running processes, livedumps. Livedumps contain `core` generated from the running process. The `core` is not created automatically but need to be requested explicitly by you. crash-manager needs to be invoked with the `--live` option, to produce the livedump report:\n\n```\n$ /usr/bin/crash-manager -p  --live --print\n```\n\n#### 99-crash-manager.conf\n\nThe `99-crash-manager.conf` file consists of the following kernel configurations related to the core dump:\n\n-  **kernel.core_pattern**  \n     This value contains the path to the file in which the kernel will store the core dump in case of a process crash. The possible values are described in [core(5)](http://man7.org/linux/man-pages/man5/core.5.html). If the first character of this path is a pipe symbol (`|`), then the whole line is interpreted as a program that can be executed, and the core dump will be given as a standard input.\n     To disable crash-manager, set this value to an empty string.\n\n     Default value: ```\"/usr/bin/crash-manager -p %p -u %u -g %g -s %s -t %t\"```\n\n-  **kernel.core_pipe_limit**  \n     Defines the maximum number of concurrent processes that may be dumped at the same time. For more information, see [core(5)](http://man7.org/linux/man-pages/man5/core.5.html).\n     If the limit is exceeded, then the next crashed process will not be dumped.\n\n     Default value: `10`\n\n-  **fs.suid_dumpable**  \n     Defines whether the core dump is produced for the set-owner-user-ID (SUID) binaries ([proc(5)](http://man7.org/linux/man-pages/man5/proc.5.html)) or not.\n\n     Default value: `2`\n\n\n#### crash-manager.conf\n\nThe default configuration file for crash-manager is `/etc/crash-manager.conf`. It is used to configure the location, the content and retention policy of crash reports.\n\n-  **SystemMaxUse**  \n     Determines the maximum size (in kilobytes) on disk that reports can occupy. If this value is exceeded, then the oldest reports will be deleted.\n     Value `0` turns off the check.\n\n     Default value: `0`\n\n-  **SystemKeepFree**  \n     If set to a value other than `0`, then crash-manager will check whether an appropriate amount of empty space (in kilobytes) is available on the disk or not.\n     Value `0` turns off the check.\n\n     Default value: `0`\n\n-  **MaxRetentionSec**  \n     Defines the maximal time (in seconds) a report will be kept. Older reports will be deleted.\n     Value `0` turns off the check.\n\n     Default value: `0`\n\n-  **MaxCrashDump**  \n     Defines how many reports will be kept. In case the number of reports exceeds this value, the oldest reports will be removed.\n     Value `0` turns off the check.\n\n     Default value: `0`\n\n-  **AllowZip**  \n     Determines whether the report will be compressed or not.\n\n     Default value: `yes`\n\n-  **CoreDump**  \n     If set to `0`, then the core dump will be removed from the final report.\n\n     Default value: `1`\n\n-  **CrashRootPath**  \n     Specifies the directory in which the crash reports will be saved. In the specified path, crash-manager will create four sub-directories:\n     - `dump/`: For saved reports of crashed applications\n     - `livedump/`: For saved reports of running processes (with option `--live`)\n     - `log/`: For logs\n     - `temp/`: For files while creating report\n\n     Default value: `/opt/user/share/crash/`\n\n-  **ReportType**  \n     Specifies the type of the crash report. Possible values are:\n     - `INFO`: Only the `*.info` file will be saved. The `*.info` file contains information about the registers and the call stack of the crashed application.\n     - `FULL`: The full crash report:\n         - `*.info`: Contains information about the registers and the call stack of the crashed application.\n         - `*.coredump`: A process memory dump.\n         - `*.so_info`: Contains information about shared libraries used by the crashed application, together with the names of packages that contain them.\n         - `*.log`: Contains information provided by [dump_systemstate](#dump_systemstate).\n         - Interesting files (`cmdline`, `environ`, `io`, `maps`, `smaps`, `stack`, `stat`, `statm`, `cwd`, `fd`) from the `/proc//` directory.\n\n     Default value: `FULL`\n\n\n-  **ExtraScript**  \n     Path to a script or an application that will be executed during report creation. The process will be started asynchronously.\n\n     Default value is empty\n\n#### Disabling crash-manager\n\nIn some situations there may be a need to disable the crash-manager functionality. In such cases, the recommended solution is to provide the `sysctl` configuration file to overwrite the default `kernel.core_pattern` setting. For example, the `99-disable-crash-manager.conf` file must be placed in the `/usr/lib/sysctl.d/` directory and must contain:\n\n```\nkernel.core_pattern=\nkernel.core_uses_pid=0\n```\n\n### D-Bus notification\n\nAfter the report is generated, crash-manager sends the D-Bus signal containing the following information about the crashed process:\n\nSignature: `sssssiia{sv}`  \nMember: `ProcessCrashed`  \nInterface: `org.tizen.system.crash.Crash`  \nPath: `/Org/Tizen/System/Crash/Crash`  \nData structure:  \n\nData         | Type\n-------------|-------\ncommand name | STRING\ncommand path | STRING\nappid        | STRING\npkgid        | STRING\nreport path  | STRING\nPID          | INT32\nTID          | INT32\narray        | ARRAY\n\nArray containing pairs of keys (STRING) and values (VARIANT). Possible keys:\n\nKey          | Type   | Description\n-------------|--------|---------------\nx86.eip      | UINT32 | instruction pointer\nx86_64.rip   | UINT64 | instruction pointer\narm.pc       | UINT32 | instruction pointer\narm.lr       | UINT32 | instruction pointer\naarch64.pc   | UINT64 | instruction pointer\naarch64.lr   | UINT64 | instruction pointer\nsys.signal   | INT32  | signal that caused crash\nsys.tid.comm | STRING | thread name\n\nDepending on the architecture, array will contain:\n\nArch    | PC (instruction pointer) | Link Register\n--------|--------------------------|------------------\nx86     | x86.eip                  | (not available)\nx86_64  | x86_64.eip               | (not available)\narm     | arm.pc                   | arm.lr\naarch64 | aarch64.pc               | aarch64.lr\n\n### minicoredumper\n\nminicoredumper is a tool that accepts a core dump on a standard input and saves the modified (size-reduced) core dump in a file. This tool is internally used by crash-manager to generate minicoredump. Modifications depends on the configuration, and they mainly rely on minimization of the core dump file.\n\nUsually, integrator does not need to modify this configuration unless integrator needs to change parameters of minicoredump files or settings for specified applications.\n\nminicoredumper can be used alone by setting `/proc/sys/kernel/core_pattern` to `|/usr/bin/minicoredumper %P %u %g %s %t %h %e`. All possible `%` specifiers are described in [core(5)](http://man7.org/linux/man-pages/man5/core.5.html).\n\nThe default path of the configuration file is `/etc/minicoredumper/minicoredumper.cfg.json` and the file format is JSON. Possible options are:\n\n-   **base_dir** (string): Defines the root directory where the dumped data will be stored. This option is overwritten by the command line option, which is set by **crash-manager**.\n-   **watch** (array): A set of recepts, which will be used for applications that meet the defined criteria:\n    -   **exe** (string): The full path to the binary returned by readlink. The `*` character is supported as wildcard. If not specified, the `*` value will be used.\n    -   **comm** (string): The basename of the command that was run. The `*` character is supported as wildcard. If not specified, the `*` value will be used.\n    -   **recept** (string): The full path to the recept file.\n\n    > **Note**\n    >\n    > If **exe** and **comm** are specified, then both conditions must be met to use the recept.\n\nDefault minicoredumper.cfg.json:\n\n```\n  {\n      \"base_dir\": \"/usr/local/var/crash/minicoredumper\",\n      \"watch\": [\n          {\n              \"exe\": \"/usr/bin/dotnet-launcher\",\n              \"recept\": \"dotnet.recept.json\"\n          },\n          {\n              \"recept\": \"generic.recept.json\"\n          }\n      ]\n  }\n```\n\n\nThe default path of the recept files is `/etc/minicoredumper/` and the format is JSON. Possible options are:\n\n-   **stacks** (list): Contains settings for what should be dumped.\n    -   **dump_stacks** (bool): If true, stacks will be dumped.\n    -   **first_thread_only** (bool): If true, only the first thread will be dumped.\n    -   **max_stack_size** (integer): Maximum size of the stack.\n-   **maps** (list): Contains list \"dump_by_name\".\n    -   **dump_by_name** (list): List of pathnames of memory regions that should be dumped (pathnames are read from `/proc//maps`).\n-   **compression** (list): Contains settings related to report compression.\n    -   **compressor** (string): Command line of compressor that supports stdin as input and stdout as output (gzip, bzip2, xz).\n    -   **extension**: (string): In case of a compressed core file, the specified value will be appended at the end of the core file name; otherwise, `.compressed` will be appended to the compressed core files.\n    -   **in_tar** (bool): Determines whether the core file should be a `.tar` file or not. This is useful because the tar format enables preserving the sparse properties of the core file.\n    -   **dump_auxv_so_list** (bool): If true, the shared object list will be saved in the core file.\n    -   **dump_pthread_list** (bool): If true, the pthread list will be saved in the core file.\n    -   **dump_robust_mutex_list** (bool): If true then robust mutexes will be saved in the core file.\n    -   **dump_scope** (int): Only registered dumps at this value or lower than this value will be dumped. This option applies only to libminicoredumper.\n    -   **dump_build_id** (bool): If true, then for all the contained ELF files, minicoredumper will save ELF header with BuildID to enable determining a specific version of the shared libraries.\n    -   **live_dumper** (bool): If true, then minicoredumper will trigger applications registered by libminicoredumper.\n    -   **write_proc_info** (boolean): If true, then interesting files (`cmdline`, `environ`, `io`, `maps`, `smaps`, `stack`, `stat`, `statm`, `cwd`, `fd`) from `/proc/` will be copied to the dump directory.\n    -   **proc_info_exclude** (list): Contains a list of filenames that must not be copied from the `/proc/` directory. For example, copying the `smaps` files will significantly increase the dumping time.\n    -   **write_debug_log** (bool): If true, then minicoredumper messages will be saved to `debug.txt` in the dump directory.\n    -   **dump_fat_core** (bool): If true, then all virtual memory areas will be saved in the separate core dump file. This must be used only for debug purpose.\n    -   **dump_pointed_by_regs** (bool): If true, then memory region around the address to which the CPU registers point is saved in the core file by minicoredumper. Precisely, for each CPU register minicoredumper saves page to which address points, one page before the address, and one page after the address. Page is 4096 bytes on most architectures.\n    -   **full_coredump** (bool): If true, then minicoredumper dumps the full core dump file.\n\nDefault `generic.recept.json`:\n\n```\n  {\n      \"stacks\": {\n          \"dump_stacks\": true,\n          \"first_thread_only\": false,\n          \"max_stack_size\": 0\n      },\n      \"maps\": {\n          \"dump_by_name\": [\n              \"[vdso]\"\n          ]\n      },\n      \"compression\": {\n          \"compressor\": \"\",\n          \"extension\": \"\",\n          \"in_tar\": true\n      },\n      \"dump_auxv_so_list\": true,\n      \"dump_pthread_list\": true,\n      \"dump_robust_mutex_list\": true,\n      \"dump_scope\": 1024,\n      \"dump_build_id\": true,\n      \"live_dumper\": true,\n      \"write_proc_info\": true,\n      \"proc_info_exclude\": [\n          \"smaps\"\n      ],\n      \"write_debug_log\": false,\n      \"dump_fat_core\": false,\n      \"dump_pointed_by_regs\": true\n  }\n```\n\n### dump_systemstate\n\n**dump_systemstate** is used to dump information that can be useful for developers to fix bugs in the crashed applications.\n\nDefault dump contains:\n-   Basic information:\n    -   Binary version from `/etc/info.ini`\n    -   Tizen version from `/etc/tizen-release`\n    -   Kernel version from `/proc/version`\n    -   Boot arguments from `/proc/cmdline`\n    -   CPU and system architecture from `/proc/cpuinfo`\n    -   System uptime from `/proc/uptime`\n    -   Local time from `/opt/etc/localtime`\n-   Resource usage information:\n    - System statistics from `/proc/stat`\n    - System memory usage from `/proc/meminfo`\n    - System disk I/O statistics from `/proc/diskstats`\n    - System disk space usage\n    - System memory statistics\n-   Process information:\n    - Process information by `ps` command\n-   Device information:\n    - Device major numbers from `/proc/devices` \n\n\nThe dump contents of **dump_systemstate** can be modified by the following command line options:\n\nOption | Description\n-------|----------------------------------\n-f     | write to file (instead of stdout)\n-k     | dump kernel messages (root only)\n-d     | dump dlog messages\n-j     | dump journal log messages\n-p     | dump list of installed packages\n-e     | dump extras defined in the config\n\nDepending on the command line options, **dump_systemstate** can save the output of these commands:\n\n-   `/bin/df -h`\n-   `/bin/du -ah /opt --exclude=/opt/usr`\n-   `/bin/ls -al /opt/etc/localtime`\n-   `/bin/top -bcH -n 1`\n-   `/bin/ps auxfw`\n-   `/bin/memps -v`\n-   `/bin/buxton2ctl dump memory`\n-   `/bin/buxton2ctl dump system`\n-   `/usr/bin/pkgcmd -l`\n-   `/bin/dmesg -T`\n-   `/bin/dlogutil -d -v threadtime -u 16384`\n-   `/bin/journalctl -b -n 1024`\n\n\nThere are two types of configuration files, under `files/` subdirectory and `programs/` subdirectory. These files allow to specify the results of additional files and programs that will be included in the **dump_systemstate** output:\n\n-   `files/` subdirectory: Specified files will be appended to the **dump_systemstate** output.\n    - **[SECTION_NAME]**\n    - **title**: Title that will be printed before contents of the file\n    - **path**: Path to the file\n\n    Example:\n\n    ```\n      [UNIQUE_ID_KEY]\n      title=header line that gets printed (path gets appended too)\n      path=/path/to/the/file\n\n      [DLOG_CONF]\n      title=dlog configuration file\n      path=/opt/etc/dlog.conf\n    ```\n\n-   `programs/` subdirectory: Specified commands will be executed and the output will be added to the **dump_systemstate** output.\n    - **[SECTION_NAME]**\n    - **title**: Title that will be printed before contents of the file\n    - **path**: Path to the application\n    - **args**: Arguments for the application\n    - **env**: Environment variable, which should be passed to the application\n\n    Example:\n\n    ```\n      [UNIQUE_ID_KEY]\n      title=header line describing the program (will be printed alongside env, path and args)\n      path=/path/to/the/program/executable\n      args=-x foo --verbose\n      env=POSIXLY_CORRECT=1\n\n      [DLOG_DUMP]\n      title=dump dlog contents\n      path=/usr/bin/dlogutil\n      args=-d\n    ```\n\n### livedumper\n\n**livedumper** is a tool to save the core dump of the live process.\n\nUsage:\n\n```\nlivedumper [-m] [-P ] [-f ] \n```\n\nOption               | Description\n---------------------|-------------------------------------------------------------------------------\n-f &lt;file_name&gt; | Saves core dump to the specified file (default livecore.&lt;PID&gt; in current directory).\n-P &lt;fd&gt;        | Descriptor for the registers structure (used by crash-manager).\n-m                   | Saves minicore. Saves minimum information that allows to restore the call stack.\n\nExample:\n\n```\n  $ sleep 123 &\n  $ livedumper -f sleep.core -m $?\n```"
					}
					
				
			
		
			
				
					,
					
					"platform-porting-system": {
						"id": "platform-porting-system",
						"title": "System",
						"categories": "",
						"url": " platform/porting/system/",
						"content": "# System\n\nYou can implement various features related to the System framework and the file system.\n\n## Partition and File System\n\nThe following description is an example of the Tizen partition layout. Product vendors can modify the sequence or partition layout for their devices, as needed.\n\n1. The `boot` partition includes the kernel image, boot-loader image, and modem image. It can also contain device driver modules.\n1. The `rootfs` partition is mounted on the root directory. It contains the fundamental frameworks for Tizen and some general utilities for Linux.\n1. The `system-data` partition is mounted on the `/opt` directory. It contains the platform database and platform configurations.\n1. The `user` partition can be mounted on the `/opt/usr` directory separately. It contains user-installed applications.\n1. External storages are mounted on `/opt/media`.\n1. The partition image files (`rootfs.img`, `system-data.img`, and `user.img`) can be zipped for downloading, such as `.tar.gz`.\n\nThe `/etc/fstab` directory must be modified or the `systemd` mount units must be added based on the partition layout. Consequently, the `fstab` file or system mount unit files for specific devices must be added to the `system-plugin` Git repository. The following example shows an `fstab` file:\n\n```\n/dev/root         /               ext4    defaults,noatime 0      1\nLABEL=system-data /opt            ext4    defaults,noatime 0      2\nLABEL=user        /opt/usr        ext4    defaults,noatime 0      3\n```\n\n### Supported File Systems\n\nTizen supports the Extended 4 (Ext 4) file system as the default file system.\n\nTo enable support for other file systems, such as JFS, XFS, BTRFS, and Reiserfs, the Tizen kernel must be modified and compiled. The following configuration options must be enabled in the kernel configuration file:\n\n- `CONFIG_EXT4_FS=y`\n- `CONFIG_EXT4_FS_XATTR=y`\n- `CONFIG_EXT4_USE_FOR_EXT23=y`\n- `CONFIG_EXT4_FS_SECURITY=y`\n\n### File System Hierarchy\n\nThe Tizen directory hierarchy intends to follow the File System Hierarchy Standard (FHS) as much as possible, for compatibility with the Linux world. However, Tizen uses the `/opt` directory for Tizen-specific purposes: place all RW data in the `/opt` directory.\n\n**Figure: File system hierarchy**\n\n![File system hierarchy](media/467px-fsh.png)\n\nDirectory macros for accessing the Tizen-specific directories are provided in the Tizen platform configuration metafile. The following table lists some example macros.\n\n**Table: Example directory macros**\n\n| Directory macro | Real path    |\n| ---------------- | ------------ |\n| `TZ_SYS_DATA`    | `/opt/data`  |\n| `TZ_SYS_SHARE`   | `/opt/share` |\n| `TZ_SYS_VAR`     | `/opt/var`   |\n\n## System Framework\n\nThe System framework module abstracts low-level system functions and manages the Tizen system:\n\n- `systemd` requirements for system and service management\n    - Linux Kernel >= 3.4 , Linux Kernel >= 3.8 for Smack support\n    - `CONFIG_CGROUPS`, `CONFIG_TIMERFD`, `CONFIG_SIGNALFD`, `CONFIG_EPOLL`, ...\n\n- Basic resource requirements (such as CPU, memory) usage management\n  - Linux Kernel >= 3.10 for `VMPRESSURE`, Linux Kernel >= 3.8 for `MEMCG SWAP`\n  - `CONFIG_CGROUPS`, `CONFIG_CGROUP_SCHED`, `CONFIG_MEMCG`, `CONFIG_MEMCG_SWAP`, ...\n- `deviced` requirements for device and power management\n    - Device HAL layer porting\n\n- dlog requirements\n\n  Select a backend for the target environment and enable the appropriate kernel feature:\n    - Additional KMSG patch for multiple Kmsg backend\n    - Android&trade; logger driver for Android log backend\n    - Userspace logger daemon\n\nUsing the Linux kernel 3.10 or above is recommended.\n\n**Figure: System framework**\n\n![System framework](media/800px-systemfw.png)\n\n### systemd\n\n`systemd` (ver.219) is a system and service manager for the Tizen system. It provides functionalities, such as parallelized service execution, socket and dbus activation for starting services and daemons, on-demand daemon start-up, service process management using Linux `cgroup`, automount point support, and service snapshot and restore.\n\nThe `systemd` core manages all units, such as service, socket, and mount. It stores all log data. When you add a new service daemon, you need to provide the proper system units and unit dependencies.\n\nTo use `systemd`, you must enable the `cgroup` and `autofs` options in the [Linux](https://wiki.tizen.org/Linux) kernel configuration. It also depends on dbus and some libraries.\n\n### resourced\n\n`resourced` is a daemon that manages system resources, such as memory and CPU.\n\nTo use most of the `resourced` functionalities, you must enable the following `cgroup` kernel features:\n\n  - `CONFIG_CGROUPS`: Base feature\n  - `CONFIG_CGROUP_SCHED`: Controls the CPU share of applications\n  - `CONFIG_MEMCG`: Selects the victim in low-memory situations\n  - `CONFIG_FREEZER`: Freezes background (and idle) applications\n  - `CONFIG_MEMCG_SWAP`, `CONFIG_MEMCG_SWAP_ENABLED`: Adds swap management features to memory resource controller. Depends on `CONFIG_MEMCG` and `CONFIG_SWAP`.\n  - `CONFIG_ZRAM`: Creates memory-backed compressed block devices /dev/zramX (X = 0, 1, …). Depends on `CONFIG_ZSMALLOC`.\n  - `CONFIG_ZRAM_LZ4_COMPRESS`: Enables support for an alternative compression algorithm. By default, ZRAM uses Lempel–Ziv–Oberhumer (LZO).\n  - `CONFIG_ZSWAP`: Compresses data in memory before moving them to a storage device.\n  - `CRYPTO_DEFLATE`, `CRYPTO_ZLIB`, `CRYPTO_LZO`, `CRYPTO_LZ4`, `CRYPTO_LZ4HC`: Compression algorithms available as part of kernel cyrpto API.\n\n> **Note**\n>\n> To use the `resourced` freezer feature, you must install the freezer plugin by enabling `CONFIG_FREEZER`.\n\n### deviced\n\n`deviced` is a daemon that handles device events, such as the battery level and plug-and-play device status, and provides interfaces to manage devices, such as power, display, and external storages. If your BSP does not provide the Linux kernel-standard interface, these functionalities can require a HAL layer:\n\n- Managing the LCD backlight state (on/off/dim)\n- Managing the CPU sleep state and handling requests to lock the CPU from sleeping\n- Monitoring external devices, such as USB cable, earjack, and charger\n- Monitoring the battery level\n- Managing external storages, such as SD card and USB storages\n- Controlling the vibrator\n- Setting the USB configuration for connecting to a host computer\n- Powering off the LED, IR, and other features\n- Using the device HAL to handle devices and get events\n\n### dlog\n\nTizen provides 3 logging system backends:\n\n- Multiple `kmsg` backend\n\n  Requires a kernel patch. For more information, see https://lwn.net/Articles/677047/.\n\n- Android-logger backend\n\n  Utilizes the Android logger driver.\n\n- User logger backend\n\n  No requirement (you do not have to enable anything from dlog)\n\n### Porting the Smart Development Bridge (SDB)\n\nSDB is a device management tool used for remote shell command, file transfer, controlling device log out, and USB debugging.\n\n- To use SDB, you must install a kernel driver.\n\n    For example:\n    - [Gadget Driver for SLP based on Android](https://review.tizen.org/git/?p=profile/mobile/platform/kernel/linux-3.10-sc7730.git;a=blob;f=drivers/usb/gadget/slp.c;h=c0d935f5362cc5ae03807d3533fe84df88e8c354;hb=refs/heads/accepted/tizen_mobile)\n    - [Gadget Driver for Samsung SDB (based on Android ADB)](https://review.tizen.org/git/?p=profile/mobile/platform/kernel/linux-3.10-sc7730.git;a=blob;f=drivers/usb/gadget/f_sdb.c;h=7f334ba01139d6bcbe7668bd84582e078d563638;hb=refs/heads/accepted/tizen_mobile)\n\n- To recognize the target as a Tizen device, the SDB interface on the target device must have the following information in the USB interface descriptor:\n    ```\n    Class: 0xff\n    SubClass: 0x20\n    Protocol: 0x02\n    ```\n- When using multi-configuration, SDB must be located in the first configuration on the target multi-configuration system. The SDB client of the host PC (Linux PC) selects the first configuration.\n\n- To recognize the USB cable connection, you must port the External Connector Class (`extcon`) to the kernel. If `extcon` cannot be ported, you can enable SDB using the following shell command:\n    ```\n    /usr/bin/direct_set_debug.sh --sdb-set\n    ```\n\n### Porting the Device HAL Interface\n\nThe device HAL is applied for the hardware-independent platform. The device HAL consists of libraries corresponding to hardware, such as display, external connector, battery, LED, and IR. The HAL is used by `deviced` (device daemon) to control hardware, and manages the events of device state changes. `deviced` opens the implemented libraries and uses the APIs to control the devices.\n\nOEM developers must implement the API defined in the header files of the `libdevice-node` package and compile their libraries (`.so` file) for their devices.\n\nThe following code snippet shows the device HAL structure:\n\n```cpp\n#define MAKE_TAG_CONSTANT(A,B,C,D) (((A) = 0 && val > 0) {\n        *src = POWER_SOURCE_AC;\n\n        return 0;\n    }\n\n    ret = sys_get_int(BATTERY_ROOT_PATH\"/\"POWER_SOURCE_USB\"/online\", &val);\n    if (ret >= 0 && val > 0) {\n        *src = POWER_SOURCE_USB;\n\n        return 0;\n    }\n\n    ret = sys_get_int(BATTERY_ROOT_PATH\"/\"POWER_SOURCE_WIRELESS\"/online\", &val);\n    if (ret >= 0 && val > 0) {\n        *src = POWER_SOURCE_WIRELESS;\n\n        return 0;\n    }\n\n    *src = POWER_SOURCE_NONE;\n\n    return 0;\n}\n\nstatic int\nbattery_get_current_state(BatteryUpdated updated_cb, void *data) {\n    int fd;\n    struct battery_info info;\n    char status[32];\n    char health[32];\n    char *power_source;\n\n    if (!updated_cb)\n        return -EINVAL;\n\n    info.name = BATTERY_HARDWARE_DEVICE_ID;\n\n\n    fd = open(BATTERY_ROOT_PATH\"/battery/status\", O_RDONLY);\n    read(fd, status, sizeof(status));\n    close(fd);\n    info.status = status;\n\n    fd = open(BATTERY_ROOT_PATH\"/battery/health\", O_RDONLY);\n    read(fd, health, sizeof(health));\n    close(fd);\n    info.health = health;\n\n    ....\n\n    get_power_source(&power_source);\n    info.power_source = power_source;\n\n    updated_cb(&info, data);\n\n    return 0;\n}\n\nstatic int\nbattery_open(struct hw_info *info, const char *id, struct hw_common **common) {\n    struct battery_device *battery_dev;\n    battery_dev = calloc(1, sizeof(struct battery_device));\n\n    battery_dev->common.info = info;\n    battery_dev->register_changed_event = battery_register_changed_event;\n    battery_dev->unregister_changed_event = battery_unregister_changed_event;\n    battery_dev->get_current_state = battery_get_current_state;\n\n    *common = (struct hw_common *)battery_dev;\n\n    return 0;\n}\n\nstatic int\nbattery_close(struct hw_common *common) {\n    free(common);\n\n    return 0;\n}\n\nHARDWARE_MODULE_STRUCTURE = {\n    .magic = HARDWARE_INFO_TAG,\n    .hal_version = HARDWARE_INFO_VERSION,\n    .device_version = BATTERY_HARDWARE_DEVICE_VERSION,\n    .id = BATTERY_HARDWARE_DEVICE_ID,\n    .name = \"battery\",\n    .open = battery_open,\n    .close = battery_close,\n};\n```\n\n#### Display HAL\n\nThe display HAL provides functions for controlling the display brightness. The HAL interface is defined in the `hw/display.h` header file of the `libdevice-node` library, and the `pkg-config` `device-node` must be used to use the HAL interface.\n\nThe following code snippet shows the display HAL interface:\n\n```cpp\n/*\n   Device ID\n*/\n#define DISPLAY_HARDWARE_DEVICE_ID \"display\"\n\n/*\n   Device version\n*/\n#define DISPLAY_HARDWARE_DEVICE_VERSION MAKE_VERSION(0,2)\n\nstruct display_device {\n    struct hw_common common;\n\n    /* Control display brightness */\n    int (*get_max_brightness)(int *brightness);\n    int (*get_brightness)(int *brightness);\n    int (*set_brightness)(int brightness);\n};\n```\n\nThe following table lists the display HAL functions.\n\n**Table: Display HAL functions**\n\n| Function prototype                       | Description                              | Mandatory |\n| ---------------------------------------- | ---------------------------------------- | --------- |\n| `int (*get_max_brightness)(int *brightness)` | Returns the maximum brightness value the display driver supports. | Yes |\n| `int (*get_brightness)(int *brightness)` | Returns the current brightness value. | Yes |\n| `int (*set_brightness)(int brightness)`  | Sets the brightness value.  | Yes |\n\nThe following code snippet shows an example of the display HAL:\n\n```cpp\n#ifndef BACKLIGHT_PATH\n#define BACKLIGHT_PATH \"/sys/class/backlight/panel\"\n#endif\n\nstatic int\ndisplay_get_max_brightness(int *val) {\n    static int max = -1;\n    char buf[BUF_MAX];\n    int fd;\n    if (max  max)\n        brightness = max;\n    snprintf(buf, sizeof(buf), \"%d\", brightness);\n    fd = open(BACKLIGHT_PATH\"/brightness\", O_WRONLY);\n    write(fd, buf, strlen(buf));\n    close(fd);\n\n    return 0;\n}\n\nstatic int\ndisplay_open(struct hw_info *info,\n        const char *id, struct hw_common **common) {\n    struct display_device *display_dev;\n\n    if (!info || !common)\n        return -EINVAL;\n\n    display_dev = calloc(1, sizeof(struct display_device));\n    if (!display_dev)\n        return -ENOMEM;\n\n    display_dev->common.info = info;\n    display_dev->get_max_brightness = display_get_max_brightness;\n    display_dev->get_brightness = display_get_brightness;\n    display_dev->set_brightness = display_set_brightness;\n\n    *common = (struct hw_common *)display_dev;\n\n    return 0;\n}\n\nstatic int\ndisplay_close(struct hw_common *common) {\n    if (!common)\n        return -EINVAL;\n\n    free(common);\n\n    return 0;\n}\n\nHARDWARE_MODULE_STRUCTURE = {\n    .magic = HARDWARE_INFO_TAG,\n    .hal_version = HARDWARE_INFO_VERSION,\n    .device_version = DISPLAY_HARDWARE_DEVICE_VERSION,\n    .id = DISPLAY_HARDWARE_DEVICE_ID,\n    .name = \"Display\",\n    .open = display_open,\n    .close = display_close,\n};\n```\n\n#### External Connector HAL\n\nThe external connector HAL provides functions for getting the external connector device status. The HAL interface is defined in the `hw/external_connection.h` header file of the `libdevice-node` library, and the `pkg-config` `device-node` needs to be used to use the HAL interface.\n\nThe following code snippet shows the interface of the external connector HAL:\n\n```cpp\n/*\n   Device ID\n*/\n#define EXTERNAL_CONNECTION_HARDWARE_DEVICE_ID \"external_connection\"\n\n#define EXTERNAL_CONNECTION_USB \"USB\"\n#define EXTERNAL_CONNECTION_USB_HOST \"USB-HOST\"\n#define EXTERNAL_CONNECTION_TA \"TA\"\n#define EXTERNAL_CONNECTION_HDMI \"HDMI\"\n#define EXTERNAL_CONNECTION_DOCK \"Dock\"\n#define EXTERNAL_CONNECTION_MIC \"Microphone\"\n#define EXTERNAL_CONNECTION_HEADPHONE \"Headphone\"\n\n/*\n   Device version\n*/\n#define EXTERNAL_CONNECTION_HARDWARE_DEVICE_VERSION MAKE_VERSION(0,1)\n\nstruct connection_info {\n    char *name;\n    char *state;\n    int flags;\n};\n\ntypedef void (*ConnectionUpdated)(struct connection_info *info, void *data);\n\nstruct external_connection_device {\n    struct hw_common common;\n\n    /* Register external_connection event */\n    int (*register_changed_event)(ConnectionUpdated updated_cb, void *data);\n    void (*unregister_changed_event)(ConnectionUpdated updated_cb);\n\n    /* Get current states */\n    int (*get_current_state)(ConnectionUpdated updated_cb, void *data);\n};\n```\n\nThe following table lists the external connector HAL functions.\n\n**Table: External connector HAL functions**\n\n| Function prototype                       | Description                              | Mandatory |\n| ---------------------------------------- | ---------------------------------------- | --------- |\n| `int (*register_changed_event)(ConnectionUpdated updated_cb, void *data);` | Adds a callback function which is called when the external connector status changes. | Yes |\n| `void (*unregister_changed_event)(ConnectionUpdated updated_cb);` | Removes the callback function added for the external connector status event. | Yes |\n| `int (*get_current_state)(ConnectionUpdated updated_cb, void *data);` | Calls the function specified in the first parameter. The external connector information is delivered to the function parameter. | Yes |\n\nThe following code snippet shows an example of the external connector HAL:\n\n```cpp\n#define SWITCH_ROOT_PATH \"/sys/devices/virtual/switch\"\n\nstatic struct switch_device {\n    char *type;\n    char *name;\n    int state;\n} switch_devices[] = {\n    {EXTERNAL_CONNECTION_USB, \"usb_cable\", 0},\n    {EXTERNAL_CONNECTION_DOCK, \"dock\", 0},\n    {EXTERNAL_CONNECTION_HEADPHONE, \"earjack\", 0},\n};\n\nstatic int\nread_switch_state(char *path) {\n    char node[128], val[8];\n    FILE *fp;\n\n    snprintf(node, sizeof(node), \"%s/%s/state\", SWITCH_ROOT_PATH, path);\n    fp = fopen(node, \"r\");\n    fgets(val, sizeof(val), fp));\n    fclose(fp);\n\n    return atoi(val);\n}\n\nstatic int\nexternal_connection_get_current_state(ConnectionUpdated updated_cb, void *data) {\n    int ret, i;\n    struct connection_info info;\n    char buf[8];\n\n    for (i = 0; i type == LED_TYPE_BLINK) {\n        printf(\"camera back led does not support LED_TYPE_BLINK mode\");\n\n        return -ENOTSUP;\n    }\n\n    if (max color >> 24) & 0xFF;\n    brt = brt / 255.f * max;\n\n    snprintf(buf, sizeof(buf), \"%d\", brt);\n    fd = open(CAMERA_BACK_PATH\"/brightness\", O_WRONLY);\n    write(fd, buf, strlen(buf));\n    close(fd);\n\n    return 0;\n}\n\nstruct led_device camera_back_dev = {\n    .set_state = camera_back_set_state,\n};\n\nstruct led_device_list {\n    const char *id;\n    struct led_device *operations;\n    struct led_device *dev;\n} led_list[] = {\n    {LED_ID_CAMERA_BACK, &camera_back_dev, NULL},\n    {LED_ID_CAMERA_FRONT, NULL, NULL},\n    {LED_ID_NOTIFICATION, NULL, NULL},\n    {LED_ID_TOUCH_KEY, NULL, NULL},\n};\n\nstatic int\nled_open(struct hw_info *info, const char *id, struct hw_common **common) {\n    int i, list_len, id_len;\n\n    list_len = ARRAY_SIZE(led_list);\n    id_len = strlen(id) + 1;\n    for (i = 0; i = list_len)\n        return -EINVAL;\n    led_list[i].dev = calloc(1, sizeof(struct led_device));\n\n    led_list[i].dev->common.info = info;\n    led_list[i].dev->set_state\n        = led_list[i].operations->set_state;\n\nout:\n    *common = (struct hw_common *)led_list[i].dev;\n\n    return 0;\n}\n\nstatic int\nled_close(struct hw_common *common) {\n    free(common);\n\n    return 0;\n}\n\nHARDWARE_MODULE_STRUCTURE = {\n    .magic = HARDWARE_INFO_TAG,\n    .hal_version = HARDWARE_INFO_VERSION,\n    .device_version = LED_HARDWARE_DEVICE_VERSION,\n    .id = LED_HARDWARE_DEVICE_ID,\n    .name = \"Default LED\",\n    .open = led_open,\n    .close = led_close,\n};\n```\n\n#### IR HAL\n\nThe IR HAL provides functions for controlling IR transmission. The HAL interface is defined in the `hw/ir.h` header file of the `libdevice-node` library, and the `pkg-config` `device-node` must be used to use the HAL interface.\n\nThe following code snippet shows the interface of the IR HAL:\n\n```cpp\n/*\n   Device ID\n*/\n#define IR_HARDWARE_DEVICE_ID \"ir\"\n\n/*\n   Device version\n*/\n#define IR_HARDWARE_DEVICE_VERSION MAKE_VERSION(0,1)\n\nstruct ir_device {\n    struct hw_common common;\n\n    /* Control the IR state */\n    int (*is_available)(bool *available);\n    int (*transmit)(int *frequency_pattern, int size);\n};\n```\n\nThe following table lists the IR HAL functions.\n\n**Table: IR HAL functions**\n\n| Function prototype                       | Description                              | Mandatory |\n| ---------------------------------------- | ---------------------------------------- | --------- |\n| `int (*is_available)(bool *available);`  | Returns whether the target device supports IR transmission. | Yes |\n| `int (*transmit)(int *frequency_pattern, int size);` | Transmits IR with frequency pattern and its size. | Yes |\n\nThe following code snippet shows an example of the IR HAL:\n\n```cpp\n#define IRLED_CONTROL_PATH \"/sys/class/ir/ir_send\"\n\nstatic int\nir_is_available(bool *available) {\n    *available = true;\n\n    return 0;\n}\n\nstatic int\nir_transmit(int *frequency_pattern, int size) {\n    int i, ret;\n\n    for (i = 0; i common.info = info;\n    ir_dev->is_available = ir_is_available;\n    ir_dev->transmit = ir_transmit;\n\n    *common = (struct hw_common *)ir_dev;\n\n    return 0;\n}\n\nstatic int\nir_close(struct hw_common *common) {\n    free(common);\n\n    return 0;\n}\n\nHARDWARE_MODULE_STRUCTURE = {\n    .magic = HARDWARE_INFO_TAG,\n    .hal_version = HARDWARE_INFO_VERSION,\n    .device_version = IR_HARDWARE_DEVICE_VERSION,\n    .id = IR_HARDWARE_DEVICE_ID,\n    .name = \"ir\",\n    .open = ir_open,\n    .close = ir_close,\n};\n```\n\n#### Touchscreen HAL\n\nThe touchscreen HAL provides functions for switching the touchscreen on and off. The HAL interface is defined in the `hw/touchscreenf.h` header file of the `libdevice-node` library, and the `pkg-config` `device-node` must be used to use the HAL interface.\n\nThe following code snippet shows the interface of the touchscreen HAL:\n\n```cpp\n/*\n   Device ID\n*/\n#define TOUCHSCREEN_HARDWARE_DEVICE_ID \"touchscreen\"\n\n/*\n   Device version\n*/\n#define TOUCHSCREEN_HARDWARE_DEVICE_VERSION MAKE_VERSION(0,1)\n\nenum touchscreen_state {\n    TOUCHSCREEN_OFF, /* Disable touchscreen */\n    TOUCHSCREEN_ON, /* Enable touchscreen */\n};\n\nstruct touchscreen_device {\n    struct hw_common common;\n\n    /* Control touchscreen state */\n    int (*get_state)(enum touchscreen_state *state);\n    int (*set_state)(enum touchscreen_state state);\n};\n```\n\nThe following table lists the touchscreen HAL functions.\n\n**Table: Touchscreen HAL functions**\n\n| Function prototype                       | Description                              | Mandatory |\n| ---------------------------------------- | ---------------------------------------- | --------- |\n| `int (*get_state)(enum touchscreen_state *state);` | Returns whether the touchscreen is enabled. | Yes |\n| `int (*set_state)(enum touchscreen_state state);` | Enables and disables the touchscreen. | Yes |\n\nThe following code snippet shows an example of the touchscreen HAL:\n\n```cpp\n#define TURNON_TOUCHSCREEN 1\n#define TURNOFF_TOUCHSCREEN 0\n#define TOUCHSCREEN_PATH \"/sys/class/input/touchscreen/enable\"\n\nstatic int\ntouchscreen_get_state(enum touchscreen_state *state) {\n    int val;\n    int fd;\n    char buf[BUF_MAX];\n\n    fd = open(TOUCHSCREEN_PATH, O_RDONLY);\n    read(fd, buf, sizeof(buf));\n    close(fd);\n    val = atoi(buf);\n\n    switch (val) {\n    case TURNOFF_TOUCHSCREEN:\n        *state = TOUCHSCREEN_OFF;\n        break;\n    case TURNON_TOUCHSCREEN:\n        *state = TOUCHSCREEN_ON;\n        break;\n    default:\n        return -EINVAL;\n    }\n\n    return 0;\n}\n\nstatic int\ntouchscreen_set_state(enum touchscreen_state state) {\n    int val;\n    char buf[BUF_MAX];\n\n    switch (state) {\n    case TOUCHSCREEN_OFF:\n        val = TURNOFF_TOUCHSCREEN;\n        break;\n    case TOUCHSCREEN_ON:\n        val = TURNON_TOUCHSCREEN;\n        break;\n    default:\n        return -EINVAL;\n    }\n\n    snprintf(buf, sizeof(buf), \"%d\", val);\n    fd = open(TOUCHSCREEN_PATH, O_WRONLY);\n    write(fd, buf, strlen(buf));\n    close(fd);\n\n    return ret;\n}\n\nstatic int\ntouchscreen_open(struct hw_info *info, const char *id, struct hw_common **common) {\n    struct touchscreen_device *touchscreen_dev;\n\n    touchscreen_dev = calloc(1, sizeof(struct touchscreen_device));\n\n    touchscreen_dev->common.info = info;\n    touchscreen_dev->get_state = touchscreen_get_state;\n    touchscreen_dev->set_state = touchscreen_set_state;\n\n    *common = (struct hw_common *)touchscreen_dev;\n\n    return 0;\n}\n\nstatic int\ntouchscreen_close(struct hw_common *common) {\n    free(common);\n\n    return 0;\n}\n\nHARDWARE_MODULE_STRUCTURE = {\n    .magic = HARDWARE_INFO_TAG,\n    .hal_version = HARDWARE_INFO_VERSION,\n    .device_version = TOUCHSCREEN_HARDWARE_DEVICE_VERSION,\n    .id = TOUCHSCREEN_HARDWARE_DEVICE_ID,\n    .name = \"touchscreen\",\n    .open = touchscreen_open,\n    .close = touchscreen_close,\n};\n```\n\n## Sensor Framework\n\nSensor devices are used widely in mobile devices to enhance the user experience. Most modern mobile operating systems have a framework which manages hardware and virtual sensors on the platform and provides convenient APIs to the application.\n\nSensors can be classified into hardware and virtual sensors. Tizen supports individual HALs for the following sensors:\n\n- Hardware sensors\n  - Accelerometer\n  - Geomagnetic sensor\n  - Gyroscope\n  - Light sensor\n  - Proximity sensor\n  - Pressure sensor\n  - Ultraviolet sensor\n  - Temperature sensor\n  - Humidity sensor\n  - HRM (Heart Rate Monitor)\n  - HRM LED green sensor\n  - HRM LED IR sensor\n  - HRM LED red sensor\n  - Uncalibrated geomagnetic sensor\n  - Uncalibrated gyroscope sensor\n  - Human pedometer\n  - Human sleep monitor\n  - Human sleep detector\n  - Human stress monitor\n- Virtual sensors\n  - Orientation sensor\n  - Gravity sensor\n  - Linear acceleration sensor\n  - Rotation vector sensor\n  - Gyroscope rotation vector sensor\n  - Geomagnetic rotation vector sensor\n\nThe sensor framework provides a sensor server for managing sensor HALs and a medium through which client applications are connected to the sensor handler to exchange data.\n\n**Figure: Sensor framework architecture**\n\n![Sensor framework architecture](media/678px-tizen-3-sensorfw.png)\n\nThe sensor HALs retrieve data from sensor hardware and enable client applications to use the data for specific requirements.\n\nThe Sensor framework consists of the following components:\n\n- Sensor client library\n\n  Any application that wants to access the sensor server and communicate with it must use the sensor API library. Using the Sensor API, the application can control sensors and receive sensor events from the sensor server. By using the sensor API, any application or middleware framework can have the sensor client library executing within its own process context.\n\n- Sensor server\n\n  The sensor server is a daemon which communicates uniquely to multiple sensors (through drivers) in the system and dispatches sensor data or events back to the application. The sensor server is responsible for initializing the sensors during boot, driver configuration, sensor data fetching and delivery, and managing all sensors and clients on the platform.\n\n- Sensor HAL (Hardware Abstraction Layer)\n\n  The sensor HAL, which is interfaced to the sensor server, is responsible for interacting with the sensor drivers. The HAL processes data from the sensor drivers and communicates it to the server. Hardware sensors must support the HAL. The sensor HAL is implemented as a shared library. The `sensor_loader` finds the `hal.so` library in the `/usr/lib/sensor/` directory, and loads it at boot time.\n\n### Porting the HAL Interface\n\nYou can port individual sensors or a sensorhub.\n\n#### Sensor\n\nTo port new hardware sensors, the HAL library-inherited `sensor_device` interface must be implemented. The HAL header files can be found at `git:sensord/src/hal`.\n\nThe Tizen HAL sensor types are also defined in the `sensor_hal_types.h` header file under the names `SENSOR_DEVICE_...`.\n\n**Figure: Sensor HAL**\n\n![Sensor HAL](media/tizen-3-sensor-fw-hal.png)\n\nThe following code snippet shows the interface of the sensor HAL in the `sensor_hal.h` header file:\n\n```cpp\n/*\n   Create devices\n*/\ntypedef void *sensor_device_t;\ntypedef int (*create_t)(sensor_device_t **devices);\n\n/*\n   Sensor device interface\n   1 device must be abstracted from 1 device event node\n*/\nclass sensor_device {\npublic:\n    virtual ~sensor_device() {}\n\n    uint32_t get_hal_version(void) {\n        return SENSOR_HAL_VERSION(1, 0);\n    }\n\n    virtual int get_poll_fd(void) = 0;\n    virtual int get_sensors(const sensor_info_t **sensors) = 0;\n\n    virtual bool enable(uint32_t id) = 0;\n    virtual bool disable(uint32_t id) = 0;\n\n    virtual int read_fd(uint32_t **ids) = 0;\n    virtual int get_data(uint32_t id, sensor_data_t **data, int *length) = 0;\n\n    virtual bool set_interval(uint32_t id, unsigned long val) {\n        return true;\n    }\n    virtual bool set_batch_latency(uint32_t id, unsigned long val) {\n        return true;\n    }\n    virtual bool set_attribute_int(uint32_t id, int32_t attribute, int32_t value) {\n        return true;\n    }\n    virtual bool set_attribute_str(uint32_t id, int32_t attribute, char *value, int value_len) {\n        return true;\n    }\n    virtual bool flush(uint32_t id) {\n        return true;\n    }\n};\n```\n\nThe following table describes the functions of the `sensor_device` interface.\n\n**Table: sensor_device interface functions**\n\n| Prototype                                | Description                              | Return value      |\n| ---------------------------------------- | ---------------------------------------- | ----------------- |\n| `uint32_t get_hal_version(void)`         | Returns the HAL version.                 | Version           |\n| `int get_poll_fd(void)`                  | Returns the file description to poll events. | `fd`              |\n| `int get_sensors(const sensor_info_t **sensors)` | Returns the list of supported sensors. See the `sensor_info_t` in the `sensor_hal_types.h` header file. | Size              |\n| `bool enable(uint32_t id)`               | Enables the sensor.                      | `true` on success |\n| `bool disable(uint32_t id)`              | Disables the sensor.                     | `true` on success |\n| `int read_fd(uint32_t **ids)`            | Returns the sensor device IDs. The sensor framework calls this function when an event is detected from the `poll-fd`. | Size              |\n| `int get_data(uint32_t id, sensor_data_t **data, int *length)` | Updates the `sensor_data_t` object (data) with details about the sensor, such as accuracy, timestamp, and values. Note that the `sensor_data_t` object must be created using the `malloc()` function. | 0 on success      |\n| `bool set_interval(uint32_t id, unsigned long val)` | Sets the interval.                       | `true` on success |\n| `bool set_batch_latency(uint32_t id, unsigned long val)` | Sets the batch latency.                   | `true` on success |\n| `bool set_attribute_int(uint32_t id, int32_t attribute, int32_t value)` | Sets the `int` value to the attribute.   | `true` on success |\n| `bool set_attribute_str(uint32_t id, int32_t attribute, char *value, int value_len)` | Sets the `string` value to the attribute.      | `true` on success |\n| `bool flush(uint32_t id)`                | Flushes the sensor events.               | `true` on success |\n| `int (create_t *)(sensor_device_t **devices)` | Returns the `sensor_device` list. To create the sensor module in `sensord`, you must implement this interface. | Size              |\n\nThe following code snippet shows the interface of the sensor HAL types in the `sensor_hal_type.h` header file:\n\n```cpp\n/*\n   Sensor Types\n   These types are used to control the sensors\n\n   - base unit\n     acceleration values : meter per second^2 (m/s^2)\n     magnetic values     : micro-Tesla (uT)\n     orientation values  : degrees\n     gyroscope values    : degree/s\n     temperature values  : degrees centigrade\n     proximity values    : distance\n     light values        : lux\n     pressure values     : hectopascal (hPa)\n     humidity            : relative humidity (%)\n*/\ntypedef enum {\n    SENSOR_DEVICE_UNKNOWN = -2,\n    SENSOR_DEVICE_ALL = -1,\n    SENSOR_DEVICE_ACCELEROMETER,\n    SENSOR_DEVICE_GRAVITY,\n    SENSOR_DEVICE_LINEAR_\n    SENSOR_DEVICE_GEOMAGNETIC,\n    SENSOR_DEVICE_ROTATION_VECTOR,\n    SENSOR_DEVICE_ORIENTATION,\n    SENSOR_DEVICE_GYROSCOPE,\n    SENSOR_DEVICE_LIGHT,\n    SENSOR_DEVICE_PROXIMITY,\n    SENSOR_DEVICE_PRESSURE,\n    SENSOR_DEVICE_ULTRAVIOLET,\n    SENSOR_DEVICE_TEMPERATURE,\n    SENSOR_DEVICE_HUMIDITY,\n    SENSOR_DEVICE_HRM,\n    SENSOR_DEVICE_HRM_LED_GREEN,\n    SENSOR_DEVICE_HRM_LED_IR,\n    SENSOR_DEVICE_HRM_LED_RED,\n    SENSOR_DEVICE_GYROSCOPE_UNCAL,\n    SENSOR_DEVICE_GEOMAGNETIC_UNCAL,\n    SENSOR_DEVICE_GYROSCOPE_RV,\n    SENSOR_DEVICE_GEOMAGNETIC_RV,\n\n    SENSOR_DEVICE_HUMAN_PEDOMETER = 0x300,\n    SENSOR_DEVICE_HUMAN_SLEEP_MONITOR,\n    SENSOR_DEVICE_HUMAN_SLEEP_DETECTOR,\n    SENSOR_DEVICE_HUMAN_STRESS_MONITOR,\n\n    SENSOR_DEVICE_EXERCISE_WALKING = 0x400,\n    SENSOR_DEVICE_EXERCISE_RUNNING,\n    SENSOR_DEVICE_EXERCISE_HIKING,\n    SENSOR_DEVICE_EXERCISE_CYCLING,\n    SENSOR_DEVICE_EXERCISE_ELLIPTICAL,\n    SENSOR_DEVICE_EXERCISE_INDOOR_CYCLING,\n    SENSOR_DEVICE_EXERCISE_ROWING,\n    SENSOR_DEVICE_EXERCISE_STEPPER,\n\n    SENSOR_DEVICE_FUSION = 0x900,\n    SENSOR_DEVICE_AUTO_ROTATION,\n    SENSOR_DEVICE_AUTO_BRIGHTNESS,\n\n    SENSOR_DEVICE_GESTURE_MOVEMENT = 0x1200,\n    SENSOR_DEVICE_GESTURE_WRIST_UP,\n    SENSOR_DEVICE_GESTURE_WRIST_\n    SENSOR_DEVICE_GESTURE_MOVEMENT_STATE,\n\n    SENSOR_DEVICE_ACTIVITY_TRACKER = 0x1A00,\n    SENSOR_DEVICE_ACTIVITY_LEVEL_MONITOR,\n} sensor_device_type;\n```\n\nThe following code snippet shows the interface of the sensor HAL information in the `sensor_hal_type.h` header file:\n\n```cpp\n/*\n   A platform sensor handler is generated based on this handle\n   This ID can be assigned by HAL developer, so it must be unique in 1 sensor_device.\n*/\ntypedef struct sensor_info_t {\n    uint32_t\n    const char *name;\n    sensor_device_type type;\n    unsigned int event_type; /* for Internal API */\n    const char *model_name;\n    const char *vendor;\n    float min_range;\n    float max_range;\n    float resolution;\n    int min_interval;\n    int max_batch_count;\n    bool wakeup_supported;\n} sensor_info_t;\n\nenum sensor_accuracy_t {\n    SENSOR_ACCURACY_UNDEFINED = -1,\n    SENSOR_ACCURACY_BAD = 0,\n    SENSOR_ACCURACY_NORMAL = 1,\n    SENSOR_ACCURACY_GOOD = 2,\n    SENSOR_ACCURACY_VERYGOOD = 3\n};\n\n#define SENSOR_DATA_VALUE_SIZE 16\n\n/* sensor_data_t */\ntypedef struct sensor_data_t {\n    int accuracy;\n    unsigned long long timestamp;\n    int value_count;\n    float values[SENSOR_DATA_VALUE_SIZE];\n} sensor_data_t;\n\n#define SENSOR_PEDOMETER_DATA_DIFFS_SIZE\t20\n\ntypedef struct {\n    int accuracy;\n    unsigned long long timestamp;\n    int value_count; /* value_count == 8 */\n    float values[SENSOR_DATA_VALUE_SIZE];\n    /* values = {step count, walk step count, run step count,\n\t         moving distance, calorie burned, last speed,\n\t         last stepping frequency (steps per sec),\n\t         last step status (walking, running, ...)} */\n    /* Additional data attributes (not in sensor_data_t)*/\n    int diffs_count;\n    struct differences {\n        int timestamp;\n        int steps;\n        int walk_steps;\n        int run_steps;\n        int walk_up_steps;\n        int walk_down_steps;\n        int run_up_steps;\n        int run_down_steps;\n        float distance;\n        float calories;\n        float speed;\n    } diffs[SENSOR_PEDOMETER_DATA_DIFFS_SIZE];\n} sensor_pedometer_data_t;\n\n#define CONVERT_TYPE_ATTR(type, index) ((type) \n#include \n#include \n\n#include \"accel/accel_device.h\"\n\nstatic std::vector devs;\n\ntemplate\nvoid\ncreate_sensor(const char *name) {\n    sensor_device *instance = NULL;\n    try {\n        instance = new _sensor;\n    } catch (std::exception &e) {\n        ERR(\"Failed to create %s sensor device, exception: %s\", name, e.what());\n\n        return;\n    } catch (int err) {\n        _ERRNO(err, _E, \"Failed to create %s sensor device\", name);\n\n        return;\n    }\n\n    devs.push_back(instance);\n}\n\nextern \"C\" int create(sensor_device_t **devices) {\n#ifdef ENABLE_ACCEL\n    create_sensor(\"Accelerometer\");\n#endif\n\n    *devices = &devs[0];\n\n    return devs.size();\n}\n```\n\n```cpp\n/* In accel_device.h */\n#ifndef _ACCEL_DEVICE_H_\n#define _ACCEL_DEVICE_H_\n\n#include \n#include \n#include \n#include \n\nclass accel_device : public sensor_device {\npublic:\n    accel_device();\n    virtual ~accel_device();\n\n    int get_poll_fd(void);\n    int get_sensors(const sensor_info_t **sensors);\n\n    bool enable(uint32_t id);\n    bool disable(uint32_t id);\n\n    bool set_interval(uint32_t id, unsigned long val);\n\n    int read_fd(uint32_t **ids);\n    int get_data(uint32_t id, sensor_data_t **data, int *length);\n\nprivate:\n    int m_node_handle;\n    int m_x;\n    int m_y;\n    int m_z;\n    unsigned long m_polling_interval;\n    unsigned long long m_fired_time;\n    bool m_sensorhub_controlled;\n\n    int m_method;\n    std::string m_data_node;\n    std::string m_enable_node;\n    std::string m_interval_node;\n\n    std::function update_value;\n\n    std::vector event_ids;\n\n    bool update_value_input_event(void);\n    bool update_value_iio(void);\n\n    void raw_to_base(sensor_data_t *data);\n};\n#endif /* _ACCEL_DEVICE_H_ */\n```\n\n```cpp\n/* In accel_device.cpp */\n#include \n#include \n#include \n#include \n\n#include \n#include \n#include \n\n#include \n#include \n#include \n\n#include \"accel_device.h\"\n\n#define MODEL_NAME \"K2HH\"\n#define VENDOR \"ST Microelectronics\"\n#define RESOLUTION 16\n#define RAW_DATA_UNIT 0.122\n#define MIN_INTERVAL 1\n#define MAX_BATCH_COUNT 0\n\n#define SENSOR_NAME \"SENSOR_ACCELEROMETER\"\n#define SENSOR_TYPE_ACCEL\t\t\"ACCEL\"\n\n#define INPUT_NAME\t\"accelerometer_sensor\"\n#define ACCEL_SENSORHUB_POLL_NODE_NAME \"accel_poll_delay\"\n\n#define GRAVITY 9.80665\n#define G_TO_MG 1000\n#define RAW_DATA_TO_G_UNIT(X) (((float)(X))/((float)G_TO_MG))\n#define RAW_DATA_TO_METRE_PER_SECOND_SQUARED_UNIT(X) (GRAVITY * (RAW_DATA_TO_G_UNIT(X)))\n\n#define MIN_RANGE(RES) (-((1 update_value_input_event();\n        };\n    } else {\n        if (!info.buffer_length_node_path.empty())\n            util::set_node_value(info.buffer_length_node_path, 480);\n\n        if (!info.buffer_enable_node_path.empty())\n            util::set_node_value(info.buffer_enable_node_path, 1);\n\n        update_value = [=]() {\n            return this->update_value_iio();\n        };\n    }\n\n    _I(\"accel_device is created!\");\n}\n\naccel_device::~accel_device() {\n    close(m_node_handle);\n    m_node_handle = -1;\n\n    _I(\"accel_device is destroyed!\");\n}\n\nint\naccel_device::get_poll_fd(void) {\n    return m_node_handle;\n}\n\nint\naccel_device::get_sensors(const sensor_info_t **sensors) {\n    *sensors = &sensor_info;\n\n    return 1;\n}\n\nbool\naccel_device::enable(uint32_t id) {\n    util::set_enable_node(m_enable_node, m_sensorhub_controlled, true, SENSORHUB_ACCELEROMETER_ENABLE_BIT);\n    set_interval(id, m_polling_interval);\n\n    m_fired_time = 0;\n    _I(\"Enable accelerometer sensor\");\n\n    return true;\n}\n\nbool\naccel_device::disable(uint32_t id) {\n    util::set_enable_node(m_enable_node, m_sensorhub_controlled, false, SENSORHUB_ACCELEROMETER_ENABLE_BIT);\n\n    _I(\"Disable accelerometer sensor\");\n\n    return true;\n}\n\nbool\naccel_device::set_interval(uint32_t id, unsigned long val) {\n    unsigned long long polling_interval_ns;\n\n    polling_interval_ns = ((unsigned long long)(val) * 1000llu * 1000llu);\n\n    if (!util::set_node_value(m_interval_node, polling_interval_ns)) {\n        _E(\"Failed to set polling resource: %s\", m_interval_node.c_str());\n\n        return false;\n    }\n\n    _I(\"Interval is changed from %dms to %dms\", m_polling_interval, val);\n    m_polling_interval = val;\n\n    return true;\n}\n\nbool\naccel_device::update_value_input_event(void) {\n    int accel_raw[3] = {0,};\n    bool x,y,z;\n    int read_input_cnt = 0;\n    const int INPUT_MAX_BEFORE_SYN = 10;\n    unsigned long long fired_time = 0;\n    bool syn = false;\n\n    x = y = z = false;\n\n    struct input_event accel_input;\n    _D(\"accel event detection!\");\n\n    while ((syn == false) && (read_input_cnt accuracy = SENSOR_ACCURACY_GOOD;\n    sensor_data->timestamp = m_fired_time;\n    sensor_data->value_count = 3;\n    sensor_data->values[0] = m_x;\n    sensor_data->values[1] = m_y;\n    sensor_data->values[2] = m_z;\n\n    raw_to_base(sensor_data);\n\n    *data = sensor_data;\n    *length = sizeof(sensor_data_t);\n\n    return 0;\n}\n\nvoid\naccel_device::raw_to_base(sensor_data_t *data) {\n    data->values[0] = RAW_DATA_TO_METRE_PER_SECOND_SQUARED_UNIT(data->values[0] * RAW_DATA_UNIT);\n    data->values[1] = RAW_DATA_TO_METRE_PER_SECOND_SQUARED_UNIT(data->values[1] * RAW_DATA_UNIT);\n    data->values[2] = RAW_DATA_TO_METRE_PER_SECOND_SQUARED_UNIT(data->values[2] * RAW_DATA_UNIT);\n}\n```\n\n#### Sensorhub\n\nThe sensorhub HAL supports multiple sensors logically from 1 physical device file. If many sensors are supported by a single device file, the sensorhub HAL can be configured so that it can operate each sensor as a logically-separate device.\n\nThe sensor HAL interface is provided to manufacturers and vendors through the `sensor_hal.h` and `sensor_hal_types.h` header files. It uses just 1 thread for polling sensor events from multiple device files.\n\n**Figure: Sensorhub HAL**\n\n![Sensorhub HAL](media/656px-tizen-3-sensorhub2.png)\n\nThe sensorhub HAL can be developed by using the `sensor_device` interface. An example of a sensorhub HAL can be found in the `sensor-hal-tm1/src/sensorhub` Git.\n\nIDs can be assigned by the vendor or manufacturer for the sensorhub sensors by using the following `sensor_info_t` interface:\n\n```cpp\ntypedef struct sensor_info_t {\n    uint32_t id;\n    const char *name;\n    sensor_device_type type;\n    unsigned int event_type; /* For Internal API */\n    const char *model_name;\n    const char *vendor;\n    float min_range;\n    float max_range;\n    float resolution;\n    int min_interval;\n    int max_batch_count;\n    bool wakeup_supported;\n} sensor_info_t;\n```\n\nThe following code snippet shows an example of a sensorhub HAL implementation:\n\n```cpp\n#include \n#include \n\n#include \"sensorhub.h\"\n#include \"sensorhub_controller.h\"\n#include \"sensorhub_manager.h\"\n#include \"system_state.h\"\n\nsensorhub_device::sensorhub_device() {\n    controller = &sensorhub_controller::get_instance();\n    if (!controller) {\n        ERR(\"Failed to allocated memory\");\n        throw;\n    }\n\n    manager = &sensorhub_manager::get_instance();\n    if (!manager) {\n        ERR(\"Failed to allocated memory\");\n        throw;\n    }\n    manager->set_controller(controller);\n    system_state_handler::get_instance().set_controller(controller);\n\n    INFO(\"sensorhub_device is created!\");\n}\n\nsensorhub_device::~sensorhub_device() {\n    INFO(\"sensorhub_device is destroyed!\");\n}\n\nint\nsensorhub_device::get_poll_fd(void) {\n    return controller->get_poll_fd();\n}\n\nint\nsensorhub_device::get_sensors(const sensor_info_t **sensors) {\n    int size;\n    size = manager->get_sensors(sensors);\n\n    return size;\n}\n\nbool\nsensorhub_device::enable(uint32_t id) {\n    system_state_handler::get_instance().initialize();\n\n    controller->enable();\n    sensorhub_sensor *sensor = manager->get_sensor(id);\n\n    if (!sensor) {\n        ERR(\"Failed to enable sensor(0x%x)\", id);\n\n        return false;\n    }\n\n    return sensor->enable();\n}\n\nbool\nsensorhub_device::disable(uint32_t id) {\n    system_state_handler::get_instance().finalize();\n\n    controller->disable();\n    sensorhub_sensor *sensor = manager->get_sensor(id);\n\n    if (!sensor) {\n        ERR(\"Failed to disable sensor(0x%x)\", id);\n\n        return false;\n    }\n\n    return sensor->disable();\n}\n\nbool\nsensorhub_device::set_interval(uint32_t id, unsigned long val) {\n    sensorhub_sensor *sensor = manager->get_sensor(id);\n\n    if (!sensor) {\n        ERR(\"Failed to set interval to sensor(0x%x)\", id);\n\n        return false;\n    }\n\n    return sensor->set_interval(val);\n}\n\nbool\nsensorhub_device::set_batch_latency(uint32_t id, unsigned long val) {\n    sensorhub_sensor *sensor = manager->get_sensor(id);\n\n    if (!sensor) {\n        ERR(\"Failed to set batch latency to sensor(0x%x)\", id);\n\n        return false;\n    }\n\n    return sensor->set_batch_latency(val);\n}\n\nbool\nsensorhub_device::set_attribute_int(uint32_t id, int32_t attribute, int32_t value) {\n    int ret;\n\n    sensorhub_sensor *sensor = manager->get_sensor(id);\n\n    if (!sensor) {\n        ERR(\"Failed to set attribute to sensor(0x%x)\", id);\n\n        return false;\n    }\n\n    ret = sensor->set_attribute_int(attribute, value);\n\n    if ((ret get_sensor(id);\n\n    if (!sensor) {\n        ERR(\"Failed to set attribute to sensor(0x%x)\", id);\n\n        return false;\n    }\n\n    ret = sensor->set_attribute_str(attribute, value, value_len);\n\n    if ((ret read_fd(data))\n        return 0;\n\n    /* Step 2 */\n    const char *hub_data = data.values;\n    int data_len = data.value_count;\n\n    /* Step 3 */\n    event_ids.clear();\n\n    while (data_len > 0) {\n        DBG(\"Remaining data length: %d\", data_len);\n        int parsed = parse(hub_data, data_len);\n        if (parsed get_sensor(id);\n    if (!sensor) {\n        ERR(\"Failed to get data from sensor(0x%x)\", id);\n\n        return -1;\n    }\n\n    remains = sensor->get_data(data, length);\n\n    return remains;\n}\n\nbool\nsensorhub_device::flush(uint32_t id) {\n    return false;\n}\n\nint\nsensorhub_device::parse(const char *hub_data, int data_len) {\n    return parse_data(hub_data, data_len);\n}\n\nint\nsensorhub_device::parse_data(const char *hub_data, int data_len) {\n    const char *cursor = hub_data;\n    int32_t libtype = 0;\n\n    sensorhub_sensor *sensor = manager->get_sensor(libtype);\n    if (!sensor) {\n        ERR(\"Unknown Sensorhub lib type: %d\", libtype);\n\n        return -1;\n    }\n\n    event_ids.push_back(sensor->get_id());\n\n    return sensor->parse(cursor, data_len);\n}\n\nint\nsensorhub_device::parse_debug(const char *hub_data, int data_len) {\n    return 0;\n}\n```\n\n```cpp\n#include \n#include \n#include \n#include \n#include \n#include \n#include \n#include \n\n#include \n#include \n#include \"sensorhub_controller.h\"\n\nsensorhub_controller::sensorhub_controller()\n: m_enabled(false)\n, m_poll_node(-1)\n, m_data_node(-1) {}\n\nsensorhub_controller::~sensorhub_controller() {}\n\nsensorhub_controller& sensorhub_controller::get_instance(void) {\n    static sensorhub_controller instance;\n\n    return instance;\n}\n\nint\nsensorhub_controller::get_poll_fd(void) {\n    /* Returns the sensorhub fd */\n\n    return -1;\n}\n\nbool\nsensorhub_controller::enable(void) {\n    m_enabled = true;\n    INFO(\"Enable Sensorhub\");\n\n    return true;\n}\n\nbool\nsensorhub_controller::disable(void) {\n    m_enabled = false;\n    INFO(\"Disable Sensorhub\");\n\n    return true;\n}\n\nint\nsensorhub_controller::open_input_node(const char* input_node) {\n    /* Implements the specific sensorhub logic */\n\n    return -1;\n}\n\nbool\nsensorhub_controller::read_fd(sensorhub_data_t &data) {\n    /* Implements the specific sensorhub logic */\n\n    return false;\n}\n\nint\nsensorhub_controller::read_sensorhub_data(void) {\n    /* Implements the specific sensorhub logic */\n\n    return -1;\n}\n\nint\nsensorhub_controller::read_large_sensorhub_data(void) {\n    /* Implements the specific sensorhub logic */\n\n    return -1;\n}\n\nint\nsensorhub_controller::send_sensorhub_data(const char *data, int data_len) {\n    /* Implements the specific sensorhub logic */\n\n    return -1;\n}\n\nint\nsensorhub_controller::print_sensorhub_data(const char* name, const char *data, int length) {\n    /* Implements the specific sensorhub logic */\n\n    return 0;\n}\n```\n\n### References\n\nThe reference kernel configuration for sensors varies depending on vendor types. However, there is a standard kernel subsystem for sensors: the Industrial I/O (IIO) subsystem. IIO is intended to provide support for devices that are, in some sense, analog to digital or digital to analog.\nFor more information, see [https://wiki.analog.com/software/linux/docs/iio/iio](https://wiki.analog.com/software/linux/docs/iio/iio).\n\nThe following table lists some example kernel configurations.\n\n**Table: Example kernel configurations**\n\n| Sensor component   | Kernel configuration    | Device nodes                             |\n| ------------------ | ----------------------- | ---------------------------------------- |\n| Accelerometer      | `CONFIG_INPUT_KR3DH`    | `/dev/input/event0/`, `/dev/input/event1/`, `/dev/input/event2/`, `/dev/input/event3/`, `/dev/input/event4/`, `/dev/input/event5/` |\n| Proximity          | `CONFIG_INPUT_GP2A`     |                                          |\n| Light sensor       | `CONFIG_INPUT_GP2A`     |                                          |\n| Electronic compass | `CONFIG_SENSORS_AK8975` |                                          |\n\n### Project Git Repositories\n\nThe following table lists the available project Git repositories.\n\n**Table: Git repositories**\n\n| Project               | Repository                               | Description                              |\n| --------------------- | ---------------------------------------- | ---------------------------------------- |\n| `capi-system-sensor`  | `platform/core/api/sensor`               | Tizen sensor C-API                       |\n| `sensord`             | `platform/core/system/sensord`           | Sensor daemon and libraries for managing sensors and clients |\n| `sensor-hal-tm1`      | `platform/adaptation/tm1/sensor-hal-tm1` | Sensor HAL for the TM1 device                |\n| `sensor-hal-tm2`      | `platform/adaptation/tm2/sensor-hal-tm2` | Sensor HAL for the TM2 device                |\n| `sensor-hal-tw1`      | `platform/adaptation/tw1/sensor-hal-tw1` | Sensor HAL for the TW1 device                |\n| `sensor-hal-emulator` | `platform/adaptation/emulator/sensor-hal-emulator` | Sensor HAL for the emulator                  |\n\n### Testing and Verifying Sensors\n\nThe `sensor-test package`, in the `sensord` Git repository, provides `sensorctl`, a command-line tool for testing sensors. After installing `sensor-test package`, you can test sensors using the following commands:\n\n```\n$ sensorctl test accelerometer\n$ sensorctl test gyroscope\n$ sensorctl test accelerometer 100 /* enable accelerometer with interval 100 ms */\n$ sensorctl test accelerometer 100 1000 /* enable accelerometer with interval 100 ms and 1s batch latency */\n$ sensorctl test accelerometer 100 1000 0 /* enable accelerometer with interval 100 ms, 1s batch latency and always on option */\n$ sensorctl info accelerometer /* retrieve accelerometer sensor information */\n```\n\n## Crash Framework\n\n### crash-manager\n\ncrash-manager is a tool used to create crash reports when an application gets crashed.\ncrash-manager is not usually invoked manually, but automatically by the kernel when the crash occurs. crash-manager generates the crash report and attaches the kernel-provided core, if requested. crash-worker package provides the `99-crash-manager.conf` file, which configures kernel parameters for crash-manager to get invoked automatically on crash. For more information, see [`99-crash-manager.conf`](#99-crash-managerconf).\n\ncrash-manager consists of the following options:\n\nOption                | Description\n----------------------|------------------------------------------------------\n-p  --pid=PID         | Specifies the process ID (PID) of the dumped process.\n-u  --uid=UID         | Specifies the real user identifier (UID) of the dumped process.\n-g  --gid=GID         | Specifies the real group identifier (GID) of the dumped process.\n-i  --tid=TID         | Specifies the thread identifier (TID) of the thread that triggered core dump. For more information, see [core(5)](http://man7.org/linux/man-pages/man5/core.5.html).\n-s  --signal=SIG      | Specifies the signal number causing dump.\n-t  --time=TIME       | Specifies the time of dump in seconds since the epoch.\n-l  --live            | Gets the core dump of the running process.\n-k  --kill-after-dump | Kills after dump (only with --live option).\n-r  --print           | Prints the report path to standard output (stdout).\n-h  --help            | Prints the help message.\n\nIn addition to handling crashes, crash-manager can create reports from running processes, livedumps. Livedumps contain `core` generated from the running process. The `core` is not created automatically but need to be requested explicitly by you. crash-manager needs to be invoked with the `--live` option, to produce the livedump report:\n\n```\n$ /usr/bin/crash-manager -p  --live --print\n```\n\n#### 99-crash-manager.conf\n\nThe `99-crash-manager.conf` file consists of the following kernel configurations related to the core dump:\n\n-  **kernel.core_pattern**  \n     This value contains the path to the file in which the kernel will store the core dump in case of a process crash. The possible values are described in [core(5)](http://man7.org/linux/man-pages/man5/core.5.html). If the first character of this path is a pipe symbol (`|`), then the whole line is interpreted as a program that can be executed, and the core dump will be given as a standard input.\n     To disable crash-manager, set this value to an empty string.\n\n     Default value: ```\"/usr/bin/crash-manager -p %p -u %u -g %g -s %s -t %t\"```\n\n-  **kernel.core_pipe_limit**  \n     Defines the maximum number of concurrent processes that may be dumped at the same time. For more information, see [core(5)](http://man7.org/linux/man-pages/man5/core.5.html).\n     If the limit is exceeded, then the next crashed process will not be dumped.\n\n     Default value: `10`\n\n-  **fs.suid_dumpable**  \n     Defines whether the core dump is produced for the set-owner-user-ID (SUID) binaries ([proc(5)](http://man7.org/linux/man-pages/man5/proc.5.html)) or not.\n\n     Default value: `2`\n\n\n#### crash-manager.conf\n\nThe default configuration file for crash-manager is `/etc/crash-manager.conf`. It is used to configure the location, the content and retention policy of crash reports.\n\n-  **SystemMaxUse**  \n     Determines the maximum size (in kilobytes) on disk that reports can occupy. If this value is exceeded, then the oldest reports will be deleted.\n     Value `0` turns off the check.\n\n     Default value: `0`\n\n-  **SystemKeepFree**  \n     If set to a value other than `0`, then crash-manager will check whether an appropriate amount of empty space (in kilobytes) is available on the disk or not.\n     Value `0` turns off the check.\n\n     Default value: `0`\n\n-  **MaxRetentionSec**  \n     Defines the maximal time (in seconds) a report will be kept. Older reports will be deleted.\n     Value `0` turns off the check.\n\n     Default value: `0`\n\n-  **MaxCrashDump**  \n     Defines how many reports will be kept. In case the number of reports exceeds this value, the oldest reports will be removed.\n     Value `0` turns off the check.\n\n     Default value: `0`\n\n-  **AllowZip**  \n     Determines whether the report will be compressed or not.\n\n     Default value: `yes`\n\n-  **CoreDump**  \n     If set to `0`, then the core dump will be removed from the final report.\n\n     Default value: `1`\n\n-  **CrashRootPath**  \n     Specifies the directory in which the crash reports will be saved. In the specified path, crash-manager will create four sub-directories:\n     - `dump/`: For saved reports of crashed applications\n     - `livedump/`: For saved reports of running processes (with option `--live`)\n     - `log/`: For logs\n     - `temp/`: For files while creating report\n\n     Default value: `/opt/user/share/crash/`\n\n-  **ReportType**  \n     Specifies the type of the crash report. Possible values are:\n     - `INFO`: Only the `*.info` file will be saved. The `*.info` file contains information about the registers and the call stack of the crashed application.\n     - `FULL`: The full crash report:\n         - `*.info`: Contains information about the registers and the call stack of the crashed application.\n         - `*.coredump`: A process memory dump.\n         - `*.so_info`: Contains information about shared libraries used by the crashed application, together with the names of packages that contain them.\n         - `*.log`: Contains information provided by [dump_systemstate](#dump_systemstate).\n         - Interesting files (`cmdline`, `environ`, `io`, `maps`, `smaps`, `stack`, `stat`, `statm`, `cwd`, `fd`) from the `/proc//` directory.\n\n     Default value: `FULL`\n\n\n-  **ExtraScript**  \n     Path to a script or an application that will be executed during report creation. The process will be started asynchronously.\n\n     Default value is empty\n\n#### Disabling crash-manager\n\nIn some situations there may be a need to disable the crash-manager functionality. In such cases, the recommended solution is to provide the `sysctl` configuration file to overwrite the default `kernel.core_pattern` setting. For example, the `99-disable-crash-manager.conf` file must be placed in the `/usr/lib/sysctl.d/` directory and must contain:\n\n```\nkernel.core_pattern=\nkernel.core_uses_pid=0\n```\n\n### D-Bus notification\n\nAfter the report is generated, crash-manager sends the D-Bus signal containing the following information about the crashed process:\n\nSignature: `sssssiia{sv}`  \nMember: `ProcessCrashed`  \nInterface: `org.tizen.system.crash.Crash`  \nPath: `/Org/Tizen/System/Crash/Crash`  \nData structure:  \n\nData         | Type\n-------------|-------\ncommand name | STRING\ncommand path | STRING\nappid        | STRING\npkgid        | STRING\nreport path  | STRING\nPID          | INT32\nTID          | INT32\narray        | ARRAY\n\nArray containing pairs of keys (STRING) and values (VARIANT). Possible keys:\n\nKey          | Type   | Description\n-------------|--------|---------------\nx86.eip      | UINT32 | instruction pointer\nx86_64.rip   | UINT64 | instruction pointer\narm.pc       | UINT32 | instruction pointer\narm.lr       | UINT32 | instruction pointer\naarch64.pc   | UINT64 | instruction pointer\naarch64.lr   | UINT64 | instruction pointer\nsys.signal   | INT32  | signal that caused crash\nsys.tid.comm | STRING | thread name\n\nDepending on the architecture, array will contain:\n\nArch    | PC (instruction pointer) | Link Register\n--------|--------------------------|------------------\nx86     | x86.eip                  | (not available)\nx86_64  | x86_64.eip               | (not available)\narm     | arm.pc                   | arm.lr\naarch64 | aarch64.pc               | aarch64.lr\n\n### minicoredumper\n\nminicoredumper is a tool that accepts a core dump on a standard input and saves the modified (size-reduced) core dump in a file. This tool is internally used by crash-manager to generate minicoredump. Modifications depends on the configuration, and they mainly rely on minimization of the core dump file.\n\nUsually, integrator does not need to modify this configuration unless integrator needs to change parameters of minicoredump files or settings for specified applications.\n\nminicoredumper can be used alone by setting `/proc/sys/kernel/core_pattern` to `|/usr/bin/minicoredumper %P %u %g %s %t %h %e`. All possible `%` specifiers are described in [core(5)](http://man7.org/linux/man-pages/man5/core.5.html).\n\nThe default path of the configuration file is `/etc/minicoredumper/minicoredumper.cfg.json` and the file format is JSON. Possible options are:\n\n-   **base_dir** (string): Defines the root directory where the dumped data will be stored. This option is overwritten by the command line option, which is set by **crash-manager**.\n-   **watch** (array): A set of recepts, which will be used for applications that meet the defined criteria:\n    -   **exe** (string): The full path to the binary returned by readlink. The `*` character is supported as wildcard. If not specified, the `*` value will be used.\n    -   **comm** (string): The basename of the command that was run. The `*` character is supported as wildcard. If not specified, the `*` value will be used.\n    -   **recept** (string): The full path to the recept file.\n\n    > **Note**\n    >\n    > If **exe** and **comm** are specified, then both conditions must be met to use the recept.\n\nDefault minicoredumper.cfg.json:\n\n```\n  {\n      \"base_dir\": \"/usr/local/var/crash/minicoredumper\",\n      \"watch\": [\n          {\n              \"exe\": \"/usr/bin/dotnet-launcher\",\n              \"recept\": \"dotnet.recept.json\"\n          },\n          {\n              \"recept\": \"generic.recept.json\"\n          }\n      ]\n  }\n```\n\n\nThe default path of the recept files is `/etc/minicoredumper/` and the format is JSON. Possible options are:\n\n-   **stacks** (list): Contains settings for what should be dumped.\n    -   **dump_stacks** (bool): If true, stacks will be dumped.\n    -   **first_thread_only** (bool): If true, only the first thread will be dumped.\n    -   **max_stack_size** (integer): Maximum size of the stack.\n-   **maps** (list): Contains list \"dump_by_name\".\n    -   **dump_by_name** (list): List of pathnames of memory regions that should be dumped (pathnames are read from `/proc//maps`).\n-   **compression** (list): Contains settings related to report compression.\n    -   **compressor** (string): Command line of compressor that supports stdin as input and stdout as output (gzip, bzip2, xz).\n    -   **extension**: (string): In case of a compressed core file, the specified value will be appended at the end of the core file name; otherwise, `.compressed` will be appended to the compressed core files.\n    -   **in_tar** (bool): Determines whether the core file should be a `.tar` file or not. This is useful because the tar format enables preserving the sparse properties of the core file.\n    -   **dump_auxv_so_list** (bool): If true, the shared object list will be saved in the core file.\n    -   **dump_pthread_list** (bool): If true, the pthread list will be saved in the core file.\n    -   **dump_robust_mutex_list** (bool): If true then robust mutexes will be saved in the core file.\n    -   **dump_scope** (int): Only registered dumps at this value or lower than this value will be dumped. This option applies only to libminicoredumper.\n    -   **dump_build_id** (bool): If true, then for all the contained ELF files, minicoredumper will save ELF header with BuildID to enable determining a specific version of the shared libraries.\n    -   **live_dumper** (bool): If true, then minicoredumper will trigger applications registered by libminicoredumper.\n    -   **write_proc_info** (boolean): If true, then interesting files (`cmdline`, `environ`, `io`, `maps`, `smaps`, `stack`, `stat`, `statm`, `cwd`, `fd`) from `/proc/` will be copied to the dump directory.\n    -   **proc_info_exclude** (list): Contains a list of filenames that must not be copied from the `/proc/` directory. For example, copying the `smaps` files will significantly increase the dumping time.\n    -   **write_debug_log** (bool): If true, then minicoredumper messages will be saved to `debug.txt` in the dump directory.\n    -   **dump_fat_core** (bool): If true, then all virtual memory areas will be saved in the separate core dump file. This must be used only for debug purpose.\n    -   **dump_pointed_by_regs** (bool): If true, then memory region around the address to which the CPU registers point is saved in the core file by minicoredumper. Precisely, for each CPU register minicoredumper saves page to which address points, one page before the address, and one page after the address. Page is 4096 bytes on most architectures.\n    -   **full_coredump** (bool): If true, then minicoredumper dumps the full core dump file.\n\nDefault `generic.recept.json`:\n\n```\n  {\n      \"stacks\": {\n          \"dump_stacks\": true,\n          \"first_thread_only\": false,\n          \"max_stack_size\": 0\n      },\n      \"maps\": {\n          \"dump_by_name\": [\n              \"[vdso]\"\n          ]\n      },\n      \"compression\": {\n          \"compressor\": \"\",\n          \"extension\": \"\",\n          \"in_tar\": true\n      },\n      \"dump_auxv_so_list\": true,\n      \"dump_pthread_list\": true,\n      \"dump_robust_mutex_list\": true,\n      \"dump_scope\": 1024,\n      \"dump_build_id\": true,\n      \"live_dumper\": true,\n      \"write_proc_info\": true,\n      \"proc_info_exclude\": [\n          \"smaps\"\n      ],\n      \"write_debug_log\": false,\n      \"dump_fat_core\": false,\n      \"dump_pointed_by_regs\": true\n  }\n```\n\n### dump_systemstate\n\n**dump_systemstate** is used to dump information that can be useful for developers to fix bugs in the crashed applications.\n\nDefault dump contains:\n-   Basic information:\n    -   Binary version from `/etc/info.ini`\n    -   Tizen version from `/etc/tizen-release`\n    -   Kernel version from `/proc/version`\n    -   Boot arguments from `/proc/cmdline`\n    -   CPU and system architecture from `/proc/cpuinfo`\n    -   System uptime from `/proc/uptime`\n    -   Local time from `/opt/etc/localtime`\n-   Resource usage information:\n    - System statistics from `/proc/stat`\n    - System memory usage from `/proc/meminfo`\n    - System disk I/O statistics from `/proc/diskstats`\n    - System disk space usage\n    - System memory statistics\n-   Process information:\n    - Process information by `ps` command\n-   Device information:\n    - Device major numbers from `/proc/devices` \n\n\nThe dump contents of **dump_systemstate** can be modified by the following command line options:\n\nOption | Description\n-------|----------------------------------\n-f     | write to file (instead of stdout)\n-k     | dump kernel messages (root only)\n-d     | dump dlog messages\n-j     | dump journal log messages\n-p     | dump list of installed packages\n-e     | dump extras defined in the config\n\nDepending on the command line options, **dump_systemstate** can save the output of these commands:\n\n-   `/bin/df -h`\n-   `/bin/du -ah /opt --exclude=/opt/usr`\n-   `/bin/ls -al /opt/etc/localtime`\n-   `/bin/top -bcH -n 1`\n-   `/bin/ps auxfw`\n-   `/bin/memps -v`\n-   `/bin/buxton2ctl dump memory`\n-   `/bin/buxton2ctl dump system`\n-   `/usr/bin/pkgcmd -l`\n-   `/bin/dmesg -T`\n-   `/bin/dlogutil -d -v threadtime -u 16384`\n-   `/bin/journalctl -b -n 1024`\n\n\nThere are two types of configuration files, under `files/` subdirectory and `programs/` subdirectory. These files allow to specify the results of additional files and programs that will be included in the **dump_systemstate** output:\n\n-   `files/` subdirectory: Specified files will be appended to the **dump_systemstate** output.\n    - **[SECTION_NAME]**\n    - **title**: Title that will be printed before contents of the file\n    - **path**: Path to the file\n\n    Example:\n\n    ```\n      [UNIQUE_ID_KEY]\n      title=header line that gets printed (path gets appended too)\n      path=/path/to/the/file\n\n      [DLOG_CONF]\n      title=dlog configuration file\n      path=/opt/etc/dlog.conf\n    ```\n\n-   `programs/` subdirectory: Specified commands will be executed and the output will be added to the **dump_systemstate** output.\n    - **[SECTION_NAME]**\n    - **title**: Title that will be printed before contents of the file\n    - **path**: Path to the application\n    - **args**: Arguments for the application\n    - **env**: Environment variable, which should be passed to the application\n\n    Example:\n\n    ```\n      [UNIQUE_ID_KEY]\n      title=header line describing the program (will be printed alongside env, path and args)\n      path=/path/to/the/program/executable\n      args=-x foo --verbose\n      env=POSIXLY_CORRECT=1\n\n      [DLOG_DUMP]\n      title=dump dlog contents\n      path=/usr/bin/dlogutil\n      args=-d\n    ```\n\n### livedumper\n\n**livedumper** is a tool to save the core dump of the live process.\n\nUsage:\n\n```\nlivedumper [-m] [-P ] [-f ] \n```\n\nOption               | Description\n---------------------|-------------------------------------------------------------------------------\n-f &lt;file_name&gt; | Saves core dump to the specified file (default livecore.&lt;PID&gt; in current directory).\n-P &lt;fd&gt;        | Descriptor for the registers structure (used by crash-manager).\n-m                   | Saves minicore. Saves minimum information that allows to restore the call stack.\n\nExample:\n\n```\n  $ sleep 123 &\n  $ livedumper -f sleep.core -m $?\n```"
					}
					
				
			
		
			
				
					,
					
					"iot-porting-system": {
						"id": "iot-porting-system",
						"title": "System",
						"categories": "",
						"url": " iot/porting/system/",
						"content": "# System\n\nYou can implement various features related to the System framework and the file system.\n\n## Partition and File System\n\nThe following description is an example of the Tizen partition layout. Product vendors can modify the sequence or partition layout for their devices, as needed.\n\n1. The `boot` partition includes the kernel image, boot-loader image, and modem image. It can also contain device driver modules.\n1. The `rootfs` partition is mounted on the root directory. It contains the fundamental frameworks for Tizen and some general utilities for Linux.\n1. The `system-data` partition is mounted on the `/opt` directory. It contains the platform database and platform configurations.\n1. The `user` partition can be mounted on the `/opt/usr` directory separately. It contains user-installed applications.\n1. External storages are mounted on `/opt/media`.\n1. The partition image files (`rootfs.img`, `system-data.img`, and `user.img`) can be zipped for downloading, such as `.tar.gz`.\n\nThe `/etc/fstab` directory must be modified or the `systemd` mount units must be added based on the partition layout. Consequently, the `fstab` file or system mount unit files for specific devices must be added to the `system-plugin` Git repository. The following example shows an `fstab` file:\n\n```\n/dev/root         /               ext4    defaults,noatime 0      1\nLABEL=system-data /opt            ext4    defaults,noatime 0      2\nLABEL=user        /opt/usr        ext4    defaults,noatime 0      3\n```\n\n### Supported File Systems\n\nTizen supports the Extended 4 (Ext 4) file system as the default file system.\n\nTo enable support for other file systems, such as JFS, XFS, BTRFS, and Reiserfs, the Tizen kernel must be modified and compiled. The following configuration options must be enabled in the kernel configuration file:\n\n- `CONFIG_EXT4_FS=y`\n- `CONFIG_EXT4_FS_XATTR=y`\n- `CONFIG_EXT4_USE_FOR_EXT23=y`\n- `CONFIG_EXT4_FS_SECURITY=y`\n\n### File System Hierarchy\n\nThe Tizen directory hierarchy intends to follow the File System Hierarchy Standard (FHS) as much as possible, for compatibility with the Linux world. However, Tizen uses the `/opt` directory for Tizen-specific purposes: place all RW data in the `/opt` directory.\n\n**Figure: File system hierarchy**\n\n![File system hierarchy](media/467px-fsh.png)\n\nDirectory macros for accessing the Tizen-specific directories are provided in the Tizen platform configuration metafile. The following table lists some example macros.\n\n**Table: Example directory macros**\n\n| Directory macro | Real path    |\n| ---------------- | ------------ |\n| `TZ_SYS_DATA`    | `/opt/data`  |\n| `TZ_SYS_SHARE`   | `/opt/share` |\n| `TZ_SYS_VAR`     | `/opt/var`   |\n\n## System Framework\n\nThe System framework module abstracts low-level system functions and manages the Tizen system:\n\n- `systemd` requirements for system and service management\n    - Linux Kernel >= 3.4 , Linux Kernel >= 3.8 for Smack support\n    - `CONFIG_CGROUPS`, `CONFIG_TIMERFD`, `CONFIG_SIGNALFD`, `CONFIG_EPOLL`, ...\n\n- Basic resource requirements (such as CPU, memory) usage management\n  - Linux Kernel >= 3.10 for `VMPRESSURE`, Linux Kernel >= 3.8 for `MEMCG SWAP`\n  - `CONFIG_CGROUPS`, `CONFIG_CGROUP_SCHED`, `CONFIG_MEMCG`, `CONFIG_MEMCG_SWAP`, ...\n- `deviced` requirements for device and power management\n    - Device HAL layer porting\n\n- dlog requirements\n\n  Select a backend for the target environment and enable the appropriate kernel feature:\n    - Additional KMSG patch for multiple Kmsg backend\n    - Android&trade; logger driver for Android log backend\n    - Userspace logger daemon\n\nUsing the Linux kernel 3.10 or above is recommended.\n\n**Figure: System framework**\n\n![System framework](media/800px-systemfw.png)\n\n### systemd\n\n`systemd` (ver.219) is a system and service manager for the Tizen system. It provides functionalities, such as parallelized service execution, socket and dbus activation for starting services and daemons, on-demand daemon start-up, service process management using Linux `cgroup`, automount point support, and service snapshot and restore.\n\nThe `systemd` core manages all units, such as service, socket, and mount. It stores all log data. When you add a new service daemon, you need to provide the proper system units and unit dependencies.\n\nTo use `systemd`, you must enable the `cgroup` and `autofs` options in the [Linux](https://wiki.tizen.org/Linux) kernel configuration. It also depends on dbus and some libraries.\n\n### resourced\n\n`resourced` is a daemon that manages system resources, such as memory and CPU.\n\nTo use most of the `resourced` functionalities, you must enable the following `cgroup` kernel features:\n\n  - `CONFIG_CGROUPS`: Base feature\n  - `CONFIG_CGROUP_SCHED`: Controls the CPU share of applications\n  - `CONFIG_MEMCG`: Selects the victim in low-memory situations\n  - `CONFIG_FREEZER`: Freezes background (and idle) applications\n  - `CONFIG_MEMCG_SWAP`, `CONFIG_MEMCG_SWAP_ENABLED`: Adds swap management features to memory resource controller. Depends on `CONFIG_MEMCG` and `CONFIG_SWAP`.\n  - `CONFIG_ZRAM`: Creates memory-backed compressed block devices /dev/zramX (X = 0, 1, …). Depends on `CONFIG_ZSMALLOC`.\n  - `CONFIG_ZRAM_LZ4_COMPRESS`: Enables support for an alternative compression algorithm. By default, ZRAM uses Lempel–Ziv–Oberhumer (LZO).\n  - `CONFIG_ZSWAP`: Compresses data in memory before moving them to a storage device.\n  - `CRYPTO_DEFLATE`, `CRYPTO_ZLIB`, `CRYPTO_LZO`, `CRYPTO_LZ4`, `CRYPTO_LZ4HC`: Compression algorithms available as part of kernel cyrpto API.\n\n> **Note**\n>\n> To use the `resourced` freezer feature, you must install the freezer plugin by enabling `CONFIG_FREEZER`.\n\n### deviced\n\n`deviced` is a daemon that handles device events, such as the battery level and plug-and-play device status, and provides interfaces to manage devices, such as power, display, and external storages. If your BSP does not provide the Linux kernel-standard interface, these functionalities can require a HAL layer:\n\n- Managing the LCD backlight state (on/off/dim)\n- Managing the CPU sleep state and handling requests to lock the CPU from sleeping\n- Monitoring external devices, such as USB cable, earjack, and charger\n- Monitoring the battery level\n- Managing external storages, such as SD card and USB storages\n- Controlling the vibrator\n- Setting the USB configuration for connecting to a host computer\n- Powering off the LED, IR, and other features\n- Using the device HAL to handle devices and get events\n\n### dlog\n\nTizen provides 3 logging system backends:\n\n- Multiple `kmsg` backend\n\n  Requires a kernel patch. For more information, see https://lwn.net/Articles/677047/.\n\n- Android-logger backend\n\n  Utilizes the Android logger driver.\n\n- User logger backend\n\n  No requirement (you do not have to enable anything from dlog)\n\n### Porting the Smart Development Bridge (SDB)\n\nSDB is a device management tool used for remote shell command, file transfer, controlling device log out, and USB debugging.\n\n- To use SDB, you must install a kernel driver.\n\n    For example:\n    - [Gadget Driver for SLP based on Android](https://review.tizen.org/git/?p=profile/mobile/platform/kernel/linux-3.10-sc7730.git;a=blob;f=drivers/usb/gadget/slp.c;h=c0d935f5362cc5ae03807d3533fe84df88e8c354;hb=refs/heads/accepted/tizen_mobile)\n    - [Gadget Driver for Samsung SDB (based on Android ADB)](https://review.tizen.org/git/?p=profile/mobile/platform/kernel/linux-3.10-sc7730.git;a=blob;f=drivers/usb/gadget/f_sdb.c;h=7f334ba01139d6bcbe7668bd84582e078d563638;hb=refs/heads/accepted/tizen_mobile)\n\n- To recognize the target as a Tizen device, the SDB interface on the target device must have the following information in the USB interface descriptor:\n    ```\n    Class: 0xff\n    SubClass: 0x20\n    Protocol: 0x02\n    ```\n- When using multi-configuration, SDB must be located in the first configuration on the target multi-configuration system. The SDB client of the host PC (Linux PC) selects the first configuration.\n\n- To recognize the USB cable connection, you must port the External Connector Class (`extcon`) to the kernel. If `extcon` cannot be ported, you can enable SDB using the following shell command:\n    ```\n    /usr/bin/direct_set_debug.sh --sdb-set\n    ```\n\n### Porting the Device HAL Interface\n\nThe device HAL is applied for the hardware-independent platform. The device HAL consists of libraries corresponding to hardware, such as display, external connector, battery, LED, and IR. The HAL is used by `deviced` (device daemon) to control hardware, and manages the events of device state changes. `deviced` opens the implemented libraries and uses the APIs to control the devices.\n\nOEM developers must implement the API defined in the header files of the `libdevice-node` package and compile their libraries (`.so` file) for their devices.\n\nThe following code snippet shows the device HAL structure:\n\n```cpp\n#define MAKE_TAG_CONSTANT(A,B,C,D) (((A) = 0 && val > 0) {\n        *src = POWER_SOURCE_AC;\n\n        return 0;\n    }\n\n    ret = sys_get_int(BATTERY_ROOT_PATH\"/\"POWER_SOURCE_USB\"/online\", &val);\n    if (ret >= 0 && val > 0) {\n        *src = POWER_SOURCE_USB;\n\n        return 0;\n    }\n\n    ret = sys_get_int(BATTERY_ROOT_PATH\"/\"POWER_SOURCE_WIRELESS\"/online\", &val);\n    if (ret >= 0 && val > 0) {\n        *src = POWER_SOURCE_WIRELESS;\n\n        return 0;\n    }\n\n    *src = POWER_SOURCE_NONE;\n\n    return 0;\n}\n\nstatic int\nbattery_get_current_state(BatteryUpdated updated_cb, void *data) {\n    int fd;\n    struct battery_info info;\n    char status[32];\n    char health[32];\n    char *power_source;\n\n    if (!updated_cb)\n        return -EINVAL;\n\n    info.name = BATTERY_HARDWARE_DEVICE_ID;\n\n\n    fd = open(BATTERY_ROOT_PATH\"/battery/status\", O_RDONLY);\n    read(fd, status, sizeof(status));\n    close(fd);\n    info.status = status;\n\n    fd = open(BATTERY_ROOT_PATH\"/battery/health\", O_RDONLY);\n    read(fd, health, sizeof(health));\n    close(fd);\n    info.health = health;\n\n    ....\n\n    get_power_source(&power_source);\n    info.power_source = power_source;\n\n    updated_cb(&info, data);\n\n    return 0;\n}\n\nstatic int\nbattery_open(struct hw_info *info, const char *id, struct hw_common **common) {\n    struct battery_device *battery_dev;\n    battery_dev = calloc(1, sizeof(struct battery_device));\n\n    battery_dev->common.info = info;\n    battery_dev->register_changed_event = battery_register_changed_event;\n    battery_dev->unregister_changed_event = battery_unregister_changed_event;\n    battery_dev->get_current_state = battery_get_current_state;\n\n    *common = (struct hw_common *)battery_dev;\n\n    return 0;\n}\n\nstatic int\nbattery_close(struct hw_common *common) {\n    free(common);\n\n    return 0;\n}\n\nHARDWARE_MODULE_STRUCTURE = {\n    .magic = HARDWARE_INFO_TAG,\n    .hal_version = HARDWARE_INFO_VERSION,\n    .device_version = BATTERY_HARDWARE_DEVICE_VERSION,\n    .id = BATTERY_HARDWARE_DEVICE_ID,\n    .name = \"battery\",\n    .open = battery_open,\n    .close = battery_close,\n};\n```\n\n#### Display HAL\n\nThe display HAL provides functions for controlling the display brightness. The HAL interface is defined in the `hw/display.h` header file of the `libdevice-node` library, and the `pkg-config` `device-node` must be used to use the HAL interface.\n\nThe following code snippet shows the display HAL interface:\n\n```cpp\n/*\n   Device ID\n*/\n#define DISPLAY_HARDWARE_DEVICE_ID \"display\"\n\n/*\n   Device version\n*/\n#define DISPLAY_HARDWARE_DEVICE_VERSION MAKE_VERSION(0,2)\n\nstruct display_device {\n    struct hw_common common;\n\n    /* Control display brightness */\n    int (*get_max_brightness)(int *brightness);\n    int (*get_brightness)(int *brightness);\n    int (*set_brightness)(int brightness);\n};\n```\n\nThe following table lists the display HAL functions.\n\n**Table: Display HAL functions**\n\n| Function prototype                       | Description                              | Mandatory |\n| ---------------------------------------- | ---------------------------------------- | --------- |\n| `int (*get_max_brightness)(int *brightness)` | Returns the maximum brightness value the display driver supports. | Yes |\n| `int (*get_brightness)(int *brightness)` | Returns the current brightness value. | Yes |\n| `int (*set_brightness)(int brightness)`  | Sets the brightness value.  | Yes |\n\nThe following code snippet shows an example of the display HAL:\n\n```cpp\n#ifndef BACKLIGHT_PATH\n#define BACKLIGHT_PATH \"/sys/class/backlight/panel\"\n#endif\n\nstatic int\ndisplay_get_max_brightness(int *val) {\n    static int max = -1;\n    char buf[BUF_MAX];\n    int fd;\n    if (max  max)\n        brightness = max;\n    snprintf(buf, sizeof(buf), \"%d\", brightness);\n    fd = open(BACKLIGHT_PATH\"/brightness\", O_WRONLY);\n    write(fd, buf, strlen(buf));\n    close(fd);\n\n    return 0;\n}\n\nstatic int\ndisplay_open(struct hw_info *info,\n        const char *id, struct hw_common **common) {\n    struct display_device *display_dev;\n\n    if (!info || !common)\n        return -EINVAL;\n\n    display_dev = calloc(1, sizeof(struct display_device));\n    if (!display_dev)\n        return -ENOMEM;\n\n    display_dev->common.info = info;\n    display_dev->get_max_brightness = display_get_max_brightness;\n    display_dev->get_brightness = display_get_brightness;\n    display_dev->set_brightness = display_set_brightness;\n\n    *common = (struct hw_common *)display_dev;\n\n    return 0;\n}\n\nstatic int\ndisplay_close(struct hw_common *common) {\n    if (!common)\n        return -EINVAL;\n\n    free(common);\n\n    return 0;\n}\n\nHARDWARE_MODULE_STRUCTURE = {\n    .magic = HARDWARE_INFO_TAG,\n    .hal_version = HARDWARE_INFO_VERSION,\n    .device_version = DISPLAY_HARDWARE_DEVICE_VERSION,\n    .id = DISPLAY_HARDWARE_DEVICE_ID,\n    .name = \"Display\",\n    .open = display_open,\n    .close = display_close,\n};\n```\n\n#### External Connector HAL\n\nThe external connector HAL provides functions for getting the external connector device status. The HAL interface is defined in the `hw/external_connection.h` header file of the `libdevice-node` library, and the `pkg-config` `device-node` needs to be used to use the HAL interface.\n\nThe following code snippet shows the interface of the external connector HAL:\n\n```cpp\n/*\n   Device ID\n*/\n#define EXTERNAL_CONNECTION_HARDWARE_DEVICE_ID \"external_connection\"\n\n#define EXTERNAL_CONNECTION_USB \"USB\"\n#define EXTERNAL_CONNECTION_USB_HOST \"USB-HOST\"\n#define EXTERNAL_CONNECTION_TA \"TA\"\n#define EXTERNAL_CONNECTION_HDMI \"HDMI\"\n#define EXTERNAL_CONNECTION_DOCK \"Dock\"\n#define EXTERNAL_CONNECTION_MIC \"Microphone\"\n#define EXTERNAL_CONNECTION_HEADPHONE \"Headphone\"\n\n/*\n   Device version\n*/\n#define EXTERNAL_CONNECTION_HARDWARE_DEVICE_VERSION MAKE_VERSION(0,1)\n\nstruct connection_info {\n    char *name;\n    char *state;\n    int flags;\n};\n\ntypedef void (*ConnectionUpdated)(struct connection_info *info, void *data);\n\nstruct external_connection_device {\n    struct hw_common common;\n\n    /* Register external_connection event */\n    int (*register_changed_event)(ConnectionUpdated updated_cb, void *data);\n    void (*unregister_changed_event)(ConnectionUpdated updated_cb);\n\n    /* Get current states */\n    int (*get_current_state)(ConnectionUpdated updated_cb, void *data);\n};\n```\n\nThe following table lists the external connector HAL functions.\n\n**Table: External connector HAL functions**\n\n| Function prototype                       | Description                              | Mandatory |\n| ---------------------------------------- | ---------------------------------------- | --------- |\n| `int (*register_changed_event)(ConnectionUpdated updated_cb, void *data);` | Adds a callback function which is called when the external connector status changes. | Yes |\n| `void (*unregister_changed_event)(ConnectionUpdated updated_cb);` | Removes the callback function added for the external connector status event. | Yes |\n| `int (*get_current_state)(ConnectionUpdated updated_cb, void *data);` | Calls the function specified in the first parameter. The external connector information is delivered to the function parameter. | Yes |\n\nThe following code snippet shows an example of the external connector HAL:\n\n```cpp\n#define SWITCH_ROOT_PATH \"/sys/devices/virtual/switch\"\n\nstatic struct switch_device {\n    char *type;\n    char *name;\n    int state;\n} switch_devices[] = {\n    {EXTERNAL_CONNECTION_USB, \"usb_cable\", 0},\n    {EXTERNAL_CONNECTION_DOCK, \"dock\", 0},\n    {EXTERNAL_CONNECTION_HEADPHONE, \"earjack\", 0},\n};\n\nstatic int\nread_switch_state(char *path) {\n    char node[128], val[8];\n    FILE *fp;\n\n    snprintf(node, sizeof(node), \"%s/%s/state\", SWITCH_ROOT_PATH, path);\n    fp = fopen(node, \"r\");\n    fgets(val, sizeof(val), fp));\n    fclose(fp);\n\n    return atoi(val);\n}\n\nstatic int\nexternal_connection_get_current_state(ConnectionUpdated updated_cb, void *data) {\n    int ret, i;\n    struct connection_info info;\n    char buf[8];\n\n    for (i = 0; i type == LED_TYPE_BLINK) {\n        printf(\"camera back led does not support LED_TYPE_BLINK mode\");\n\n        return -ENOTSUP;\n    }\n\n    if (max color >> 24) & 0xFF;\n    brt = brt / 255.f * max;\n\n    snprintf(buf, sizeof(buf), \"%d\", brt);\n    fd = open(CAMERA_BACK_PATH\"/brightness\", O_WRONLY);\n    write(fd, buf, strlen(buf));\n    close(fd);\n\n    return 0;\n}\n\nstruct led_device camera_back_dev = {\n    .set_state = camera_back_set_state,\n};\n\nstruct led_device_list {\n    const char *id;\n    struct led_device *operations;\n    struct led_device *dev;\n} led_list[] = {\n    {LED_ID_CAMERA_BACK, &camera_back_dev, NULL},\n    {LED_ID_CAMERA_FRONT, NULL, NULL},\n    {LED_ID_NOTIFICATION, NULL, NULL},\n    {LED_ID_TOUCH_KEY, NULL, NULL},\n};\n\nstatic int\nled_open(struct hw_info *info, const char *id, struct hw_common **common) {\n    int i, list_len, id_len;\n\n    list_len = ARRAY_SIZE(led_list);\n    id_len = strlen(id) + 1;\n    for (i = 0; i = list_len)\n        return -EINVAL;\n    led_list[i].dev = calloc(1, sizeof(struct led_device));\n\n    led_list[i].dev->common.info = info;\n    led_list[i].dev->set_state\n        = led_list[i].operations->set_state;\n\nout:\n    *common = (struct hw_common *)led_list[i].dev;\n\n    return 0;\n}\n\nstatic int\nled_close(struct hw_common *common) {\n    free(common);\n\n    return 0;\n}\n\nHARDWARE_MODULE_STRUCTURE = {\n    .magic = HARDWARE_INFO_TAG,\n    .hal_version = HARDWARE_INFO_VERSION,\n    .device_version = LED_HARDWARE_DEVICE_VERSION,\n    .id = LED_HARDWARE_DEVICE_ID,\n    .name = \"Default LED\",\n    .open = led_open,\n    .close = led_close,\n};\n```\n\n#### IR HAL\n\nThe IR HAL provides functions for controlling IR transmission. The HAL interface is defined in the `hw/ir.h` header file of the `libdevice-node` library, and the `pkg-config` `device-node` must be used to use the HAL interface.\n\nThe following code snippet shows the interface of the IR HAL:\n\n```cpp\n/*\n   Device ID\n*/\n#define IR_HARDWARE_DEVICE_ID \"ir\"\n\n/*\n   Device version\n*/\n#define IR_HARDWARE_DEVICE_VERSION MAKE_VERSION(0,1)\n\nstruct ir_device {\n    struct hw_common common;\n\n    /* Control the IR state */\n    int (*is_available)(bool *available);\n    int (*transmit)(int *frequency_pattern, int size);\n};\n```\n\nThe following table lists the IR HAL functions.\n\n**Table: IR HAL functions**\n\n| Function prototype                       | Description                              | Mandatory |\n| ---------------------------------------- | ---------------------------------------- | --------- |\n| `int (*is_available)(bool *available);`  | Returns whether the target device supports IR transmission. | Yes |\n| `int (*transmit)(int *frequency_pattern, int size);` | Transmits IR with frequency pattern and its size. | Yes |\n\nThe following code snippet shows an example of the IR HAL:\n\n```cpp\n#define IRLED_CONTROL_PATH \"/sys/class/ir/ir_send\"\n\nstatic int\nir_is_available(bool *available) {\n    *available = true;\n\n    return 0;\n}\n\nstatic int\nir_transmit(int *frequency_pattern, int size) {\n    int i, ret;\n\n    for (i = 0; i common.info = info;\n    ir_dev->is_available = ir_is_available;\n    ir_dev->transmit = ir_transmit;\n\n    *common = (struct hw_common *)ir_dev;\n\n    return 0;\n}\n\nstatic int\nir_close(struct hw_common *common) {\n    free(common);\n\n    return 0;\n}\n\nHARDWARE_MODULE_STRUCTURE = {\n    .magic = HARDWARE_INFO_TAG,\n    .hal_version = HARDWARE_INFO_VERSION,\n    .device_version = IR_HARDWARE_DEVICE_VERSION,\n    .id = IR_HARDWARE_DEVICE_ID,\n    .name = \"ir\",\n    .open = ir_open,\n    .close = ir_close,\n};\n```\n\n#### Touchscreen HAL\n\nThe touchscreen HAL provides functions for switching the touchscreen on and off. The HAL interface is defined in the `hw/touchscreenf.h` header file of the `libdevice-node` library, and the `pkg-config` `device-node` must be used to use the HAL interface.\n\nThe following code snippet shows the interface of the touchscreen HAL:\n\n```cpp\n/*\n   Device ID\n*/\n#define TOUCHSCREEN_HARDWARE_DEVICE_ID \"touchscreen\"\n\n/*\n   Device version\n*/\n#define TOUCHSCREEN_HARDWARE_DEVICE_VERSION MAKE_VERSION(0,1)\n\nenum touchscreen_state {\n    TOUCHSCREEN_OFF, /* Disable touchscreen */\n    TOUCHSCREEN_ON, /* Enable touchscreen */\n};\n\nstruct touchscreen_device {\n    struct hw_common common;\n\n    /* Control touchscreen state */\n    int (*get_state)(enum touchscreen_state *state);\n    int (*set_state)(enum touchscreen_state state);\n};\n```\n\nThe following table lists the touchscreen HAL functions.\n\n**Table: Touchscreen HAL functions**\n\n| Function prototype                       | Description                              | Mandatory |\n| ---------------------------------------- | ---------------------------------------- | --------- |\n| `int (*get_state)(enum touchscreen_state *state);` | Returns whether the touchscreen is enabled. | Yes |\n| `int (*set_state)(enum touchscreen_state state);` | Enables and disables the touchscreen. | Yes |\n\nThe following code snippet shows an example of the touchscreen HAL:\n\n```cpp\n#define TURNON_TOUCHSCREEN 1\n#define TURNOFF_TOUCHSCREEN 0\n#define TOUCHSCREEN_PATH \"/sys/class/input/touchscreen/enable\"\n\nstatic int\ntouchscreen_get_state(enum touchscreen_state *state) {\n    int val;\n    int fd;\n    char buf[BUF_MAX];\n\n    fd = open(TOUCHSCREEN_PATH, O_RDONLY);\n    read(fd, buf, sizeof(buf));\n    close(fd);\n    val = atoi(buf);\n\n    switch (val) {\n    case TURNOFF_TOUCHSCREEN:\n        *state = TOUCHSCREEN_OFF;\n        break;\n    case TURNON_TOUCHSCREEN:\n        *state = TOUCHSCREEN_ON;\n        break;\n    default:\n        return -EINVAL;\n    }\n\n    return 0;\n}\n\nstatic int\ntouchscreen_set_state(enum touchscreen_state state) {\n    int val;\n    char buf[BUF_MAX];\n\n    switch (state) {\n    case TOUCHSCREEN_OFF:\n        val = TURNOFF_TOUCHSCREEN;\n        break;\n    case TOUCHSCREEN_ON:\n        val = TURNON_TOUCHSCREEN;\n        break;\n    default:\n        return -EINVAL;\n    }\n\n    snprintf(buf, sizeof(buf), \"%d\", val);\n    fd = open(TOUCHSCREEN_PATH, O_WRONLY);\n    write(fd, buf, strlen(buf));\n    close(fd);\n\n    return ret;\n}\n\nstatic int\ntouchscreen_open(struct hw_info *info, const char *id, struct hw_common **common) {\n    struct touchscreen_device *touchscreen_dev;\n\n    touchscreen_dev = calloc(1, sizeof(struct touchscreen_device));\n\n    touchscreen_dev->common.info = info;\n    touchscreen_dev->get_state = touchscreen_get_state;\n    touchscreen_dev->set_state = touchscreen_set_state;\n\n    *common = (struct hw_common *)touchscreen_dev;\n\n    return 0;\n}\n\nstatic int\ntouchscreen_close(struct hw_common *common) {\n    free(common);\n\n    return 0;\n}\n\nHARDWARE_MODULE_STRUCTURE = {\n    .magic = HARDWARE_INFO_TAG,\n    .hal_version = HARDWARE_INFO_VERSION,\n    .device_version = TOUCHSCREEN_HARDWARE_DEVICE_VERSION,\n    .id = TOUCHSCREEN_HARDWARE_DEVICE_ID,\n    .name = \"touchscreen\",\n    .open = touchscreen_open,\n    .close = touchscreen_close,\n};\n```\n\n## Sensor Framework\n\nSensor devices are used widely in mobile devices to enhance the user experience. Most modern mobile operating systems have a framework which manages hardware and virtual sensors on the platform and provides convenient APIs to the application.\n\nSensors can be classified into hardware and virtual sensors. Tizen supports individual HALs for the following sensors:\n\n- Hardware sensors\n  - Accelerometer\n  - Geomagnetic sensor\n  - Gyroscope\n  - Light sensor\n  - Proximity sensor\n  - Pressure sensor\n  - Ultraviolet sensor\n  - Temperature sensor\n  - Humidity sensor\n  - HRM (Heart Rate Monitor)\n  - HRM LED green sensor\n  - HRM LED IR sensor\n  - HRM LED red sensor\n  - Uncalibrated geomagnetic sensor\n  - Uncalibrated gyroscope sensor\n  - Human pedometer\n  - Human sleep monitor\n  - Human sleep detector\n  - Human stress monitor\n- Virtual sensors\n  - Orientation sensor\n  - Gravity sensor\n  - Linear acceleration sensor\n  - Rotation vector sensor\n  - Gyroscope rotation vector sensor\n  - Geomagnetic rotation vector sensor\n\nThe sensor framework provides a sensor server for managing sensor HALs and a medium through which client applications are connected to the sensor handler to exchange data.\n\n**Figure: Sensor framework architecture**\n\n![Sensor framework architecture](media/678px-tizen-3-sensorfw.png)\n\nThe sensor HALs retrieve data from sensor hardware and enable client applications to use the data for specific requirements.\n\nThe Sensor framework consists of the following components:\n\n- Sensor client library\n\n  Any application that wants to access the sensor server and communicate with it must use the sensor API library. Using the Sensor API, the application can control sensors and receive sensor events from the sensor server. By using the sensor API, any application or middleware framework can have the sensor client library executing within its own process context.\n\n- Sensor server\n\n  The sensor server is a daemon which communicates uniquely to multiple sensors (through drivers) in the system and dispatches sensor data or events back to the application. The sensor server is responsible for initializing the sensors during boot, driver configuration, sensor data fetching and delivery, and managing all sensors and clients on the platform.\n\n- Sensor HAL (Hardware Abstraction Layer)\n\n  The sensor HAL, which is interfaced to the sensor server, is responsible for interacting with the sensor drivers. The HAL processes data from the sensor drivers and communicates it to the server. Hardware sensors must support the HAL. The sensor HAL is implemented as a shared library. The `sensor_loader` finds the `hal.so` library in the `/usr/lib/sensor/` directory, and loads it at boot time.\n\n### Porting the HAL Interface\n\nYou can port individual sensors or a sensorhub.\n\n#### Sensor\n\nTo port new hardware sensors, the HAL library-inherited `sensor_device` interface must be implemented. The HAL header files can be found at `git:sensord/src/hal`.\n\nThe Tizen HAL sensor types are also defined in the `sensor_hal_types.h` header file under the names `SENSOR_DEVICE_...`.\n\n**Figure: Sensor HAL**\n\n![Sensor HAL](media/tizen-3-sensor-fw-hal.png)\n\nThe following code snippet shows the interface of the sensor HAL in the `sensor_hal.h` header file:\n\n```cpp\n/*\n   Create devices\n*/\ntypedef void *sensor_device_t;\ntypedef int (*create_t)(sensor_device_t **devices);\n\n/*\n   Sensor device interface\n   1 device must be abstracted from 1 device event node\n*/\nclass sensor_device {\npublic:\n    virtual ~sensor_device() {}\n\n    uint32_t get_hal_version(void) {\n        return SENSOR_HAL_VERSION(1, 0);\n    }\n\n    virtual int get_poll_fd(void) = 0;\n    virtual int get_sensors(const sensor_info_t **sensors) = 0;\n\n    virtual bool enable(uint32_t id) = 0;\n    virtual bool disable(uint32_t id) = 0;\n\n    virtual int read_fd(uint32_t **ids) = 0;\n    virtual int get_data(uint32_t id, sensor_data_t **data, int *length) = 0;\n\n    virtual bool set_interval(uint32_t id, unsigned long val) {\n        return true;\n    }\n    virtual bool set_batch_latency(uint32_t id, unsigned long val) {\n        return true;\n    }\n    virtual bool set_attribute_int(uint32_t id, int32_t attribute, int32_t value) {\n        return true;\n    }\n    virtual bool set_attribute_str(uint32_t id, int32_t attribute, char *value, int value_len) {\n        return true;\n    }\n    virtual bool flush(uint32_t id) {\n        return true;\n    }\n};\n```\n\nThe following table describes the functions of the `sensor_device` interface.\n\n**Table: sensor_device interface functions**\n\n| Prototype                                | Description                              | Return value      |\n| ---------------------------------------- | ---------------------------------------- | ----------------- |\n| `uint32_t get_hal_version(void)`         | Returns the HAL version.                 | Version           |\n| `int get_poll_fd(void)`                  | Returns the file description to poll events. | `fd`              |\n| `int get_sensors(const sensor_info_t **sensors)` | Returns the list of supported sensors. See the `sensor_info_t` in the `sensor_hal_types.h` header file. | Size              |\n| `bool enable(uint32_t id)`               | Enables the sensor.                      | `true` on success |\n| `bool disable(uint32_t id)`              | Disables the sensor.                     | `true` on success |\n| `int read_fd(uint32_t **ids)`            | Returns the sensor device IDs. The sensor framework calls this function when an event is detected from the `poll-fd`. | Size              |\n| `int get_data(uint32_t id, sensor_data_t **data, int *length)` | Updates the `sensor_data_t` object (data) with details about the sensor, such as accuracy, timestamp, and values. Note that the `sensor_data_t` object must be created using the `malloc()` function. | 0 on success      |\n| `bool set_interval(uint32_t id, unsigned long val)` | Sets the interval.                       | `true` on success |\n| `bool set_batch_latency(uint32_t id, unsigned long val)` | Sets the batch latency.                   | `true` on success |\n| `bool set_attribute_int(uint32_t id, int32_t attribute, int32_t value)` | Sets the `int` value to the attribute.   | `true` on success |\n| `bool set_attribute_str(uint32_t id, int32_t attribute, char *value, int value_len)` | Sets the `string` value to the attribute.      | `true` on success |\n| `bool flush(uint32_t id)`                | Flushes the sensor events.               | `true` on success |\n| `int (create_t *)(sensor_device_t **devices)` | Returns the `sensor_device` list. To create the sensor module in `sensord`, you must implement this interface. | Size              |\n\nThe following code snippet shows the interface of the sensor HAL types in the `sensor_hal_type.h` header file:\n\n```cpp\n/*\n   Sensor Types\n   These types are used to control the sensors\n\n   - base unit\n     acceleration values : meter per second^2 (m/s^2)\n     magnetic values     : micro-Tesla (uT)\n     orientation values  : degrees\n     gyroscope values    : degree/s\n     temperature values  : degrees centigrade\n     proximity values    : distance\n     light values        : lux\n     pressure values     : hectopascal (hPa)\n     humidity            : relative humidity (%)\n*/\ntypedef enum {\n    SENSOR_DEVICE_UNKNOWN = -2,\n    SENSOR_DEVICE_ALL = -1,\n    SENSOR_DEVICE_ACCELEROMETER,\n    SENSOR_DEVICE_GRAVITY,\n    SENSOR_DEVICE_LINEAR_\n    SENSOR_DEVICE_GEOMAGNETIC,\n    SENSOR_DEVICE_ROTATION_VECTOR,\n    SENSOR_DEVICE_ORIENTATION,\n    SENSOR_DEVICE_GYROSCOPE,\n    SENSOR_DEVICE_LIGHT,\n    SENSOR_DEVICE_PROXIMITY,\n    SENSOR_DEVICE_PRESSURE,\n    SENSOR_DEVICE_ULTRAVIOLET,\n    SENSOR_DEVICE_TEMPERATURE,\n    SENSOR_DEVICE_HUMIDITY,\n    SENSOR_DEVICE_HRM,\n    SENSOR_DEVICE_HRM_LED_GREEN,\n    SENSOR_DEVICE_HRM_LED_IR,\n    SENSOR_DEVICE_HRM_LED_RED,\n    SENSOR_DEVICE_GYROSCOPE_UNCAL,\n    SENSOR_DEVICE_GEOMAGNETIC_UNCAL,\n    SENSOR_DEVICE_GYROSCOPE_RV,\n    SENSOR_DEVICE_GEOMAGNETIC_RV,\n\n    SENSOR_DEVICE_HUMAN_PEDOMETER = 0x300,\n    SENSOR_DEVICE_HUMAN_SLEEP_MONITOR,\n    SENSOR_DEVICE_HUMAN_SLEEP_DETECTOR,\n    SENSOR_DEVICE_HUMAN_STRESS_MONITOR,\n\n    SENSOR_DEVICE_EXERCISE_WALKING = 0x400,\n    SENSOR_DEVICE_EXERCISE_RUNNING,\n    SENSOR_DEVICE_EXERCISE_HIKING,\n    SENSOR_DEVICE_EXERCISE_CYCLING,\n    SENSOR_DEVICE_EXERCISE_ELLIPTICAL,\n    SENSOR_DEVICE_EXERCISE_INDOOR_CYCLING,\n    SENSOR_DEVICE_EXERCISE_ROWING,\n    SENSOR_DEVICE_EXERCISE_STEPPER,\n\n    SENSOR_DEVICE_FUSION = 0x900,\n    SENSOR_DEVICE_AUTO_ROTATION,\n    SENSOR_DEVICE_AUTO_BRIGHTNESS,\n\n    SENSOR_DEVICE_GESTURE_MOVEMENT = 0x1200,\n    SENSOR_DEVICE_GESTURE_WRIST_UP,\n    SENSOR_DEVICE_GESTURE_WRIST_\n    SENSOR_DEVICE_GESTURE_MOVEMENT_STATE,\n\n    SENSOR_DEVICE_ACTIVITY_TRACKER = 0x1A00,\n    SENSOR_DEVICE_ACTIVITY_LEVEL_MONITOR,\n} sensor_device_type;\n```\n\nThe following code snippet shows the interface of the sensor HAL information in the `sensor_hal_type.h` header file:\n\n```cpp\n/*\n   A platform sensor handler is generated based on this handle\n   This ID can be assigned by HAL developer, so it must be unique in 1 sensor_device.\n*/\ntypedef struct sensor_info_t {\n    uint32_t\n    const char *name;\n    sensor_device_type type;\n    unsigned int event_type; /* for Internal API */\n    const char *model_name;\n    const char *vendor;\n    float min_range;\n    float max_range;\n    float resolution;\n    int min_interval;\n    int max_batch_count;\n    bool wakeup_supported;\n} sensor_info_t;\n\nenum sensor_accuracy_t {\n    SENSOR_ACCURACY_UNDEFINED = -1,\n    SENSOR_ACCURACY_BAD = 0,\n    SENSOR_ACCURACY_NORMAL = 1,\n    SENSOR_ACCURACY_GOOD = 2,\n    SENSOR_ACCURACY_VERYGOOD = 3\n};\n\n#define SENSOR_DATA_VALUE_SIZE 16\n\n/* sensor_data_t */\ntypedef struct sensor_data_t {\n    int accuracy;\n    unsigned long long timestamp;\n    int value_count;\n    float values[SENSOR_DATA_VALUE_SIZE];\n} sensor_data_t;\n\n#define SENSOR_PEDOMETER_DATA_DIFFS_SIZE\t20\n\ntypedef struct {\n    int accuracy;\n    unsigned long long timestamp;\n    int value_count; /* value_count == 8 */\n    float values[SENSOR_DATA_VALUE_SIZE];\n    /* values = {step count, walk step count, run step count,\n\t         moving distance, calorie burned, last speed,\n\t         last stepping frequency (steps per sec),\n\t         last step status (walking, running, ...)} */\n    /* Additional data attributes (not in sensor_data_t)*/\n    int diffs_count;\n    struct differences {\n        int timestamp;\n        int steps;\n        int walk_steps;\n        int run_steps;\n        int walk_up_steps;\n        int walk_down_steps;\n        int run_up_steps;\n        int run_down_steps;\n        float distance;\n        float calories;\n        float speed;\n    } diffs[SENSOR_PEDOMETER_DATA_DIFFS_SIZE];\n} sensor_pedometer_data_t;\n\n#define CONVERT_TYPE_ATTR(type, index) ((type) \n#include \n#include \n\n#include \"accel/accel_device.h\"\n\nstatic std::vector devs;\n\ntemplate\nvoid\ncreate_sensor(const char *name) {\n    sensor_device *instance = NULL;\n    try {\n        instance = new _sensor;\n    } catch (std::exception &e) {\n        ERR(\"Failed to create %s sensor device, exception: %s\", name, e.what());\n\n        return;\n    } catch (int err) {\n        _ERRNO(err, _E, \"Failed to create %s sensor device\", name);\n\n        return;\n    }\n\n    devs.push_back(instance);\n}\n\nextern \"C\" int create(sensor_device_t **devices) {\n#ifdef ENABLE_ACCEL\n    create_sensor(\"Accelerometer\");\n#endif\n\n    *devices = &devs[0];\n\n    return devs.size();\n}\n```\n\n```cpp\n/* In accel_device.h */\n#ifndef _ACCEL_DEVICE_H_\n#define _ACCEL_DEVICE_H_\n\n#include \n#include \n#include \n#include \n\nclass accel_device : public sensor_device {\npublic:\n    accel_device();\n    virtual ~accel_device();\n\n    int get_poll_fd(void);\n    int get_sensors(const sensor_info_t **sensors);\n\n    bool enable(uint32_t id);\n    bool disable(uint32_t id);\n\n    bool set_interval(uint32_t id, unsigned long val);\n\n    int read_fd(uint32_t **ids);\n    int get_data(uint32_t id, sensor_data_t **data, int *length);\n\nprivate:\n    int m_node_handle;\n    int m_x;\n    int m_y;\n    int m_z;\n    unsigned long m_polling_interval;\n    unsigned long long m_fired_time;\n    bool m_sensorhub_controlled;\n\n    int m_method;\n    std::string m_data_node;\n    std::string m_enable_node;\n    std::string m_interval_node;\n\n    std::function update_value;\n\n    std::vector event_ids;\n\n    bool update_value_input_event(void);\n    bool update_value_iio(void);\n\n    void raw_to_base(sensor_data_t *data);\n};\n#endif /* _ACCEL_DEVICE_H_ */\n```\n\n```cpp\n/* In accel_device.cpp */\n#include \n#include \n#include \n#include \n\n#include \n#include \n#include \n\n#include \n#include \n#include \n\n#include \"accel_device.h\"\n\n#define MODEL_NAME \"K2HH\"\n#define VENDOR \"ST Microelectronics\"\n#define RESOLUTION 16\n#define RAW_DATA_UNIT 0.122\n#define MIN_INTERVAL 1\n#define MAX_BATCH_COUNT 0\n\n#define SENSOR_NAME \"SENSOR_ACCELEROMETER\"\n#define SENSOR_TYPE_ACCEL\t\t\"ACCEL\"\n\n#define INPUT_NAME\t\"accelerometer_sensor\"\n#define ACCEL_SENSORHUB_POLL_NODE_NAME \"accel_poll_delay\"\n\n#define GRAVITY 9.80665\n#define G_TO_MG 1000\n#define RAW_DATA_TO_G_UNIT(X) (((float)(X))/((float)G_TO_MG))\n#define RAW_DATA_TO_METRE_PER_SECOND_SQUARED_UNIT(X) (GRAVITY * (RAW_DATA_TO_G_UNIT(X)))\n\n#define MIN_RANGE(RES) (-((1 update_value_input_event();\n        };\n    } else {\n        if (!info.buffer_length_node_path.empty())\n            util::set_node_value(info.buffer_length_node_path, 480);\n\n        if (!info.buffer_enable_node_path.empty())\n            util::set_node_value(info.buffer_enable_node_path, 1);\n\n        update_value = [=]() {\n            return this->update_value_iio();\n        };\n    }\n\n    _I(\"accel_device is created!\");\n}\n\naccel_device::~accel_device() {\n    close(m_node_handle);\n    m_node_handle = -1;\n\n    _I(\"accel_device is destroyed!\");\n}\n\nint\naccel_device::get_poll_fd(void) {\n    return m_node_handle;\n}\n\nint\naccel_device::get_sensors(const sensor_info_t **sensors) {\n    *sensors = &sensor_info;\n\n    return 1;\n}\n\nbool\naccel_device::enable(uint32_t id) {\n    util::set_enable_node(m_enable_node, m_sensorhub_controlled, true, SENSORHUB_ACCELEROMETER_ENABLE_BIT);\n    set_interval(id, m_polling_interval);\n\n    m_fired_time = 0;\n    _I(\"Enable accelerometer sensor\");\n\n    return true;\n}\n\nbool\naccel_device::disable(uint32_t id) {\n    util::set_enable_node(m_enable_node, m_sensorhub_controlled, false, SENSORHUB_ACCELEROMETER_ENABLE_BIT);\n\n    _I(\"Disable accelerometer sensor\");\n\n    return true;\n}\n\nbool\naccel_device::set_interval(uint32_t id, unsigned long val) {\n    unsigned long long polling_interval_ns;\n\n    polling_interval_ns = ((unsigned long long)(val) * 1000llu * 1000llu);\n\n    if (!util::set_node_value(m_interval_node, polling_interval_ns)) {\n        _E(\"Failed to set polling resource: %s\", m_interval_node.c_str());\n\n        return false;\n    }\n\n    _I(\"Interval is changed from %dms to %dms\", m_polling_interval, val);\n    m_polling_interval = val;\n\n    return true;\n}\n\nbool\naccel_device::update_value_input_event(void) {\n    int accel_raw[3] = {0,};\n    bool x,y,z;\n    int read_input_cnt = 0;\n    const int INPUT_MAX_BEFORE_SYN = 10;\n    unsigned long long fired_time = 0;\n    bool syn = false;\n\n    x = y = z = false;\n\n    struct input_event accel_input;\n    _D(\"accel event detection!\");\n\n    while ((syn == false) && (read_input_cnt accuracy = SENSOR_ACCURACY_GOOD;\n    sensor_data->timestamp = m_fired_time;\n    sensor_data->value_count = 3;\n    sensor_data->values[0] = m_x;\n    sensor_data->values[1] = m_y;\n    sensor_data->values[2] = m_z;\n\n    raw_to_base(sensor_data);\n\n    *data = sensor_data;\n    *length = sizeof(sensor_data_t);\n\n    return 0;\n}\n\nvoid\naccel_device::raw_to_base(sensor_data_t *data) {\n    data->values[0] = RAW_DATA_TO_METRE_PER_SECOND_SQUARED_UNIT(data->values[0] * RAW_DATA_UNIT);\n    data->values[1] = RAW_DATA_TO_METRE_PER_SECOND_SQUARED_UNIT(data->values[1] * RAW_DATA_UNIT);\n    data->values[2] = RAW_DATA_TO_METRE_PER_SECOND_SQUARED_UNIT(data->values[2] * RAW_DATA_UNIT);\n}\n```\n\n#### Sensorhub\n\nThe sensorhub HAL supports multiple sensors logically from 1 physical device file. If many sensors are supported by a single device file, the sensorhub HAL can be configured so that it can operate each sensor as a logically-separate device.\n\nThe sensor HAL interface is provided to manufacturers and vendors through the `sensor_hal.h` and `sensor_hal_types.h` header files. It uses just 1 thread for polling sensor events from multiple device files.\n\n**Figure: Sensorhub HAL**\n\n![Sensorhub HAL](media/656px-tizen-3-sensorhub2.png)\n\nThe sensorhub HAL can be developed by using the `sensor_device` interface. An example of a sensorhub HAL can be found in the `sensor-hal-tm1/src/sensorhub` Git.\n\nIDs can be assigned by the vendor or manufacturer for the sensorhub sensors by using the following `sensor_info_t` interface:\n\n```cpp\ntypedef struct sensor_info_t {\n    uint32_t id;\n    const char *name;\n    sensor_device_type type;\n    unsigned int event_type; /* For Internal API */\n    const char *model_name;\n    const char *vendor;\n    float min_range;\n    float max_range;\n    float resolution;\n    int min_interval;\n    int max_batch_count;\n    bool wakeup_supported;\n} sensor_info_t;\n```\n\nThe following code snippet shows an example of a sensorhub HAL implementation:\n\n```cpp\n#include \n#include \n\n#include \"sensorhub.h\"\n#include \"sensorhub_controller.h\"\n#include \"sensorhub_manager.h\"\n#include \"system_state.h\"\n\nsensorhub_device::sensorhub_device() {\n    controller = &sensorhub_controller::get_instance();\n    if (!controller) {\n        ERR(\"Failed to allocated memory\");\n        throw;\n    }\n\n    manager = &sensorhub_manager::get_instance();\n    if (!manager) {\n        ERR(\"Failed to allocated memory\");\n        throw;\n    }\n    manager->set_controller(controller);\n    system_state_handler::get_instance().set_controller(controller);\n\n    INFO(\"sensorhub_device is created!\");\n}\n\nsensorhub_device::~sensorhub_device() {\n    INFO(\"sensorhub_device is destroyed!\");\n}\n\nint\nsensorhub_device::get_poll_fd(void) {\n    return controller->get_poll_fd();\n}\n\nint\nsensorhub_device::get_sensors(const sensor_info_t **sensors) {\n    int size;\n    size = manager->get_sensors(sensors);\n\n    return size;\n}\n\nbool\nsensorhub_device::enable(uint32_t id) {\n    system_state_handler::get_instance().initialize();\n\n    controller->enable();\n    sensorhub_sensor *sensor = manager->get_sensor(id);\n\n    if (!sensor) {\n        ERR(\"Failed to enable sensor(0x%x)\", id);\n\n        return false;\n    }\n\n    return sensor->enable();\n}\n\nbool\nsensorhub_device::disable(uint32_t id) {\n    system_state_handler::get_instance().finalize();\n\n    controller->disable();\n    sensorhub_sensor *sensor = manager->get_sensor(id);\n\n    if (!sensor) {\n        ERR(\"Failed to disable sensor(0x%x)\", id);\n\n        return false;\n    }\n\n    return sensor->disable();\n}\n\nbool\nsensorhub_device::set_interval(uint32_t id, unsigned long val) {\n    sensorhub_sensor *sensor = manager->get_sensor(id);\n\n    if (!sensor) {\n        ERR(\"Failed to set interval to sensor(0x%x)\", id);\n\n        return false;\n    }\n\n    return sensor->set_interval(val);\n}\n\nbool\nsensorhub_device::set_batch_latency(uint32_t id, unsigned long val) {\n    sensorhub_sensor *sensor = manager->get_sensor(id);\n\n    if (!sensor) {\n        ERR(\"Failed to set batch latency to sensor(0x%x)\", id);\n\n        return false;\n    }\n\n    return sensor->set_batch_latency(val);\n}\n\nbool\nsensorhub_device::set_attribute_int(uint32_t id, int32_t attribute, int32_t value) {\n    int ret;\n\n    sensorhub_sensor *sensor = manager->get_sensor(id);\n\n    if (!sensor) {\n        ERR(\"Failed to set attribute to sensor(0x%x)\", id);\n\n        return false;\n    }\n\n    ret = sensor->set_attribute_int(attribute, value);\n\n    if ((ret get_sensor(id);\n\n    if (!sensor) {\n        ERR(\"Failed to set attribute to sensor(0x%x)\", id);\n\n        return false;\n    }\n\n    ret = sensor->set_attribute_str(attribute, value, value_len);\n\n    if ((ret read_fd(data))\n        return 0;\n\n    /* Step 2 */\n    const char *hub_data = data.values;\n    int data_len = data.value_count;\n\n    /* Step 3 */\n    event_ids.clear();\n\n    while (data_len > 0) {\n        DBG(\"Remaining data length: %d\", data_len);\n        int parsed = parse(hub_data, data_len);\n        if (parsed get_sensor(id);\n    if (!sensor) {\n        ERR(\"Failed to get data from sensor(0x%x)\", id);\n\n        return -1;\n    }\n\n    remains = sensor->get_data(data, length);\n\n    return remains;\n}\n\nbool\nsensorhub_device::flush(uint32_t id) {\n    return false;\n}\n\nint\nsensorhub_device::parse(const char *hub_data, int data_len) {\n    return parse_data(hub_data, data_len);\n}\n\nint\nsensorhub_device::parse_data(const char *hub_data, int data_len) {\n    const char *cursor = hub_data;\n    int32_t libtype = 0;\n\n    sensorhub_sensor *sensor = manager->get_sensor(libtype);\n    if (!sensor) {\n        ERR(\"Unknown Sensorhub lib type: %d\", libtype);\n\n        return -1;\n    }\n\n    event_ids.push_back(sensor->get_id());\n\n    return sensor->parse(cursor, data_len);\n}\n\nint\nsensorhub_device::parse_debug(const char *hub_data, int data_len) {\n    return 0;\n}\n```\n\n```cpp\n#include \n#include \n#include \n#include \n#include \n#include \n#include \n#include \n\n#include \n#include \n#include \"sensorhub_controller.h\"\n\nsensorhub_controller::sensorhub_controller()\n: m_enabled(false)\n, m_poll_node(-1)\n, m_data_node(-1) {}\n\nsensorhub_controller::~sensorhub_controller() {}\n\nsensorhub_controller& sensorhub_controller::get_instance(void) {\n    static sensorhub_controller instance;\n\n    return instance;\n}\n\nint\nsensorhub_controller::get_poll_fd(void) {\n    /* Returns the sensorhub fd */\n\n    return -1;\n}\n\nbool\nsensorhub_controller::enable(void) {\n    m_enabled = true;\n    INFO(\"Enable Sensorhub\");\n\n    return true;\n}\n\nbool\nsensorhub_controller::disable(void) {\n    m_enabled = false;\n    INFO(\"Disable Sensorhub\");\n\n    return true;\n}\n\nint\nsensorhub_controller::open_input_node(const char* input_node) {\n    /* Implements the specific sensorhub logic */\n\n    return -1;\n}\n\nbool\nsensorhub_controller::read_fd(sensorhub_data_t &data) {\n    /* Implements the specific sensorhub logic */\n\n    return false;\n}\n\nint\nsensorhub_controller::read_sensorhub_data(void) {\n    /* Implements the specific sensorhub logic */\n\n    return -1;\n}\n\nint\nsensorhub_controller::read_large_sensorhub_data(void) {\n    /* Implements the specific sensorhub logic */\n\n    return -1;\n}\n\nint\nsensorhub_controller::send_sensorhub_data(const char *data, int data_len) {\n    /* Implements the specific sensorhub logic */\n\n    return -1;\n}\n\nint\nsensorhub_controller::print_sensorhub_data(const char* name, const char *data, int length) {\n    /* Implements the specific sensorhub logic */\n\n    return 0;\n}\n```\n\n### References\n\nThe reference kernel configuration for sensors varies depending on vendor types. However, there is a standard kernel subsystem for sensors: the Industrial I/O (IIO) subsystem. IIO is intended to provide support for devices that are, in some sense, analog to digital or digital to analog.\nFor more information, see [https://wiki.analog.com/software/linux/docs/iio/iio](https://wiki.analog.com/software/linux/docs/iio/iio).\n\nThe following table lists some example kernel configurations.\n\n**Table: Example kernel configurations**\n\n| Sensor component   | Kernel configuration    | Device nodes                             |\n| ------------------ | ----------------------- | ---------------------------------------- |\n| Accelerometer      | `CONFIG_INPUT_KR3DH`    | `/dev/input/event0/`, `/dev/input/event1/`, `/dev/input/event2/`, `/dev/input/event3/`, `/dev/input/event4/`, `/dev/input/event5/` |\n| Proximity          | `CONFIG_INPUT_GP2A`     |                                          |\n| Light sensor       | `CONFIG_INPUT_GP2A`     |                                          |\n| Electronic compass | `CONFIG_SENSORS_AK8975` |                                          |\n\n### Project Git Repositories\n\nThe following table lists the available project Git repositories.\n\n**Table: Git repositories**\n\n| Project               | Repository                               | Description                              |\n| --------------------- | ---------------------------------------- | ---------------------------------------- |\n| `capi-system-sensor`  | `platform/core/api/sensor`               | Tizen sensor C-API                       |\n| `sensord`             | `platform/core/system/sensord`           | Sensor daemon and libraries for managing sensors and clients |\n| `sensor-hal-tm1`      | `platform/adaptation/tm1/sensor-hal-tm1` | Sensor HAL for the TM1 device                |\n| `sensor-hal-tm2`      | `platform/adaptation/tm2/sensor-hal-tm2` | Sensor HAL for the TM2 device                |\n| `sensor-hal-tw1`      | `platform/adaptation/tw1/sensor-hal-tw1` | Sensor HAL for the TW1 device                |\n| `sensor-hal-emulator` | `platform/adaptation/emulator/sensor-hal-emulator` | Sensor HAL for the emulator                  |\n\n### Testing and Verifying Sensors\n\nThe `sensor-test package`, in the `sensord` Git repository, provides `sensorctl`, a command-line tool for testing sensors. After installing `sensor-test package`, you can test sensors using the following commands:\n\n```\n$ sensorctl test accelerometer\n$ sensorctl test gyroscope\n$ sensorctl test accelerometer 100 /* enable accelerometer with interval 100 ms */\n$ sensorctl test accelerometer 100 1000 /* enable accelerometer with interval 100 ms and 1s batch latency */\n$ sensorctl test accelerometer 100 1000 0 /* enable accelerometer with interval 100 ms, 1s batch latency and always on option */\n$ sensorctl info accelerometer /* retrieve accelerometer sensor information */\n```\n\n## Crash Framework\n\n### crash-manager\n\ncrash-manager is a tool used to create crash reports when an application gets crashed.\ncrash-manager is not usually invoked manually, but automatically by the kernel when the crash occurs. crash-manager generates the crash report and attaches the kernel-provided core, if requested. crash-worker package provides the `99-crash-manager.conf` file, which configures kernel parameters for crash-manager to get invoked automatically on crash. For more information, see [`99-crash-manager.conf`](#99-crash-managerconf).\n\ncrash-manager consists of the following options:\n\nOption                | Description\n----------------------|------------------------------------------------------\n-p  --pid=PID         | Specifies the process ID (PID) of the dumped process.\n-u  --uid=UID         | Specifies the real user identifier (UID) of the dumped process.\n-g  --gid=GID         | Specifies the real group identifier (GID) of the dumped process.\n-i  --tid=TID         | Specifies the thread identifier (TID) of the thread that triggered core dump. For more information, see [core(5)](http://man7.org/linux/man-pages/man5/core.5.html).\n-s  --signal=SIG      | Specifies the signal number causing dump.\n-t  --time=TIME       | Specifies the time of dump in seconds since the epoch.\n-l  --live            | Gets the core dump of the running process.\n-k  --kill-after-dump | Kills after dump (only with --live option).\n-r  --print           | Prints the report path to standard output (stdout).\n-h  --help            | Prints the help message.\n\nIn addition to handling crashes, crash-manager can create reports from running processes, livedumps. Livedumps contain `core` generated from the running process. The `core` is not created automatically but need to be requested explicitly by you. crash-manager needs to be invoked with the `--live` option, to produce the livedump report:\n\n```\n$ /usr/bin/crash-manager -p  --live --print\n```\n\n#### 99-crash-manager.conf\n\nThe `99-crash-manager.conf` file consists of the following kernel configurations related to the core dump:\n\n-  **kernel.core_pattern**  \n     This value contains the path to the file in which the kernel will store the core dump in case of a process crash. The possible values are described in [core(5)](http://man7.org/linux/man-pages/man5/core.5.html). If the first character of this path is a pipe symbol (`|`), then the whole line is interpreted as a program that can be executed, and the core dump will be given as a standard input.\n     To disable crash-manager, set this value to an empty string.\n\n     Default value: ```\"/usr/bin/crash-manager -p %p -u %u -g %g -s %s -t %t\"```\n\n-  **kernel.core_pipe_limit**  \n     Defines the maximum number of concurrent processes that may be dumped at the same time. For more information, see [core(5)](http://man7.org/linux/man-pages/man5/core.5.html).\n     If the limit is exceeded, then the next crashed process will not be dumped.\n\n     Default value: `10`\n\n-  **fs.suid_dumpable**  \n     Defines whether the core dump is produced for the set-owner-user-ID (SUID) binaries ([proc(5)](http://man7.org/linux/man-pages/man5/proc.5.html)) or not.\n\n     Default value: `2`\n\n\n#### crash-manager.conf\n\nThe default configuration file for crash-manager is `/etc/crash-manager.conf`. It is used to configure the location, the content and retention policy of crash reports.\n\n-  **SystemMaxUse**  \n     Determines the maximum size (in kilobytes) on disk that reports can occupy. If this value is exceeded, then the oldest reports will be deleted.\n     Value `0` turns off the check.\n\n     Default value: `0`\n\n-  **SystemKeepFree**  \n     If set to a value other than `0`, then crash-manager will check whether an appropriate amount of empty space (in kilobytes) is available on the disk or not.\n     Value `0` turns off the check.\n\n     Default value: `0`\n\n-  **MaxRetentionSec**  \n     Defines the maximal time (in seconds) a report will be kept. Older reports will be deleted.\n     Value `0` turns off the check.\n\n     Default value: `0`\n\n-  **MaxCrashDump**  \n     Defines how many reports will be kept. In case the number of reports exceeds this value, the oldest reports will be removed.\n     Value `0` turns off the check.\n\n     Default value: `0`\n\n-  **AllowZip**  \n     Determines whether the report will be compressed or not.\n\n     Default value: `yes`\n\n-  **CoreDump**  \n     If set to `0`, then the core dump will be removed from the final report.\n\n     Default value: `1`\n\n-  **CrashRootPath**  \n     Specifies the directory in which the crash reports will be saved. In the specified path, crash-manager will create four sub-directories:\n     - `dump/`: For saved reports of crashed applications\n     - `livedump/`: For saved reports of running processes (with option `--live`)\n     - `log/`: For logs\n     - `temp/`: For files while creating report\n\n     Default value: `/opt/user/share/crash/`\n\n-  **ReportType**  \n     Specifies the type of the crash report. Possible values are:\n     - `INFO`: Only the `*.info` file will be saved. The `*.info` file contains information about the registers and the call stack of the crashed application.\n     - `FULL`: The full crash report:\n         - `*.info`: Contains information about the registers and the call stack of the crashed application.\n         - `*.coredump`: A process memory dump.\n         - `*.so_info`: Contains information about shared libraries used by the crashed application, together with the names of packages that contain them.\n         - `*.log`: Contains information provided by [dump_systemstate](#dump_systemstate).\n         - Interesting files (`cmdline`, `environ`, `io`, `maps`, `smaps`, `stack`, `stat`, `statm`, `cwd`, `fd`) from the `/proc//` directory.\n\n     Default value: `FULL`\n\n\n-  **ExtraScript**  \n     Path to a script or an application that will be executed during report creation. The process will be started asynchronously.\n\n     Default value is empty\n\n#### Disabling crash-manager\n\nIn some situations there may be a need to disable the crash-manager functionality. In such cases, the recommended solution is to provide the `sysctl` configuration file to overwrite the default `kernel.core_pattern` setting. For example, the `99-disable-crash-manager.conf` file must be placed in the `/usr/lib/sysctl.d/` directory and must contain:\n\n```\nkernel.core_pattern=\nkernel.core_uses_pid=0\n```\n\n### D-Bus notification\n\nAfter the report is generated, crash-manager sends the D-Bus signal containing the following information about the crashed process:\n\nSignature: `sssssiia{sv}`  \nMember: `ProcessCrashed`  \nInterface: `org.tizen.system.crash.Crash`  \nPath: `/Org/Tizen/System/Crash/Crash`  \nData structure:  \n\nData         | Type\n-------------|-------\ncommand name | STRING\ncommand path | STRING\nappid        | STRING\npkgid        | STRING\nreport path  | STRING\nPID          | INT32\nTID          | INT32\narray        | ARRAY\n\nArray containing pairs of keys (STRING) and values (VARIANT). Possible keys:\n\nKey          | Type   | Description\n-------------|--------|---------------\nx86.eip      | UINT32 | instruction pointer\nx86_64.rip   | UINT64 | instruction pointer\narm.pc       | UINT32 | instruction pointer\narm.lr       | UINT32 | instruction pointer\naarch64.pc   | UINT64 | instruction pointer\naarch64.lr   | UINT64 | instruction pointer\nsys.signal   | INT32  | signal that caused crash\nsys.tid.comm | STRING | thread name\n\nDepending on the architecture, array will contain:\n\nArch    | PC (instruction pointer) | Link Register\n--------|--------------------------|------------------\nx86     | x86.eip                  | (not available)\nx86_64  | x86_64.eip               | (not available)\narm     | arm.pc                   | arm.lr\naarch64 | aarch64.pc               | aarch64.lr\n\n### minicoredumper\n\nminicoredumper is a tool that accepts a core dump on a standard input and saves the modified (size-reduced) core dump in a file. This tool is internally used by crash-manager to generate minicoredump. Modifications depends on the configuration, and they mainly rely on minimization of the core dump file.\n\nUsually, integrator does not need to modify this configuration unless integrator needs to change parameters of minicoredump files or settings for specified applications.\n\nminicoredumper can be used alone by setting `/proc/sys/kernel/core_pattern` to `|/usr/bin/minicoredumper %P %u %g %s %t %h %e`. All possible `%` specifiers are described in [core(5)](http://man7.org/linux/man-pages/man5/core.5.html).\n\nThe default path of the configuration file is `/etc/minicoredumper/minicoredumper.cfg.json` and the file format is JSON. Possible options are:\n\n-   **base_dir** (string): Defines the root directory where the dumped data will be stored. This option is overwritten by the command line option, which is set by **crash-manager**.\n-   **watch** (array): A set of recepts, which will be used for applications that meet the defined criteria:\n    -   **exe** (string): The full path to the binary returned by readlink. The `*` character is supported as wildcard. If not specified, the `*` value will be used.\n    -   **comm** (string): The basename of the command that was run. The `*` character is supported as wildcard. If not specified, the `*` value will be used.\n    -   **recept** (string): The full path to the recept file.\n\n    > **Note**\n    >\n    > If **exe** and **comm** are specified, then both conditions must be met to use the recept.\n\nDefault minicoredumper.cfg.json:\n\n```\n  {\n      \"base_dir\": \"/usr/local/var/crash/minicoredumper\",\n      \"watch\": [\n          {\n              \"exe\": \"/usr/bin/dotnet-launcher\",\n              \"recept\": \"dotnet.recept.json\"\n          },\n          {\n              \"recept\": \"generic.recept.json\"\n          }\n      ]\n  }\n```\n\n\nThe default path of the recept files is `/etc/minicoredumper/` and the format is JSON. Possible options are:\n\n-   **stacks** (list): Contains settings for what should be dumped.\n    -   **dump_stacks** (bool): If true, stacks will be dumped.\n    -   **first_thread_only** (bool): If true, only the first thread will be dumped.\n    -   **max_stack_size** (integer): Maximum size of the stack.\n-   **maps** (list): Contains list \"dump_by_name\".\n    -   **dump_by_name** (list): List of pathnames of memory regions that should be dumped (pathnames are read from `/proc//maps`).\n-   **compression** (list): Contains settings related to report compression.\n    -   **compressor** (string): Command line of compressor that supports stdin as input and stdout as output (gzip, bzip2, xz).\n    -   **extension**: (string): In case of a compressed core file, the specified value will be appended at the end of the core file name; otherwise, `.compressed` will be appended to the compressed core files.\n    -   **in_tar** (bool): Determines whether the core file should be a `.tar` file or not. This is useful because the tar format enables preserving the sparse properties of the core file.\n    -   **dump_auxv_so_list** (bool): If true, the shared object list will be saved in the core file.\n    -   **dump_pthread_list** (bool): If true, the pthread list will be saved in the core file.\n    -   **dump_robust_mutex_list** (bool): If true then robust mutexes will be saved in the core file.\n    -   **dump_scope** (int): Only registered dumps at this value or lower than this value will be dumped. This option applies only to libminicoredumper.\n    -   **dump_build_id** (bool): If true, then for all the contained ELF files, minicoredumper will save ELF header with BuildID to enable determining a specific version of the shared libraries.\n    -   **live_dumper** (bool): If true, then minicoredumper will trigger applications registered by libminicoredumper.\n    -   **write_proc_info** (boolean): If true, then interesting files (`cmdline`, `environ`, `io`, `maps`, `smaps`, `stack`, `stat`, `statm`, `cwd`, `fd`) from `/proc/` will be copied to the dump directory.\n    -   **proc_info_exclude** (list): Contains a list of filenames that must not be copied from the `/proc/` directory. For example, copying the `smaps` files will significantly increase the dumping time.\n    -   **write_debug_log** (bool): If true, then minicoredumper messages will be saved to `debug.txt` in the dump directory.\n    -   **dump_fat_core** (bool): If true, then all virtual memory areas will be saved in the separate core dump file. This must be used only for debug purpose.\n    -   **dump_pointed_by_regs** (bool): If true, then memory region around the address to which the CPU registers point is saved in the core file by minicoredumper. Precisely, for each CPU register minicoredumper saves page to which address points, one page before the address, and one page after the address. Page is 4096 bytes on most architectures.\n    -   **full_coredump** (bool): If true, then minicoredumper dumps the full core dump file.\n\nDefault `generic.recept.json`:\n\n```\n  {\n      \"stacks\": {\n          \"dump_stacks\": true,\n          \"first_thread_only\": false,\n          \"max_stack_size\": 0\n      },\n      \"maps\": {\n          \"dump_by_name\": [\n              \"[vdso]\"\n          ]\n      },\n      \"compression\": {\n          \"compressor\": \"\",\n          \"extension\": \"\",\n          \"in_tar\": true\n      },\n      \"dump_auxv_so_list\": true,\n      \"dump_pthread_list\": true,\n      \"dump_robust_mutex_list\": true,\n      \"dump_scope\": 1024,\n      \"dump_build_id\": true,\n      \"live_dumper\": true,\n      \"write_proc_info\": true,\n      \"proc_info_exclude\": [\n          \"smaps\"\n      ],\n      \"write_debug_log\": false,\n      \"dump_fat_core\": false,\n      \"dump_pointed_by_regs\": true\n  }\n```\n\n### dump_systemstate\n\n**dump_systemstate** is used to dump information that can be useful for developers to fix bugs in the crashed applications.\n\nDefault dump contains:\n-   Basic information:\n    -   Binary version from `/etc/info.ini`\n    -   Tizen version from `/etc/tizen-release`\n    -   Kernel version from `/proc/version`\n    -   Boot arguments from `/proc/cmdline`\n    -   CPU and system architecture from `/proc/cpuinfo`\n    -   System uptime from `/proc/uptime`\n    -   Local time from `/opt/etc/localtime`\n-   Resource usage information:\n    - System statistics from `/proc/stat`\n    - System memory usage from `/proc/meminfo`\n    - System disk I/O statistics from `/proc/diskstats`\n    - System disk space usage\n    - System memory statistics\n-   Process information:\n    - Process information by `ps` command\n-   Device information:\n    - Device major numbers from `/proc/devices` \n\n\nThe dump contents of **dump_systemstate** can be modified by the following command line options:\n\nOption | Description\n-------|----------------------------------\n-f     | write to file (instead of stdout)\n-k     | dump kernel messages (root only)\n-d     | dump dlog messages\n-j     | dump journal log messages\n-p     | dump list of installed packages\n-e     | dump extras defined in the config\n\nDepending on the command line options, **dump_systemstate** can save the output of these commands:\n\n-   `/bin/df -h`\n-   `/bin/du -ah /opt --exclude=/opt/usr`\n-   `/bin/ls -al /opt/etc/localtime`\n-   `/bin/top -bcH -n 1`\n-   `/bin/ps auxfw`\n-   `/bin/memps -v`\n-   `/bin/buxton2ctl dump memory`\n-   `/bin/buxton2ctl dump system`\n-   `/usr/bin/pkgcmd -l`\n-   `/bin/dmesg -T`\n-   `/bin/dlogutil -d -v threadtime -u 16384`\n-   `/bin/journalctl -b -n 1024`\n\n\nThere are two types of configuration files, under `files/` subdirectory and `programs/` subdirectory. These files allow to specify the results of additional files and programs that will be included in the **dump_systemstate** output:\n\n-   `files/` subdirectory: Specified files will be appended to the **dump_systemstate** output.\n    - **[SECTION_NAME]**\n    - **title**: Title that will be printed before contents of the file\n    - **path**: Path to the file\n\n    Example:\n\n    ```\n      [UNIQUE_ID_KEY]\n      title=header line that gets printed (path gets appended too)\n      path=/path/to/the/file\n\n      [DLOG_CONF]\n      title=dlog configuration file\n      path=/opt/etc/dlog.conf\n    ```\n\n-   `programs/` subdirectory: Specified commands will be executed and the output will be added to the **dump_systemstate** output.\n    - **[SECTION_NAME]**\n    - **title**: Title that will be printed before contents of the file\n    - **path**: Path to the application\n    - **args**: Arguments for the application\n    - **env**: Environment variable, which should be passed to the application\n\n    Example:\n\n    ```\n      [UNIQUE_ID_KEY]\n      title=header line describing the program (will be printed alongside env, path and args)\n      path=/path/to/the/program/executable\n      args=-x foo --verbose\n      env=POSIXLY_CORRECT=1\n\n      [DLOG_DUMP]\n      title=dump dlog contents\n      path=/usr/bin/dlogutil\n      args=-d\n    ```\n\n### livedumper\n\n**livedumper** is a tool to save the core dump of the live process.\n\nUsage:\n\n```\nlivedumper [-m] [-P ] [-f ] \n```\n\nOption               | Description\n---------------------|-------------------------------------------------------------------------------\n-f &lt;file_name&gt; | Saves core dump to the specified file (default livecore.&lt;PID&gt; in current directory).\n-P &lt;fd&gt;        | Descriptor for the registers structure (used by crash-manager).\n-m                   | Saves minicore. Saves minimum information that allows to restore the call stack.\n\nExample:\n\n```\n  $ sleep 123 &\n  $ livedumper -f sleep.core -m $?\n```"
					}
					
				
			
		
			
				
					,
					
					"tizenstudio-setup-tau-quick-start-guide": {
						"id": "tizenstudio-setup-tau-quick-start-guide",
						"title": "Hardware Accelerated Execution Manager",
						"categories": "",
						"url": " tizenstudio/setup/tau_quick_start_guide/",
						"content": "# How to Develop Wearable Web Application with TAU\r\n\r\nTAU stands for Tizen Advanced UI framework, which is the Tizen Web UI framework. \r\nTAU helps you to: \r\n- Create, manage pages, and various kinds of UI components \r\n- Use utilities for Web applications such as using transition effect for pages\r\n- Support the Mobile and Wearable profiles \r\n- Support the circular UI for Wearable devices\r\n\r\nThe concept of TAU is similar to jQuery Mobile, which is a commonly used Web UI system for making responsive Web sites and applications on the mobile devices. Compared to jQuery Mobile, TAU is much faster because it is made with pure JavaScript.\r\nTAU supports the layout styles and page navigation of Web applications. TAU makes it easy to develop your own Tizen Web application with the UI components provided by TAU.\r\n\r\n![Step 1](./media/tau1.PNG)\r\n\r\nThis page explains how to develop a Wearable Web application in Tizen Studio using **TAU**.\r\n\r\n## TAU Development Process\r\n\r\n![Step 1](./media/ta1.PNG)\r\n\r\n![Step 2](./media/ta2.PNG)\r\n\r\n![Step 3](./media/ta3.PNG)\r\n\r\n![Step 4](./media/ta4.PNG)\r\n\r\n## Web Application with TAU\r\n\r\n![Step 1](./media/w1.PNG)\r\n\r\n![Step 1](./media/w2.PNG)\r\n\r\n![Step 1](./media/w3.PNG)\r\n\r\n![Step 1](./media/w4.PNG)\r\n\r\n![Step 1](./media/w5.PNG)"
					}
					
				
			
		
			
				
					,
					
					"application-porting-telephony": {
						"id": "application-porting-telephony",
						"title": "Telephony",
						"categories": "",
						"url": " application/porting/telephony/",
						"content": "# Telephony\n\nThis guide describes the Telephony architecture in detail, including the various telephony components and the workflow in the Telephony framework. It also provides porting guidelines for vendors to facilitate OAL interface development for their hardware.\n\nThe Tizen Telephony features include:\n- Telecommunication functionalities, such as call, SS, SMS, SIM, network, and packet service\n- Plug-in architecture\n\n\nTo understand the telephony implementation, you must be familiar with the following definitions:\n\n- Core object\n  - Bundle of functions and supporting database information which processes requests, responses, and notifications designated to a specific module, such as call, SS, SIM, and network.\n  - Core objects form the executable component of a Telephony module (call, SS, SIM, network)\n- Hardware Abstraction Layer (HAL)\n  - The HAL ensures that similar functionality is provided by various hardware (modems) from the same modem vendor.\n  - All hardware-specific changes are controlled and processed by HALs.\n  - Depending on the modem chipset, a modem driver can be required.\n- Hooks\n  - Hooks provide a mechanism to tap the requests, responses, and notifications of other Telephony modules.\n  - Hooking is a transparent mechanism and does not affect the normal processing of requests, responses, and notifications.\n\n## Tizen Telephony Architecture\n\nTizen Telephony supports plugin architecture, which provides the flexibility to include various predefined plugins in the system with little modification.\n\n**Figure: Telephony architecture**\n\n![Telephony architecture](media/telephony-arch.png)\n\nThe 3 major components of Tizen Telephony are the libraries, plugins, and server.\n\n## Telephony Libraries\n\nThere are 2 main telephony libraries:\n\n- Telephony API (TAPI) library\n\n  The TAPI library (or simply TAPI) is a standardized interface, provided as the `libtapi` package, for applications to interact with Tizen Telephony. TAPI executes in the application's context, and it provides synchronous and asynchronous APIs. The following figure shows the `libtapi` components.\n\n  **Figure: libtapi components**\n\n  ![libtapi components](media/libtapi.png)\n\n  Applications can interface to telephony features, such as call, SMS, and network, through the respective module APIs exposed in the `libtapi` library. Telephony also provides an additional library, `capi-telephony`, for third-party applications.\n\n- Core Telephony library\n\n  The Core Telephony library, provided as the `libtcore` package, provides an API framework to interwork with Tizen Telephony. The following figure shows the `libtcore` components.\n\n  **Figure: libtcore components**\n\n  ![libtcore components](media/telephony03.png)\n\n  With `libtcore`, you can:\n\n  - Create, destroy, and maintain various server components, such as the server, communicators, HALs, core objects, and plugins.\n  - Maintain storage, queue mechanism, and general utilities.\n  - Support CMUX (creation/destruction/processing).\n  - Parse AT.\n\n## Telephony Plugins\n\nThere are 4 kinds of plugins:\n\n- **Communicator plugins** interface TAPI and the telephony server. For example, the DBUS communicator (`DBUS_TAPI`) is provided by default.\n- **Modem plugins** are core functional units providing the telephony functionality. They maintain and manage the telephony states and related databases.\n- **Modem interface plugins** interface the telephony server to the communication processor. They are hardware-specific plugins which define hardware capabilities and usage. Modem interface plugins are also called HALs.\n- **Free style plugins** provide functionality independent of communication processor hardware. Examples of free style plugins are packetservice, storage, and indicator.\n\nThe following figure provides an overview of the Telephony plugin types.\n\n**Figure: Telephony plugins**\n\n![Telephony plugins](media/telephony08.png)\n\n## Telephony Server\n\nTizen Telephony runs as a Telephony server daemon, `telephony-daemon`.\n\nThe Telephony server executes as a `g-main` loop from the `glib` library.\n\n**Figure: Telephony server**\n\n![Telephony server](media/telephony09.png)\n\n## Porting the OAL Interface\n\nOEM vendors can port available plugins within Telephony as needed to support specific hardware. It is not mandatory that all plugins are ported.\n\nThis section provides guidance to OEM vendors to develop various Telephony plugins.\n\n### Plugin Descriptor\n\nEach telephony plugin must provide a descriptor structure:\n\n```cpp\nstruct tcore_plugin_define_desc {\n    /* Name of the plugin */\n    gchar *name;\n\n    /* Initializing priority of the plugin */\n    enum tcore_plugin_priority priority;\n\n    /* Plugin version */\n    int version;\n\n    /* Plugin 'load' function reference */\n    gboolean(*load)();\n\n    /* Plugin 'init' function reference */\n    gboolean(*init)(TcorePlugin *);\n\n    /* Plugin 'unload' function reference */\n    void (*unload)(TcorePlugin *);\n};\n```\n\nThe plugin descriptor structure must be named as `plugin_define_desc`. The server obtains the address of this symbol to give control to the plugin to execute its defined functionality.\n\nThe initialization order among various Telephony plugins is based on each plugin's priority.\n\nOEMs need to specifically implement the modem and modem interface plugins to support their hardware.\n\n### Call Service Operations\n\nTo provide call services, the following functions must be implemented:\n\n```cpp\nstruct tcore_call_operations {\n    /* Call 'dial' function reference */\n    TReturn (*dial)(CoreObject *o, UserRequest *ur);\n\n    /* Call 'answer' function reference */\n    TReturn (*answer)(CoreObject *o, UserRequest *ur);\n\n    /* Call 'end' function reference */\n    TReturn (*end)(CoreObject *o, UserRequest *ur);\n\n    /* Call 'hold' function reference */\n    TReturn (*hold)(CoreObject *o, UserRequest *ur);\n\n    /* Call 'active' function reference */\n    TReturn (*active)(CoreObject *o, UserRequest *ur);\n\n    /* Call 'swap' function reference */\n    TReturn (*swap)(CoreObject *o, UserRequest *ur);\n\n    /* Call 'join' function reference */\n    TReturn (*join)(CoreObject *o, UserRequest *ur);\n\n    /* Call 'split' function reference */\n    TReturn (*split)(CoreObject *o, UserRequest *ur);\n};\n```\n\n### SMS Service Operations\n\nTo provide SMS services, the following functions must be implemented:\n\n```cpp\nstruct tcore_sms_operations {\n    /* For UMTS, SMS 'send' function reference */\n    TReturn (*send_umts_msg)(CoreObject *o, UserRequest *ur);\n\n    /* For CDMA, SMS 'read' function reference */\n    TReturn (*send_cdma_msg)(CoreObject *o, UserRequest *ur);\n\n    /* SMS 'read' function reference */\n    TReturn (*read_msg)(CoreObject *o, UserRequest *ur);\n\n    /* SMS 'save' function reference */\n    TReturn (*save_msg)(CoreObject *o, UserRequest *ur);\n\n    /* SMS 'delete' function reference */\n    TReturn (*delete_msg)(CoreObject *o, UserRequest *ur);\n\n    /* SMS 'get sca' function reference */\n    TReturn (*get_sca)(CoreObject *o, UserRequest *ur);\n\n    /* SMS 'set sca' function reference */\n    TReturn (*set_sca)(CoreObject *o, UserRequest *ur);\n\n    /* SMS 'get sms params' function reference */\n    TReturn (*get_sms_params)(CoreObject *o, UserRequest *ur);\n\n    /* SMS 'set sms params' function reference */\n    TReturn (*set_sms_params)(CoreObject *o, UserRequest *ur);\n};\n```\n\n### Network Service Operations\n\nTo provide network services, the following functions must be implemented:\n\n```cpp\nstruct tcore_network_operations {\n    /* Network 'search' function reference */\n    TReturn (*search)(CoreObject *o, UserRequest *ur);\n\n    /* Network 'set plmn selection mode' function reference */\n    TReturn (*set_plmn_selection_mode)(CoreObject *o, UserRequest *ur);\n\n    /* Network 'get plmn selection mode'' function reference */\n    TReturn (*get_plmn_selection_mode)(CoreObject *o, UserRequest *ur);\n\n    /* Network 'set service domain' function reference */\n    TReturn (*set_service_domain)(CoreObject *o, UserRequest *ur);\n\n    /* Network 'get service domain' function reference */\n    TReturn (*get_service_domain)(CoreObject *o, UserRequest *ur);\n\n    /* Network 'set band' function reference */\n    TReturn (*set_band)(CoreObject *o, UserRequest *ur);\n\n    /* Network 'get band' function reference */\n    TReturn (*get_band)(CoreObject *o, UserRequest *ur);\n};\n```\n\n### HAL Operations\n\nTo provide HAL operations, the following functions must be implemented:\n\n```cpp\nstruct tcore_hal_operations {\n    /* HAL 'power' function reference */\n    TReturn (*power)(TcoreHal *hal, gboolean flag);\n\n    /* HAL 'send' function reference */\n    TReturn (*send)(TcoreHal *hal, unsigned int data_len, void *data);\n\n    /* Network 'set up network interface' function reference */\n    TReturn (*setup_netif)(CoreObject *co,\n                           TcoreHalSetupNetifCallback func, void *user_data,\n                           unsigned int cid, gboolean enable);\n};\n```\n\nFor sample implementations of the modem and modem interface plugins, see [Sample Modem Interface Plugin Implementation](#sample-modem-interface-plugin-implementation).\n\n## Configuration\n\nTelephony plugins must be installed in the following folders:\n\n- Modem plugins: `%{_libdir}/telephony/plugins/modems/`\n- Other plugins: `%{_libdir}/telephony/plugins/`\n\n## References\n\nTizen source site: [http://review.tizen.org/git/](http://review.tizen.org/git/)\n\nTelephony packages:\n- Telephony daemon\n- Telephony core library\n- TAPI\n- Telephony API for a third party application\n- Communicator (DBUS_TAPI)\n- Free style plugin (indicator)\n- Free style plugin (packetservice)\n- Free style plugin (nitz)\n- Free style plugin (Database)\n- Free style plugin (VCONF)\n- Modem plugin (device)\n- Modem interface plugin (device)\n- Modem plugin (emulator)\n- Modem interface plugin (emulator)\n\n## Sample Modem Interface Plugin Implementation\n\n```cpp\n/* HAL Operations */\nstatic struct tcore_hal_operations hal_ops = {\n    .power = hal_power,\n    .send = hal_send,\n    .setup_netif = hal_setup_netif,\n};\n\nstatic\ngboolean on_load() {\n    dbg(\" Load!!!\");\n\n    return TRUE;\n}\n\nstatic\ngboolean on_init(TcorePlugin *plugin) {\n    TcoreHal *hal;\n    PluginData *user_data;\n    struct custom_data *data;\n\n    dbg(\" Init!!!\");\n\n    if (plugin == NULL) {\n        err(\" PLug-in is NULL\");\n\n        return FALSE;\n    }\n\n    /* User data for Modem Interface plugin */\n    user_data = g_try_new0(PluginData, 1);\n    if (user_data == NULL) {\n        err(\" Failed to allocate memory for Plugin data\");\n\n        return FALSE;\n    }\n\n    /* Register to server */\n    user_data->modem = tcore_server_register_modem(tcore_plugin_ref_server(plugin), plugin);\n    if (user_data->modem == NULL) {\n        err(\" Registration Failed\");\n        g_free(user_data);\n\n        return FALSE;\n    }\n    dbg(\" Registered from Server\");\n\n\n    data = g_try_new0(struct custom_data, 1);\n    if (data == NULL) {\n        err(\" Failed to allocate memory for Custom data\");\n\n        /* Unregister from server */\n        tcore_server_unregister_modem(tcore_plugin_ref_server(plugin), user_data->modem);\n\n        /* Free plugin data */\n        g_free(user_data);\n\n        return FALSE;\n    }\n\n    /* Open DPRAM device */\n    data->vdpram_fd = vdpram_open();\n    if (data->vdpram_fd modem);\n\n        /* Free plugin data */\n        g_free(user_data);\n\n        return FALSE;\n    }\n    /* Create and initialize HAL */\n    hal = tcore_hal_new(plugin, \"vmodem\", &hal_ops, TCORE_HAL_MODE_AT);\n    if (hal == NULL) {\n        /* Close VDPRAM device */\n        vdpram_close(data->vdpram_fd);\n\n        /* Free custom data */\n        g_free(data);\n\n        /* Unregister from server */\n        tcore_server_unregister_modem(tcore_plugin_ref_server(plugin), user_data->modem);\n\n        /* Free Plugin data */\n        g_free(user_data);\n\n        return FALSE;\n    }\n    user_data->hal = hal;\n\n    /* Link custom data to HAL user data */\n    tcore_hal_link_user_data(hal, data);\n\n    /* Set HAL as Modem Interface plugin's user data */\n    tcore_plugin_link_user_data(plugin, user_data);\n\n    /* Register to Watch list */\n    data->watch_id_vdpram = __register_gio_watch(hal, data->vdpram_fd, on_recv_vdpram_message);\n    dbg(\" fd: [%d] Watch ID: [%d]\", data->vdpram_fd, data->watch_id_vdpram);\n\n    /* Power ON VDPRAM device */\n    if (_modem_power(hal, TRUE) == TCORE_RETURN_SUCCESS) {\n        dbg(\" Power ON - [SUCCESS]\");\n    } else {\n        err(\" Power ON - [FAIL]\");\n        goto EXIT;\n    }\n\n    /* Check CP Power ON */\n    g_timeout_add_full(G_PRIORITY_HIGH, SERVER_INIT_WAIT_TIMEOUT, __load_modem_plugin, hal, 0);\n\n    dbg(\"[VMMODEM] Exit\");\n\n    return TRUE;\n\nEXIT:\n    /* Deregister from Watch list */\n    __deregister_gio_watch(data->watch_id_vdpram);\n\n    /* Free HAL */\n    tcore_hal_free(hal);\n\n    /* Close VDPRAM device */\n    vdpram_close(data->vdpram_fd);\n\n    /* Free custom data */\n    g_free(data);\n\n    /* Unregister from Server */\n    tcore_server_unregister_modem(tcore_plugin_ref_server(plugin), user_data->modem);\n\n    /* Free plugin data */\n    g_free(user_data);\n\n    return FALSE;\n}\n\nstatic void\non_unload(TcorePlugin *plugin) {\n    TcoreHal *hal;\n    struct custom_data *data;\n    PluginData *user_data;\n\n    dbg(\" Unload!!!\");\n\n    if (plugin == NULL)\n        return;\n\n    user_data = tcore_plugin_ref_user_data(plugin);\n    if (user_data == NULL)\n        return;\n\n    hal = user_data->hal;\n\n    data = tcore_hal_ref_user_data(hal);\n    if (data == NULL)\n        return;\n\n    /* Deregister from Watch list */\n    __deregister_gio_watch(data->watch_id_vdpram);\n    dbg(\" Deregistered Watch ID\");\n\n    /* Free HAL */\n    tcore_hal_free(hal);\n    dbg(\" Freed HAL\");\n\n    /* Close VDPRAM device */\n    vdpram_close(data->vdpram_fd);\n    dbg(\" Closed VDPRAM device\");\n\n    /* Free custom data */\n    g_free(data);\n\n    tcore_server_unregister_modem(tcore_plugin_ref_server(plugin), user_data->modem);\n    dbg(\" Unregistered from Server\");\n\n    dbg(\" Unloaded MODEM\");\n    g_free(user_data);\n}\n\n/* VMODEM Descriptor Structure */\nEXPORT_API struct tcore_plugin_define_desc plugin_define_desc = {\n    .name = \"VMODEM\",\n    .priority = TCORE_PLUGIN_PRIORITY_HIGH,\n    .version = 1,\n    .load = on_load,\n    .init = on_init,\n    .unload = on_unload\n};\n```\n\n### Sample Modem Plugin Implementation\n\n```cpp\nstatic\ngboolean on_load() {\n    dbg(\"LOAD!!!\");\n\n    return TRUE;\n}\n\nstatic\ngboolean on_init(TcorePlugin *p) {\n    TcoreHal *h;\n\n    dbg(\"INIT!!!\");\n\n    if (!p) {\n        err(\"Plug-in is NULL\");\n\n        return FALSE;\n    }\n\n    h = tcore_server_find_hal(tcore_plugin_ref_server(p), \"vmodem\");\n    if (!h) {\n        err(\"HAL is NULL\");\n\n        return FALSE;\n    }\n\n    tcore_hal_add_send_hook(h, on_hal_send, p);\n    tcore_hal_add_recv_callback(h, on_hal_recv, p);\n\n    /* Initialize modules */\n    s_modem_init(p, h);\n    s_network_init(p, h);\n    s_sim_init(p, h);\n    s_ps_init(p, h);\n    s_call_init(p, h);\n    s_ss_init(p, h);\n    s_sms_init(p, h);\n    tcore_hal_set_power(h, TRUE);\n\n    /* Send \"CPAS\" command to invoke POWER UP NOTI */\n    s_modem_send_poweron(p);\n\n    dbg(\"Init - Successful\");\n\n    return TRUE;\n}\n\nstatic void\non_unload(TcorePlugin *p) {\n    TcoreHal *h;\n\n    dbg(\"UNLOAD!!!\");\n\n    if (!p) {\n        err(\"Plug-in is NULL\");\n\n        return;\n    }\n\n    h = tcore_server_find_hal(tcore_plugin_ref_server(p), \"vmodem\");\n    if (h) {\n        tcore_hal_remove_send_hook(h, on_hal_send);\n        tcore_hal_remove_recv_callback(h, on_hal_recv);\n    }\n\n    /* Deinitialize the modules */\n    s_modem_exit(p);\n    s_network_exit(p);\n    s_sim_exit(p);\n    s_ps_exit(p);\n    s_call_exit(p);\n    s_ss_exit(p);\n    s_sms_exit(p);\n}\n\n/* ATMODEM plug-in descriptor */\nstruct tcore_plugin_define_desc plugin_define_desc = {\n    .name = \"ATMODEM\",\n    .priority = TCORE_PLUGIN_PRIORITY_MID,\n    .version = 1,\n    .load = on_load,\n    .init = on_init,\n    .unload = on_unload\n};\n```\n\n### Workflow\n\n- Initialization sequence\n   1. The server loads the modem interface plugin.\n\n   2. The modem interface plugin registers to the server.\n\n   3. The server enumerates the modem interface plugin.\n\n   4. The physical HAL is created.\n\n   5. The modem interface plugin queries the modem state.\n\n   6. If the modem is online, the CMUX (internal) channels are established.\n\n   7. A logical HAL is created for each CMUX channel and assigned to a core object type. These are updated to the mapping table.\n\n   8. The physical HAL mode is changed to `TRANSPARENT`, which disables the queue.\n\n   9. The modem interface plugin requests the server to load the modem plugin corresponding to its architecture.\n\n   10. The server loads the modem plugin.\n\n   11. The modem plugin initializes the sub-modules and creates the core objects, based on the core object types defined in the mapping table by the modem interface plugin.\n\n   12. The modem plugin notifies the server of the `PLUGIN_ADDED` event.\n\n   13. The modem notifies the communicator of the `PLUGIN_ADDED` event.\n\n   14. The communicator creates interfaces for the sub-modules present, based on the core objects created.\n\n   **Figure: Initialization sequence**\n\n   ![Telephony11.png](media/telephony11.png)\n\n\n\n- Request processing sequence\n   1. The application request is sent to the communicator through TAPI.\n\n   2. The communicator creates a user request based on the incoming request.\n\n   3. The user request is dispatched to the communicator.\n\n   4. The communicator dispatches the user request to the server.\n\n   5. The server finds the plugin based on the modem name.\n\n   6. The server extracts the core object type from the plugin's core objects list, based on the request command.\n\n   7. The server dispatches the user request to the core object.\n\n   8. The core object dispatches the user request to dispatch a function based on the request command.\n\n   9. A pending request is formed, added to the queue, and sent to the logical HAL assigned to the core object.\n\n   10. The logical HAL dispatches the request data to its dedicated CMUX channel.\n\n   11. CMUX encodes the request data and dispatches it to the physical HAL.\n\n   12. The physical HAL sends the request data to the modem.\n\n   **Figure: Request processing sequence**\n\n   ![Request processing sequence](media/telephony11.png)\n\n\n- Response processing sequence\n   1. The modem sends response data to the physical HAL.\n\n   2. The physical HAL dispatches the response data to CMUX.\n\n   3. CMUX decodes the received response data and dispatches it to the corresponding logical HAL, based on the CMUX channel.\n\n   4. The logical HAL dispatches the decoded response data to the corresponding core object.\n\n   5. The core object processes the received response data and extracts the user request from the pending queue. It sends the response data corresponding to the user request.\n\n   6. The user request extracts the communicator.\n\n   7. The received response data is sent to the corresponding communicator.\n\n   8. The communicator sends the response data to TAPI, which communicates it to the application.\n\n   **Figure: Response processing sequence**\n\n   ![Response processing sequence](media/telephony12.png)\n\n\n- Indication processing sequence\n   1. The modem sends notification data to the physical HAL.\n\n   2. The physical HAL dispatches the notification data to CMUX.\n\n   3. CMUX decodes the received notification data and dispatches it to the corresponding logical HAL, based on the CMUX channel registered for the notification.\n\n   4. The logical HAL dispatches the decoded notification data to the corresponding core object registered for the notification.\n\n   5. The core object processes the received notification data and dispatches to the server.\n\n   6. The server dispatches the notification data to the corresponding communicator.\n\n   7. The communicator sends the notification data to TAPI, which communicates it to the application.\n\n   **Figure: Indication processing sequence**\n\n   ![Telephony13.png](media/telephony13.png)"
					}
					
				
			
		
			
				
					,
					
					"platform-porting-telephony": {
						"id": "platform-porting-telephony",
						"title": "Telephony",
						"categories": "",
						"url": " platform/porting/telephony/",
						"content": "# Telephony\n\nThis guide describes the Telephony architecture in detail, including the various telephony components and the workflow in the Telephony framework. It also provides porting guidelines for vendors to facilitate OAL interface development for their hardware.\n\nThe Tizen Telephony features include:\n- Telecommunication functionalities, such as call, SS, SMS, SIM, network, and packet service\n- Plug-in architecture\n\n\nTo understand the telephony implementation, you must be familiar with the following definitions:\n\n- Core object\n  - Bundle of functions and supporting database information which processes requests, responses, and notifications designated to a specific module, such as call, SS, SIM, and network.\n  - Core objects form the executable component of a Telephony module (call, SS, SIM, network)\n- Hardware Abstraction Layer (HAL)\n  - The HAL ensures that similar functionality is provided by various hardware (modems) from the same modem vendor.\n  - All hardware-specific changes are controlled and processed by HALs.\n  - Depending on the modem chipset, a modem driver can be required.\n- Hooks\n  - Hooks provide a mechanism to tap the requests, responses, and notifications of other Telephony modules.\n  - Hooking is a transparent mechanism and does not affect the normal processing of requests, responses, and notifications.\n\n## Tizen Telephony Architecture\n\nTizen Telephony supports plugin architecture, which provides the flexibility to include various predefined plugins in the system with little modification.\n\n**Figure: Telephony architecture**\n\n![Telephony architecture](media/telephony-arch.png)\n\nThe 3 major components of Tizen Telephony are the libraries, plugins, and server.\n\n## Telephony Libraries\n\nThere are 2 main telephony libraries:\n\n- Telephony API (TAPI) library\n\n  The TAPI library (or simply TAPI) is a standardized interface, provided as the `libtapi` package, for applications to interact with Tizen Telephony. TAPI executes in the application's context, and it provides synchronous and asynchronous APIs. The following figure shows the `libtapi` components.\n\n  **Figure: libtapi components**\n\n  ![libtapi components](media/libtapi.png)\n\n  Applications can interface to telephony features, such as call, SMS, and network, through the respective module APIs exposed in the `libtapi` library. Telephony also provides an additional library, `capi-telephony`, for third-party applications.\n\n- Core Telephony library\n\n  The Core Telephony library, provided as the `libtcore` package, provides an API framework to interwork with Tizen Telephony. The following figure shows the `libtcore` components.\n\n  **Figure: libtcore components**\n\n  ![libtcore components](media/telephony03.png)\n\n  With `libtcore`, you can:\n\n  - Create, destroy, and maintain various server components, such as the server, communicators, HALs, core objects, and plugins.\n  - Maintain storage, queue mechanism, and general utilities.\n  - Support CMUX (creation/destruction/processing).\n  - Parse AT.\n\n## Telephony Plugins\n\nThere are 4 kinds of plugins:\n\n- **Communicator plugins** interface TAPI and the telephony server. For example, the DBUS communicator (`DBUS_TAPI`) is provided by default.\n- **Modem plugins** are core functional units providing the telephony functionality. They maintain and manage the telephony states and related databases.\n- **Modem interface plugins** interface the telephony server to the communication processor. They are hardware-specific plugins which define hardware capabilities and usage. Modem interface plugins are also called HALs.\n- **Free style plugins** provide functionality independent of communication processor hardware. Examples of free style plugins are packetservice, storage, and indicator.\n\nThe following figure provides an overview of the Telephony plugin types.\n\n**Figure: Telephony plugins**\n\n![Telephony plugins](media/telephony08.png)\n\n## Telephony Server\n\nTizen Telephony runs as a Telephony server daemon, `telephony-daemon`.\n\nThe Telephony server executes as a `g-main` loop from the `glib` library.\n\n**Figure: Telephony server**\n\n![Telephony server](media/telephony09.png)\n\n## Porting the OAL Interface\n\nOEM vendors can port available plugins within Telephony as needed to support specific hardware. It is not mandatory that all plugins are ported.\n\nThis section provides guidance to OEM vendors to develop various Telephony plugins.\n\n### Plugin Descriptor\n\nEach telephony plugin must provide a descriptor structure:\n\n```cpp\nstruct tcore_plugin_define_desc {\n    /* Name of the plugin */\n    gchar *name;\n\n    /* Initializing priority of the plugin */\n    enum tcore_plugin_priority priority;\n\n    /* Plugin version */\n    int version;\n\n    /* Plugin 'load' function reference */\n    gboolean(*load)();\n\n    /* Plugin 'init' function reference */\n    gboolean(*init)(TcorePlugin *);\n\n    /* Plugin 'unload' function reference */\n    void (*unload)(TcorePlugin *);\n};\n```\n\nThe plugin descriptor structure must be named as `plugin_define_desc`. The server obtains the address of this symbol to give control to the plugin to execute its defined functionality.\n\nThe initialization order among various Telephony plugins is based on each plugin's priority.\n\nOEMs need to specifically implement the modem and modem interface plugins to support their hardware.\n\n### Call Service Operations\n\nTo provide call services, the following functions must be implemented:\n\n```cpp\nstruct tcore_call_operations {\n    /* Call 'dial' function reference */\n    TReturn (*dial)(CoreObject *o, UserRequest *ur);\n\n    /* Call 'answer' function reference */\n    TReturn (*answer)(CoreObject *o, UserRequest *ur);\n\n    /* Call 'end' function reference */\n    TReturn (*end)(CoreObject *o, UserRequest *ur);\n\n    /* Call 'hold' function reference */\n    TReturn (*hold)(CoreObject *o, UserRequest *ur);\n\n    /* Call 'active' function reference */\n    TReturn (*active)(CoreObject *o, UserRequest *ur);\n\n    /* Call 'swap' function reference */\n    TReturn (*swap)(CoreObject *o, UserRequest *ur);\n\n    /* Call 'join' function reference */\n    TReturn (*join)(CoreObject *o, UserRequest *ur);\n\n    /* Call 'split' function reference */\n    TReturn (*split)(CoreObject *o, UserRequest *ur);\n};\n```\n\n### SMS Service Operations\n\nTo provide SMS services, the following functions must be implemented:\n\n```cpp\nstruct tcore_sms_operations {\n    /* For UMTS, SMS 'send' function reference */\n    TReturn (*send_umts_msg)(CoreObject *o, UserRequest *ur);\n\n    /* For CDMA, SMS 'read' function reference */\n    TReturn (*send_cdma_msg)(CoreObject *o, UserRequest *ur);\n\n    /* SMS 'read' function reference */\n    TReturn (*read_msg)(CoreObject *o, UserRequest *ur);\n\n    /* SMS 'save' function reference */\n    TReturn (*save_msg)(CoreObject *o, UserRequest *ur);\n\n    /* SMS 'delete' function reference */\n    TReturn (*delete_msg)(CoreObject *o, UserRequest *ur);\n\n    /* SMS 'get sca' function reference */\n    TReturn (*get_sca)(CoreObject *o, UserRequest *ur);\n\n    /* SMS 'set sca' function reference */\n    TReturn (*set_sca)(CoreObject *o, UserRequest *ur);\n\n    /* SMS 'get sms params' function reference */\n    TReturn (*get_sms_params)(CoreObject *o, UserRequest *ur);\n\n    /* SMS 'set sms params' function reference */\n    TReturn (*set_sms_params)(CoreObject *o, UserRequest *ur);\n};\n```\n\n### Network Service Operations\n\nTo provide network services, the following functions must be implemented:\n\n```cpp\nstruct tcore_network_operations {\n    /* Network 'search' function reference */\n    TReturn (*search)(CoreObject *o, UserRequest *ur);\n\n    /* Network 'set plmn selection mode' function reference */\n    TReturn (*set_plmn_selection_mode)(CoreObject *o, UserRequest *ur);\n\n    /* Network 'get plmn selection mode'' function reference */\n    TReturn (*get_plmn_selection_mode)(CoreObject *o, UserRequest *ur);\n\n    /* Network 'set service domain' function reference */\n    TReturn (*set_service_domain)(CoreObject *o, UserRequest *ur);\n\n    /* Network 'get service domain' function reference */\n    TReturn (*get_service_domain)(CoreObject *o, UserRequest *ur);\n\n    /* Network 'set band' function reference */\n    TReturn (*set_band)(CoreObject *o, UserRequest *ur);\n\n    /* Network 'get band' function reference */\n    TReturn (*get_band)(CoreObject *o, UserRequest *ur);\n};\n```\n\n### HAL Operations\n\nTo provide HAL operations, the following functions must be implemented:\n\n```cpp\nstruct tcore_hal_operations {\n    /* HAL 'power' function reference */\n    TReturn (*power)(TcoreHal *hal, gboolean flag);\n\n    /* HAL 'send' function reference */\n    TReturn (*send)(TcoreHal *hal, unsigned int data_len, void *data);\n\n    /* Network 'set up network interface' function reference */\n    TReturn (*setup_netif)(CoreObject *co,\n                           TcoreHalSetupNetifCallback func, void *user_data,\n                           unsigned int cid, gboolean enable);\n};\n```\n\nFor sample implementations of the modem and modem interface plugins, see [Sample Modem Interface Plugin Implementation](#sample-modem-interface-plugin-implementation).\n\n## Configuration\n\nTelephony plugins must be installed in the following folders:\n\n- Modem plugins: `%{_libdir}/telephony/plugins/modems/`\n- Other plugins: `%{_libdir}/telephony/plugins/`\n\n## References\n\nTizen source site: [http://review.tizen.org/git/](http://review.tizen.org/git/)\n\nTelephony packages:\n- Telephony daemon\n- Telephony core library\n- TAPI\n- Telephony API for a third party application\n- Communicator (DBUS_TAPI)\n- Free style plugin (indicator)\n- Free style plugin (packetservice)\n- Free style plugin (nitz)\n- Free style plugin (Database)\n- Free style plugin (VCONF)\n- Modem plugin (device)\n- Modem interface plugin (device)\n- Modem plugin (emulator)\n- Modem interface plugin (emulator)\n\n## Sample Modem Interface Plugin Implementation\n\n```cpp\n/* HAL Operations */\nstatic struct tcore_hal_operations hal_ops = {\n    .power = hal_power,\n    .send = hal_send,\n    .setup_netif = hal_setup_netif,\n};\n\nstatic\ngboolean on_load() {\n    dbg(\" Load!!!\");\n\n    return TRUE;\n}\n\nstatic\ngboolean on_init(TcorePlugin *plugin) {\n    TcoreHal *hal;\n    PluginData *user_data;\n    struct custom_data *data;\n\n    dbg(\" Init!!!\");\n\n    if (plugin == NULL) {\n        err(\" PLug-in is NULL\");\n\n        return FALSE;\n    }\n\n    /* User data for Modem Interface plugin */\n    user_data = g_try_new0(PluginData, 1);\n    if (user_data == NULL) {\n        err(\" Failed to allocate memory for Plugin data\");\n\n        return FALSE;\n    }\n\n    /* Register to server */\n    user_data->modem = tcore_server_register_modem(tcore_plugin_ref_server(plugin), plugin);\n    if (user_data->modem == NULL) {\n        err(\" Registration Failed\");\n        g_free(user_data);\n\n        return FALSE;\n    }\n    dbg(\" Registered from Server\");\n\n\n    data = g_try_new0(struct custom_data, 1);\n    if (data == NULL) {\n        err(\" Failed to allocate memory for Custom data\");\n\n        /* Unregister from server */\n        tcore_server_unregister_modem(tcore_plugin_ref_server(plugin), user_data->modem);\n\n        /* Free plugin data */\n        g_free(user_data);\n\n        return FALSE;\n    }\n\n    /* Open DPRAM device */\n    data->vdpram_fd = vdpram_open();\n    if (data->vdpram_fd modem);\n\n        /* Free plugin data */\n        g_free(user_data);\n\n        return FALSE;\n    }\n    /* Create and initialize HAL */\n    hal = tcore_hal_new(plugin, \"vmodem\", &hal_ops, TCORE_HAL_MODE_AT);\n    if (hal == NULL) {\n        /* Close VDPRAM device */\n        vdpram_close(data->vdpram_fd);\n\n        /* Free custom data */\n        g_free(data);\n\n        /* Unregister from server */\n        tcore_server_unregister_modem(tcore_plugin_ref_server(plugin), user_data->modem);\n\n        /* Free Plugin data */\n        g_free(user_data);\n\n        return FALSE;\n    }\n    user_data->hal = hal;\n\n    /* Link custom data to HAL user data */\n    tcore_hal_link_user_data(hal, data);\n\n    /* Set HAL as Modem Interface plugin's user data */\n    tcore_plugin_link_user_data(plugin, user_data);\n\n    /* Register to Watch list */\n    data->watch_id_vdpram = __register_gio_watch(hal, data->vdpram_fd, on_recv_vdpram_message);\n    dbg(\" fd: [%d] Watch ID: [%d]\", data->vdpram_fd, data->watch_id_vdpram);\n\n    /* Power ON VDPRAM device */\n    if (_modem_power(hal, TRUE) == TCORE_RETURN_SUCCESS) {\n        dbg(\" Power ON - [SUCCESS]\");\n    } else {\n        err(\" Power ON - [FAIL]\");\n        goto EXIT;\n    }\n\n    /* Check CP Power ON */\n    g_timeout_add_full(G_PRIORITY_HIGH, SERVER_INIT_WAIT_TIMEOUT, __load_modem_plugin, hal, 0);\n\n    dbg(\"[VMMODEM] Exit\");\n\n    return TRUE;\n\nEXIT:\n    /* Deregister from Watch list */\n    __deregister_gio_watch(data->watch_id_vdpram);\n\n    /* Free HAL */\n    tcore_hal_free(hal);\n\n    /* Close VDPRAM device */\n    vdpram_close(data->vdpram_fd);\n\n    /* Free custom data */\n    g_free(data);\n\n    /* Unregister from Server */\n    tcore_server_unregister_modem(tcore_plugin_ref_server(plugin), user_data->modem);\n\n    /* Free plugin data */\n    g_free(user_data);\n\n    return FALSE;\n}\n\nstatic void\non_unload(TcorePlugin *plugin) {\n    TcoreHal *hal;\n    struct custom_data *data;\n    PluginData *user_data;\n\n    dbg(\" Unload!!!\");\n\n    if (plugin == NULL)\n        return;\n\n    user_data = tcore_plugin_ref_user_data(plugin);\n    if (user_data == NULL)\n        return;\n\n    hal = user_data->hal;\n\n    data = tcore_hal_ref_user_data(hal);\n    if (data == NULL)\n        return;\n\n    /* Deregister from Watch list */\n    __deregister_gio_watch(data->watch_id_vdpram);\n    dbg(\" Deregistered Watch ID\");\n\n    /* Free HAL */\n    tcore_hal_free(hal);\n    dbg(\" Freed HAL\");\n\n    /* Close VDPRAM device */\n    vdpram_close(data->vdpram_fd);\n    dbg(\" Closed VDPRAM device\");\n\n    /* Free custom data */\n    g_free(data);\n\n    tcore_server_unregister_modem(tcore_plugin_ref_server(plugin), user_data->modem);\n    dbg(\" Unregistered from Server\");\n\n    dbg(\" Unloaded MODEM\");\n    g_free(user_data);\n}\n\n/* VMODEM Descriptor Structure */\nEXPORT_API struct tcore_plugin_define_desc plugin_define_desc = {\n    .name = \"VMODEM\",\n    .priority = TCORE_PLUGIN_PRIORITY_HIGH,\n    .version = 1,\n    .load = on_load,\n    .init = on_init,\n    .unload = on_unload\n};\n```\n\n### Sample Modem Plugin Implementation\n\n```cpp\nstatic\ngboolean on_load() {\n    dbg(\"LOAD!!!\");\n\n    return TRUE;\n}\n\nstatic\ngboolean on_init(TcorePlugin *p) {\n    TcoreHal *h;\n\n    dbg(\"INIT!!!\");\n\n    if (!p) {\n        err(\"Plug-in is NULL\");\n\n        return FALSE;\n    }\n\n    h = tcore_server_find_hal(tcore_plugin_ref_server(p), \"vmodem\");\n    if (!h) {\n        err(\"HAL is NULL\");\n\n        return FALSE;\n    }\n\n    tcore_hal_add_send_hook(h, on_hal_send, p);\n    tcore_hal_add_recv_callback(h, on_hal_recv, p);\n\n    /* Initialize modules */\n    s_modem_init(p, h);\n    s_network_init(p, h);\n    s_sim_init(p, h);\n    s_ps_init(p, h);\n    s_call_init(p, h);\n    s_ss_init(p, h);\n    s_sms_init(p, h);\n    tcore_hal_set_power(h, TRUE);\n\n    /* Send \"CPAS\" command to invoke POWER UP NOTI */\n    s_modem_send_poweron(p);\n\n    dbg(\"Init - Successful\");\n\n    return TRUE;\n}\n\nstatic void\non_unload(TcorePlugin *p) {\n    TcoreHal *h;\n\n    dbg(\"UNLOAD!!!\");\n\n    if (!p) {\n        err(\"Plug-in is NULL\");\n\n        return;\n    }\n\n    h = tcore_server_find_hal(tcore_plugin_ref_server(p), \"vmodem\");\n    if (h) {\n        tcore_hal_remove_send_hook(h, on_hal_send);\n        tcore_hal_remove_recv_callback(h, on_hal_recv);\n    }\n\n    /* Deinitialize the modules */\n    s_modem_exit(p);\n    s_network_exit(p);\n    s_sim_exit(p);\n    s_ps_exit(p);\n    s_call_exit(p);\n    s_ss_exit(p);\n    s_sms_exit(p);\n}\n\n/* ATMODEM plug-in descriptor */\nstruct tcore_plugin_define_desc plugin_define_desc = {\n    .name = \"ATMODEM\",\n    .priority = TCORE_PLUGIN_PRIORITY_MID,\n    .version = 1,\n    .load = on_load,\n    .init = on_init,\n    .unload = on_unload\n};\n```\n\n### Workflow\n\n- Initialization sequence\n   1. The server loads the modem interface plugin.\n\n   2. The modem interface plugin registers to the server.\n\n   3. The server enumerates the modem interface plugin.\n\n   4. The physical HAL is created.\n\n   5. The modem interface plugin queries the modem state.\n\n   6. If the modem is online, the CMUX (internal) channels are established.\n\n   7. A logical HAL is created for each CMUX channel and assigned to a core object type. These are updated to the mapping table.\n\n   8. The physical HAL mode is changed to `TRANSPARENT`, which disables the queue.\n\n   9. The modem interface plugin requests the server to load the modem plugin corresponding to its architecture.\n\n   10. The server loads the modem plugin.\n\n   11. The modem plugin initializes the sub-modules and creates the core objects, based on the core object types defined in the mapping table by the modem interface plugin.\n\n   12. The modem plugin notifies the server of the `PLUGIN_ADDED` event.\n\n   13. The modem notifies the communicator of the `PLUGIN_ADDED` event.\n\n   14. The communicator creates interfaces for the sub-modules present, based on the core objects created.\n\n   **Figure: Initialization sequence**\n\n   ![Telephony11.png](media/telephony11.png)\n\n\n\n- Request processing sequence\n   1. The application request is sent to the communicator through TAPI.\n\n   2. The communicator creates a user request based on the incoming request.\n\n   3. The user request is dispatched to the communicator.\n\n   4. The communicator dispatches the user request to the server.\n\n   5. The server finds the plugin based on the modem name.\n\n   6. The server extracts the core object type from the plugin's core objects list, based on the request command.\n\n   7. The server dispatches the user request to the core object.\n\n   8. The core object dispatches the user request to dispatch a function based on the request command.\n\n   9. A pending request is formed, added to the queue, and sent to the logical HAL assigned to the core object.\n\n   10. The logical HAL dispatches the request data to its dedicated CMUX channel.\n\n   11. CMUX encodes the request data and dispatches it to the physical HAL.\n\n   12. The physical HAL sends the request data to the modem.\n\n   **Figure: Request processing sequence**\n\n   ![Request processing sequence](media/telephony11.png)\n\n\n- Response processing sequence\n   1. The modem sends response data to the physical HAL.\n\n   2. The physical HAL dispatches the response data to CMUX.\n\n   3. CMUX decodes the received response data and dispatches it to the corresponding logical HAL, based on the CMUX channel.\n\n   4. The logical HAL dispatches the decoded response data to the corresponding core object.\n\n   5. The core object processes the received response data and extracts the user request from the pending queue. It sends the response data corresponding to the user request.\n\n   6. The user request extracts the communicator.\n\n   7. The received response data is sent to the corresponding communicator.\n\n   8. The communicator sends the response data to TAPI, which communicates it to the application.\n\n   **Figure: Response processing sequence**\n\n   ![Response processing sequence](media/telephony12.png)\n\n\n- Indication processing sequence\n   1. The modem sends notification data to the physical HAL.\n\n   2. The physical HAL dispatches the notification data to CMUX.\n\n   3. CMUX decodes the received notification data and dispatches it to the corresponding logical HAL, based on the CMUX channel registered for the notification.\n\n   4. The logical HAL dispatches the decoded notification data to the corresponding core object registered for the notification.\n\n   5. The core object processes the received notification data and dispatches to the server.\n\n   6. The server dispatches the notification data to the corresponding communicator.\n\n   7. The communicator sends the notification data to TAPI, which communicates it to the application.\n\n   **Figure: Indication processing sequence**\n\n   ![Telephony13.png](media/telephony13.png)"
					}
					
				
			
		
			
				
					,
					
					"iot-porting-telephony": {
						"id": "iot-porting-telephony",
						"title": "Telephony",
						"categories": "",
						"url": " iot/porting/telephony/",
						"content": "# Telephony\n\nThis guide describes the Telephony architecture in detail, including the various telephony components and the workflow in the Telephony framework. It also provides porting guidelines for vendors to facilitate OAL interface development for their hardware.\n\nThe Tizen Telephony features include:\n- Telecommunication functionalities, such as call, SS, SMS, SIM, network, and packet service\n- Plug-in architecture\n\n\nTo understand the telephony implementation, you must be familiar with the following definitions:\n\n- Core object\n  - Bundle of functions and supporting database information which processes requests, responses, and notifications designated to a specific module, such as call, SS, SIM, and network.\n  - Core objects form the executable component of a Telephony module (call, SS, SIM, network)\n- Hardware Abstraction Layer (HAL)\n  - The HAL ensures that similar functionality is provided by various hardware (modems) from the same modem vendor.\n  - All hardware-specific changes are controlled and processed by HALs.\n  - Depending on the modem chipset, a modem driver can be required.\n- Hooks\n  - Hooks provide a mechanism to tap the requests, responses, and notifications of other Telephony modules.\n  - Hooking is a transparent mechanism and does not affect the normal processing of requests, responses, and notifications.\n\n## Tizen Telephony Architecture\n\nTizen Telephony supports plugin architecture, which provides the flexibility to include various predefined plugins in the system with little modification.\n\n**Figure: Telephony architecture**\n\n![Telephony architecture](media/telephony-arch.png)\n\nThe 3 major components of Tizen Telephony are the libraries, plugins, and server.\n\n## Telephony Libraries\n\nThere are 2 main telephony libraries:\n\n- Telephony API (TAPI) library\n\n  The TAPI library (or simply TAPI) is a standardized interface, provided as the `libtapi` package, for applications to interact with Tizen Telephony. TAPI executes in the application's context, and it provides synchronous and asynchronous APIs. The following figure shows the `libtapi` components.\n\n  **Figure: libtapi components**\n\n  ![libtapi components](media/libtapi.png)\n\n  Applications can interface to telephony features, such as call, SMS, and network, through the respective module APIs exposed in the `libtapi` library. Telephony also provides an additional library, `capi-telephony`, for third-party applications.\n\n- Core Telephony library\n\n  The Core Telephony library, provided as the `libtcore` package, provides an API framework to interwork with Tizen Telephony. The following figure shows the `libtcore` components.\n\n  **Figure: libtcore components**\n\n  ![libtcore components](media/telephony03.png)\n\n  With `libtcore`, you can:\n\n  - Create, destroy, and maintain various server components, such as the server, communicators, HALs, core objects, and plugins.\n  - Maintain storage, queue mechanism, and general utilities.\n  - Support CMUX (creation/destruction/processing).\n  - Parse AT.\n\n## Telephony Plugins\n\nThere are 4 kinds of plugins:\n\n- **Communicator plugins** interface TAPI and the telephony server. For example, the DBUS communicator (`DBUS_TAPI`) is provided by default.\n- **Modem plugins** are core functional units providing the telephony functionality. They maintain and manage the telephony states and related databases.\n- **Modem interface plugins** interface the telephony server to the communication processor. They are hardware-specific plugins which define hardware capabilities and usage. Modem interface plugins are also called HALs.\n- **Free style plugins** provide functionality independent of communication processor hardware. Examples of free style plugins are packetservice, storage, and indicator.\n\nThe following figure provides an overview of the Telephony plugin types.\n\n**Figure: Telephony plugins**\n\n![Telephony plugins](media/telephony08.png)\n\n## Telephony Server\n\nTizen Telephony runs as a Telephony server daemon, `telephony-daemon`.\n\nThe Telephony server executes as a `g-main` loop from the `glib` library.\n\n**Figure: Telephony server**\n\n![Telephony server](media/telephony09.png)\n\n## Porting the OAL Interface\n\nOEM vendors can port available plugins within Telephony as needed to support specific hardware. It is not mandatory that all plugins are ported.\n\nThis section provides guidance to OEM vendors to develop various Telephony plugins.\n\n### Plugin Descriptor\n\nEach telephony plugin must provide a descriptor structure:\n\n```cpp\nstruct tcore_plugin_define_desc {\n    /* Name of the plugin */\n    gchar *name;\n\n    /* Initializing priority of the plugin */\n    enum tcore_plugin_priority priority;\n\n    /* Plugin version */\n    int version;\n\n    /* Plugin 'load' function reference */\n    gboolean(*load)();\n\n    /* Plugin 'init' function reference */\n    gboolean(*init)(TcorePlugin *);\n\n    /* Plugin 'unload' function reference */\n    void (*unload)(TcorePlugin *);\n};\n```\n\nThe plugin descriptor structure must be named as `plugin_define_desc`. The server obtains the address of this symbol to give control to the plugin to execute its defined functionality.\n\nThe initialization order among various Telephony plugins is based on each plugin's priority.\n\nOEMs need to specifically implement the modem and modem interface plugins to support their hardware.\n\n### Call Service Operations\n\nTo provide call services, the following functions must be implemented:\n\n```cpp\nstruct tcore_call_operations {\n    /* Call 'dial' function reference */\n    TReturn (*dial)(CoreObject *o, UserRequest *ur);\n\n    /* Call 'answer' function reference */\n    TReturn (*answer)(CoreObject *o, UserRequest *ur);\n\n    /* Call 'end' function reference */\n    TReturn (*end)(CoreObject *o, UserRequest *ur);\n\n    /* Call 'hold' function reference */\n    TReturn (*hold)(CoreObject *o, UserRequest *ur);\n\n    /* Call 'active' function reference */\n    TReturn (*active)(CoreObject *o, UserRequest *ur);\n\n    /* Call 'swap' function reference */\n    TReturn (*swap)(CoreObject *o, UserRequest *ur);\n\n    /* Call 'join' function reference */\n    TReturn (*join)(CoreObject *o, UserRequest *ur);\n\n    /* Call 'split' function reference */\n    TReturn (*split)(CoreObject *o, UserRequest *ur);\n};\n```\n\n### SMS Service Operations\n\nTo provide SMS services, the following functions must be implemented:\n\n```cpp\nstruct tcore_sms_operations {\n    /* For UMTS, SMS 'send' function reference */\n    TReturn (*send_umts_msg)(CoreObject *o, UserRequest *ur);\n\n    /* For CDMA, SMS 'read' function reference */\n    TReturn (*send_cdma_msg)(CoreObject *o, UserRequest *ur);\n\n    /* SMS 'read' function reference */\n    TReturn (*read_msg)(CoreObject *o, UserRequest *ur);\n\n    /* SMS 'save' function reference */\n    TReturn (*save_msg)(CoreObject *o, UserRequest *ur);\n\n    /* SMS 'delete' function reference */\n    TReturn (*delete_msg)(CoreObject *o, UserRequest *ur);\n\n    /* SMS 'get sca' function reference */\n    TReturn (*get_sca)(CoreObject *o, UserRequest *ur);\n\n    /* SMS 'set sca' function reference */\n    TReturn (*set_sca)(CoreObject *o, UserRequest *ur);\n\n    /* SMS 'get sms params' function reference */\n    TReturn (*get_sms_params)(CoreObject *o, UserRequest *ur);\n\n    /* SMS 'set sms params' function reference */\n    TReturn (*set_sms_params)(CoreObject *o, UserRequest *ur);\n};\n```\n\n### Network Service Operations\n\nTo provide network services, the following functions must be implemented:\n\n```cpp\nstruct tcore_network_operations {\n    /* Network 'search' function reference */\n    TReturn (*search)(CoreObject *o, UserRequest *ur);\n\n    /* Network 'set plmn selection mode' function reference */\n    TReturn (*set_plmn_selection_mode)(CoreObject *o, UserRequest *ur);\n\n    /* Network 'get plmn selection mode'' function reference */\n    TReturn (*get_plmn_selection_mode)(CoreObject *o, UserRequest *ur);\n\n    /* Network 'set service domain' function reference */\n    TReturn (*set_service_domain)(CoreObject *o, UserRequest *ur);\n\n    /* Network 'get service domain' function reference */\n    TReturn (*get_service_domain)(CoreObject *o, UserRequest *ur);\n\n    /* Network 'set band' function reference */\n    TReturn (*set_band)(CoreObject *o, UserRequest *ur);\n\n    /* Network 'get band' function reference */\n    TReturn (*get_band)(CoreObject *o, UserRequest *ur);\n};\n```\n\n### HAL Operations\n\nTo provide HAL operations, the following functions must be implemented:\n\n```cpp\nstruct tcore_hal_operations {\n    /* HAL 'power' function reference */\n    TReturn (*power)(TcoreHal *hal, gboolean flag);\n\n    /* HAL 'send' function reference */\n    TReturn (*send)(TcoreHal *hal, unsigned int data_len, void *data);\n\n    /* Network 'set up network interface' function reference */\n    TReturn (*setup_netif)(CoreObject *co,\n                           TcoreHalSetupNetifCallback func, void *user_data,\n                           unsigned int cid, gboolean enable);\n};\n```\n\nFor sample implementations of the modem and modem interface plugins, see [Sample Modem Interface Plugin Implementation](#sample-modem-interface-plugin-implementation).\n\n## Configuration\n\nTelephony plugins must be installed in the following folders:\n\n- Modem plugins: `%{_libdir}/telephony/plugins/modems/`\n- Other plugins: `%{_libdir}/telephony/plugins/`\n\n## References\n\nTizen source site: [http://review.tizen.org/git/](http://review.tizen.org/git/)\n\nTelephony packages:\n- Telephony daemon\n- Telephony core library\n- TAPI\n- Telephony API for a third party application\n- Communicator (DBUS_TAPI)\n- Free style plugin (indicator)\n- Free style plugin (packetservice)\n- Free style plugin (nitz)\n- Free style plugin (Database)\n- Free style plugin (VCONF)\n- Modem plugin (device)\n- Modem interface plugin (device)\n- Modem plugin (emulator)\n- Modem interface plugin (emulator)\n\n## Sample Modem Interface Plugin Implementation\n\n```cpp\n/* HAL Operations */\nstatic struct tcore_hal_operations hal_ops = {\n    .power = hal_power,\n    .send = hal_send,\n    .setup_netif = hal_setup_netif,\n};\n\nstatic\ngboolean on_load() {\n    dbg(\" Load!!!\");\n\n    return TRUE;\n}\n\nstatic\ngboolean on_init(TcorePlugin *plugin) {\n    TcoreHal *hal;\n    PluginData *user_data;\n    struct custom_data *data;\n\n    dbg(\" Init!!!\");\n\n    if (plugin == NULL) {\n        err(\" PLug-in is NULL\");\n\n        return FALSE;\n    }\n\n    /* User data for Modem Interface plugin */\n    user_data = g_try_new0(PluginData, 1);\n    if (user_data == NULL) {\n        err(\" Failed to allocate memory for Plugin data\");\n\n        return FALSE;\n    }\n\n    /* Register to server */\n    user_data->modem = tcore_server_register_modem(tcore_plugin_ref_server(plugin), plugin);\n    if (user_data->modem == NULL) {\n        err(\" Registration Failed\");\n        g_free(user_data);\n\n        return FALSE;\n    }\n    dbg(\" Registered from Server\");\n\n\n    data = g_try_new0(struct custom_data, 1);\n    if (data == NULL) {\n        err(\" Failed to allocate memory for Custom data\");\n\n        /* Unregister from server */\n        tcore_server_unregister_modem(tcore_plugin_ref_server(plugin), user_data->modem);\n\n        /* Free plugin data */\n        g_free(user_data);\n\n        return FALSE;\n    }\n\n    /* Open DPRAM device */\n    data->vdpram_fd = vdpram_open();\n    if (data->vdpram_fd modem);\n\n        /* Free plugin data */\n        g_free(user_data);\n\n        return FALSE;\n    }\n    /* Create and initialize HAL */\n    hal = tcore_hal_new(plugin, \"vmodem\", &hal_ops, TCORE_HAL_MODE_AT);\n    if (hal == NULL) {\n        /* Close VDPRAM device */\n        vdpram_close(data->vdpram_fd);\n\n        /* Free custom data */\n        g_free(data);\n\n        /* Unregister from server */\n        tcore_server_unregister_modem(tcore_plugin_ref_server(plugin), user_data->modem);\n\n        /* Free Plugin data */\n        g_free(user_data);\n\n        return FALSE;\n    }\n    user_data->hal = hal;\n\n    /* Link custom data to HAL user data */\n    tcore_hal_link_user_data(hal, data);\n\n    /* Set HAL as Modem Interface plugin's user data */\n    tcore_plugin_link_user_data(plugin, user_data);\n\n    /* Register to Watch list */\n    data->watch_id_vdpram = __register_gio_watch(hal, data->vdpram_fd, on_recv_vdpram_message);\n    dbg(\" fd: [%d] Watch ID: [%d]\", data->vdpram_fd, data->watch_id_vdpram);\n\n    /* Power ON VDPRAM device */\n    if (_modem_power(hal, TRUE) == TCORE_RETURN_SUCCESS) {\n        dbg(\" Power ON - [SUCCESS]\");\n    } else {\n        err(\" Power ON - [FAIL]\");\n        goto EXIT;\n    }\n\n    /* Check CP Power ON */\n    g_timeout_add_full(G_PRIORITY_HIGH, SERVER_INIT_WAIT_TIMEOUT, __load_modem_plugin, hal, 0);\n\n    dbg(\"[VMMODEM] Exit\");\n\n    return TRUE;\n\nEXIT:\n    /* Deregister from Watch list */\n    __deregister_gio_watch(data->watch_id_vdpram);\n\n    /* Free HAL */\n    tcore_hal_free(hal);\n\n    /* Close VDPRAM device */\n    vdpram_close(data->vdpram_fd);\n\n    /* Free custom data */\n    g_free(data);\n\n    /* Unregister from Server */\n    tcore_server_unregister_modem(tcore_plugin_ref_server(plugin), user_data->modem);\n\n    /* Free plugin data */\n    g_free(user_data);\n\n    return FALSE;\n}\n\nstatic void\non_unload(TcorePlugin *plugin) {\n    TcoreHal *hal;\n    struct custom_data *data;\n    PluginData *user_data;\n\n    dbg(\" Unload!!!\");\n\n    if (plugin == NULL)\n        return;\n\n    user_data = tcore_plugin_ref_user_data(plugin);\n    if (user_data == NULL)\n        return;\n\n    hal = user_data->hal;\n\n    data = tcore_hal_ref_user_data(hal);\n    if (data == NULL)\n        return;\n\n    /* Deregister from Watch list */\n    __deregister_gio_watch(data->watch_id_vdpram);\n    dbg(\" Deregistered Watch ID\");\n\n    /* Free HAL */\n    tcore_hal_free(hal);\n    dbg(\" Freed HAL\");\n\n    /* Close VDPRAM device */\n    vdpram_close(data->vdpram_fd);\n    dbg(\" Closed VDPRAM device\");\n\n    /* Free custom data */\n    g_free(data);\n\n    tcore_server_unregister_modem(tcore_plugin_ref_server(plugin), user_data->modem);\n    dbg(\" Unregistered from Server\");\n\n    dbg(\" Unloaded MODEM\");\n    g_free(user_data);\n}\n\n/* VMODEM Descriptor Structure */\nEXPORT_API struct tcore_plugin_define_desc plugin_define_desc = {\n    .name = \"VMODEM\",\n    .priority = TCORE_PLUGIN_PRIORITY_HIGH,\n    .version = 1,\n    .load = on_load,\n    .init = on_init,\n    .unload = on_unload\n};\n```\n\n### Sample Modem Plugin Implementation\n\n```cpp\nstatic\ngboolean on_load() {\n    dbg(\"LOAD!!!\");\n\n    return TRUE;\n}\n\nstatic\ngboolean on_init(TcorePlugin *p) {\n    TcoreHal *h;\n\n    dbg(\"INIT!!!\");\n\n    if (!p) {\n        err(\"Plug-in is NULL\");\n\n        return FALSE;\n    }\n\n    h = tcore_server_find_hal(tcore_plugin_ref_server(p), \"vmodem\");\n    if (!h) {\n        err(\"HAL is NULL\");\n\n        return FALSE;\n    }\n\n    tcore_hal_add_send_hook(h, on_hal_send, p);\n    tcore_hal_add_recv_callback(h, on_hal_recv, p);\n\n    /* Initialize modules */\n    s_modem_init(p, h);\n    s_network_init(p, h);\n    s_sim_init(p, h);\n    s_ps_init(p, h);\n    s_call_init(p, h);\n    s_ss_init(p, h);\n    s_sms_init(p, h);\n    tcore_hal_set_power(h, TRUE);\n\n    /* Send \"CPAS\" command to invoke POWER UP NOTI */\n    s_modem_send_poweron(p);\n\n    dbg(\"Init - Successful\");\n\n    return TRUE;\n}\n\nstatic void\non_unload(TcorePlugin *p) {\n    TcoreHal *h;\n\n    dbg(\"UNLOAD!!!\");\n\n    if (!p) {\n        err(\"Plug-in is NULL\");\n\n        return;\n    }\n\n    h = tcore_server_find_hal(tcore_plugin_ref_server(p), \"vmodem\");\n    if (h) {\n        tcore_hal_remove_send_hook(h, on_hal_send);\n        tcore_hal_remove_recv_callback(h, on_hal_recv);\n    }\n\n    /* Deinitialize the modules */\n    s_modem_exit(p);\n    s_network_exit(p);\n    s_sim_exit(p);\n    s_ps_exit(p);\n    s_call_exit(p);\n    s_ss_exit(p);\n    s_sms_exit(p);\n}\n\n/* ATMODEM plug-in descriptor */\nstruct tcore_plugin_define_desc plugin_define_desc = {\n    .name = \"ATMODEM\",\n    .priority = TCORE_PLUGIN_PRIORITY_MID,\n    .version = 1,\n    .load = on_load,\n    .init = on_init,\n    .unload = on_unload\n};\n```\n\n### Workflow\n\n- Initialization sequence\n   1. The server loads the modem interface plugin.\n\n   2. The modem interface plugin registers to the server.\n\n   3. The server enumerates the modem interface plugin.\n\n   4. The physical HAL is created.\n\n   5. The modem interface plugin queries the modem state.\n\n   6. If the modem is online, the CMUX (internal) channels are established.\n\n   7. A logical HAL is created for each CMUX channel and assigned to a core object type. These are updated to the mapping table.\n\n   8. The physical HAL mode is changed to `TRANSPARENT`, which disables the queue.\n\n   9. The modem interface plugin requests the server to load the modem plugin corresponding to its architecture.\n\n   10. The server loads the modem plugin.\n\n   11. The modem plugin initializes the sub-modules and creates the core objects, based on the core object types defined in the mapping table by the modem interface plugin.\n\n   12. The modem plugin notifies the server of the `PLUGIN_ADDED` event.\n\n   13. The modem notifies the communicator of the `PLUGIN_ADDED` event.\n\n   14. The communicator creates interfaces for the sub-modules present, based on the core objects created.\n\n   **Figure: Initialization sequence**\n\n   ![Telephony11.png](media/telephony11.png)\n\n\n\n- Request processing sequence\n   1. The application request is sent to the communicator through TAPI.\n\n   2. The communicator creates a user request based on the incoming request.\n\n   3. The user request is dispatched to the communicator.\n\n   4. The communicator dispatches the user request to the server.\n\n   5. The server finds the plugin based on the modem name.\n\n   6. The server extracts the core object type from the plugin's core objects list, based on the request command.\n\n   7. The server dispatches the user request to the core object.\n\n   8. The core object dispatches the user request to dispatch a function based on the request command.\n\n   9. A pending request is formed, added to the queue, and sent to the logical HAL assigned to the core object.\n\n   10. The logical HAL dispatches the request data to its dedicated CMUX channel.\n\n   11. CMUX encodes the request data and dispatches it to the physical HAL.\n\n   12. The physical HAL sends the request data to the modem.\n\n   **Figure: Request processing sequence**\n\n   ![Request processing sequence](media/telephony11.png)\n\n\n- Response processing sequence\n   1. The modem sends response data to the physical HAL.\n\n   2. The physical HAL dispatches the response data to CMUX.\n\n   3. CMUX decodes the received response data and dispatches it to the corresponding logical HAL, based on the CMUX channel.\n\n   4. The logical HAL dispatches the decoded response data to the corresponding core object.\n\n   5. The core object processes the received response data and extracts the user request from the pending queue. It sends the response data corresponding to the user request.\n\n   6. The user request extracts the communicator.\n\n   7. The received response data is sent to the corresponding communicator.\n\n   8. The communicator sends the response data to TAPI, which communicates it to the application.\n\n   **Figure: Response processing sequence**\n\n   ![Response processing sequence](media/telephony12.png)\n\n\n- Indication processing sequence\n   1. The modem sends notification data to the physical HAL.\n\n   2. The physical HAL dispatches the notification data to CMUX.\n\n   3. CMUX decodes the received notification data and dispatches it to the corresponding logical HAL, based on the CMUX channel registered for the notification.\n\n   4. The logical HAL dispatches the decoded notification data to the corresponding core object registered for the notification.\n\n   5. The core object processes the received notification data and dispatches to the server.\n\n   6. The server dispatches the notification data to the corresponding communicator.\n\n   7. The communicator sends the notification data to TAPI, which communicates it to the application.\n\n   **Figure: Indication processing sequence**\n\n   ![Telephony13.png](media/telephony13.png)"
					}
					
				
			
		
			
				
					,
					
					"application-developing-tips": {
						"id": "application-developing-tips",
						"title": "Development Tips",
						"categories": "",
						"url": " application/developing/tips/",
						"content": "# Development Tips\n\n- **SSH configuration file content**\n\n  - When working at home, you do not need a proxy, so the SSH configuration file is identical for all Linux distribution versions:\n\n    ```\n    Host tizen review.tizen.org\n    Hostname review.tizen.org\n    IdentityFile ~/.ssh/id_rsa\n    User \n    Port 29418\n    ```\n\n  - When working in a corporate environment, a proxy line in the SSH configuration is mandatory, and its format depends on the Linux distribution version you are using.\n\n    For Ubuntu, openSUSE, and CentOS, append `ProxyCommand nc -X5 -x : %h %p` to the SSH configuration, whereas for Fedora, append `ProxyCommand nc --proxy-type socks4 --proxy : %h %p` instead.\n\n- **Problems when cloning through SSH/HTTP**\n\n  - If you are located in China, you can experience problems connecting to Google servers when downloading the repo tool, initializing the repository, and synchronizing Tizen source.\n\n    In a typical error situation, no error message is displayed when downloading the repo tool by using curl, but connection problems occur when attempting to run the `repo init` command. In such cases, clear the Git HEAD and try running the repo commands through the `tsocks` proxy:\n\n    ```\n    $ tsocks curl http://commondatastorage.googleapis.com/git-repo-downloads/repo > ~/bin/repo\n    $ tsocks repo init -u ssh://@review.tizen.org:29418/scm/manifest -b tizen -m ivi.xml\n    $ tsocks repo init -u https://:@review.tizen.org/gerrit/p/scm/manifest -b tizen -m ivi.xml\n    ```\n\n  - When initializing and cloning through HTTP, you can be blocked by the \"server certificate verification\" issue. Run the following command and try again:\n\n    ```\n    $ export GIT_SSL_NO_VERIFY=1\n    ```"
					}
					
				
			
		
			
				
					,
					
					"platform-developing-tips": {
						"id": "platform-developing-tips",
						"title": "Development Tips",
						"categories": "",
						"url": " platform/developing/tips/",
						"content": "# Development Tips\n\n- **SSH configuration file content**\n\n  - When working at home, you do not need a proxy, so the SSH configuration file is identical for all Linux distribution versions:\n\n    ```\n    Host tizen review.tizen.org\n    Hostname review.tizen.org\n    IdentityFile ~/.ssh/id_rsa\n    User \n    Port 29418\n    ```\n\n  - When working in a corporate environment, a proxy line in the SSH configuration is mandatory, and its format depends on the Linux distribution version you are using.\n\n    For Ubuntu, openSUSE, and CentOS, append `ProxyCommand nc -X5 -x : %h %p` to the SSH configuration, whereas for Fedora, append `ProxyCommand nc --proxy-type socks4 --proxy : %h %p` instead.\n\n- **Problems when cloning through SSH/HTTP**\n\n  - If you are located in China, you can experience problems connecting to Google servers when downloading the repo tool, initializing the repository, and synchronizing Tizen source.\n\n    In a typical error situation, no error message is displayed when downloading the repo tool by using curl, but connection problems occur when attempting to run the `repo init` command. In such cases, clear the Git HEAD and try running the repo commands through the `tsocks` proxy:\n\n    ```\n    $ tsocks curl http://commondatastorage.googleapis.com/git-repo-downloads/repo > ~/bin/repo\n    $ tsocks repo init -u ssh://@review.tizen.org:29418/scm/manifest -b tizen -m ivi.xml\n    $ tsocks repo init -u https://:@review.tizen.org/gerrit/p/scm/manifest -b tizen -m ivi.xml\n    ```\n\n  - When initializing and cloning through HTTP, you can be blocked by the \"server certificate verification\" issue. Run the following command and try again:\n\n    ```\n    $ export GIT_SSL_NO_VERIFY=1\n    ```"
					}
					
				
			
		
			
				
					,
					
					"iot-developing-tips": {
						"id": "iot-developing-tips",
						"title": "Development Tips",
						"categories": "",
						"url": " iot/developing/tips/",
						"content": "# Development Tips\n\n- **SSH configuration file content**\n\n  - When working at home, you do not need a proxy, so the SSH configuration file is identical for all Linux distribution versions:\n\n    ```\n    Host tizen review.tizen.org\n    Hostname review.tizen.org\n    IdentityFile ~/.ssh/id_rsa\n    User \n    Port 29418\n    ```\n\n  - When working in a corporate environment, a proxy line in the SSH configuration is mandatory, and its format depends on the Linux distribution version you are using.\n\n    For Ubuntu, openSUSE, and CentOS, append `ProxyCommand nc -X5 -x : %h %p` to the SSH configuration, whereas for Fedora, append `ProxyCommand nc --proxy-type socks4 --proxy : %h %p` instead.\n\n- **Problems when cloning through SSH/HTTP**\n\n  - If you are located in China, you can experience problems connecting to Google servers when downloading the repo tool, initializing the repository, and synchronizing Tizen source.\n\n    In a typical error situation, no error message is displayed when downloading the repo tool by using curl, but connection problems occur when attempting to run the `repo init` command. In such cases, clear the Git HEAD and try running the repo commands through the `tsocks` proxy:\n\n    ```\n    $ tsocks curl http://commondatastorage.googleapis.com/git-repo-downloads/repo > ~/bin/repo\n    $ tsocks repo init -u ssh://@review.tizen.org:29418/scm/manifest -b tizen -m ivi.xml\n    $ tsocks repo init -u https://:@review.tizen.org/gerrit/p/scm/manifest -b tizen -m ivi.xml\n    ```\n\n  - When initializing and cloning through HTTP, you can be blocked by the \"server certificate verification\" issue. Run the following command and try again:\n\n    ```\n    $ export GIT_SSL_NO_VERIFY=1\n    ```"
					}
					
				
			
		
			
				
					,
					
					"tizenstudio-setup-tizen-cli": {
						"id": "tizenstudio-setup-tizen-cli",
						"title": "Install Tizen Studio using CLI",
						"categories": "",
						"url": " tizenstudio/setup/tizen-cli/",
						"content": "## Install Tizen Studio using CLI  \r\n\r\nThis page explains how to install Command Line Interface (CLI) version of Tizen Studio. The CLI installer provides functional tools for running Tizen Studio without a Graphical User Interface (GUI) environment.\r\nThe CLI installation is mostly intended for advanced developers. The Tizen Studio CLI installation is supported on all the major operating systems. \r\n\r\n### Prerequisites\r\n\r\n- Ensure that you download the appropriate CLI installer for your operating system. For more information, see the [Download page](https://developer.tizen.org/development/tizen-studio/download#).\r\n- Ensure that you have Open JDK 10 or Oracle JDK 10 installed on your development hardware. For more information, see the following table to setup the Open JDK: \r\n\r\n | Operating System  | Setup Information  |  \r\n |-------------------|------------------------------------------|\r\n |    Windows        | [Open JDK instructions](./tizenstudio/setup/windows/#set-up-open-jdk)|\r\n |    Ubuntu         | [Open JDK instructions](./tizenstudio/setup/ubuntu/#set-up-open-jdk)| \r\n |    MacOS          | [Open JDK instructions](./tizenstudio/setup/mac/#set-up-open-jdk)| \r\n\r\n### Tizen Studio Command Line Installation  \r\n\r\nTizen Studio command line installation takes minimal network resources and time to download and install on your development hardware. \r\n\r\n- To install Tizen Studio on Windows&reg; using the CLI installer, double click the installer file. The console window appears and the installer gets executed automatically. You can follow the console window to see the installation progress. \r\n   \r\n- To install Tizen Studio on Ubuntu&reg; and MacOS&reg;, navigate to the directory where you downloaded the installer file and follow these steps:\r\n      \r\n    1. Open the terminal.\r\n    2. Type the `chmod +x` command to apply the execute permission to the installer file.\r\n    3. Type the command with the following syntax:\r\n\r\n         ```\r\n         web-cli_Tizen_Studio_ [options] []\r\n     \r\n         ```\r\n       The following table identifies the standard command line options for the CLI installation. Command line options are case insensitive:\r\n   \r\n       | Options             | Descriptions                            |\r\n       |--------------------|------------------------------------------|\r\n       | `--show-license`   | Displays the Tizen Studio software license agreement.Note You must use this option alone. Do not use with other options. |\r\n       | `--accept-license` | Accepts the license terms.               |\r\n       | `--no-java-check`  | Skips the Java version check.            |\r\n\r\n       The following table identifies the standard command line parameter for installation related tasks. Command line options are case insensitive:\r\n\r\n       | Parameter        | Description                              |\r\n       |------------------|------------------------------------------|\r\n       | `directory path` | Specifies the installation directory path. **Note** If you do not enter the path, Tizen Studio is installed in the default directory (`/home/{user}/tizen-studio`). |\r\n\r\n    4. Accept the license terms and type **Y** when prompted, to proceed with the installation.\r\n    5. Type the Tizen Studio installation location. \r\n\r\n   The CLI installer begins installing Tizen Studio. \r\n\r\n> **Note**\r\n>\r\n> By default, the Web App Development platform and related tools are installed. For installing Native application platform and tools use CLI Package Manager.\r\n\r\n## Install Additional Packages\r\n\r\nThe CLI package manager tool also provides you the option to install additional required packages and tools.\r\n\r\nTo run the CLI Package Manager with the `install` command, use the following syntax:\r\n\r\n```\r\npackage-manager-cli install [--accept-license] [--no-java-check] [--proxy ] [-f ] [-p ] [,...]\r\n```\r\nThe following table identifies the standard command line parameters for CLI package management tasks. Command line options are case insensitive:\r\n\r\n\r\n| Parameters                  | Descriptions                             |\r\n|-----------------------------|------------------------------------------|\r\n| `--accept-license`          | Accepts the license terms.               |\r\n| `--no-java-check`           | Skips the Java version check.            |\r\n| `--proxy `           | Proxy configuration value. Use any one of the following values: direct, auto, or ip:port. |\r\n| `-f, --file `    | If you want to install packages from a local SDK image, specify the full path of the SDK image file. |\r\n| `-p, --password ` | Administrator (sudo) password for authentication in Ubuntu only. |\r\n| `[,...]`        | Name of the package that you want to install. You can enter multiple package names such as **NativeIDE** and **Emulator**.To retrieve the names of the installable packages, use the following command:`package-manager-cli show-pkgs` |"
					}
					
				
			
		
			
				
					,
					
					"application-about-tizen-open-source-overview": {
						"id": "application-about-tizen-open-source-overview",
						"title": "Tizen Open Source Project",
						"categories": "",
						"url": " application/about/tizen-open-source-overview/",
						"content": "# Application Folder\n# Tizen Open Source Project\n\nTizen is an open source software stack created for a wide array of devices with different form factors. The primary objectives of Tizen are to create an open software platform available for carriers, OEMs, and developers to make their innovative ideas a reality, and to introduce a successful, real-world product that improves the mobile experience for users. We have also wanted to make sure there is no central point of failure, where 1 industry player can restrict or control the innovations of another. The result is a full, production-quality consumer product with source code open for customization and porting.\n\nThe Tizen operating system is available in multiple profiles to serve different industry requirements. The current Tizen profiles are Tizen IVI (in-vehicle infotainment), Tizen Mobile, Tizen TV, and Tizen Wearable. Additionally, as of Tizen 3.0, all profiles are built on top of a common, shared infrastructure called Tizen Common.\n\nWith Tizen:\n\n- **Device manufacturers** can begin with 1 of the profiles and modify it to serve their own needs, or use the Tizen Common base to develop a new profile to meet the memory, processing, and power requirements of any device and quickly bring it to market.\n- **Mobile operators** can work with device partners to customize the operating system and user experience to meet the needs of specific customer segments or demographics.\n- **Application developers and ISVs** can take advantage of the power of native application development with the flexibility of unparalleled HTML5 support. Tizen also offers the potential for application developers to extend their reach to new \"smart devices\" running Tizen, including wearables, consumer electronics (such as TVs, gaming consoles, and DVRs), cars, and appliances.\n\nThe Tizen project is a part of the [Linux Foundation](https://www.linuxfoundation.org/projects/) and is governed by a Technical Steering Group, which is the primary decision-making body for the open source project, with a focus on platform development and delivery, along with the formation of working groups to support device verticals.\n\nThe [Tizen Association](http://www.tizenassociation.org/) has been formed to guide the industry role of Tizen, including gathering of requirements, identification and facilitation of service models, and overall industry marketing and education.\n\n\n## Get Started with Tizen\n\nTo get started with Tizen development:\n\n- Get access\n\n  You can register for an account at [https://www.tizen.org/user/register](https://www.tizen.org/user/register).\n\n- Study the development workflow\n\n  Tizen developers use the Git and [GBS command-line tools](../reference/gbs/gbs-overview.md) for most of their work. Tizen source code is managed by [Gerrit](../reference/gerrit-usage.md), a code review system for Git-based projects. Source code cloning, development, and review are done under ACL (Access Control Lists). Make sure you have access rights to them.\n\nStart by reading the [Development Workflow](work-flow.md) page."
					}
					
				
			
		
			
				
					,
					
					"platform-about-tizen-open-source-overview": {
						"id": "platform-about-tizen-open-source-overview",
						"title": "Tizen Open Source Project",
						"categories": "",
						"url": " platform/about/tizen-open-source-overview/",
						"content": "# Tizen Open Source Project\n\nTizen is an open source software stack created for a wide array of devices with different form factors. The primary objectives of Tizen are to create an open software platform available for carriers, OEMs, and developers to make their innovative ideas a reality, and to introduce a successful, real-world product that improves the mobile experience for users. We have also wanted to make sure there is no central point of failure, where 1 industry player can restrict or control the innovations of another. The result is a full, production-quality consumer product with source code open for customization and porting.\n\nThe Tizen operating system is available in multiple profiles to serve different industry requirements. The current Tizen profiles are Tizen IVI (in-vehicle infotainment), Tizen Mobile, Tizen TV, and Tizen Wearable. Additionally, as of Tizen 3.0, all profiles are built on top of a common, shared infrastructure called Tizen Common.\n\nWith Tizen:\n\n- **Device manufacturers** can begin with 1 of the profiles and modify it to serve their own needs, or use the Tizen Common base to develop a new profile to meet the memory, processing, and power requirements of any device and quickly bring it to market.\n- **Mobile operators** can work with device partners to customize the operating system and user experience to meet the needs of specific customer segments or demographics.\n- **Application developers and ISVs** can take advantage of the power of native application development with the flexibility of unparalleled HTML5 support. Tizen also offers the potential for application developers to extend their reach to new \"smart devices\" running Tizen, including wearables, consumer electronics (such as TVs, gaming consoles, and DVRs), cars, and appliances.\n\nThe Tizen project is a part of the [Linux Foundation](https://www.linuxfoundation.org/projects/) and is governed by a Technical Steering Group, which is the primary decision-making body for the open source project, with a focus on platform development and delivery, along with the formation of working groups to support device verticals.\n\nThe [Tizen Association](http://www.tizenassociation.org/) has been formed to guide the industry role of Tizen, including gathering of requirements, identification and facilitation of service models, and overall industry marketing and education.\n\n\n## Get Started with Tizen\n\nTo get started with Tizen development:\n\n- Get access\n\n  You can register for an account at [https://www.tizen.org/user/register](https://www.tizen.org/user/register).\n\n- Study the development workflow\n\n  Tizen developers use the Git and [GBS command-line tools](../reference/gbs/gbs-overview.md) for most of their work. Tizen source code is managed by [Gerrit](../reference/gerrit-usage.md), a code review system for Git-based projects. Source code cloning, development, and review are done under ACL (Access Control Lists). Make sure you have access rights to them.\n\nStart by reading the [Development Workflow](work-flow.md) page."
					}
					
				
			
		
			
				
					,
					
					"iot-about-tizen-open-source-overview": {
						"id": "iot-about-tizen-open-source-overview",
						"title": "Tizen Open Source Project",
						"categories": "",
						"url": " iot/about/tizen-open-source-overview/",
						"content": "# IOT Folder\n# Tizen Open Source Project\n\nTizen is an open source software stack created for a wide array of devices with different form factors. The primary objectives of Tizen are to create an open software platform available for carriers, OEMs, and developers to make their innovative ideas a reality, and to introduce a successful, real-world product that improves the mobile experience for users. We have also wanted to make sure there is no central point of failure, where 1 industry player can restrict or control the innovations of another. The result is a full, production-quality consumer product with source code open for customization and porting.\n\nThe Tizen operating system is available in multiple profiles to serve different industry requirements. The current Tizen profiles are Tizen IVI (in-vehicle infotainment), Tizen Mobile, Tizen TV, and Tizen Wearable. Additionally, as of Tizen 3.0, all profiles are built on top of a common, shared infrastructure called Tizen Common.\n\nWith Tizen:\n\n- **Device manufacturers** can begin with 1 of the profiles and modify it to serve their own needs, or use the Tizen Common base to develop a new profile to meet the memory, processing, and power requirements of any device and quickly bring it to market.\n- **Mobile operators** can work with device partners to customize the operating system and user experience to meet the needs of specific customer segments or demographics.\n- **Application developers and ISVs** can take advantage of the power of native application development with the flexibility of unparalleled HTML5 support. Tizen also offers the potential for application developers to extend their reach to new \"smart devices\" running Tizen, including wearables, consumer electronics (such as TVs, gaming consoles, and DVRs), cars, and appliances.\n\nThe Tizen project is a part of the [Linux Foundation](https://www.linuxfoundation.org/projects/) and is governed by a Technical Steering Group, which is the primary decision-making body for the open source project, with a focus on platform development and delivery, along with the formation of working groups to support device verticals.\n\nThe [Tizen Association](http://www.tizenassociation.org/) has been formed to guide the industry role of Tizen, including gathering of requirements, identification and facilitation of service models, and overall industry marketing and education.\n\n\n## Get Started with Tizen\n\nTo get started with Tizen development:\n\n- Get access\n\n  You can register for an account at [https://www.tizen.org/user/register](https://www.tizen.org/user/register).\n\n- Study the development workflow\n\n  Tizen developers use the Git and [GBS command-line tools](../reference/gbs/gbs-overview.md) for most of their work. Tizen source code is managed by [Gerrit](../reference/gerrit-usage.md), a code review system for Git-based projects. Source code cloning, development, and review are done under ACL (Access Control Lists). Make sure you have access rights to them.\n\nStart by reading the [Development Workflow](work-flow.md) page."
					}
					
				
			
		
			
				
					,
					
					"trademarks": {
						"id": "trademarks",
						"title": "Trademarks",
						"categories": "",
						"url": " trademarks/",
						"content": "# Trademarks\n\nThe names of products or other services on this site are the trademarks or registered trademarks of their respective companies.\n\nApple,  iPhone, Mac, MacBook, MacBook Pro, Mac OS, macOS, and OS X are trademarks of Apple Inc., registered in the U.S. and other countries.\n\niOS is a trademark or registered trademark of Cisco in the U.S. and other countries and is used under license.\n\nMicrosoft, Windows, Windows Server and Internet Explorer are either registered trademarks or trademarks of Microsoft Corp. in the U.S. and/or other countries. \n\nWi-Fi, Wi-Fi Direct are registered trademarks of Wi-Fi Alliance.\n\nAndroid&trade;: Android and Chrome browser are trademarks of Google Inc.\n\nEGL&trade;: EGL and the EGL logo are trademarks of the Khronos Group Inc.\n\nFIDO Ready&trade;:  The FIDO, FIDO ALLIANCE and FIDO CERTIFIED trademarks and logos are trademarks of FIDO Alliance, Inc.\n\nGoogle Chrome&trade; browser: Android and Chrome browser are trademarks of Google Inc.\n\nIntel&reg; : Intel is a trademark of Intel Corporation or its subsidiaries in the U.S. and/or other countries.\n\nNVIDIA&reg;: NVIDIA, the NVIDIA logo, and NVIDIA Optimus are trademarks and/or registered trademarks of NVIDIA Corporation in the U.S. and other countries. Other company and product names may be trademarks of the respective companies with which they are associated.\n\nNVIDIA Optimus&reg;: NVIDIA, the NVIDIA logo, and NVIDIA Optimus are trademarks and/or registered trademarks of NVIDIA Corporation in the U.S. and other countries. Other company and product names may be trademarks of the respective companies with which they are associated.\n\nOpenGL&reg;: OpenGL&reg; and the oval logo are trademarks or registered trademarks of Silicon Graphics, Inc. in the United States and/or other countries worldwide.\n\nOpenGL&reg; ES: OpenGL is a registered trademark and the OpenGL ES logo is a trademark of Silicon Graphics Inc. used by permission by Khronos.\n\nOracle&reg;: Oracle and Java are registered trademarks of Oracle and/or its affiliates. Other names may be trademarks of their respective owners.\n\nUNIX&reg; is a registered trademark of The Open Group.\n\nVulkan&reg;:  Vulkan and the Vulkan logo are registered trademarks of the Khronos Group Inc.\n\nWebGL&trade;: WebGL and the WebGL logo are trademarks of the Khronos Group Inc.\n\nAll other trademarks are the property of their respective owners."
					}
					
				
			
		
			
				
					,
					
					"tizenstudio-setup-troubleshooting": {
						"id": "tizenstudio-setup-troubleshooting",
						"title": "Troubleshooting",
						"categories": "",
						"url": " tizenstudio/setup/troubleshooting/",
						"content": "## Troubleshooting \r\n\r\nThis page provides the information needed to troubleshoot Tizen Studio. Participate in the [Tizen User Community forum](https://developer.tizen.org/forums), and suggest ways to improve the documentation. This page describes methodologies, techniques, and procedures for troubleshooting problems that might arise in the day-to-day operations while using Tizen Studio.\r\n\r\n## Issue: HAXM fails to install\r\n**Description:** You encounter an HAXM installation failure.\r\n\r\n**Solution:** \r\n- Ensure that **VT**, **Execute Disable Bit** option is enabled in BIOS\r\n- Ensure that **Data Execution Prevention** is enabled in Windows&reg;\r\n        \r\n  - To enable **Data Execution Prevention**On the Windows&reg;, follow these steps:\r\n\r\n    1. Click **Control Panel > System and Security > System**.\r\n    2. Select **Advanced system settings**.\r\n    3. In the left navigation bar, Click **Advanced**.\r\n    4. In **Performance section**, click **Settings**.\r\n    5. In **Performance Options** dialogue window that appears, click **Data Execution Prevention**.\r\n    6. Select **Turn on DEP**. \r\n    7. Click **Apply** and click **OK**.\r\n\r\n- Ensure that **Hyper-V** is disabled (on Windows&reg; 8 or after).\r\n    1. In the **Start** menu Run **Programs and Features**.  \r\n       ![Run Programs and Features](./media/hardware_run_program.png)  \r\n    2. In the **Programs and Features** window, click **Turn Windows features on or off**.\r\n    3. In the **Turn Windows features on or off** window that appears, disable **Hyper-V** and click **OK**.  \r\n       ![Disable Hyper-V](./media/hardware_hyper_v.png)  \r\n    4. Reboot the computer.\r\n \r\n## Issue: HAXM installation fails due to Intel Execute Disable (XD) Bit capability\r\n\r\n**Description:**\r\n While installing Intel HAXM, you may encounter an error regarding the Intel XD support.\r\n  This error message can be triggered by the following conditions:\r\n\r\n  - Intel XD is not supported by your computer�s processor\r\n  - Intel XD is not enabled\r\n  \r\n  **Solution:** \r\n   - **For Intel XD not supported**\r\n  \r\n   Intel HAXM requires an Intel processor with Execute Disable (XD) Bit functionality and cannot be used on systems not supporting this hardware feature. To determine the capabilities of your Intel processor, see [official site] (http://ark.intel.com/).\r\n  \r\n   - **For Intel XD not enabled**\r\n      > **Note**\r\n      >\r\n      > Apple based computers have Intel XD permanently enabled, if the feature is supported by the processor.\r\n  \r\n   If you receive an error message that Intel XD is not enabled, it implies that your computer does not meet the minimum system requirements to use Intel HAXM.In addition, to determine the capabilities of your Intel processor, see [official site](http://ark.intel.com/).\r\n\r\n\r\n## Issue: HAXM installation fails due to Intel Virtualization Technology (VT-x)\r\n**Description:**\r\n  When installing Intel HAXM, you may encounter an error regarding Intel VT-x support. This error message can be triggered by the following conditions:\r\n\r\n   - Intel VT-x is not supported by your computer�s processor\r\n   - Intel VT-x is not enabled\r\n  \r\n**Resolution:** \r\n- **Intel VT-x is not supported**\r\n  \r\nIntel HAXM requires an Intel processor with Intel VT-x functionality and cannot be used on systems lacking this hardware feature. To determine the capabilities of your Intel processor, see [official site](http://ark.intel.com/).\r\n\r\n  - **Intel VT-x is not enabled**\r\n    > **Note**\r\n    >\r\n    >  Apple based computers have Intel VT-x permanently enabled, if the feature is supported by the processor.\r\n  \r\nIf you receive an error message indicating that Intel VT is not enabled, your computer does not meet the minimum system requirements to use Intel HAXM. To determine the capabilities of your Intel processor, see the [official site](http://ark.intel.com/).\r\n  \r\n\r\n## Issue: Visual Studio throws errors when using Tizen.NET.SDK 1.0.0\r\n\r\n**Description:**\r\n\r\nVisual Studio Tools for Tizen support Visual Studio 2019 (16.0 or higher version), yet you encounter errors while using Tizen.NET.SDK 1.0.0 or 1.0.1 as shown in the following:\r\n\r\n```\r\nSeverity    Code\t    Description\tProject\tFile\tLine\t   Suppression State\r\nError\t  NETSDK1013\tThe TargetFramework value 'tizen40' was not recognized. It may be misspelled. If not, then the TargetFrameworkIdentifier and/or TargetFrameworkVersion properties must be specified explicitly.\tAnalogWatch.Tizen.Wearable\tC:\\Program Files\\dotnet\\sdk\\2.1.700\\Sdks\\Microsoft.NET.Sdk\\targets\\Microsoft.NET.TargetFrameworkInference.targets\t96\r\n```\r\n**Resolution:**\r\n\r\nThis error occurs due to the recent changes in visual studio project system. You can resolve the issue by following\r\neither of the options: \r\n\r\n1. Use Tizen.NET.Sdk 1.0.3\r\n   Since Tizen.NET.Sdk 1.0.3, Tizen.NET can be used as a custom SDK for MSBuild.\r\n   \r\n   ```\r\n   \r\n\r\n   \r\n      Exe\r\n      tizen40\r\n   \r\n\r\n   \r\n   ```\r\n   \r\n2. Use Microsoft.NET.Sdk, if you want to continue working with existing Tizen project using legacy Tizen.NET.Sdk. Add the following lines to your **csproj** file:\r\n   ```\r\n   \r\n\r\n   \r\n      Exe\r\n      tizen40\r\n      \r\n      Tizen \r\n      v4.0\r\n   \r\n\r\n   \r\n   ```\r\n\r\n## Issue: Cannot use external library (FSharp.Core.dll) in .NET Core SDK preview version\r\n**Description:**  While trying to use external libraries, you get an error. \r\n\r\n**Resolution:** \r\n\r\n1. Switch from .NET Core SDK preview version (v3.0.0-preview5) to .NET Core SDK preview version 2.2.102 \r\n2. Build using Visual Studio (right click on the **Project > Build**) and the FSharp.Core.dll library gets included in the build directory, and using the functions from FSharp.Core will also resolve the issue.\r\n\r\n## Issue: Screen Reader not working\r\n\r\n**Description:** \r\nThe screen reader is not working \r\n\r\n**Resolution:** \r\n- Check whether the accessibility TTS(screen reader - voice assistant) and SystemSettings.AccessibilityTtsEnabled is enabled. For more information, see [Accessibility](https://developer.tizen.org/dev-guide/csapi/api/Tizen.System.SystemSettings.html#Tizen_System_SystemSettings_AccessibilityTtsEnabled).\r\n\r\n\r\n## Issue: Emulator terminates unexpectdly on MacOS&reg;\r\n\r\n**Description:** If you use a Macbook that has both Intel HD and NVIDIA graphics, the emulator terminates nexpectedly while you execute the emulator with OpenGL ES version 1.1 or 2.0.\r\n\r\n**Resolution:** \r\n1. Verify the emulator configuration in **Emulator Manager**. \r\n2. On **General tab** in the Emulator configuration window, set **OpenGL ES version to version 2.0** or to **version 3.0.**\r\n\r\n## Issue: UI display perspective issues on MacOS\r\n**Description:** : After updating Tizen Studio, UI perspectives are not displayed properly.\r\n\r\n**Resolution:**\r\n\r\n- In MacOS, if the UI perspectives are not displayed properly, after you update Tizen Studio. It is recommended to restart the IDE, doing so clears the cache from the previous installation.\r\n\r\n- In case, you see any old perspective, it is recommended to create a new workspace and import the projects to the new workspace to resolve the issue.\r\n\r\n## Issue: Not able to view Connection Explorer\r\n\r\n**Description:** Cannot view Connection Explorer.  \r\n\r\n**Resolution:**\r\nSince Tizen Studio 2.0 and higher,**Connection Explorer** is replaced with **Device Manager**. Additionally, You can fix this issues in following ways:\r\n\r\n- Reset the perspective:\r\n  1. In Tizen Studio menu, select **Window > Perspective > Reset Perspective**.\r\n  2. After updating Tizen Studio to higher version, run the following command:\r\n  `eclipse.exe -clean -clearPersistedState` \r\n  3. Launch the Tizen Studio normally.\r\n\r\n>**Note:** \r\n>\r\n> You can create unit tests for Tizen Studio versions higher than 2.3.1. \r\n\r\n## Issue: Preview tab does not appear\r\n\r\n**Description:**\r\n\r\nThe preview tab in the Web Page Editor does not appear. \r\n\r\n**Resolution:**\r\n- Use Web SDK HTML Editor, that enhanced features compared to the Web Page Editor. \r\n- Instead of the preview tab in the Web Page Editor, use the preview feature by pressing the **Ctrl + 4** combination of keys in Web SDK HTML Editor.\r\n- In Rapid Development Support (RDS) mode, the web unit test result is not updated.\r\n\r\n## Issue: Cannot launch Tizen Studio with GDB Client\r\n\r\n**Description:** Tizen Studio fails to launch with GDB client on Ubuntu 18.04\r\n**Resolution:**\r\n\r\nUbuntu 18.04 does not come with readline6 dev package,to install the readline6 dev package, run the following command, for 64 bit system:\r\n\r\n```\r\n$ wget http://mirrors.edge.kernel.org/ubuntu/pool/main/r/readline6/libreadline6-dev_6.3-8ubuntu2_amd64.deb\r\n$ wget http://mirrors.edge.kernel.org/ubuntu/pool/main/r/readline6/libreadline6_6.3-8ubuntu2_amd64.deb \r\n$ sudo dpkg -i libreadline6_6.3-8ubuntu2_amd64.deb\r\n$ sudo dpkg -i libreadline6-dev_6.3-8ubuntu2_amd64.deb \r\n```\r\n\r\nXenial (16.04) contains libreadline6-dev package, but Ubuntu 18.04 does not. You can download and install it with the preceding commands.\r\n\r\n## Issue: Emulator stuck at booting kernel\r\n\r\n**Description:** Emulator gets stuck at booting kernel \r\n\r\n**Resolution:**\r\n\r\n The cause for such an issue is that the user has insufficient permissions. To resolve this problem, after installing KVM for Ubuntu-18.04, run the following command:\r\n\r\n```\r\n$ sudo adduser $USER kvm\r\n```\r\nAfter the command is executed,  \"kvm\" group(/dev/kvm) will be added into the group file(/etc/group).\r\n\r\n> **Note**\r\n>\r\n> To apply this change, you must restart or logout/login."
					}
					
				
			
		
			
				
					,
					
					"tizenstudio-setup-ubuntu": {
						"id": "tizenstudio-setup-ubuntu",
						"title": "Install Tizen Studio on Ubuntu",
						"categories": "",
						"url": " tizenstudio/setup/ubuntu/",
						"content": "# Install Tizen Studio on Ubuntu\r\n\r\nThis page guides you with downloading and installing Tizen Studio on your development hardware. \r\n\r\nTo have the optimal installation experience, follow these steps chronologically:\r\n\r\n- System prerequisites\r\n  - Hardware requirements\r\n  - Software requirements\r\n- Setup Open JDK in Ubuntu\r\n- Install dependencies\r\n- Launch installer\r\n- Verify installation\r\n\r\n### System Prerequisites\r\n\r\nEnsure that the following system prerequisites are met:\r\n\r\n#### Hardware Requirements\r\n\r\n\r\n  \r\n    CPU\r\n    Dual Core, 2Ghz or faster\r\n  \r\n  \r\n    Architecture\r\n    x32 or x64 \r\n  \r\n  \r\n    Memory\r\n    3GB or more\r\n  \r\n  \r\n    Disk Space\r\n    6 GB or more\r\n  \r\n \r\n\r\n#### Software Requirements\r\n\r\n\r\n  \r\n    Ubuntu\r\n  \r\n  \r\n    Version\r\n    16.04/ 14.04/ 18.04\r\n  \r\n  \r\n    Bit\r\n    32 or 64 bit\r\n  \r\n\r\n\r\n\r\n  \r\n    Software\r\n    Download Link \r\n  \r\n  \r\n    Open JDK\r\n    \r\n    Click to Download\r\n    \r\n  \r\n  \r\n    OpenJavaFX\r\n    Click to Download \r\n  \r\n  \r\n    Tizen Studio setup file\r\n    Click to Download\r\n  \r\n\r\n\r\n> **Note**\r\n>\r\n> - Download the relevant version based on the target device operating system, for example, **openjdk-10_linux-x64_bin.tar.gz**. \r\n> - Ensure that you download the JavaFX  SDK product only, for example: JavaFX Linux SDK.\r\n\r\n**Disclaimer:** The third party download links are subjected to change. Search and download the appropriate software.\r\n\r\n## Set Up Open JDK\r\n\r\nTo set up Open JDK, follow these steps: \r\n\r\n1. Extract the downloaded **openjdk-10_linux-x64_bin.tar.gz** and  **javafx-11-0-2-sdk-linux.zip** files at your preferred location.\r\n   - Locate the **jdk-10** and the **javafx-sdk-11.0.2** directories.\r\n     > **Note**\r\n     >\r\n     >The **jdk-10**, **javafx-sdk-11.0.2** directories are created as a result of extraction. \r\n   \r\n2. Copy all the files except the **src.zip** file from the **lib** sub directory located in the **javafx-sdk-11.0.2** directory.\r\n3. Paste all the copied files in the **lib** folder located in the **jdk-10** directory. \r\n   >Note:\r\n   >\r\n   >- In this installation guide, setting up OpenJDK is covered. However, Oracle JDK versions until version 10 are also supported.\r\n   >- For Oracle JDK 10 installation steps, see the [Oracle official site](https://docs.oracle.com/javase/10/install/installation-jdk-and-jre-linux-platforms.htm#JSJIG-GUID-79FBE4A9-4254-461E-8EA7-A02D7979A161). \r\n   >- If you have installed Oracle JDK 10 or below already, you can skip **Setting up OpenJDK**. \r\n\r\n### Set Up Open JDK Path \r\n\r\nTo set up the JDK path, follow these steps:  \r\n\r\n1.\tOpen the terminal.\r\n2.\tType the following command in the terminal to set JAVA_HOME as the OpenJDK directory path, for example:\r\n\t- `JAVA_HOME=/home//Desktop/openJDK/jdk-10.0.2/`.\r\n3.\tType the following commands in the terminal one after the other to complete the process:\r\n\t- ` sudo apt update-alternatives --install /usr/bin/java java ${JAVA_HOME%*/}/bin/java 20000`\r\n\t- ` sudo apt update-alternatives --install /usr/bin/javac javac ${JAVA_HOME%*/}/bin/javac 20000`\r\n4.\tType the following command to get a list of JDK versions installed:\r\n\t- ` sudo apt update-alternatives --config java`\r\n\t    > **Note**\r\n      >\r\n      > If there are multiple versions of JDK installed, enter the selection number to choose your desired JDK version.\r\n\r\n5. To configure the default Java compiler, type the following command:\r\n\t\r\n   - ` sudo apt update-alternatives --config javac`\r\n\t\r\n\t   > **Note**\r\n     >\r\n     >**javac** is used for compilation. For more information on the differences between java and javac, see the [Oracle documentation](https://docs.oracle.com).\r\n\t\r\n6.\tType the `java –version` command to verify whether the OpenJDK version 10 is installed.\r\n\t\r\n## Install Dependencies\r\n\r\nThe installer package consists of basic and immediate libraries. However, the Tizen Studio application requires additional libraries in order to work flawlessly. \r\n\r\nTo install the dependencies, open the terminal and execute the following commands: \r\n\r\n```sudo apt install expect  sudo apt install gtk2-engines-pixbuf sudo apt install libgnome2-0 sudo apt install qemu-user-static sudo apt install libwebkitgtk-1.0-0 sudo apt install libwebkitgtk-1.0-0 cpio rpm2cpio sudo apt install gettext sudo apt install gksudo sudo apt install module-init-tools sudo apt install libudev-dev sudo apt install libsdl1.2debian sudo apt install bridge-utils sudo apt install openvpn\r\n ```\r\n \r\n### Install Emulator Dependencies\r\n\r\nThe Emulator also requires a few additional libraries to work smoothly. To install these dependencies, open the terminal and enter the following command:\r\n\r\n  ` sudo apt install acl bridge-utils openvpn libfontconfig1 libglib2.0-0 libjpeg-turbo8 libpixman-1-0 libpng12-0 libsdl1.2debian libsm6 libv4l-0 libx11-xcb1 libxcb-icccm4 libxcb-image0 libxcb-randr0 libxcb-render-util0 libxcb-shape0 libxcb-xfixes0 libxi6`\r\n\r\n## Launch Installer \r\n\r\nNavigate to the directory where you have saved the installer file and proceed with the further instructions. \r\n\r\nTo launch the installer, follow these steps:\r\n\r\n1. Open the terminal and execute the following commands:\r\n\t\r\n\t- `chmod +x web-ide_Tizen_Studio_x.x_ubuntu-64.bin`\r\n\t- `./web-ide_Tizen_Studio_x.x_ubuntu-64.bin` \r\n\t>Note:\r\n\t>\r\n\t>**x.x** represents the latest version of Tizen Studio, for example: web-ide_Tizen_Studio_**3.3**_ubuntu-64.bin.\r\n2. Accept the software license.\r\n   \r\n   > **Note**\r\n   >\r\n   >The license contains important legal notices for using Tizen Studio. Read it fully, and click **Accept** only if you agree with the license terms.\r\n\r\n   ![Tizen Studio License Agreement](./tizenstudio/setup/media/install_sdk_license.png)\r\n\r\n3. Click **Browse** and specify a new directory to set the SDK location and the SDK data location.\r\n\r\n   ![Set SDK and data location](./tizenstudio/setup/media/install_sdk_directory.png)\r\n   \r\n   >**Note** \r\n   > \r\n   >If the new directory is valid, it shows no errors.\r\n4. Click **Install**.\r\n5. Click **Finish** to close the installer.\r\n\r\n   ![Installation complete](./tizenstudio/setup/media/migration_finish_instal.png)\r\n\r\n   > **Note**\r\n   >\r\n   >If you want to install additional platforms and tools, launch Package Manager by selecting the Launch Package Manager **check box** and click **Finish**.\r\n   > - Use Tizen Studio Package Manager, to install and update additional tools. \r\n   > - For more information on the Package Manager, see [Updating Tizen Studio](./tizenstudio/setup/update-sdk/).\r\n\r\n### Verify Installation\r\n   \r\nTo verify whether the installation is successful or not, click **Tizen Studio icon**. The Tizen Studio startup window must appear."
					}
					
				
			
		
			
				
					,
					
					"tizenstudio-setup-uninstall-sdk": {
						"id": "tizenstudio-setup-uninstall-sdk",
						"title": "Uninstall Tizen Studio",
						"categories": "",
						"url": " tizenstudio/setup/uninstall-sdk/",
						"content": "# Uninstall Tizen Studio\r\n\r\nThis page explains how to uninstall Tizen Studio from your system. The Tizen Studio uninstaller removes all the installed Tizen platforms and the tools. During the uninstallation procedure, all the data stored in the installation directory is removed, including any customizations or any other data you have stored within that directory. Make a back up of any data you want to keep prior to performing the uninstallation procedure.\r\n\r\nYou can uninstall Tizen Studio in one of the following ways: \r\n- Using GUI uninstaller\r\n- Using CLI uninstaller\r\n\r\n> **Note**\r\n>  \r\n> For more information on how to remove a single package or multiple packages, see [Updating Tizen Studio](./tizenstudio/setup/update-sdk/).\r\n\r\n## GUI Uninstaller\r\n\r\nWith an intuitive interface, the GUI uninstaller simplifies the uninstallation process. You can easily uninstall Tizen Studio and the related platforms and packages. \r\n\r\nTo uninstall Tizen Studio using GUI uninstaller, follow these steps:\r\n\r\n1. Back up all the data and the files in case you want to keep them for future reference. \r\n   > **Note**\r\n   >\r\n   > Once you start the uninstallation process, the process is irreversible. You cannot restore the removed files.\r\n2. Launch Tizen Studio uninstaller, click the **uninstaller icon.**\r\n3. Check the following section to make a choice of components that you want to uninstall. \r\n\r\n   - **SDK data**  \r\n   The SDK data directory typically contains user-created data files, including emulator images, log files, and tool configuration files.\r\n\r\n   - **KeyStore**  \r\n   The keystore directory is located inside the SDK data directory and contains the author and distributor certificate files. If the certificate files are deleted, you cannot restore them from any Tizen seller market site. If you plan to install another Tizen Studio version or reinstall Tizen Studio later, it is strongly recommended that you back up the certificate files or keep the keystore directory by unchecking the **KeyStore** component.\r\n\r\n     > **Note**  \r\n     > \r\n     > If you do not select SDK data or KeyStore components, you can keep the SDK data or KeyStore files in their directories for future re-use.\r\n\r\n4. To remove all the installed platforms, packages, tools, and the user-created data and the files, click **Uninstall**.\r\n\r\n   ![Uninstaller selections](./tizenstudio/setup/media/uninstall_sdk_selection.png)\r\n\r\n5. If you click the **checkbox** to uninstall the SDK data or the KeyStore components, they get uninstalled during the process. In case you want to keep one of them, uncheck the respective **checkbox**.\r\n\r\n   ![Uninstallation in progress](./tizenstudio/setup/media/uninstall_sdk_progress.png)\r\n\r\n## CLI Uninstaller\r\n\r\nFor advanced users, Tizen Studio provides a CLI uninstaller. The following procedure facilitates removing Tizen Studio and the related platforms and packages. \r\n\r\nTo uninstall Tizen Studio using the CLI uninstaller, run th eCLI Package Manager with `uninstall` command using the following syntax:\r\n\r\n   ```\r\n   package-manager-cli uninstall [-p ] [,...] | [--all]\r\n   ```\r\n\r\nThe following table explains various command parameters to perform uninstallation tasks:\r\n\r\n**Table: Uninstall command parameters**\r\n\r\n| Parameter                   | Description                              |\r\n|---------------------------|----------------------------------------|\r\n| `-p, --password ` | Administrator (sudo) password for authentication. Works in Ubuntu only. |\r\n| `--all`                     | Uninstalls the entire Tizen Studio with tools and platforms including user-created data, emulator images, and settings. |\r\n| `[,...]`        | Name of the package you want to uninstall. You can enter multiple package names such as **NativeIDE** and **Emulator**.To retrieve the names of the uninstallable packages, use the following command:`package-manager-cli show-pkgs` |\r\n\r\n## Related Information\r\n-  Dependencies\r\n   - Tizen Studio 1.0 and Higher"
					}
					
				
			
		
			
				
					,
					
					"tizenstudio-setup-update-sdk": {
						"id": "tizenstudio-setup-update-sdk",
						"title": "Update Tizen Studio",
						"categories": "",
						"url": " tizenstudio/setup/update-sdk/",
						"content": "# Update Tizen Studio\r\n\r\nThis page explains how to install, update, and remove packages using the Package Manager tool in Tizen Studio. It also guides advanced developers to manage packages with the CLI version of the tool. At its core, Tizen Studio primarily comprises of various packages that includes necessary files, metadata, installation, and removal scripts, and these packages have interdependencies. \r\n\r\nAfter you install Tizen Studio, it is easy to keep the packages, platforms, and other tools up-to-date with automatic updates. Tizen Studio includes a comprehensive package management tool to manage processes such as installing, uninstalling, updating packages and platforms, and other related tools.\r\n\r\n## Launch Package Manager\r\n\r\nPackage Manager offers a simple way to manage packages without getting into the complicated package dependencies.\r\n\r\nTo launch Package Manager on your preferred operating system, follow these steps: \r\n\r\n- Windows&reg;: Click **Start > All Programs > Tizen Studio > Tools > Package Manager**.\r\n- MacOS&reg;: Click **Launchpad > Package Manager**.\r\n- Ubuntu&reg;: Click **Dashboard Home > Package Manager**.\r\n\r\n>Note: \r\n>\r\n> Before you launch Package Manager, ensure that you close all the Tizen Studio programs.\r\n\r\n## Package Manager Components \r\n\r\nThe Package Manager window is made up of the following logical areas as identified in the following figure:\r\n\r\n**Figure: Package Manager main window**\r\n\r\n![Package Manager main window](./tizenstudio/setup/media/updating_sdk_main.png)\r\n\r\nThe Package Manager window consists of the following logical areas:\r\n\r\n- **Header area** comprises of the following elements:\r\n\r\n    - **Trouble Shooting** ![Inside Trouble Shooting icon](./tizenstudio/setup/media/updating_sdk_icon_troubleshoot.png): You can  access troubleshooting guides that help you resolve common issues related to Package Manager.\r\n    - **Configuration** ![Configuration icon](./tizenstudio/setup/media/updating_sdk_icon_config.png): You can change the Package Manager configuration and other related settings, such as package repository locations, proxy options, and so on.\r\n    - **Information** ![Information icon](./tizenstudio/setup/media/updating_sdk_icon_info.png): You can access the details of Package Manager, such as version number, installation path, package repository URL, distribution name, and package snapshot.\r\n    \r\n    **Figure: Header area**\r\n\r\n     ![Header area](./tizenstudio/setup/media/header_area.png)\r\n- **Main area** comprises of the following tabs:\r\n\r\n    - **Main SDK**: It enables you to install and remove packages, platforms, and tools. In addition, the filter button narrows down the choice of the package list display based on the selected profiles.\r\n    - **Extension SDK**: It enables you to install or remove extension tools and packages such as Samsung Certificate Extension.\r\n    - **Progress**: It enables you to see the progress of the packages that are currently getting installed or removed.\r\n  \r\n    \r\n    In the **Main SDK** and the **Extension SDK** tab, you can also list the installed packages by selecting **View installed packages**.\r\n\r\n     **Figure: Main area with package list**\r\n\r\n     ![Package list](./tizenstudio/setup/media/updating_sdk_main_area.png)\r\n\r\n- **Description area**: It enables you to view the detailed description of each package or platform that is currently selected on the list in the main area.\r\n\r\n    **Figure: Description area**\r\n\r\n    ![Description area](./tizenstudio/setup/media/updating_sdk_description.png)\r\n\r\n## Update Packages\r\n\r\nPackage Manager makes it easy to update your packages and platforms. You can use the Package Manager tool to locate and install updates and new features for the packages that are already installed. \r\n\r\n>**Note**\r\n>\r\n>Before you begin to update a package, ensure that Package Manager has access to the repository that contains the packages and you have access to the Internet. \r\n\r\nTizen Studio notifies you with the **Updates available** button that appears in the **Package Manager** window, if new updates are available for your existing Tizen Studio packages and platforms.\r\n\r\nTo update the existing packages, click **Updates available**.\r\n    \r\n**Figure: Updates available button**\r\n\r\n![Updates available button](./tizenstudio/setup/media/updating_sdk_updates.png)\r\n\r\n>**Note**\r\n>\r\n>- To ensure system integrity across all the packages in Tizen Studio, Package Manager does not support updating packages individually.\r\n>- In case, you do not have access to the Internet, you can update the packages with an image file, which can be downloaded separately. \r\n\r\n### Update Packages Offline\r\n\r\nPackage Manager also facilitates offline upgrade with an update image for all the existing packages.\r\n\r\nTo install the packages with an image file, follow these steps:\r\n\r\n1. In Package Manager, click ![Configuration icon](./tizenstudio/setup/media/updating_sdk_icon_config.png).\r\n2. In the **Configuration** window that appears, enter the full path of the image file in **Package Repository**. Alternatively, to select the image file, click **Browse** next to the combo box. \r\n3. To close the **Configuration** window, click **Open**.\r\n\r\n > **Note:**\r\n >\r\n >If the image file is valid, detailed information about the image is displayed below the combo box.\r\n\r\n4. To close the **Configuration** dialog, click **OK**. \r\n   \r\n   The **Update available** button appears.\r\n5. To update and install additional platforms and tools with the image file, click **Update available**.\r\n\r\n > **Note**  \r\n > \r\n > Ensure that the image file includes the latest version of Tizen Studio, before updating or installing using the image file.\r\n\r\n## Install Additional Packages\r\n\r\nPackage Manager simplifies the process to install packages, platforms, and tools. You can install any platform or tool that are listed under the **Main SDK** and **Extension SDK** tabs.\r\n\r\nIn the **Main SDK** and the **Extension SDK** tab, click **install** next to any desired platform or tool in the list that you want to install. \r\n\r\n>**Note**\r\n>\r\n>Package Manager installs all the packages that are required for that platform or tool.\r\n\r\nPackage Manager also provides you the flexibility to install an individual preferred package for a particular platform or tool.\r\n\r\nTo install individual packages for a particular platform or tool, follow these steps: \r\n\r\n1. Click ![Expander](./tizenstudio/setup/media/expander_button.png) located on the left of the main area of the window for each platform or tool to view more packages and tools.\r\n2. Click **install** next to the package, if want to install that package.\r\n \r\n**Figure: Install platform packages**\r\n\r\n![Installing platform packages](./tizenstudio/setup/media/updating_sdk_install_platform.png)\r\n\r\n## Cancel Installation\r\n\r\nThe Package Manager tool gives you total control over the installation related tasks, you can cancel an installation anytime. \r\n\r\nTo cancel the installation process, click ![Cancel](./tizenstudio/setup/media/cancel_button.png) under the **Progress** tab next to the respective package. \r\n\r\n>**Note:** \r\n>\r\n>Due to package dependencies, cancelling the installation of a single package may also cancel the installation of other packages.\r\n\r\n**Figure: Cancel installation**\r\n\r\n![Cancelling the installation](./tizenstudio/setup/media/updating_sdk_install_cancel.png)\r\n\r\n## Retry Cancelled Installation \r\n\r\nThe Package Manager tool also provides utmost flexibility. It enables you to retry a cancelled installation anytime. \r\n\r\nTo retry a cancelled or failed installation, click ![Retry icon](./tizenstudio/setup/media/updating_sdk_icon_retry.png) under the **Progress** tab next to the respective package. \r\n\r\n>**Note:**\r\n>\r\n>Due to package interdependencies, retrying the installation of a single package may also cause the installation of other related packages.\r\n\r\n## Remove Packages\r\n\r\nThe Package Manager tool also provides an intuitive user interface that helps you to remove any package, platform, or tool with ease. \r\n\r\nTo remove a package, click ![delete](./tizenstudio/setup/media/delete.png) located next to the respective package. \r\n\r\n>**Note:**\r\n>\r\n>- Due to package interdependencies, removing a single package may also cause other related packages to be removed. \r\n>- To ensure system integrity across all installed Tizen Studio packages, package removal process cannot be cancelled while the process is in progress.\r\n\r\n**Figure: Remove packages**\r\n\r\n![Remove packages](./tizenstudio/setup/media/updating_sdk_install_remove.png)\r\n\r\n## Monitor Progress\r\n\r\nTizen Studio provides a progress bar where you can monitor the installation, update, or removal progress. This progress bar appears on the header area and helps in checking the overall progress of a respective process.  Also, to monitor the progress of specific installation, uninstallation, or update, as well as view the expected time of completion, Package Manager provides respective progress bars for each package or tool.\r\n\r\n**Figure: Progress tab**\r\n\r\n![Progress tab](./tizenstudio/setup/media/updating_sdk_progress.png)\r\n\r\n## Update Packages using CLI\r\n\r\nFor advanced developers, Tizen Studio provides command line version of the Package Manager tool. It can be used to install, update, remove packages, and platform tools respectively using the terminal or the console window. \r\n\r\nTo Run the CLI version of Package Manager with the `update` command, use the following syntax:\r\n\r\n```\r\npackage-manager-cli update [--accept-license] [--no-java-check] [--proxy ] [-f ] [-p ] [--latest]\r\n```\r\n\r\nThe following table lists various options that you can append to the syntax for the desired choice of the process:   \r\n\r\n| Parameters                   | Descriptions                              |\r\n|---------------------------|----------------------------------------|\r\n| `--accept-license`          | Accepts the license terms.               |\r\n| `--no-java-check`           | Skips the Java version check.            |\r\n| `--proxy `           | Represents proxy configuration value. You can use one of the following values: direct, auto, or ip:port. |\r\n| `-f, --file `    | If you want to install packages from a local SDK image, specify the full path of the SDK image file. |\r\n| `-p, --password ` | Specifies Administrator (sudo) password for authentication in Ubuntu only |\r\n| `--latest`                  | Specifies the option for updating Tizen Studio to the latest version. |\r\n\r\n## Related Information\r\n- Dependencies\r\n  - Tizen Studio 1.0 and Higher"
					}
					
				
			
		
			
				
					,
					
					"tizenstudio-extension-sdk-vmax": {
						"id": "tizenstudio-extension-sdk-vmax",
						"title": "VMAX AD SDK on tizen",
						"categories": "",
						"url": " tizenstudio/extension-sdk/vmax/",
						"content": "# VMAX AD SDK on tizen\r\n\r\nVMAX&trade; is the one-stop solution that gives you complete control over your app monetization. It is a publisher-centric mediation SSP platform which sources ads from various sources and optimizes to maximize yield rate and fill rate.\r\n\r\nVMAX provides support for Ads in Tizen Native, Unity and Web applications.\r\n1. **Native SDK**: It is for the Application developers who want to build Tizen Native App, utilizing EFL (Enlightenment Foundation Libraries) for the UI. Among the other SDK's available, Native SDK allows building Native feature-rich app.\r\n2. **Unity SDK**: Game developers can utilize this SDK to monetize various in-game ad placements.\r\n3. **Webapp SDK**: Web application developers can use this SDK for applications using web technologies (HTML, CSS & Javascript).\r\n\r\nVMAX support wide range of ad formats to provide better user ad experience on Tizen.\r\n\r\n**Ad Formats**:\r\n\r\n1. Banner\r\n2. Billboard\r\n3. Interstitial\r\n4. Interstitial Video\r\n5. Native In Feed\r\n6. Native Content stream\r\n7. Rewarded Video\r\n8. In-Stream Video\r\n\r\n**Getting Started**:\r\n\r\nThe VMAX Tizen SDK is designed to help you integrate Ads and fast track your way to monetizing your Tizen applications. It provides you with various mechanisms to request for Ads in your application.\r\n\r\nIt is  very lightweight, modular & feature-rich SDK. The VMAX&trade; SDK delivers highest yield ads for app publishers from Ad mediation partner, Programmatic, direct deals & Agencies.\r\n\r\nThe SDK has simple & fully-managed Ad request methods.Our SDK lets you quickly and easily integrate with multiple ad partners.\r\n\r\nStep of Integration of VMAX Tizen SDK into you Native, Unity or Web app\r\n\r\n1. [Signup](https://www.vmax.com/signup) on VMAX Dashboard\r\n\r\n    1. Add an app\r\n\r\n    2. Create an adspot\r\n\r\n    3. Add mediation network\r\n\r\n2. Add VMAX SDK in your project based on your app type (Native, Unity or Web app)\r\n\r\n    1. [Download Zip file](https://www.vmax.com/?ddownload=6495). You will find Three folder Native, Unity & web App. Each folder contains SDK and Sample App\r\n\r\n    2. Choose right SDK based on you app type.\r\n\r\n    3. Add chosen SDK & add into your project. You can refer sample app\r\n\r\n    4. Refer [Native](https://www.vmax.com/2017/10/27/introduction-vmax-tizen), [Unity](https://www.vmax.com/2017/10/27/vmax-unity-sdk-tizen-introduction) and [Web app](https://www.vmax.com/en/2017/10/27/vmax-webapp-sdk-tizen-introduction) link to follow detailed Instruction\r\n\r\n3. Add ad format specific code to request ads from VMAX\r\n4. Add an ad network SDK into your app to receive ads from mediation partner\r\n5. Compile your project and release for user"
					}
					
				
			
		
			
				
					,
					
					"tizenstudio-setup-windows": {
						"id": "tizenstudio-setup-windows",
						"title": "Install Tizen Studio on Windows",
						"categories": "",
						"url": " tizenstudio/setup/windows/",
						"content": "# Install Tizen Studio on Windows\r\n\r\nThis page explains the process to download and install Tizen Studio on your development hardware.\r\n\r\nTo have optimal installation experience, follow these steps chronologically:\r\n\r\n- System prerequisites\r\n  - Hardware requirements\r\n  - Software requirements\r\n- Setup OpenJDK in Windows\r\n- Launch installer\r\n- Verify installation\r\n\r\n## System Prerequisites\r\n\r\nEnsure that the following system prerequisites are met:\r\n\r\n### Hardware Requirements\r\n\r\n\r\n  \r\n    CPU\r\n    Dual Core, 2Ghz or faster\r\n  \r\n  \r\n    Architecture\r\n    x32 or x64 \r\n  \r\n  \r\n    Memory\r\n    3GB or more \r\n  \r\n  \r\n    Disk space\r\n    6 GB or more \r\n  \r\n \r\n\r\n### Software Requirements\r\n\r\n\r\n  \r\n    Windows\r\n  \r\n  \r\n    Version\r\n    7/8/10\r\n  \r\n  \r\n    Bit\r\n    32 or 64 bit\r\n  \r\n\r\n\r\n\r\n  \r\n    Software\r\n    Download Link \r\n  \r\n  \r\n    Open JDK\r\n    Click to Download\r\n  \r\n  \r\n    OpenJavaFX\r\n    Click to Download\r\n  \r\n  \r\n    Tizen Studio setup file\r\n    Click to Download\r\n  \r\n\r\n\r\n> **Note:**\r\n>\r\n> - Download the relevant version based on the target device operating system, for example, **openjdk-10_windows-x64_bin.tar.gz** and **openjfx-11.0.2_windows-x64_bin-sdk.zip**\r\n> - Ensure that you download the JavaFX  SDK product only, for example: JavaFX Windows SDK.\r\n\r\n**Disclaimer:** The third party download links are subjected to change. Search and download the appropriate software.\r\n\r\n## Set Up Open JDK\r\n\r\n To set up the Open JDK, follow these steps: \r\n\r\n1. Extract the downloaded **openjdk-10_windows-x64_bin.tar.gz**, and **openjfx-11.0.2_windows-x64_bin-sdk.zip** files at your preferred location.\r\n     >**Note**\r\n     >\r\n     >The **openjdk-10_windows-x64_bin > jdk-10**, **openjfx-11.0.2_windows-x64_bin-sdk** directories are created as a result of extraction. \r\n2. Locate the **jdk-10** and the **javafx-sdk-11.0.2** directories after extraction.\r\n    > **Note**\r\n    >\r\n    > - The **jdk-10** is the sub directory under the **openjdk-10_windows-x64_bin** directory.\r\n    >- The **javafx-sdk-11.0.2** is the sub directory under the **openjfx-11.0.2_windows-x64_bin-sdk** directory.\r\n3. Double click to open the **javafx-sdk-11.0.2** directory.\r\n4. Copy all the files except the **src.zip** from the **lib** sub directory located in the **javafx-sdk-11.0.2** directory.\r\n5. Paste all the copied files in the **lib** sub directory of the  **jdk-10** directory.\r\n6. Copy all the files from the **bin** sub directory in the **javafx-sdk-11.0.2**.\r\n7. Paste all the copied files in the **bin** sub directory of the **jdk-10** directory.\r\n\r\n   >**Note**\r\n   >\r\n   >- In this installation guide, setting up OpenJDK is covered. However, Oracle JDK versions until version 10 are also supported.\r\n   >- For Oracle JDK 10 installation steps, see the [Oracle Documentation](https://docs.oracle.com/javase/10/install/installation-jdk-and-jre-microsoft-windows-platforms.htm#JSJIG-GUID-DAF345BA-B3E7-4CF2-B87A-B6662D691840).\r\n   >- If you have installed Oracle JDK 10 or below already, you can skip setting up OpenJDK. \r\n \r\n### Set Up Open JDK Path \r\n\r\nTo set up the JDK path, follow these steps:\r\n\r\n1. On the Windows desktop, click **Start > Control Panel > System and security > System > Advanced system settings**, the System Properties window appears. \r\n3. In the **Startup and Recovery** section, click **Environment Variables** the Environment Variables window appears.  \r\n4. Click **New** under **User variables for {user}** section, also in case the **JAVA_HOME** variable is already in the list, select it and click **Edit**, enter the following details: \r\n\t- Variable name: **JAVA_HOME** \r\n\t- Variable value: **C:\\Path\\to\\your\\openJDKtype**, i.e. browse for the JDK directory path (for example, C:\\Users\\user\\Desktop\\jdk-10.0.2) \t\r\n5. Click **OK**, the Environment Variable list is updated with the **JAVA_HOME** variable.\r\n6. Click **New** under the **System variables** section also in case, if the **Path variable** already exists, select it and click **Edit**, and enter the following details: \r\n\t- Variable name: **Path** \r\n\t- Variable value: **C:\\Path \\to\\ openJDK\\bin directory**; i.e. browse for the **bin** subdirectory path in the JDK directory  (for example, C:\\Users\\user\\Desktop\\jdk-10.0.2\\bin ) \r\n8. Click **OK**, the System Variable list is updated with the **Path** variable.\r\n9. Save and close the **Environment Variables** window.\r\n10. Open Command Prompt and type the `java –version` command to verify whether the OpenJDK version 10 is installed or not. Entering the command must give the following output: \r\n\r\n   ```windows console\r\n   C:\\Users\\exampleconsole>java -version\r\n   openjdk version \"10\" 2018-03-20\r\n   OpenJDK Runtime Environment 18.3 (build 10+46)\r\n   OpenJDK 64-Bit Server VM 18.3 (build 10+46, mixed mode)\r\n   ```\r\n\r\n## Launch Installer\r\n \r\nTo launch the installer, follow these steps:\r\n\r\n1. Double click **web-ide_Tizen_Studio_x.x_windows-64.exe** file.\r\n\t>**Note:** \r\n\t>\r\n\t>**x.x** represents the latest version of Tizen Studio, for example:web-ide_Tizen_Studio_**3.3**_windows-64.exe.\r\n\r\n2. Accept the software license.\r\n\r\n   >**Note:**\r\n   >\r\n   >The license contains important legal notices for using Tizen Studio. Read it fully, and click **Accept** only if you agree with the license statement.\r\n\r\n   ![Tizen Studio License Agreement](./tizenstudio/setup/media/install_sdk_license.png)\r\n\r\n3. Click **Browse** and specify a new directory to set the SDK data location. \r\n\r\n   ![Set SDK and data location](./tizenstudio/setup/media/install_sdk_directory.png)\r\n  \r\n   >**Note:** \r\n   > \r\n   >If the new directory is valid, it shows no errors.\r\n\r\n4. Click **Install**.\r\n5. Click **Finish** to close the installer.\r\n\r\n   ![Installation complete](./tizenstudio/setup/media/migration_finish_instal.png)\r\n\r\n   >**Note:**\r\n   >\r\n   > - If you install the Tizen Studio in a directory that requires administrator privileges for access, such as `C:\\Program Files`, then administrator privileges are required to run the Tizen SDK tools.\r\n   > - If you want to install additional platforms and tools, launch Package Manager by selecting the Launch the Package Manager **check box** and click **Finish**.\r\n   > - Use Tizen Package Manager, to install and update additional tools. \r\n   > - For more information on the Package Manager, see [Updating Tizen Studio](./tizenstudio/setup/update-sdk/).\r\n\r\n## Verify Installation   \r\n\r\n   To verify whether the installation is successful or not, click **Tizen Studio icon**. The Tizen Studio startup window must appear."
					}
					
				
			
		
			
				
					,
					
					"application-about-work-flow": {
						"id": "application-about-work-flow",
						"title": "Tizen Development Workflow",
						"categories": "",
						"url": " application/about/work-flow/",
						"content": "# Tizen Development Workflow\n\nThe Tizen development system has 2 main components:\n\n- **Source Code Management (SCM)** system consists of 2 parts:\n  - **Git** is a particularly powerful, flexible, and low-overhead version control system that makes collaborative development efficient and robust. For more information, see:\n    - [Git Community Book](http://git-scm.com/book)\n    - [Git Wiki](https://git.wiki.kernel.org/index.php/Main_Page)\n    - [Git Manual Page](https://www.kernel.org/pub/software/scm/git/docs/)\n  - **Gerrit** is a Web-based code review system, facilitating online code reviews for projects using the Git version control system. By showing changes in a side-by-side display and supporting inline comments, Gerrit optimizes the code review process, enhancing review quality. Furthermore, by permitting any authorized user to submit changes to the central Git repository, Gerrit simplifies the maintenance of Git-based projects, enabling a more centralized use of Git.\n- **Open Build Service (OBS)** is an open and complete distribution development platform that provides the infrastructure for developers to easily create and release open source software for various Linux distributions on different hardware architectures. In addition, OBS delivers a collaborative environment that enables developer groups to build and submit changes to other projects.\n\n  For more information, see:\n  - [Open Build Service](http://openbuildservice.org/)\n  - [Build Service (openSUSE)](http://en.opensuse.org/openSUSE:Build_Service)\n\n\n## Git Branches\n\nA given project in the Git repository has 2 possible branches: a master branch and an upstream branch.\n\n- **Master branch**\n\n  Git introduces the master branch (also known as development branch) during the initialization of a repository, thus the default branch in a repository is the master branch and most developers keep the repository's most robust and dependable line of development on the master branch.\n\n  In other words, the master branch hosts each project's full source tree (for example, in C/C++, `.h`, and `makefile` files), including the upstream source and any Tizen local changes. Though the master branch can be renamed or even deleted, it is best practice to regard it as mandatory and leave as is.\n\n  > **Note**\n  >\n  > You are responsible for maintaining the packaging change log within the `/packaging` folder of each Git tree.\n\n- **Upstream branch**\n\n  When talking about 2 repositories that have been cloned one from the other, the parent repository is commonly referred to as being \"upstream\".\n\n  This conventional concept applies to the \"upstream branch\", as well. More specifically, a parent branch is referred to as the \"upstream branch\" on which developers base their Git projects. The upstream branch becomes optional in the following scenarios:\n\n  - The project only contains native code from Tizen and has no upstream project to base on.\n  - The project does not need to track the latest update of the upstream project.\n\n> **Note**\n>\n> The master branch is mandatory, whereas the upstream branch is optional.\n\n## Roles and Responsibilities\n\nThe development workflow includes various roles and related responsibilities:\n\n- **Developers** are responsible for:\n\n  - Writing and submitting code to the development branch of a Git project.\n  - Verifying and reviewing (vote \"+1\" or \"-1\") code changes for any project on any branch.\n\n- **Maintainers** are responsible for:\n\n  - Creating additional branches, such as upstream and development branches to profile projects.\n  - Rebasing the master branch to the upstream branch.\n  - Reviewing code, as well as approving (vote \"+2\") or reject (vote \"-2\") patches.\n\n  Maintainers also must adhere to the following guidelines:\n\n  - Despite the granted power, maintainers must not accept their own changes without them passing a peer review (\"+1\") or (\"+2\").\n  - The force push right is granted for maintainers to be able to handle code rebasing. Maintainers must not abuse the right to hide patch submissions that are supposed to be reviewed.\n\n- **Reviewers** are responsible for:\n\n  - Reviewing code, as well as approving (vote \"+2\") or rejecting (vote \"-2\") patches.\n\n- **Release engineers** are responsible for:\n\n  - Approving submissions to OBS.\n  - Performing smoke tests on the resulting images and transferring them to the release area for QA engineers to perform further tests.\n\n- **QA engineers** are responsible for:\n\n  - Performing thorough integration and verification of the image to eliminate regressions and bugs.\n\n## Package Development Workflow\n\nThe package development workflow is described in the following procedure and shown in the following figure.\n\n**Figure: Package development workflow**\n\n![Package development workflow](media/800px-tizen-work-flow.png)\n\n1. Developers set up the development environment and install the development tools.\n1. Developers clone the source code, do required development, and perform local verification through a local build.\n1. Developers submit patches to Gerrit for all stakeholders to review.\n1. Tizen backend service and reviewers verify the patches through automated and manual testing, respectively, and then vote \"-1\", \"0\", or \"+1\" based on the quality of the patches.\n   - Automated testing: Tizen backend service automatically submits patches to OBS to perform a remote build and then posts the test results back to Gerrit.\n   - Manual testing: Testers verify the patches manually and then publish comments on Gerrit.\n1. Maintainers approve the patches (\"Code-Review +2\") after they pass verification (\"Verified +1\") and then merge code changes to the Gerrit repository.\n1. Maintainers and developers submit packages to OBS by using the `gbs submit` command.\n   > **Note**\n   >\n   > It is best practice to always have a maintainer role for every Tizen project, and maintainers must submit packages to OBS as soon as all merged packages are ready for submission, in order to prevent possible omissions.\n1. Tizen backend service activates pre-release and normal release processes at the same time. During the pre-release process, Tizen images that incorporate specific packages are created and submitted to release engineers for review.\n1. Release engineers accept or reject submissions based on the quality of the packages. For accepted submissions, the corresponding source code is merged into the OBS repository. Meanwhile, the normal release process takes over and publishes repositories together with Tizen images.\n\n\n### Package Generation\n\nAfter submitting code from a source repository to OBS, the backend generates the package file in the required format, by the following steps:\n\n1. Create a tarball.\n\n   Create the tarball using the `git-archive` command. The `/packaging` directory must be included in the tarball as well. The tarball version is abstracted from the spec file by **rpmbuild**.\n\n1. Take the contents of the packaging directory and put them alongside the tarball.\n\n   The package files in the required form are shown in the following figure.\n\n**Figure: Package files**\n\n![Package files](media/700px-package-generation.png)"
					}
					
				
			
		
			
				
					,
					
					"platform-about-work-flow": {
						"id": "platform-about-work-flow",
						"title": "Tizen Development Workflow",
						"categories": "",
						"url": " platform/about/work-flow/",
						"content": "# Tizen Development Workflow\n\nThe Tizen development system has 2 main components:\n\n- **Source Code Management (SCM)** system consists of 2 parts:\n  - **Git** is a particularly powerful, flexible, and low-overhead version control system that makes collaborative development efficient and robust. For more information, see:\n    - [Git Community Book](http://git-scm.com/book)\n    - [Git Wiki](https://git.wiki.kernel.org/index.php/Main_Page)\n    - [Git Manual Page](https://www.kernel.org/pub/software/scm/git/docs/)\n  - **Gerrit** is a Web-based code review system, facilitating online code reviews for projects using the Git version control system. By showing changes in a side-by-side display and supporting inline comments, Gerrit optimizes the code review process, enhancing review quality. Furthermore, by permitting any authorized user to submit changes to the central Git repository, Gerrit simplifies the maintenance of Git-based projects, enabling a more centralized use of Git.\n- **Open Build Service (OBS)** is an open and complete distribution development platform that provides the infrastructure for developers to easily create and release open source software for various Linux distributions on different hardware architectures. In addition, OBS delivers a collaborative environment that enables developer groups to build and submit changes to other projects.\n\n  For more information, see:\n  - [Open Build Service](http://openbuildservice.org/)\n  - [Build Service (openSUSE)](http://en.opensuse.org/openSUSE:Build_Service)\n\n\n## Git Branches\n\nA given project in the Git repository has 2 possible branches: a master branch and an upstream branch.\n\n- **Master branch**\n\n  Git introduces the master branch (also known as development branch) during the initialization of a repository, thus the default branch in a repository is the master branch and most developers keep the repository's most robust and dependable line of development on the master branch.\n\n  In other words, the master branch hosts each project's full source tree (for example, in C/C++, `.h`, and `makefile` files), including the upstream source and any Tizen local changes. Though the master branch can be renamed or even deleted, it is best practice to regard it as mandatory and leave as is.\n\n  > **Note**\n  >\n  > You are responsible for maintaining the packaging change log within the `/packaging` folder of each Git tree.\n\n- **Upstream branch**\n\n  When talking about 2 repositories that have been cloned one from the other, the parent repository is commonly referred to as being \"upstream\".\n\n  This conventional concept applies to the \"upstream branch\", as well. More specifically, a parent branch is referred to as the \"upstream branch\" on which developers base their Git projects. The upstream branch becomes optional in the following scenarios:\n\n  - The project only contains native code from Tizen and has no upstream project to base on.\n  - The project does not need to track the latest update of the upstream project.\n\n> **Note**\n>\n> The master branch is mandatory, whereas the upstream branch is optional.\n\n## Roles and Responsibilities\n\nThe development workflow includes various roles and related responsibilities:\n\n- **Developers** are responsible for:\n\n  - Writing and submitting code to the development branch of a Git project.\n  - Verifying and reviewing (vote \"+1\" or \"-1\") code changes for any project on any branch.\n\n- **Maintainers** are responsible for:\n\n  - Creating additional branches, such as upstream and development branches to profile projects.\n  - Rebasing the master branch to the upstream branch.\n  - Reviewing code, as well as approving (vote \"+2\") or reject (vote \"-2\") patches.\n\n  Maintainers also must adhere to the following guidelines:\n\n  - Despite the granted power, maintainers must not accept their own changes without them passing a peer review (\"+1\") or (\"+2\").\n  - The force push right is granted for maintainers to be able to handle code rebasing. Maintainers must not abuse the right to hide patch submissions that are supposed to be reviewed.\n\n- **Reviewers** are responsible for:\n\n  - Reviewing code, as well as approving (vote \"+2\") or rejecting (vote \"-2\") patches.\n\n- **Release engineers** are responsible for:\n\n  - Approving submissions to OBS.\n  - Performing smoke tests on the resulting images and transferring them to the release area for QA engineers to perform further tests.\n\n- **QA engineers** are responsible for:\n\n  - Performing thorough integration and verification of the image to eliminate regressions and bugs.\n\n## Package Development Workflow\n\nThe package development workflow is described in the following procedure and shown in the following figure.\n\n**Figure: Package development workflow**\n\n![Package development workflow](media/800px-tizen-work-flow.png)\n\n1. Developers set up the development environment and install the development tools.\n1. Developers clone the source code, do required development, and perform local verification through a local build.\n1. Developers submit patches to Gerrit for all stakeholders to review.\n1. Tizen backend service and reviewers verify the patches through automated and manual testing, respectively, and then vote \"-1\", \"0\", or \"+1\" based on the quality of the patches.\n   - Automated testing: Tizen backend service automatically submits patches to OBS to perform a remote build and then posts the test results back to Gerrit.\n   - Manual testing: Testers verify the patches manually and then publish comments on Gerrit.\n1. Maintainers approve the patches (\"Code-Review +2\") after they pass verification (\"Verified +1\") and then merge code changes to the Gerrit repository.\n1. Maintainers and developers submit packages to OBS by using the `gbs submit` command.\n   > **Note**\n   >\n   > It is best practice to always have a maintainer role for every Tizen project, and maintainers must submit packages to OBS as soon as all merged packages are ready for submission, in order to prevent possible omissions.\n1. Tizen backend service activates pre-release and normal release processes at the same time. During the pre-release process, Tizen images that incorporate specific packages are created and submitted to release engineers for review.\n1. Release engineers accept or reject submissions based on the quality of the packages. For accepted submissions, the corresponding source code is merged into the OBS repository. Meanwhile, the normal release process takes over and publishes repositories together with Tizen images.\n\n\n### Package Generation\n\nAfter submitting code from a source repository to OBS, the backend generates the package file in the required format, by the following steps:\n\n1. Create a tarball.\n\n   Create the tarball using the `git-archive` command. The `/packaging` directory must be included in the tarball as well. The tarball version is abstracted from the spec file by **rpmbuild**.\n\n1. Take the contents of the packaging directory and put them alongside the tarball.\n\n   The package files in the required form are shown in the following figure.\n\n**Figure: Package files**\n\n![Package files](media/700px-package-generation.png)"
					}
					
				
			
		
			
				
					,
					
					"iot-about-work-flow": {
						"id": "iot-about-work-flow",
						"title": "Tizen Development Workflow",
						"categories": "",
						"url": " iot/about/work-flow/",
						"content": "# Tizen Development Workflow\n\nThe Tizen development system has 2 main components:\n\n- **Source Code Management (SCM)** system consists of 2 parts:\n  - **Git** is a particularly powerful, flexible, and low-overhead version control system that makes collaborative development efficient and robust. For more information, see:\n    - [Git Community Book](http://git-scm.com/book)\n    - [Git Wiki](https://git.wiki.kernel.org/index.php/Main_Page)\n    - [Git Manual Page](https://www.kernel.org/pub/software/scm/git/docs/)\n  - **Gerrit** is a Web-based code review system, facilitating online code reviews for projects using the Git version control system. By showing changes in a side-by-side display and supporting inline comments, Gerrit optimizes the code review process, enhancing review quality. Furthermore, by permitting any authorized user to submit changes to the central Git repository, Gerrit simplifies the maintenance of Git-based projects, enabling a more centralized use of Git.\n- **Open Build Service (OBS)** is an open and complete distribution development platform that provides the infrastructure for developers to easily create and release open source software for various Linux distributions on different hardware architectures. In addition, OBS delivers a collaborative environment that enables developer groups to build and submit changes to other projects.\n\n  For more information, see:\n  - [Open Build Service](http://openbuildservice.org/)\n  - [Build Service (openSUSE)](http://en.opensuse.org/openSUSE:Build_Service)\n\n\n## Git Branches\n\nA given project in the Git repository has 2 possible branches: a master branch and an upstream branch.\n\n- **Master branch**\n\n  Git introduces the master branch (also known as development branch) during the initialization of a repository, thus the default branch in a repository is the master branch and most developers keep the repository's most robust and dependable line of development on the master branch.\n\n  In other words, the master branch hosts each project's full source tree (for example, in C/C++, `.h`, and `makefile` files), including the upstream source and any Tizen local changes. Though the master branch can be renamed or even deleted, it is best practice to regard it as mandatory and leave as is.\n\n  > **Note**\n  >\n  > You are responsible for maintaining the packaging change log within the `/packaging` folder of each Git tree.\n\n- **Upstream branch**\n\n  When talking about 2 repositories that have been cloned one from the other, the parent repository is commonly referred to as being \"upstream\".\n\n  This conventional concept applies to the \"upstream branch\", as well. More specifically, a parent branch is referred to as the \"upstream branch\" on which developers base their Git projects. The upstream branch becomes optional in the following scenarios:\n\n  - The project only contains native code from Tizen and has no upstream project to base on.\n  - The project does not need to track the latest update of the upstream project.\n\n> **Note**\n>\n> The master branch is mandatory, whereas the upstream branch is optional.\n\n## Roles and Responsibilities\n\nThe development workflow includes various roles and related responsibilities:\n\n- **Developers** are responsible for:\n\n  - Writing and submitting code to the development branch of a Git project.\n  - Verifying and reviewing (vote \"+1\" or \"-1\") code changes for any project on any branch.\n\n- **Maintainers** are responsible for:\n\n  - Creating additional branches, such as upstream and development branches to profile projects.\n  - Rebasing the master branch to the upstream branch.\n  - Reviewing code, as well as approving (vote \"+2\") or reject (vote \"-2\") patches.\n\n  Maintainers also must adhere to the following guidelines:\n\n  - Despite the granted power, maintainers must not accept their own changes without them passing a peer review (\"+1\") or (\"+2\").\n  - The force push right is granted for maintainers to be able to handle code rebasing. Maintainers must not abuse the right to hide patch submissions that are supposed to be reviewed.\n\n- **Reviewers** are responsible for:\n\n  - Reviewing code, as well as approving (vote \"+2\") or rejecting (vote \"-2\") patches.\n\n- **Release engineers** are responsible for:\n\n  - Approving submissions to OBS.\n  - Performing smoke tests on the resulting images and transferring them to the release area for QA engineers to perform further tests.\n\n- **QA engineers** are responsible for:\n\n  - Performing thorough integration and verification of the image to eliminate regressions and bugs.\n\n## Package Development Workflow\n\nThe package development workflow is described in the following procedure and shown in the following figure.\n\n**Figure: Package development workflow**\n\n![Package development workflow](media/800px-tizen-work-flow.png)\n\n1. Developers set up the development environment and install the development tools.\n1. Developers clone the source code, do required development, and perform local verification through a local build.\n1. Developers submit patches to Gerrit for all stakeholders to review.\n1. Tizen backend service and reviewers verify the patches through automated and manual testing, respectively, and then vote \"-1\", \"0\", or \"+1\" based on the quality of the patches.\n   - Automated testing: Tizen backend service automatically submits patches to OBS to perform a remote build and then posts the test results back to Gerrit.\n   - Manual testing: Testers verify the patches manually and then publish comments on Gerrit.\n1. Maintainers approve the patches (\"Code-Review +2\") after they pass verification (\"Verified +1\") and then merge code changes to the Gerrit repository.\n1. Maintainers and developers submit packages to OBS by using the `gbs submit` command.\n   > **Note**\n   >\n   > It is best practice to always have a maintainer role for every Tizen project, and maintainers must submit packages to OBS as soon as all merged packages are ready for submission, in order to prevent possible omissions.\n1. Tizen backend service activates pre-release and normal release processes at the same time. During the pre-release process, Tizen images that incorporate specific packages are created and submitted to release engineers for review.\n1. Release engineers accept or reject submissions based on the quality of the packages. For accepted submissions, the corresponding source code is merged into the OBS repository. Meanwhile, the normal release process takes over and publishes repositories together with Tizen images.\n\n\n### Package Generation\n\nAfter submitting code from a source repository to OBS, the backend generates the package file in the required format, by the following steps:\n\n1. Create a tarball.\n\n   Create the tarball using the `git-archive` command. The `/packaging` directory must be included in the tarball as well. The tarball version is abstracted from the spec file by **rpmbuild**.\n\n1. Take the contents of the packaging directory and put them alongside the tarball.\n\n   The package files in the required form are shown in the following figure.\n\n**Figure: Package files**\n\n![Package files](media/700px-package-generation.png)"
					}
					
				
			
		
	};
</script>

<script src="/js/lunr.min.js"></script>

<script src="/js/search.js"></script>


						</section>
					</main>
				</div>
			</div>
		</div>
	</div>
    <div class="container-fluid">
  <div class="top_footer">
    <div class="footer-nav">
      <nav class="footer_sub_nav">
        <ul class="menu">
          <li><a href="https://developer.tizen.org/">Developer</a></li>
          <li><a href="https://dashboard.tizen.org/">Dashboard</a></li>
          <li><a href="https://craftroom.tizen.org/">Craftroom</a></li>
        </ul>
      </nav>
    </div>
  </div>
  <div class="bottom_footer">
    <div class="footer-copyright col-xs-12 col-md-8">
      <p class="copyright">
        Copyright &copy; 2019 Tizen Inc. All rights reserved.
      </p>
    </div>
    <div class="footer_social_nav">
      <ul class="nav-social">
        <li class="fa fa-github"><a href="https://github.com/samsung-test">GitHub</a></li>  
        <li class="fa fa-twitter"><a href="https://twitter.com/TizenProject">Twitter</a></li>
        <li class="fa fa-facebook"><a href="http://www.facebook.com/pages/Tizen-Project">Facebook</a></li>
      </ul>
    </div>
  </div>
</div>

    <div id="templates"></div>
    <script type="text/javascript" src="/js/jquery-3.2.1.min.js"></script>
<script type="text/javascript" src="/js/bootstrap.min.js"></script>
<script type="text/javascript" src="/js/common.js?v=09122019"></script>
<script type="text/javascript" src="/js/handlebars-v4.0.11.js?v=09122019"></script>
<script type="text/javascript" src="/js/widgets-data.js?v=09122019"></script>
<script type="text/javascript" src="/js/widgets.js?v=09122019"></script>
<script type="text/javascript" src="/js/highlight.pack.js"></script>
<script type="text/javascript" src="/js/tocs.js"></script>
<script type="text/javascript" src="/js/menu.js"></script>
<script type="text/javascript" src="/js/stickyfill.min.js"></script>
<script type="text/javascript" src="/js/metadata.js"></script>
<script type="text/javascript" src="/js/docs.js"></script>
</body>
</html>
